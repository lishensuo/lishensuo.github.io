[{"content":" 统计的对象是数据，其中会涉及到不同类型的数据；统计的目的是描述，描述一组数据的分布特征、两组至多组数据之间的关系。\n1、数据分类 根据数据特点，可以分为2大类：\n1.1 数值型数据 连续型数据：可在一个数值范围内任意取值的数据，特点之一就是允许包含小数。例如身高值。\n离散型数据：只能取整数的数据，多见于计算次数的数据。例如每分钟跳绳次数。\n计数数据是离散型数据，反之不是。\n1.2 分类型数据 二分类数据：只有两个类别。例如生死。\n无序多分类：多种类别，无逻辑上的顺序关系。例如职业分布。\n有序多分类：多种类别，有逻辑上的顺序关系。例如考试等级。\n（1）分类资料的有序与无序有一定的主观性。可以把有序资料视为无序资料，反之亦然。\n（2）另外可通过对数值型数据划分阈值，转换为分类数据。\n2、统计描述 给定一组连续型数据，可以从下面三个角度进行描述。\n2.1 数据位置估计 位置估计指该组数据的”代表值“，最常见的是均值；而中位数更稳健，适用于含有离群点的数据。\n（1）均值 一般均值：累加的和除以个数 $$ \\overline{X} = \\frac{\\sum_{i=1}^{n}x_i}{n} $$ 截尾均值：去掉若干(p)个最小值与若干(p)个最大值的均值 $$ \\overline{X} = \\frac{\\sum_{i=p+1}^{n-p}x_i}{n-2p} $$ 加权均值：数值乘以权重的求和除以权重和 $$ \\overline{X_w} = \\frac{\\sum_{i=1}^{n}x_iw_i}{\\sum{_{i=1}^{n}}{w_i}} $$\n（2）中位数 中位数：将数据进行排序，处于中间位置的数据。是对位置的健壮估计，不收离群值影（极端值）响。\n加权中位数：将原始数据进行排序，该值上半部分的权重和等于该值下半部分的权重和。\n2.2 数据变异估计 变异估计去评价一组数据是紧凑的，还是分散的。\n（1）方差 偏差：均值与每一个实际值的差异。也称为误差、残差。\n平均绝对偏差：差值的绝对值的平均数。 $$ \\frac{\\sum_{i=1}^{n}|x_i-\\overline{x}|}{n} $$\n方差：偏差平方的平均数。\n$$ s^2 = \\frac{\\sum_{i=1}^{n}(x_i-\\overline{x})^2}{n-1} $$\n在大样本下（即n特别大），除以（n-1）还是除以（n）区别不大。如果在小样本时，除以（n）会低估观测值的变异度，称之为有偏估计。这里涉及到了自由度的影响，之后还会提到。\n标准差(standard deviation, sd)：方差的平方根。 上述指标均为基于均值的统计，容易受到极端离群值的影响。变异性的一种健壮估计是中位数绝对偏差，成为MAD：\n$$ MAD = 中位数(|x_1-m|, |x_2-m|, \u0026hellip;,|x_N-m|) $$\n（2）分位数 百分位数：第P个百分位数指的是 \u0026gt; P%的值，而 \u0026lt; (1-P)%的值。\nQ1表示第25百分位数，Q2表示第50百分位数（即中位数），Q3表示第75百分位数。\n四分位距（IQR）= Q3-Q1，可用于描述一组数据的变异性\n箱线图就是依据百分位数绘制的。\n1 2 3 4 5 6 7 x = 1:100 quantile(x) # 0% 25% 50% 75% 100% # 1.00 25.75 50.50 75.25 100.00 quantile(x, probs = c(0.3, 0.6,0.9)) # 30% 60% 90% # 30.7 60.4 90.1 2.3 数据分布估计 直方图：将数据分布范围分为若干个连续的bin，每个bin的长度相同。然后进一步统计处于每个bin中的数量。纵坐标表示为频数。 密度图：可以理解为直方图的平滑表示，即bin的宽度无限小化。纵坐标表示为概率，曲线下面积等于1；所以概率密度图。 概率密度函数：用一个函数方程去描述/预测某个观测值出现的概率，绘制概率密度曲线。不同类型的概率密度函数具有不同的分布特征，适用于不同类型的数据。比如正态分布，二项分布\u0026hellip;\u0026hellip;，其本质上就是描述了数据的分布特征。 3、常见分布 3.1 正态分布 （1）正态分布 数据围绕均值波动，曲线呈钟形。具体的形状取决于数据的两个特征值：（1）均值；（2）方差 $$ X \\sim N(\\mu, \\sigma^2) $$ 正态分布的数据分布很有规律性：以均值为中心，±1σ面积为68.2%；±2σ面积为95.4%；±3σ面积为99.7%\nzscore标准化：数据与均值的差值，再除以标准差的比。它反映了某个值偏离均数的标准差倍数。 $$ Z = \\frac{X-\\mu}{\\sigma} $$\n由Z值组成的数据分布称为均值为0，方差为1的标准正态分布。Z值可直观表示某个观测值在一组数据中所处的位置，例如Z=0，表示处于中间位置；Z=1，表示约处于第84百分位数的位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 rnorm(5) #[1] -1.1093736 0.6631883 0.1295332 -1.5635006 0.5994136 rnorm(5, mean = 10, sd = 10) #[1] 13.5595849 0.2666945 12.9323366 2.0843432 19.4443122 dnorm(1) #密度概率 # [1] 0.2419707 pnorm(1) #累积分布 # [1] 0.8413447 qnorm(0.5) #分位数 # [1] 0 ##下同，每种分布都有上述4类函数 （2）T分布 t分布可以理解为小样本的标准正态分布，相对于标准正态分布曲线更加扁平； t分布是一簇分布，随着样本量/自由度的增加，越接近标准正态分布(n\u0026gt;30)； 在自由度=5时，右侧2.5%面积对应t值为2.57；自由度=30时，右侧2.5%面积对应t值为2.04。（标准正态分布的右侧2.5%面积为1.96） 常用于两个均数是否相等，系数是否为0等\n1 2 rt(5, df=5) # [1] -2.95051051 -0.54738086 -1.60480176 1.13751489 0.08116877 （3）χ2卡方分布 卡方分布衍生自标准正态分布。\n假设一组观测值符合标准正态分布，那么其所有观测值的平方符合自由度为1的卡方分布。\n$$ X = Z_1^2 \\quad\\quad X \\backsim \\chi^2(1) $$\nZ1 = （ 0.16, -0.07, -1.07, -0.44, 0.90）\nS1 = Z1平方 = （0.0256, 0.0049, 1.1449, 0.1936, 0.8100）\n即X = S1符合自由度为1的卡方分布。\n对于多组(n)均符合标准正态分布的观测值，那么其各组平方值跨组相加的结果，符合自由度为n的卡方分布。 $$ X = Z_1^2 + Z_2^2 + \u0026hellip;Z_n^2 = \\sum_{i=1}^{n}Z_i^2 \\quad\\quad X \\backsim \\chi^2(n) $$\nZ1 = （ 0.16, -0.07, -1.07, -0.44, 0.90）; Z2 = (-1.40, 0.00, 0.98, -0.92, -1.12)\nS1 = Z1平方 = （0.0256, 0.0049, 1.1449, 0.1936, 0.8100）\nS2 = Z2平方 = （1.9600, 0.0000, 0.9604, 0.8464, 1.2544）\nS1 + S2 = （1.9856 0.0049 2.1053 1.0400 2.0644）\n即X = S1 + S2 符合自由度为2的卡方分布。\n卡方分布曲线特征只取决于自由度（因为是由标准正态分布转换而来） 卡方分布多用于描述分类资料的实际频数与理论频数之间的抽样误差。\n1 2 3 # shape= 交代自由度 rgamma(5, shape = 3) # [1] 3.054343 2.324643 2.898174 2.223752 3.088181 （4）F分布 若随机变量X符合自由度为m的卡方分布，随机变量Y符合自由度为n的卡方分布。则(X/Y) 符合自由度为m,n的F分布。 如上，F分布有两个参数分别为分子自由度与分母自由度。 $$ X \\backsim \\chi_m^2, , Y \\backsim \\chi_n^2 \\quad\\quad F = \\frac{X/m}{Y/n} $$\nF分布多用于方差比的相关分析，例如方差分析是组间方差与组内方差之比。\n1 2 rf(5, df1 = 5, df2 = 1) #[1] 1.554777e+03 5.389789e-02 3.793949e+01 1.923800e+00 3.065202e+00 3.2 二项分布 （1）二项分布 给定实验次数n，以及每次实验次数成功的概率p，那么成功次数x(0≤x≤n)的概率符合参数为（n，p）的二项分布。 $$ X \\backsim b(n,p) $$\n关于二项分布的期望值与方差的计算公式为 $$ \\mu = np,; \\quad\\quad \\sigma^2 = n\\cdot p\\cdot (1-p) $$\n关于方差的计算公式直观上难以理解，是由二项分布函数推导得到的。\n例如抛硬币实验，定义抛出正面为实验成功，已知正面概率为0.7。假设全班同学每人抛了20次，那么计算出有多少比例同学会抛出了10次以上的正面结果。\n二项分布是离散分布，横坐标表示每次实验发生次数。在规定一个N值很大的情景，即很多次实验的前提下，二项分布可以近似表示为均值为u的正态分布（连续分布）。当n越大（至少20）且p不接近0或1时近似效果更好。 伯努利试验（Bernoulli trial，或译为白努利试验）是只有两种可能结果（“成功”或“失败”）的单次随机试验。\n1 2 rbinom(10, size=5, prob=0.3) #[1] 1 1 1 2 2 0 1 2 0 1 （2）泊松分布 泊松分布：用于估计每时间单位或者空间单位条件下，事件所发生的的平均次数。分布特征仅取决于参数：平均次数λ 可以认为是二项分布的特例。即N非常大，P非常小。例如每次中彩票的人数；每年患流感的人数；在每个样本RNAseq文库中比对到GeneA的count数，实验背景总数很多，但是事件发生的概率很小。当n≧20,p≦0.05时。\n根据二项分布中期望与方差的计算公式，可以推导出在泊松分布中 期望值（即λ）=方差。 $$ \\lambda = np \\approx n\\cdot p\\cdot (1-p) = \\sigma^2 $$\n1 2 rpois(10, lambda=5) # [1] 9 4 5 3 7 7 6 6 4 10 负二项分布：对于一次伯努利试验中，事件成功的概率为p。反复进行该伯努利试验，直到观察到第r次成功发生。此时试验失败次数X的分布即为负二项分布\n（4） 超几何分布 假设在N个物体中，有一组特殊标签的K个物体。当对所有物体不放回地抽出n个物体时，其中k个属于该标签的概率。\n示例-1：N为所有产品数，K为其中不合格样本数。从中抽取n个产品中，有k个产品为不合格概率； 示例-2：N为所有基因数，K为通路A的基因数。分析得到n个差异基因，有k个基因属于该通路的概率。 $$ X \\sim H(n, K, N) $$\n1 2 3 4 5 # n为合格产品数 # m为不合格产品数 # k为抽检的数目 rhyper(5, m=10, n=50, k=5) # [1] 0 1 0 2 0 ","permalink":"https://lishensuo.github.io/en/posts/basic/001%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80--%E7%BB%9F%E8%AE%A1%E6%8F%8F%E8%BF%B0%E6%8C%87%E6%A0%87%E4%B8%8E%E5%B8%B8%E8%A7%81%E7%BB%9F%E8%AE%A1%E5%88%86%E5%B8%83/","summary":"\u003cblockquote\u003e\n\u003cp\u003e统计的对象是\u003cstrong\u003e数据\u003c/strong\u003e，其中会涉及到不同类型的数据；统计的目的是\u003cstrong\u003e描述\u003c/strong\u003e，描述一组数据的分布特征、两组至多组数据之间的关系。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1数据分类\"\u003e1、数据分类\u003c/h1\u003e\n\u003cp\u003e根据数据特点，可以分为2大类：\u003c/p\u003e","title":"统计学基础--统计描述指标与常见统计分布"},{"content":"print()打印 1 2 3 4 5 6 7 8 print(\u0026#34;Hello, world!\u0026#34;) #打印多个字符串，默认用空格链接 print(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;) print(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;,sep=\u0026#34;,\u0026#34;) #`+`可直接拼接字符串 print(\u0026#34;A\u0026#34;+\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;) #AB C input()取用户输入 1 2 x = int(input(\u0026#34;请输入x：\u0026#34;)) print(x) 关于python脚本程序 1 2 3 4 5 6 7 8 9 # 方式一：使用shell的python命令显示运行python脚本 python hello.py # 方式二：在python脚本首行指定python解释器，如下所示 #!/usr/bin/env python #然后可执行 chmod a+x hello.py #直接运行 ./hello.py 关于反斜杠\\ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### (1) 转义符 print(\u0026#39;Let\\\u0026#39;s, go\u0026#39;) print(\u0026#34;Let\u0026#39;s, go\u0026#34;) ### (2) 转义转义符:将转义符当作普通的转斜杠字符 # \\n 表示换行 print(\u0026#34;Hello, \\nworld\u0026#34;) # 将 `\\n`当作普通字符打印 print(r\u0026#39;Hello, \\nworld\u0026#39;) ### (3) 字符串/表达式/语句换行 print(\u0026#34;Hello, \\ world!\u0026#34;) print \\ (\u0026#34;Hello, world!\u0026#34;) 赋值语句与序列解包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #简单用法 x = 1 #序列解包 x, y, z = 1, 2, 3 ## 其实上面表达式右边本质是一个元组序列 print(x,y,z) x, y, z = [1, 2, 3] print(x,y,z) #一般来说左右两边的元素数要相同，但可以使用星号运算符收集多余的值 x, y, *z = 1,2,3,4,5 print(x, y) ## 1 2 x, *y, z = 1,2,3,4,5 print(x, y, z) ## 1 [2, 3, 4] 5 ","permalink":"https://lishensuo.github.io/en/posts/program/001python%E5%9F%BA%E7%A1%80-1%E5%88%9D%E8%AF%86/","summary":"\u003ch4 id=\"print打印\"\u003eprint()打印\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#打印多个字符串，默认用空格链接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;A\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;B\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;C\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;A\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;B\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;C\u0026#34;\u003c/span\u003e,sep=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#`+`可直接拼接字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;A\u0026#34;\u003c/span\u003e+\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;B\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;C\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#AB C\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"input取用户输入\"\u003einput()取用户输入\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;请输入x：\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"关于python脚本程序\"\u003e关于python脚本程序\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 方式一：使用shell的python命令显示运行python脚本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epython  hello.py\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 方式二：在python脚本首行指定python解释器，如下所示\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#!/usr/bin/env python\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#然后可执行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003echmod a+x hello.py\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#直接运行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e./hello.py \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"关于反斜杠\"\u003e关于反斜杠\u003ccode\u003e\\\u003c/code\u003e\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### (1) 转义符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;Let\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003es, go\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Let\u0026#39;s, go\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### (2) 转义转义符:将转义符当作普通的转斜杠字符\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \\n 表示换行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Hello, \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003eworld\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 将 `\\n`当作普通字符打印\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003er\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;Hello, \\nworld\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### (3) 字符串/表达式/语句换行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Hello, \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003eworld!\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e \\\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Hello, world!\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"赋值语句与序列解包\"\u003e赋值语句与序列解包\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#简单用法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#序列解包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex, y, z = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 其实上面表达式右边本质是一个元组序列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x,y,z)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex, y, z = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x,y,z)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#一般来说左右两边的元素数要相同，但可以使用星号运算符收集多余的值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex, y, *z = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x, y)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 1 2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex, *y, z = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x, y, z)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 1 [2, 3, 4] 5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Python基础-(1)初识"},{"content":"统计学常用样本数据推断总体结果，或者说使用样本统计量推断总体参数。包含如下意义：\n（1）对于样本数据，根据问题的不同，会有不同的形式。例如单纯描述一组的数据分布，那么就是原始收集数据；如果描述两组差异，那么差值才是样本数据，而此时目的就是研究总体差值的分布。\n（2）理论上来说：总体的参数(均值，方差\u0026hellip;)是固定的，但是现实一般做不到；但是从总体抽取的样本数据可以计算样本统计量，但是每一次抽样结果计算的样本统计量存在差异。即抽样误差。\n1、中心极限定理 1.1 统计量符合正态分布 假定有一个总体数据，如果从该总体中多次抽样，那么理论上，每次抽样所得的统计量(如均数)与总体参数应该差别不大，大致围绕在总体参数中心，并且呈正态分布（如果是少量样本的话，就是对应自由度的T分布）。\n（1）无论原总体数据是什么分布，多次抽样的样本统计量都呈正态分布；\n（2）中心极限定理描述的是样本统计量的分布，常见的就是均值。\n（3）抽样的样本量越大（大于30），越容易得到一个接近总体参数的统计量（曲线越瘦长）。\n1.2 标准误与置信区间 (1) 标准误 由于样本统计量符合正态分布，可以计算出标准误(se, Stand Error)，用以描述表示样本统计量的标准差\n标准误越大，表明一次抽样结果计算出的样本统计量难以反映总体水平的真实情况；或者说”准确性“越低。\n按照直观理解，计算标准误需要进行多次抽样，然后根据每次抽样的样本统计量计算结果标准误。\n但是现实一般都只有一个样本数据，可通过如下公式近似计算：\n下述公式中 s表示当前样本数据的标准差，n表示样本数。 s越大(样本数据越离散)、n越小(样本数据越少)，则标准误越大； 计算公式由数学推导而得，前提是样本数据符合正态分布。这一点很重要，之后还会提到。 $$ se = \\frac{s}{\\sqrt{n}} $$\n(2) 置信区间 假如使用一组样本数据的统计量(例如均值)去描述总体参数，通常称之为点估计。但是由于抽样误差的存在，样本统计量与总体参数总会存在一定差距，可使用区间估计的方法，描述总体参数的大致范围。\n置信区间(confidence interval, CI)：基于标准误的结果，估计某一区间内包含总体参数的可能性。\n例如：90%置信区间，表示有90%的信心认为该区间内包含了总体参数。 结合正态分布或者近似正态分布的t分布的曲线下面积规律，可以计算出相应t值/或者z值对应的置信区间。\n如下公式表示均数的置信区间： $$ CI \\in \\overline{x} ,\\pm , t × se $$\n2、假设检验与T检验 2.1 假设检验 （1）假设检验采用反证法：即设法证明预期结论的完全对立面是不可能发生的。例如判断一个人是好人，就证明他不可能是坏人。\n（2）两个假设：\n零假设（null hypothesis，H0）：之所以称为零假设，是因为它的假设一般是组间差异为0；两个变量相关系数为0；回归系数为0等 备择假设（alternative hypothesis，H1）：而零假设完全相反的陈述。如组间差异不为0（即有差异）；相关系数不为0（即相关） （3）零假设是要推翻的。如果零假设是错误的，那么备择假设就一定是正确的。\n（4）假设检验通常用于计算得出定性的结论，而不能得出定量的结论。例如两组的均值存在显著差异，但差异幅度是多少是无法获知的。\n（5）假设检验的判断基于中心极限定理，即多次抽样的统计量分布符合正态分布（t分布）。下面以T检验为例，解释下假设检验的思路。\n2.2 T检验 （1）T检验根据假设检验的思想，常用于检验某一样本统计量是否与总体参数相等。要根据实际问题理解样本统计量与总体参数。\n在两独立样本t检验中某样本统计量是两组均值差，总体参数是两总体均值差（常假定为0，即不存在差异） 在回归系数检验中，样本统计量是样本系数，总体参数是总体系数（常假定为，即不存在回归关系）。 以两独立样本t检验为例：先假设两组样本均值不存在差异；然后判断所计算差值的概率是多少。一般认为P\u0026lt;0.05是小概率事件。即两组样本均值不存在差异的概率很小；反之均值存在差异的概率就很大。\n（2）应用假设检验的前提是样本数据符合正态分布。当样本数据在比较小(\u0026lt;30)的范围时，则是要符合相应自由度的T分布。\n（3）根据具体问题，有三种常见的T检验：[关键是辨析样本数据的定义]\n单样本T检验：给定一组样本的数据，判断是否等于某一水平。\n例如某班学生成绩是否接近于80分。\n学生 小明 小王 小李 小红 小孙 成绩 81 90 70 85 76 样本值 81-80=1 90-80=10 70-80=-10 85-80=5 76-80=-4 如上表，该问题转换为 [1, 10, -10, 5, -4]这组数据的统计量(1+10-10+5-4)/5=0.4出现在均值为0，标准差为se（参考极限中心定理的标准误计算公式，取决于样本标准差与样本数）的零假设统计量的t分布的可能性是多少？\n配对T检验：给定一一对应的两组数据，判断两组间水平是否存在差异。\n例如取10个癌症患者的各自癌旁与癌组织测序，分析某一基因的表达是否存在差异。\n病人 01 02 03 04 05 癌组织 10 12 24 15 19 癌旁组织 8 9 12 10 11 样本值 10-8=2 12-9=3 24-12=12 15-10=5 19-11=8 如上表，该问题转换为 [2,3,12,5,8]这组数据的统计量(2+3+12+5+8)/5=6出现在均值为0，标准差为se（参考极限中心定理的标准误计算公式，取决于样本标准差与样本数）的零假设统计量的t分布的可能性是多少？\n所以配对T检验本质上还是单样本T检验。\n独立样本T检验：不同来源的两组数据，判断两组水平是否存在差异。\n例如取10个癌症患者的血液，与5个健康人的血液样品测序，分析某一基因的表达是否存在差异。\n编号 P01 P02 P03 P04 P05 H01 H02 H03 组别 患者 患者 患者 患者 患者 健康 健康 健康 结果 12 15 11 14 14 10 11 9 组均值 13.2 13.2 13.2 13.2 13.2 10 10 10 如上表，该问题转换为样本统计量13.2-10=3.2出现在均值为0，标注差为se（参考极限中心定理，取决于样本标准差与样本数）的零假设统计量的t分布的可能性是多少？\n对于独立样本T检验中标准误的计算，根据两组数据的方差是否相同有两种不同处理方式。但仍与各组的方差与样本数有关。\n上面三种方法最终都会计算出t值，继而求出在对应自由度的零假设T分布中出现该t值（甚至）更大的概率，即P值。\n对于双侧检验（零假设 H0: Udiff=0）:计算两端的概率；对于单侧检验（零假设H0：0）: Udiff\u0026gt;0 计算右侧的概率；Udiff\u0026lt;0 计算左侧的概率 P值可以理解为：在零假设成立的前提下，出现如此t统计量的概率是多少。P值越小，表明越不可能出现，即零假设越不可能成立；进而支持其对立面的备择假设。 $$ t = \\frac{样本统计量-总体参数}{样本统计量的标准差(标准误)} $$\n假如样本数据不符合正态分布，那么理论上就不可以使用T检验。可以选择非参数检验的Wilcoxon秩和检验，将样本数据转换为秩（排名）进行假设检验分析。\n2.3 两类错误 假如把看病问题视为假设检验，零假设为健康，备择假设为患病。\n当医生碰到一个经常锻炼的运动员时较容易正确判断是健康人，碰到一个咳嗽不停的人时较容易争取判断是病人；但是遇到一个处于这两者中间状态的人，判断时需要谨慎：以免娇弱的人误诊为病人（假阳性）；有前兆的病人漏诊为健康人（假阴性）。\n根据假设检验的P值结果得出的结论，会不可避免出现下面两种错误的可能：\n假阳性(FP, False Positive)又称为第一类错误，错误地认为H1是正确的，用α表示；如上图蓝色区域(娇弱的人)；\n假阴性(FN, False Negative)又称为第二类错误，错误地认为H1是不存在的，用β表示；如上图红色区域(有前兆的病人)\n这两类错误的出现是此消彼长的关系：\n当P值很小，才判定H0假设为不可能事件时\u0026ndash;α降低；β增高\n宁可漏诊，不能错诊。 一般来说更加重视假阳性的结果，即将P值的阈值定位非常低的水平。\n3、T检验基于R 1 2 3 4 5 6 7 8 9 10 11 12 13 # 两种安眠药(与控制组相比所增加的睡眠时间)对10名患者的影响。 data(sleep) table(sleep$group) # 1 2 # 10 10 head(sleep) # extra group ID # 1 0.7 1 1 # 2 -1.6 1 2 # 3 -0.2 1 3 # 4 -1.2 1 4 # 5 -0.1 1 5 # 6 3.4 1 6 3.1 单样本T检验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 t.test(extra ~ 1, data = sleep) # One Sample t-test # # data: extra # t = 3.413, df = 19, p-value = 0.002918 # alternative hypothesis: true mean is not equal to 0 # 95 percent confidence interval: # 0.5955845 2.4844155 # sample estimates: # mean of x # 1.54 t.test(extra ~ 1, data = sleep)$p.value t.test(sleep$extra ~ 1) 3.2 独立样本T检验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 t.test(extra ~ group, data = sleep) # t.test(extra ~ group, data = sleep) # Welch Two Sample t-test # # data: extra by group # t = -1.8608, df = 17.776, p-value = 0.07939 # alternative hypothesis: true difference in means between group 1 and group 2 is not equal to 0 # 95 percent confidence interval: # -3.3654832 0.2054832 # sample estimates: # mean in group 1 mean in group 2 # 0.75 2.33 t.test(extra ~ group, data = sleep)$p.value t.test(sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2]) 3.3 配对样本T检验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 t.test(extra ~ group, data = sleep, paired = TRUE) # Paired t-test # # data: extra by group # t = -4.0621, df = 9, p-value = 0.002833 # alternative hypothesis: true difference in means is not equal to 0 # 95 percent confidence interval: # -2.4598858 -0.7001142 # sample estimates: # mean of the differences # -1.58 t.test(extra ~ group, data = sleep, paired = TRUE)$p.value t.test(sleep$extra[sleep$group==1], y = sleep$extra[sleep$group==2], paired = TRUE) 3.4 wilcox.test秩和检验 将上述的t.test()替换为wilcox.test()，即可执行对应方式的秩和检验。\nPerforms one- and two-sample Wilcoxon tests on vectors of data; the latter is also known as ‘Mann-Whitney’ test.\n1 2 3 4 5 6 7 8 ##(1)单样本 wilcox.test(extra ~ 1, data = sleep) ##(2)两独立样本 wilcox.test(extra ~ group, data = sleep) ##(3)配对样本 wilcox.test(extra ~ group, data = sleep, paired = TRUE) ","permalink":"https://lishensuo.github.io/en/posts/basic/002%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80--%E4%BB%A5t%E6%A3%80%E9%AA%8C%E4%B8%BA%E4%BE%8B%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86%E7%9A%84%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/","summary":"\u003cp\u003e统计学常用样本数据推断总体结果，或者说使用\u003cstrong\u003e样本统计量\u003c/strong\u003e推断总体参数。包含如下意义：\u003c/p\u003e\n\u003cp\u003e（1）对于\u003cstrong\u003e样本数据\u003c/strong\u003e，根据问题的不同，会有不同的形式。例如单纯描述一组的数据分布，那么就是原始收集数据；如果描述两组差异，那么\u003cstrong\u003e差值才是样本数据\u003c/strong\u003e，而此时目的就是研究总体差值的分布。\u003c/p\u003e","title":"统计学基础--以T检验为例学习基于中心极限定理的假设检验"},{"content":" conda开源包管理系统和环境管理系统 ，包括多种语言的包安装，运行，更新，删除，最重要的是可以解决包依赖问题。在做生信分析时，感觉就是一个软件管家一样的存在，在安装生信软件等方面上十分方便。下面小结一下conda的基础操作\n后面介绍的所有conda命令都可以替换为如下的mamba命令，从而实现高速的下载等操作 1 conda install -c conda-forge mamba 1、下载、安装miniconda包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh # 开始安装，过程中根据提示回车或者yes就行了~ # source ~/.bashrc # 配置国内镜像源，提高以后下载软件速度 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda conda config --set show_channel_urls yes conda config --get #查看已设置的channels # 如果想要删除某镜像源 # conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free 如果出现conda命令找不到的情况，可按下法操作。不过现在安装，好像一般都会自动添加了。\n1 2 3 4 5 6 7 8 9 cat ~/.bashrc #此时应该没有miniconda的路径 nano ~/.bashrc #将下面一行代码输入到最后 echo ‘export PATH=“home/user/miniconda3/bin:$PATH”’ \u0026gt;\u0026gt; ~/.bashrc #保存退出 cat ~/.bashrc #此时应该是修改好的版本了 source ~/.bashrc #更新一下，然后下面的操作就可以顺利进行了。 2、环境管理 类似Linux系统是一个大庭院，我们专门为做一件事情（需要一系列软件）而设置的一个房间（环境），这样就会使这个大庭院干净利落很多，不会很乱。做一件事，到相应的房间（conda环境）去使用软件就行。这些软件的命令都是可以直接使用的，这就很方便了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #创建一个名为rna-seq的环境 conda create -n rna-seq #进入该环境，此时可以看到命令行提示符前缀已经发生了变化 conda activate rna-seq #退出环境 conda deactivate #查看系统有哪些环境（房间） conda info --envs #删除名字为name的环境 conda remove -n name --all #环境重命名：先复制改名，再删除旧的 conda create -n newname --clone oldname conda remove -n oldname --all #复制环境到新电脑 ## 先进入目标环境 conda activate myconda ## 然后生成yaml文件 conda env export \u0026gt; myconda.yaml ## 传递该yaml文件到目标电脑，再安装即可 conda env create -f myconda.yaml 3、下载、管理软件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #搜索软件 conda search fastqc #下载软件， ## -y 参数表自动安装 ## -c 指定软件下载的channal源 conda install -c bioconda fastqc -y #下载指定版本的软件 conda install -c bioconda fastqc=0.11.7 #查看当前环境下的所有软件 conda list #卸载软件 conda remove fastqc -y 4、安装R包 CRAN的R包：r-package；不区分大小写 1 2 3 mamba install -c r r-base mamba install -c r r-essentials mamba install -c r r-ggplot2 安装r-base之后，就可以进入R环境，使用R的命令安装包。\n（1）有时R的命令安装不了的包，使用conda可以安装成功。\n（2）但是conda安装包的版本往往具有滞后性\nBioconductor的生信包：bioconductor-package；不区分大小写 1 mamba install -c r bioconductor-deseq2 bioconductor-edger Rstudio\n在conda里也可以安装自己的rstudio，相关网页参见：https://anaconda.org/r/rstudio\n经过实践尝试之后，发现最新只提供到1.1.456的Rstudio版本（目前已经更新到1.4版本了），与之对应的就只能使用3.6的R\n1 2 3 4 5 6 7 8 9 10 #单独创建一个rstudio环境 conda activate rstudio #这一步会默认安装最新版的R(\u0026gt;4.0) mamba install -c r r-essentials r-base #首先会默认安装1.0版本的rstudio，会自动把r降到3.2的版本 conda install -c r rstudio #然后再指定升级rstudio至1.1.456版本，会自动把r升到3.6的版本 conda install -c r rstudio=1.1.456 #启动rstudio界面 rstudio 安装rstudio时并没有使用mamba安装，因为失败了。使用conda安装，也需要等待较长时间，甚至多试几次。但最终还是可以滴。 关于设置R包下载镜像地址：https://www.jianshu.com/p/9940fb1864c3 20241226补：conda-pack环境迁移\n官方文档 https://conda.github.io/conda-pack/\n(1) 首先在想要迁移的conda环境中安装 conda-pack 1 2 conda activate huggingface conda install conda-pack (2) 然后对当前环境打包为压缩文件 1 2 conda-pack # huggingface.tar.gz (3) 将该压缩包文件移到新环境中，并解压 1 2 mkdir -p miniconda3/envs/huggingface tar -xf huggingface.tar.gz -C miniconda3/envs/huggingface/ 可以使用rsync命令，将数据在不同服务器之间远程同步。\n1 2 3 4 5 6 7 8 9 # 将data文件或者目录本身搬到另一个服务器的save目录下 rsync -avzP /home/user/data name@ip:/home0/user2/save # 将data目录下所有内容搬到另一个服务器的save目录下 rsync -avzP /home/user/data/ name@ip:/home0/user2/save # -a：归档模式，保留文件的权限、符号链接、修改时间和其他属性。 # -v：详细模式，显示传输过程中的详细信息。 # -z：在传输过程中压缩数据以减少带宽使用。 # -P：断点续传+实时进度： 1 2 3 4 5 6 7 8 9 10 11 12 13 # 如果需要秘钥登陆目标服务器 rsync -avzP -e \u0026#34;ssh -i ./id_rsa -p 22\u0026#34; /home/user/data/ name@ip:/home0/user2/save # --exclude参数可以排除特定文件的传输 # 服务器002 192.168.101.1 OR 192.158.1.101 # 服务器Dragon 192.168.101.2 OR 192.158.1.100 # 服务器002 ---\u0026gt; 服务器Dragon: rsync -avz --progress -e \u0026#39;ssh -p 22\u0026#39; /002_data01/liss/processing/ 192.158.1.100:/dragon_home/liss/processing rsync -avz --progress -e \u0026#39;ssh -p 22\u0026#39; /home01/liss/datasets/ 192.158.1.100:/home00/liss/datasets # \u0026#34;--delete\u0026#34; is dangerous (4) 最后即可使用常规的conda命令进行操作 补充：对于R语言环境，产生类似如下的报错时，可参考这个解决方式：https://github.com/conda/conda-pack/issues/246 方法之一是在解压、激活后，使用conda-unpack命令\n1 cannot open /workspace/croot/r-base_1695428141831/_h_env_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_placehold_/lib/R/etc/ldpaths: No such file 在conda-pack的解压过程中，有几次遇到类似如下报错，暂时不清楚原因，目前测试解压后的环境可以使用 1 2 3 tar -xzf r_env3.tar.gz -C miniconda3/envs/r_env3_test/ tar: Skipping to next header tar: Exiting with failure status due to previous errors ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/002conda%E7%8E%AF%E5%A2%83%E4%B8%8B%E8%BD%BD%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6r%E5%8C%85/","summary":"\u003cblockquote\u003e\n\u003cp\u003econda开源包管理系统和环境管理系统 ，包括多种语言的包安装，运行，更新，删除，最重要的是可以解决包依赖问题。在做生信分析时，感觉就是一个软件管家一样的存在，在安装生信软件等方面上十分方便。下面小结一下conda的基础操作\u003c/p\u003e","title":"conda环境下载管理软件、R包"},{"content":"关于序列 序列：有顺序的元素排列；第一个元素的索引为0 列表list，元组tuple，字符串str都属于序列；但一般情况下，只有list可修改，后二者不可修改 一、序列通用操作 1、索引\u0026ndash;访问元素里的单个元素 indexing 第一个元素的索引为0； 倒数第n个元素的索引为-n 1 2 3 4 greet = \u0026#39;Hello\u0026#39; greet[0] greet[-1] \u0026#39;Hello\u0026#39;[0] 2、切片\u0026ndash;访问某个范围的多个元素 slicing 需要提供两个索引指定范围的边界。 第一个索引是起始点的编号，第二个索引是边界终点的编号**+1** 1 2 3 4 5 6 7 8 9 numbers = [1,2,3,4,5,6,7,8,9,10] numbers[1:3] # [2, 3] numbers[-5:-3] # [6, 7] numbers[3:] numbers[:9] numbers[:] 3、序列相加/相乘 1 2 3 4 5 # 序列相加（连接） [1,2,3] + [4,5,6] # 序列相乘 \u0026#39;hello\u0026#39; * 3 4、确认是否包含某元素 1 2 3 4 5 \u0026#39;A\u0026#39; in \u0026#39;ABC\u0026#39; # True \u0026#39;li\u0026#39; in [\u0026#39;li\u0026#39;, \u0026#39;wang\u0026#39;,\u0026#39;zhou\u0026#39;] # True 5、补充：关于set集合 集合set内没有重复元素，且没有顺序，所以本质上不属于序列； 可使用set()函数创建集合，或者使用{}创建； 主要用于成员资格检查（类似上面的第4点），以及集合的交、并、补等操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ##创建集合 set(range(5)) # {0, 1, 2, 3, 4} {4,6,1,9,0} # {0, 1, 4, 6, 9} ##成员资格检查 0 in {4,6,1,9,0} # True ##集合操作 a = {1,2,3} b = {1,2,4} c = {1,2} ###(1)交集 a.intersection(b) # 通过函数调用，b可以是list等可迭代对象 （下同） a \u0026amp; b # 通过符号调用，b必须是set对象 （下同） # {1, 2} ###(2)是否子集 c.issubset(a) c \u0026lt;= a # True ###(3)差集 a.difference(b) a-b # {3} ###(4)全集 a.union(b) a | b # {1, 2, 3, 4} 二、列表的特有操作 1、利用索引与切片直接修改列表 索引 1 2 x = [1,2,3] x[1] = 1 切片 1 2 3 4 5 6 7 8 9 10 11 #由于字符串不能修改，需要先将字符串转为列表 names = list(\u0026#39;python\u0026#39;) names[1:3] = list(\u0026#39;YT\u0026#39;) #由于赋值的字符串的长度可以与被修改的字符串长度不同，所以可以引申用法 ## 变相的插入 names = list(\u0026#39;python\u0026#39;) names[1:1] = list(\u0026#39;AAA\u0026#39;) ## 变相的删除 names = list(\u0026#39;python\u0026#39;) names[1:3] = [] 2、列表的方法\u0026ndash;增删改查 增 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # (1) append: 增加元素到末尾 numbers = [1, 2, 3] numbers.append(4) ##原地修改，无返回值 # (2) extend: 增加列表里的元素到末尾 numbers = [1, 2, 3] numbers.extend([4, 5, 6]) ##原地修改，无返回值 # (3) insert: 在指定索引位置插入元素 numbers = [1, 2, 3] numbers.insert(2, \u0026#34;four\u0026#34;) # [1, 2, \u0026#39;four\u0026#39;, 3] ##原地修改，无返回值 删 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # (1) pop: 删除最后一个元素 numbers = [1, 2, 3] numbers.pop() ##原地修改，并返回被删除的值 # (2) remove: 删除指定元素的值 numbers = [1, 2, 3] numbers.remove(1) # [2, 3] ##原地修改，无返回值 # 关于list列表的删除操作，有一个函数`del`支持根据索引删除元素 numbers = [1, 2, 3] del numbers[1] # [1, 3] 改 1 2 3 4 5 6 7 8 9 # (1) reverse: 逆转当前列表元素的顺序 numbers = [1, 2, 3] numbers.reverse() ##原地修改，无返回值 # (2) sort: 顺序排列当前列表的元素, 默认升序排列 numbers = [2, 1, 3] numbers.sort() numbers.sort(reverse=True) 查 1 2 3 4 5 6 7 # (1) count: 查看某一元素的频率 numbers = [1, 2, 2, 3, 3, 3] numbers.count(2) # (2) index: 查看某一元素值的索引 numbers = [1, 2, 3] numbers.index(2) 3、filter()搭配lamda列表筛选 filter()函数包含如下两个参数\n第一个参数是函数：以列表的元素作为逐一遍历，返回一一对应的逻辑值True/False 第二个参数是想要筛选的目标列表 1 2 3 4 5 6 7 8 9 10 11 12 ## 示例1 def is_odd(n): #判断是否为奇数 return n % 2 == 1 list(filter(is_odd, [1, 2, 3, 4, 5])) # [1, 3, 5] ## 示例2 import re data_list = [\u0026#39;cat_1\u0026#39;, \u0026#39;dog_1\u0026#39;, \u0026#39;dog_2\u0026#39;, \u0026#39;cat_2\u0026#39;, \u0026#39;dog_3\u0026#39;, \u0026#39;cat_3\u0026#39;] list(filter(lambda x: re.match(\u0026#39;dog.*\u0026#39;, x) != None, data_list)) # [\u0026#39;dog_1\u0026#39;, \u0026#39;dog_2\u0026#39;, \u0026#39;dog_3\u0026#39;] 三、元组的特有操作 创建元组 1 2 3 4 5 6 7 8 9 10 11 #创建3个元素的元组 (1, 2, 3) #创建1个元素的元组 (1,) #创建空元组 () #将列表转为元组 tuple([1,2,3]) 四、字符串操作 字符串本身也是一种序列，且不可修改\n1、字符串格式化 %百分号 1 2 3 4 5 6 7 test = \u0026#39;Hello, %s!\u0026#39; test % \u0026#39;Li\u0026#39; # \u0026#39;Hello, Li!\u0026#39; test_num = \u0026#39;%s price is %.2f\u0026#39; test_num % (\u0026#39;Tomato\u0026#39;, 3.23333) # \u0026#39;Tomato price is 3.23\u0026#39; format方法：{}花括号 1 2 3 4 5 6 7 8 9 10 11 test = \u0026#39;Hello, {} and {}\u0026#39; test.format(\u0026#39;Li\u0026#39;, \u0026#39;Wang\u0026#39;) # \u0026#39;Hello, Li and Wang\u0026#39; ##可以指定顺序 \u0026#39;Hello, {2} , {0} and {1}\u0026#39;.format(\u0026#34;Li\u0026#34;,\u0026#34;Wang\u0026#34;,\u0026#34;Sun\u0026#34;) # \u0026#39;Hello, Sun , Li and Wang\u0026#39; ##可以通过关键字参数调整顺序 \u0026#39;{something} price is {price:.2f}\u0026#39;.format(something=\u0026#39;Tomato\u0026#39;, price=3.23333) # \u0026#39;Tomato price is 3.23\u0026#39; f关键字 1 2 3 4 5 name = \u0026#34;Li\u0026#34; time = \u0026#34;Morning\u0026#34; f\u0026#34;Good {time}, Mr.{name}\u0026#34; # \u0026#39;Good Morning, Mr.Li\u0026#39; 2、字符串常用方法 替换 1 2 3 4 5 6 7 8 9 10 11 # (1) replace: 全部替换 \u0026#39;This is a test\u0026#39;.replace(\u0026#39;is\u0026#39;, \u0026#39;eez\u0026#39;) # (2) translate: 一一对应替换 table = str.maketrans(\u0026#39;ATCG\u0026#39;,\u0026#39;TAGC\u0026#39;) \u0026#39;ATTCCCGGGG\u0026#39;.translate(table) ## \u0026#39;TAAGGGCCCC\u0026#39; table = str.maketrans(\u0026#39;ATCG\u0026#39;,\u0026#39;TAGC\u0026#39;,\u0026#39;N\u0026#39;) #第3个参数表示删除字符 \u0026#39;ANTTNCCCNGGGG\u0026#39;.translate(table) ## \u0026#39;TAAGGGCCCC\u0026#39; 序列与字符串的转换 1 2 3 4 5 6 7 8 9 10 11 # (1) join: 将列表转为字符串 \u0026#39;\u0026#39;.join([\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]) ## \u0026#39;ABC\u0026#39; \u0026#39;,\u0026#39;.join([\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]) ## \u0026#39;A,B,C\u0026#39; # (2) split: 将字符串转为列表 \u0026#39;1+2+3+4\u0026#39;.split(\u0026#39;+\u0026#39;) ## [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] \u0026#39;1 2 3 4\u0026#39;.split() #默认为空格为分隔符 ## [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] 字符串两端的修剪 1 2 3 4 5 6 # (1) strip: 去除字符串两端的空格或者其它字符 \u0026#39; ABC \u0026#39;.strip() \u0026#39;* ABC !\u0026#39;.strip(\u0026#39; *!\u0026#39;) # (2) center: 在字符串两端添加空格或者其它字符至指定的长度 \u0026#39;ABC\u0026#39;.center(10,\u0026#39;*\u0026#39;) 子串的定位 1 2 3 # find: 返回子串的第一个索引。若没有找到，则返回 -1 \u0026#39;This is a test\u0026#39;.find(\u0026#39;is\u0026#39;) ## 2 大小写转换 1 2 3 4 5 \u0026#39;ABC\u0026#39;.lower() ## \u0026#39;abc\u0026#39; \u0026#39;abc\u0026#39;.upper() ## \u0026#39;ABC\u0026#39; 五、字典 字典dictionary就是键值对（键-key与值-value一一对应） 字典是无序的，不属于上述所说的序列 字典的键不能重复 1、创建字典 1 2 3 4 5 6 7 8 # (1) 直接创建 test = {\u0026#34;A\u0026#34;:1, \u0026#34;B\u0026#34;:2, \u0026#34;C\u0026#34;:3} # (2) 向dict()函数提供包含键值对信息的列表嵌套元组/列表 test = dict([(\u0026#34;A\u0026#34;, 1), (\u0026#34;B\u0026#34;, 2), (\u0026#34;C\u0026#34;, 3)]) # (3) 使用dict()函数的关键字实参 test = dict(A=1, B=2, C=3) 2、适用字典的序列操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 test = dict(A=1, B=2, C=3) # (1) 长度 len(test) # (2) 查看某个键的值 test[\u0026#34;A\u0026#34;] # (3) 修改某个键的值 test[\u0026#34;A\u0026#34;] = 0 # (4) 新增键值对 test[\u0026#34;D\u0026#34;] = 4 # (5) 删除键值对 del test[\u0026#34;A\u0026#34;] # (6) 查看字典里是否包含某一个键 \u0026#34;A\u0026#34; in test \u0026#34;B\u0026#34; in test # (7) 字符串的format_map方法即使用字典对字符串进行格式化操作 test = dict(A=1, B=2, C=3) \u0026#39;This is just {A}{B}{C}, not {C}{B}{A}\u0026#39;.format_map(test) 3、字典的方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 test = dict(A=1, B=2, C=3) # (1) items 键值对字典视图,可通过list函数转为列表 test.items() list(test.items()) # (2) keys 键的字典视图,可通过list函数转为列表 test.keys() list(test.keys()) # (3) values 值的字典视图,可通过list函数转为列表 test.values() list(test.values()) # (4) get 查找字典里某一个键的值，如果没有不会报错 test = dict(A=1, B=2, C=3) test.get(\u0026#39;A\u0026#39;) test.get(\u0026#39;D\u0026#39;) #返回空值 test.get(\u0026#39;D\u0026#39;, \u0026#34;N/A\u0026#34;) #返回指定值 # (5) pop 在键值对取出指定键值对 test = dict(A=1, B=2, C=3) a = test.pop(\u0026#39;A\u0026#39;) a # 1 test # {\u0026#39;B\u0026#39;: 2, \u0026#39;C\u0026#39;: 3} # (6) updata 合并两个字典为一个字典 dict1 = {\u0026#39;a\u0026#39;: 10, \u0026#39;b\u0026#39;: 8} dict2 = {\u0026#39;d\u0026#39;: 6, \u0026#39;c\u0026#39;: 4} dict2.update(dict1, ) #原地修改，无返回值 dict2 # {\u0026#39;d\u0026#39;: 6, \u0026#39;c\u0026#39;: 4, \u0026#39;a\u0026#39;: 10, \u0026#39;b\u0026#39;: 8} ","permalink":"https://lishensuo.github.io/en/posts/program/002python%E5%9F%BA%E7%A1%80-2%E5%88%97%E8%A1%A8%E5%85%83%E7%BB%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E5%85%B8/","summary":"\u003ch2 id=\"关于序列\"\u003e关于序列\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e序列：有顺序的元素排列；第一个元素的索引为0\u003c/li\u003e\n\u003cli\u003e列表list，元组tuple，字符串str都属于序列；但一般情况下，只有list可修改，后二者不可修改\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"一序列通用操作\"\u003e一、序列通用操作\u003c/h2\u003e\n\u003ch4 id=\"1索引访问元素里的单个元素\"\u003e1、索引\u0026ndash;访问元素里的单个元素\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eindexing\u003c/li\u003e\n\u003cli\u003e第一个元素的索引为\u003ccode\u003e0\u003c/code\u003e；\u003c/li\u003e\n\u003cli\u003e倒数第n个元素的索引为\u003ccode\u003e-n\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egreet = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;Hello\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egreet[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egreet[-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;Hello\u0026#39;\u003c/span\u003e[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2切片访问某个范围的多个元素\"\u003e2、切片\u0026ndash;访问某个范围的多个元素\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eslicing\u003c/li\u003e\n\u003cli\u003e需要提供两个索引指定范围的边界。\u003c/li\u003e\n\u003cli\u003e第一个索引是起始点的编号，第二个索引是边界终点的编号**+1**\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [2, 3]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers[-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e:-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [6, 7]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e:] \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers[:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers[:]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"3序列相加相乘\"\u003e3、序列相加/相乘\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 序列相加（连接）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] + [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 序列相乘\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;hello\u0026#39;\u003c/span\u003e * \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"4确认是否包含某元素\"\u003e4、确认是否包含某元素\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;A\u0026#39;\u003c/span\u003e in \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;ABC\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;li\u0026#39;\u003c/span\u003e in [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;li\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;wang\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;zhou\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"5补充关于set集合\"\u003e5、补充：关于set集合\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e集合set内没有重复元素，且没有顺序，所以本质上不属于序列；\u003c/li\u003e\n\u003cli\u003e可使用\u003ccode\u003eset()\u003c/code\u003e函数创建集合，或者使用\u003ccode\u003e{}\u003c/code\u003e创建；\u003c/li\u003e\n\u003cli\u003e主要用于成员资格检查（类似上面的第4点），以及集合的交、并、补等操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##创建集合\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eset\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {0, 1, 2, 3, 4}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {0, 1, 4, 6, 9}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##成员资格检查\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e in {\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##集合操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = {\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb = {\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ec = {\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###(1)交集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea.intersection(b) \u003cspan style=\"color:#007f7f\"\u003e# 通过函数调用，b可以是list等可迭代对象 （下同）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u0026amp; b             \u003cspan style=\"color:#007f7f\"\u003e# 通过符号调用，b必须是set对象 （下同）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {1, 2}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###(2)是否子集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ec.issubset(a)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ec \u0026lt;= a\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###(3)差集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea.difference(b)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea-b\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {3}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###(4)全集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea.union(b)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea | b\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {1, 2, 3, 4}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"二列表的特有操作\"\u003e二、列表的特有操作\u003c/h2\u003e\n\u003ch4 id=\"1利用索引与切片直接修改列表\"\u003e1、利用索引与切片直接修改列表\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e索引\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e切片\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#由于字符串不能修改，需要先将字符串转为列表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;python\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;YT\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#由于赋值的字符串的长度可以与被修改的字符串长度不同，所以可以引申用法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 变相的插入\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;python\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e] = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;AAA\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 变相的删除\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;python\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] = []\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2列表的方法增删改查\"\u003e2、列表的方法\u0026ndash;增删改查\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e增\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) append: 增加元素到末尾\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.append(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##原地修改，无返回值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (2) extend: 增加列表里的元素到末尾\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.extend([\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##原地修改，无返回值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (3) insert: 在指定索引位置插入元素\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.insert(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;four\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1, 2, \u0026#39;four\u0026#39;, 3]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##原地修改，无返回值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e删\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) pop: 删除最后一个元素\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.pop()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##原地修改，并返回被删除的值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (2) remove: 删除指定元素的值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.remove(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [2, 3]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##原地修改，无返回值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 关于list列表的删除操作，有一个函数`del`支持根据索引删除元素\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edel\u003c/span\u003e numbers[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1, 3]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e改\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) reverse: 逆转当前列表元素的顺序\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.reverse()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##原地修改，无返回值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (2) sort: 顺序排列当前列表的元素, 默认升序排列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.sort()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.sort(reverse=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e查\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) count: 查看某一元素的频率\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.count(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (2) index: 查看某一元素值的索引\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers.index(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"3filter搭配lamda列表筛选\"\u003e3、filter()搭配lamda列表筛选\u003c/h4\u003e\n\u003cp\u003e\u003ccode\u003efilter()\u003c/code\u003e函数包含如下两个参数\u003c/p\u003e","title":"Python基础-(2)列表、元组、字符串、字典"},{"content":"方差分析(analysis of variance)可以简单的理解为多组间的均值比较。例如A班、B班、C班、D班的考试成绩均值是否存在显著差异。方差分析是基于F分布的假设检验，所以又称F检验\n方差分析 1、分析步骤 1.1 明确问题，做出假设 零假设为组间（假设有k组）均值相同。备择假设表示为k组中至少有两组不相等。\nk表示组别数，nj表示第j组的样本数，xij表示第j组的第i个样本；(hat)x表示总均值。根据分组信息，可以将总变异分解为组间方差与组内误差两部分\n$$ H_0 : \\mu_1=\\mu_2= \u0026hellip; =\\mu_k $$\n1.2 方差分解 （1）所有样本的总方差计算即所有组样本与总均值的差值的平方和。然后可将总分差分解为组间方差与组内方差两部分。\n总方差计算公式 $$ SS_{total} = \\sum_{j=1}^{k} \\sum_{i=1}^{n_j}(x_{ij}-\\overline{x})^2 $$\n（2）组间误差：分析组与组之间的差异。如果分组变量对结果有很大的影响，那么组间差异应该很大。\n组间方差计算公式 $$ SS_{between} = \\sum_{j=1}^{k}n_{j}(\\overline{x}_{j} - \\overline{x})^2 $$\n（3）组内方差：组内样本由于个体随机性造成差异。这种差异占比理论上应该越小越好，则每组的水平都很一致。\n组内方差计算公式 $$ SS_{within} = \\sum_{j=1}^{k} \\sum_{i=1}^{n_j}(x_{ij}-\\overline{x}_j)^2 $$\n1.3 计算F统计量 （1）在零假设的前提下，组间方差等于0。而如果预期分类变量对样本结果影响很大，那么组间方差应远大于组内方差。\n$$ SS_{total} = SS_{between} + SS_{within} $$\n（2）因此可计算F统计量表示组间方差与组内方差的比值，其中分子的自由度为（k-1），分母的自由度为（N-k）。 $$ F = \\frac{\\frac{SS_{between}}{k-1}}{\\frac{SS_{within}}{N-k}} $$\n（3）在零假设成立的情况下，F统计量符合自由度组合为[(k-1), (N-k)]的F分布。据此计算出当前F统计量对应的P值结果。\n2、注意事项 2.1 变异分解与分组变量 如上方差分析的本质是变异(方差)分解。在给定一样本数据的总变异的前提下，观测指定的分组(分类)变量对于总变异的贡献度或者说解释度。在此基础上有一些衍生。\n多因素方差分析\n可能存在多个分组(健康/不健康、男女)变量共同影响样本的总变异，且这些影响具有可加性，即独立的。(不独立的情况即存在交互效应)\n回归分析\n换一个角度思考回归分析也属于方差分解。即分组变量为连续变量，以分析该自变量对样本数据的影响是否占总变异的主要部分。\n2.2 Kruskal-Wails秩和检验 方差分析的重要前提是组间方差齐性与正态性。即每组数据的方差相等，且均符合正态分布。如不符合正态分布的假设，可以使用Kruskal-Wails秩和检验的非参数检验方法。\n符合正态分布 不符合正态分布 两组间均值比较 T检验 Wilcoxon秩和检验 多组间均值比较 方差分析 Kruskal-Wails秩和检验 2.3 两两比较与P值校正 根据方差分析的零假设，在P值显著的情况下所能得到结论是至少存在两组间均值不同。如果想知道哪两组存在不同则需要进行两两比较（T检验）。\n如果连续进行多次T检验，则一类错误概率会增加。例如将P值定义0.05，那么连续比较20次，则至少会有一次假阳性的结果发生；或者理解为 (1-0.05)^20=0.36，即只有36%的把握，认为20次比较中没有假阳性发生。\n因此需要对原始P值进行调整，获得adjusted P-value，有如下方法\nFDR/BH(Benjamini \u0026amp; Hochberg)：多重比较在所有拒绝H0的次数中，错误拒绝H0(假阳性)所占的比例\nBonferroni：根据比较的次数，将一类错误率控制在0.05/k之内。在比较次数比较多时，较为严苛\nHolm，也称step-down Bonferroni法，不会太严苛 Hochberg，也称step-up Bonferryoni法，不会太严苛 本质是对给定的一串P值进行调整；调整之后的值普遍比原始值高一点，所以在下结论时假阳性率会低一点。\n3、R实操 示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #加载示例数据集：五种降低胆固醇疗法的结果 library(multcomp) data(cholesterol) head(cholesterol) # trt response # 1 1time 3.8612 # 2 1time 10.3868 # 3 1time 5.9059 # 4 1time 3.0609 # 5 1time 7.7204 # 6 1time 2.7139 table(cholesterol$trt) # 1time 2times 4times drugD drugE # 10 10 10 10 10 方差分析 1 2 3 4 5 6 7 8 9 10 fit = aov(response ~ trt, data = cholesterol) summary(fit) # Df Sum Sq Mean Sq F value Pr(\u0026gt;F) # trt 4 1351.4 337.8 32.43 9.82e-13 *** # Residuals 45 468.8 10.4 # --- # Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 summary(fit)[[1]][1,5] # Pr(\u0026gt;F) # [1] 9.818516e-13 此外aov()还支持单因素协方差分析，双因素方差分析等\nTukey多重两两比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 TukeyHSD(fit) # Tukey multiple comparisons of means # 95% family-wise confidence level # # Fit: aov(formula = response ~ trt, data = cholesterol) # # $trt # diff lwr upr p adj # 2times-1time 3.44300 -0.6582817 7.544282 0.1380949 # 4times-1time 6.59281 2.4915283 10.694092 0.0003542 # drugD-1time 9.57920 5.4779183 13.680482 0.0000003 # drugE-1time 15.16555 11.0642683 19.266832 0.0000000 # 4times-2times 3.14981 -0.9514717 7.251092 0.2050382 # drugD-2times 6.13620 2.0349183 10.237482 0.0009611 # drugE-2times 11.72255 7.6212683 15.823832 0.0000000 # drugD-4times 2.98639 -1.1148917 7.087672 0.2512446 # drugE-4times 8.57274 4.4714583 12.674022 0.0000037 # drugE-drugD 5.58635 1.4850683 9.687632 0.0030633 Kruskal-Wails 秩和检验 1 2 3 4 5 6 fit = kruskal.test(response ~ trt, data = cholesterol) fit # Kruskal-Wallis rank sum test # # data: response by trt # Kruskal-Wallis chi-squared = 36.542, df = 4, p-value = 2.238e-07 卡方检验 1、零假设的频率分布 在上面学到方差分析主要是对多组间均值差异比较的方法，样本数据（或者说结局变量）通常为连续型变量；从而探究分组变量的影响。\n而卡方检验可以理解为样本数据（或者说结局变量）为分类型变量时，从而探究分组变量的影响。\n例如如下数据：探究吸烟是否会影响健康\n分组变量(是否吸烟)\\结局变量(是否患病) health patient 是 20 10 否 80 15 零假设：吸烟不影响健康。在此前提下，每组（是否吸烟）的发病率应该相同。\n由于总发病率为（10+15）/（20+80+10+15） = 20%，而吸烟人数有30人，不吸烟人数有95人。所以理想的列联表频数分布应为\n分组变量(是否吸烟)\\结局变量(是否患病) health patient 是 30×(1-20%) = 24 30×20% = 6 否 95×(1-20%) = 76 95×20% = 19 2、卡方分布 卡方检验就是比较基于零假设的频数分布于真实频数分布的差距是否具有显著差异，如果有就可以拒绝零假设（在零假设的前提下出现此次观测样本数据的概率很低），认为吸烟会影响健康。\n使用皮尔逊残差描述实际频数与理论频数之间的差异\n$$ R = \\frac{观测频数-预期频数}{\\sqrt{预期频数}} \\quad R_{1,1} = \\frac{20-24}{\\sqrt{24}} = 0.82 $$\n所以卡方统计量为所有皮尔逊残差的平方和，计算公式为如下。其中r表示行数，c表示列数。\n$$ \\chi^2 = \\sum_i^r\\sum_j^c R^2 $$\n计算得到的卡方统计量符合**自由度为 (r-1)×(c-1)**的卡方分布。如果对于统计量的分布概率值足够小，那么可拒绝零假设，认为分组变量与分类变量有关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # M \u0026lt;- as.table(rbind(c(762, 327, 468), c(484, 239, 477))) dimnames(M) \u0026lt;- list(gender = c(\u0026#34;F\u0026#34;, \u0026#34;M\u0026#34;), party = c(\u0026#34;Democrat\u0026#34;,\u0026#34;Independent\u0026#34;, \u0026#34;Republican\u0026#34;)) M # party # gender Democrat Independent Republican # F 762 327 468 # M 484 239 477 Xsq \u0026lt;- chisq.test(M) Xsq # Pearson\u0026#39;s Chi-squared test # # data: M # X-squared = 30.07, df = 2, p-value = 2.954e-07 3、Fisher精确检验 （1）上述卡方检验又称Pearson χ2检验。这种检验方式在样本数较少时，结果不太可靠。此时可以考虑使用Fisher精确检验。Fisher精确检验基于超几何分布计算出组合的概率，从而计算P值。\n（2）如上例对于总样本数的125人中有25人是病人。现在根据吸烟因素抽出30人，其中有10人是病人。\n对于X ~ H(125, 30, 25)的超几何分布，计算出(k=10)的概率\u0026ndash;\n$$ P(X=10) = \\frac{C_{25}^{10}×C_{100}^{20}}{C_{120}^{30}} $$\n如果P值足够小，可认为不是随机抽样，而是吸烟因素相对富集在病人标签群体。换而言之，吸烟因素影响健康。\n最后如果在对有等级关系的分类变量（低、中、高）进行分组比较时，则应选用Wilcoxon秩和检验，而不是卡方检验。\n4、R实操 卡方检验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 示例数据：3个党派中，男女人数分布比例 M \u0026lt;- as.table(rbind(c(762, 327, 468), c(484, 239, 477))) dimnames(M) \u0026lt;- list(gender = c(\u0026#34;F\u0026#34;, \u0026#34;M\u0026#34;), party = c(\u0026#34;Democrat\u0026#34;,\u0026#34;Independent\u0026#34;, \u0026#34;Republican\u0026#34;)) M # party # gender Democrat Independent Republican # F 762 327 468 # M 484 239 477 # 问题：3个党派的男女分布比例是否具有显著差异 Xsq \u0026lt;- chisq.test(M) Xsq # Pearson\u0026#39;s Chi-squared test # # data: M # X-squared = 30.07, df = 2, p-value = 2.954e-07 Fisher精确检验 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 示例数据：猜测饮料的类别与饮料真实类别的关系 TeaTasting \u0026lt;- matrix(c(3, 1, 1, 3), nrow = 2, dimnames = list(Guess = c(\u0026#34;Milk\u0026#34;, \u0026#34;Tea\u0026#34;), Truth = c(\u0026#34;Milk\u0026#34;, \u0026#34;Tea\u0026#34;))) TeaTasting # Truth # Guess Milk Tea # Milk 3 1 # Tea 1 3 # 问题：猜测者是否具有识别饮料类别的能力 fisher.test(TeaTasting, alternative = \u0026#34;greater\u0026#34;) # Fisher\u0026#39;s Exact Test for Count Data # # data: TeaTasting # p-value = 0.2429 # alternative hypothesis: true odds ratio is greater than 1 # 95 percent confidence interval: # 0.3135693 Inf # sample estimates: # odds ratio # 6.408309 实例：差异基因通路富集分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 backgroud = 10000 gset = 500 deg = 100 deg2gset = 50 dat_mt = matrix(c(deg2gset, gset - deg2gset, deg-deg2gset, backgroud-deg-(gset-deg2gset)), nrow=2, byrow=TRUE) dat_mt fisher.test(dat_mt, alternative = \u0026#34;greater\u0026#34;) # Fisher\u0026#39;s Exact Test for Count Data # data: dat_mt # p-value \u0026lt; 2.2e-16 # alternative hypothesis: true odds ratio is greater than 1 # 95 percent confidence interval: # 15.25888 Inf # sample estimates: # odds ratio # 21.86715 ","permalink":"https://lishensuo.github.io/en/posts/basic/003%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80--%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90%E4%B8%8E%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C/","summary":"\u003cp\u003e方差分析(analysis of variance)可以简单的理解为多组间的均值比较。例如A班、B班、C班、D班的考试成绩均值是否存在显著差异。方差分析是基于F分布的假设检验，所以又称F检验\u003c/p\u003e","title":"统计学基础--方差分析与卡方检验"},{"content":"一、条件语句 1、布尔值 在python中，这些值均为视为假：False, None, 0, '',(), [], {}。其余所有可能的值都视为真 1 2 3 4 5 6 7 bool(None) # False bool(\u0026#39;\u0026#39;) # False bool(\u0026#34;anything\u0026#34;) # True 2、if语句结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 thisnum = 6 ##层级1 if thisnum \u0026gt; 0: print(\u0026#34;This number is positive.\u0026#34;) ##层级2 if thisnum \u0026gt; 0: print(\u0026#34;This number is positive.\u0026#34;) else: print(\u0026#34;This number is negative.\u0026#34;) ##层级3 if thisnum \u0026gt; 0: print(\u0026#34;This number is positive.\u0026#34;) elif thisnum == 0: print(\u0026#34;This number is zero.\u0026#34;) else: print(\u0026#34;This number is negative.\u0026#34;) 3、运算符 and, or, not 1 2 3 4 5 6 7 thisnum = 5 if thisnum \u0026lt;= 9 and thisnum \u0026gt; 0: print(\u0026#34;This is a natural number\u0026#34;) #也可以使用链式比较 if 0 \u0026lt; thisnum \u0026lt;= 9: print(\u0026#34;This is a natural number\u0026#34;) 二、for循环语句 1、for语句结构 1 2 3 4 5 6 numebrs = [1,2,3,4,5,6] #等价于 numbers = list(range(0,7)) for number in range(0,7): print(number) 2、迭代方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #(1)迭代字典 d = {\u0026#39;x\u0026#39;:1, \u0026#39;y\u0026#39;:2, \u0026#39;z\u0026#39;:3} ##迭代字典的键 for key in d: print(key, \u0026#39;value is\u0026#39;, d[key]) ##迭代字典的每一项 for key, value in d.items(): print(key, \u0026#39;value is\u0026#39;, value) #(2) zip()可缝合多个等长序列，用于迭代 name=[\u0026#39;AA\u0026#39;,\u0026#34;BB\u0026#34;,\u0026#34;CC\u0026#34;] age=[12,15,11] list(zip(name, age)) ## [(\u0026#39;AA\u0026#39;, 12), (\u0026#39;BB\u0026#39;, 15), (\u0026#39;CC\u0026#39;, 11)] for name,age in zip(name, age): print(name, \u0026#39;is\u0026#39;, age, \u0026#39;years old\u0026#39;) #(3) enumerate()同时迭代索引 strs = [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;] for index, st in enumerate(strs): print(index, st) ## 0 A ## 1 B ## 2 C 3、break/continue break：结束循环 1 2 3 4 5 6 from math import sqrt for n in range(99,0,-1): root = sqrt(n) #平方根 if root == int(root): print(n) break continue：跳过当前循环 1 2 3 4 5 #打印奇数 for i in range(0,9): if i%2==0: continue print(i) 4、for语句创建列表 1 2 3 4 5 6 7 8 9 10 11 12 [x*x for x in range(5)] # [0, 1, 4, 9, 16] ##筛选符合条件的变量x [x*x for x in range(5) if x%2==0] # [0, 4, 16] ##组合两个列表，不同于zip() As = [1,2] Bs = [\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;] [(x, y) for x in As for y in Bs] # [(1, \u0026#39;a\u0026#39;), (1, \u0026#39;b\u0026#39;), (2, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;)] 三、其它语句 pass 占位符，什么都不做；\ndel 删除（对象的名称）\nexec/eval 将字符串视为代码执行\n1 2 3 4 5 6 7 exec(\u0026#34;print(\u0026#39;Hello, world\u0026#39;)\u0026#34;) # Hello, world # eval则用于计算字符串表示的Python表达式的值，并返回结果 a = eval(\u0026#39;6 + 18*2\u0026#39;) a # 42 ","permalink":"https://lishensuo.github.io/en/posts/program/003python%E5%9F%BA%E7%A1%80-3%E6%9D%A1%E4%BB%B6%E4%B8%8E%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003ch2 id=\"一条件语句\"\u003e一、条件语句\u003c/h2\u003e\n\u003ch4 id=\"1布尔值\"\u003e1、布尔值\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e在python中，这些值均为视为\u003cstrong\u003e假\u003c/strong\u003e：\u003ccode\u003eFalse\u003c/code\u003e, \u003ccode\u003eNone\u003c/code\u003e, \u003ccode\u003e0\u003c/code\u003e, \u003ccode\u003e''\u003c/code\u003e,\u003ccode\u003e()\u003c/code\u003e, \u003ccode\u003e[]\u003c/code\u003e, \u003ccode\u003e{}\u003c/code\u003e。其余所有可能的值都视为\u003cstrong\u003e真\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# False\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# False\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;anything\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2if语句结构\"\u003e2、if语句结构\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ethisnum = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##层级1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e thisnum \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This number is positive.\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##层级2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e thisnum \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This number is positive.\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This number is negative.\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##层级3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e thisnum \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This number is positive.\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eelif\u003c/span\u003e thisnum == \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This number is zero.\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This number is negative.\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"3运算符\"\u003e3、运算符\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eand\u003c/code\u003e, \u003ccode\u003eor\u003c/code\u003e, \u003ccode\u003enot\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ethisnum = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e thisnum \u0026lt;= \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e and thisnum \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This is a natural number\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#也可以使用链式比较\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e \u0026lt; thisnum \u0026lt;= \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;This is a natural number\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"二for循环语句\"\u003e二、for循环语句\u003c/h2\u003e\n\u003ch4 id=\"1for语句结构\"\u003e1、for语句结构\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumebrs = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#等价于\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e number in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(number)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"2迭代方法\"\u003e2、迭代方法\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(1)迭代字典\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ed = {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;x\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;y\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;z\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##迭代字典的键\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e key in d:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(key, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;value is\u0026#39;\u003c/span\u003e, d[key])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##迭代字典的每一项\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e key, value in d.items():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(key, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;value is\u0026#39;\u003c/span\u003e, value)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(2) zip()可缝合多个等长序列，用于迭代\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ename=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;AA\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BB\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;CC\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eage=[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e11\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003ezip\u003c/span\u003e(name, age))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## [(\u0026#39;AA\u0026#39;, 12), (\u0026#39;BB\u0026#39;, 15), (\u0026#39;CC\u0026#39;, 11)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e name,age in \u003cspan style=\"color:#fff;font-weight:bold\"\u003ezip\u003c/span\u003e(name, age):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(name, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;is\u0026#39;\u003c/span\u003e, age, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;years old\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(3) enumerate()同时迭代索引\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estrs = [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;A\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;B\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e index, st in \u003cspan style=\"color:#fff;font-weight:bold\"\u003eenumerate\u003c/span\u003e(strs):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(index, st)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 0 A\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 1 B\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 2 C\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"3breakcontinue\"\u003e3、break/continue\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003ebreak：结束循环\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e math \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e sqrt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e n in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e99\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    root = sqrt(n) \u003cspan style=\"color:#007f7f\"\u003e#平方根\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e root == \u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(root):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ebreak\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003econtinue：跳过当前循环\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#打印奇数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e i in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e i%\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e==\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(i)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"4for语句创建列表\"\u003e4、for语句创建列表\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[x*x \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e x in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [0, 1, 4, 9, 16]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##筛选符合条件的变量x\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[x*x \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e x in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e x%\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e==\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [0, 4, 16]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##组合两个列表，不同于zip()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eAs = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBs = [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e[(x, y) \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e x in As \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e y in Bs]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [(1, \u0026#39;a\u0026#39;), (1, \u0026#39;b\u0026#39;), (2, \u0026#39;a\u0026#39;), (2, \u0026#39;b\u0026#39;)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"三其它语句\"\u003e三、其它语句\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003epass\u003c/code\u003e 占位符，什么都不做；\u003c/p\u003e","title":"Python基础-(3)条件与循环语句"},{"content":"一、相关性 1、线性相关系数 （1）线性相关系数用于描述多个样本数据中两个变量之间的线性相关的程度。\n变量通常为连续型变量； 两个变量一般为描述样本的不同指标，例如人群的体重值与血糖值 （2）协方差(Corvariance)：用于衡量两个随机变量的联合变化程度。\n如果协方差大于0，表示正相关；小于0表示负相关。 $$ Cov(y, x) = \\frac{\\sum_{i=1}^n(y_i-\\overline{y})(x_i-\\overline{x})}{n-1} $$\n如上公式，可以看出方差其实是协方差的特例。自己对自己的关系就是方差。\n（3）为了克服不同变量的尺度不相同所带来的的干扰，在计算需要对原始变量进行标准正态分布转换。此时得到的协方差就是两个连续变量的线性相关系数，常称为Person相关系数。 $$ r = \\frac{\\sum_{i=1}^n(y_i-\\overline{y})(x_i-\\overline{x})}{\\sqrt{\\sum_{i=1}^n(y_i-\\overline{y})^2}\\sqrt{\\sum_{i=1}^n(x_i-\\overline{x})^2}} $$\nr(r\u0026gt;0)值越大表示两个变量呈正相关；r(r\u0026lt;0)值越小表示两个变量呈负相关；r=0表示两个变量不相关。 （4）P值与假设检验\n在相关性分析的假设检验中，零假设通常为r=0。在p值显著的情况下，可认为两个变量存在相关性，仅此而已。 不能说P值越小，两个变量的相关性越强(包括正负)。 当P值不显著时，所能得到的结论是两个变量不存在线性相关；而不是不相关。 2、基于秩次的相关系数 当连续变量值的分布特征不符合正态分布时，一般不可使用Person相关系数，可选择如下基于秩次的计算方式。\n2.1 Spearman相关系数 计算思路比较简单：首先求出每个变量各自排序后的秩次，然后以秩次作为变量计算其Person相关系数。\n在计算秩次时，如果对于某一变量，多个样本的值相同的情况，则称为Tie或者说是打结。此时一般取秩次的平均值。如下例图所示。\nSample Var1 Var1-Rank Sp1 1.1 1 Sp2 2.5 2.5 Sp3 2.5 2.5 Sp4 4.9 4 2.2 Kendall的tau系数 （1）首先对于每个变量(Var1, Var2)，计算每个样本的样本秩次。\n（2）然后随机抽取一对样本Sp1，Sp2：\n如果Sp1的Var1秩次大于(小于)Sp2的Var1秩次，同时Sp1的Var2秩次也大于(小于)Sp2的Var2秩次，则记为Concordant，简记为C； 如不符合上述情况，则记为Discordant，简记为D。 （3）最后统计对于所有两两组合的情况下，C与D的差值所占的比例，即为tau系数。\ntau值越高表明两个变量越相关。 $$ \\tau = \\frac{C-D}{n(n-1)/2} $$\n在涉及有序分类(等级)变量的相关性时，可以转换为基于秩次的相关性计算。\n此时会存在很多打结的秩次数据，此时使用Tau/b系数相对Spearman可以更好地处理打结数据。\n3、R实操 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 a1 = c(1,2,4,5,8,11) a2 = c(2,3,5,7,6,15) cor(a1, a2) # [1] 0.9136724 cor(a1, a2, method = \u0026#34;pearson\u0026#34;) # default cor(a1, a2, method = \u0026#34;kendall\u0026#34;) cor(a1, a2, method = \u0026#34;spearman\u0026#34;) cor.test(a1, a2) # data: a1 and a2 # t = 4.4959, df = 4, p-value = 0.01086 # alternative hypothesis: true correlation is not equal to 0 # 95 percent confidence interval: # 0.3950157 0.9906589 # sample estimates: # cor # 0.9136724 cor.test(a1, a2)$p.value cor.test(a1, a2, method = \u0026#34;pearson\u0026#34;) # default cor.test(a1, a2, method = \u0026#34;kendall\u0026#34;) cor.test(a1, a2, method = \u0026#34;spearman\u0026#34;) 二、一致性 一致性与相关性的区别体现在如下两个方面\n一致性强调是描述同一指标的不同测量方式的关系。例如仪器A测量体重值与仪器B测量体重值的一致性。\n一致性更注重两个指标的尺度上的一致性，即[1,2,3]与[1.1,1.9,2.8]的一致性更高；而与[2,4,6]的一致性则较低。\n2.1 CCC CCC(Concordance Correlation Coefficient)用偏离45度线的程度，对Pearson相关系数进行校正。\n计算公式如下：其中r\u0026ndash;相关系数；Sx\u0026ndash;变量x的标准差；x(hat)\u0026ndash;变量x的均值 $$ r_c = \\frac{2r\\cdot S_xS_y}{S_x^2+S_y^2+(\\overline{x}-\\overline{y})^2} $$\n如下图所示，展现了CCC与线性相关系数的不同之处。 2.2 Kappa系数 Cohen’s Kappa\n（1）Kappa系数用于分类变量的一致性评价。值范围在 -1 ~ 1之间，越接近1表示一致性越好。\n可用于机器学习中评价模型分类预测能力。 例如真实的有效、无效所预测的有效、无效的一致性程度。 计算公式如下：其中Po表示观察的一致性，即同一样本的两个变量分类结果相同；Pe表示期望的一致性，即同一样本一致性的期望频率 $$ \\kappa = \\frac{p_o - p_e}{1 - p_e} $$\n（2）举例来说，需要对一批产品(N=20)进行质量评价，分为A、B、C 这3个等级。两个质检员分别独自评价分类，使用kappa系数计算两次结果的一致性。\nA B C sum A 8 2 1 11 B 2 3 0 5 C 0 1 3 4 sum 10 6 4 20 $$ p_o = \\frac{8}{20} + \\frac{3}{20}+ \\frac{3}{20} = 0.70 $$\n$$ p_e = \\frac{10}{20}\\cdot\\frac{11}{20}+\\frac{6}{20}\\cdot\\frac{5}{20}+\\frac{4}{20}\\cdot\\frac{4}{20} = 0.39 $$\n$$ \\kappa = \\frac{0.7 - 0.39}{1-0.39} = 0.51 $$\n（3）加权kappa系数：适用于有序分类变量的一致性评价。\n还是上面的例子，如果A、B、C分别表示好、中、差3个有序等级。\n把同一个产品标记为A、B的情况与把同一个产品标记为A、C的一致性差异是不一致的，前者会比后者更好一些。\n如下为一个示例的权重矩阵\nA B C A 1 0.5 0 B 0.5 1 0.5 C 0 0.5 1 把同一产品分为同一等级的一致性最高，故赋予最高的权重\n把同一产品分为相差一级的一致性中等，故赋予较低的权重\n把同一产品分为相差两级的一致性最低，故赋予最低的权重\n所以加权的观察一致性计算如下\nA B C sum A 8×1=8 2×0.5=1 1×0=0 9 B 2×0.5=1 3×1=3 0×0.5=0 4 C 0×0=0 1×0.5=0.5 3×1=3 3.5 sum 9 4.5 3 16.5 $$ p_o = \\frac{16.5}{20} = 0.825 $$\n加权的预期一致性计算如下\nA B C sum A 10×11×1=110 6×11×0.5=33 4×11×0=0 143 B 10×5×0.5=25 6×5×1=30 4×5×0.5=10 65 C 10×4×0=0 6×4×0.5=12 4×4×1=16 28 sum 135 75 26 236 $$ p_e = \\frac{236 }{20×20} = 0.59 $$\n$$ \\kappa = \\frac{0.825 - 0.59}{1-0.59} = 0.57 $$\n未加权矩阵相当于多角线元素值为1，其余元素值为0的权重值矩阵。\n2.3 AC系数 Gwet’s AC1 $$ AC1 = \\frac{p-e(\\gamma)}{1-e(\\gamma)} $$\nP：the overall percent agreement $$ P = \\frac{A+D}{N} $$ e(γ): the chance agreement probability\n相比Kappa系数，AC系数对边际分类问题准确性有更高的容忍度。\nhttps://bmcmedresmethodol.biomedcentral.com/track/pdf/10.1186/1471-2288-13-61.pdf 2.4 R实操 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 ##(1) CCC系数 a1 = c(1,2,4,5,8,11) a2 = c(2,3,5,7,6,15) library(DescTools) CCC(a1, a2) # $rho.c # est lwr.ci upr.ci # 1 0.8550984 0.3990051 0.971993 # # $s.shift # [1] 1.230973 # # $l.shift # [1] 0.3060408 # # $C.b # [1] 0.9358917 # # $blalt # mean delta # 1 1.5 -1 # 2 2.5 -1 # 3 4.5 -1 # 4 6.0 -2 # 5 7.0 2 # 6 13.0 -4 ##(2) Kappa系数 library(vcd) library(vcd) mat = matrix(c(10, 2, 1, 2, 3 ,0, 0, 1 ,3), byrow = T, nrow = 3) colnames(mat) = c(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;) rownames(mat) = c(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;) mat # A B C # A 10 2 1 # B 2 3 0 # C 0 1 3 Kappa(mat) # value ASE z Pr(\u0026gt;|z|) # Unweighted 0.5319 0.1611 3.301 0.0009629 # Weighted 0.5969 0.1554 3.841 0.0001224 Kappa(mat)$Weights # [,1] [,2] [,3] # [1,] 1.0 0.5 0.0 # [2,] 0.5 1.0 0.5 # [3,] 0.0 0.5 1.0 ##(3) $$ AC1 = \\frac{p-e(\\gamma)}{1-e(\\gamma)} $$\n$$ p = \\frac{a_1 + a_5 + a_9}{\\sum_{i=1}^{9}a_i} $$\n$$ e(\\gamma) = 2q(1-q), \\quad q=\\frac{(a_1 + a_2 + a_3)+(a_1+a_4+a_9)}{2\\sum_{i=1}^{9}a_i} $$\n","permalink":"https://lishensuo.github.io/en/posts/basic/004%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80--%E7%9B%B8%E5%85%B3%E6%80%A7%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7/","summary":"\u003ch1 id=\"一相关性\"\u003e一、相关性\u003c/h1\u003e\n\u003ch2 id=\"1线性相关系数\"\u003e1、线性相关系数\u003c/h2\u003e\n\u003cp\u003e（1）线性相关系数用于描述多个样本数据中两个变量之间的线性相关的程度。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e变量通常为连续型变量；\u003c/li\u003e\n\u003cli\u003e两个变量一般为描述样本的不同指标，例如人群的体重值与血糖值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（2）协方差(Corvariance)：用于衡量两个随机变量的联合变化程度。\u003c/p\u003e","title":"统计学基础--相关性与一致性"},{"content":"1、奶牛快传 (1) linux服务器安装 https://github.com/Mikubill/cowtransfer-uploader/releases\n选择一个最新的linux版本下载（如果wget下载太慢，就下载的本地电脑，再上传到linux）\n解压即用\n1 2 3 wget https://github.com/Mikubill/cowtransfer-uploader/releases/download/v0.4.21/cowtransfer-uploader_0.4.21_linux_amd64.tar.gz tar -zxvf cowtransfer-uploader_0.4.21_linux_amd64.tar.gz ./cowtransfer-uploader #查看帮助文档 (2) 将本地文件上传到服务器 进入https://cowtransfer.com/，上传本地文件，获取下载链接\n在linux端，下载即可\n1 2 3 4 5 ./cowtransfer-uploader https://cowtransfer.com/s/c7899f85cb354f # Remote: https://cowtransfer.com/s/c7899f85cb354f # File save to: 图片1.png # 0 B / 36.34 KiB [_________________________________________________________________________________________________________________________] 0.00% ? p/s ? # 36.34 KiB / 36.34 KiB [-----------------------------------------------------------------------------------------------------] 100.00% 76.27 KiB p/s 700ms (3) 将服务器文件下载到本地(试了几次，都失败了) 上传服务器文件，获取下载链接。但是遇到如下报错，尚未解决。 1 2 ./cowtransfer-uploader test.txt.gz # getSendConfig returns error: json: cannot unmarshal string into Go struct field prepareSendResp.error of type bool, onfile: test.txt.gz 进入https://cowtransfer.com/，根据链接接收文件即可。 最近发现这个工具的linux版本不好用了，仍适用于window电脑之间互传数据比较方便。\n2、阿里云盘 官方教程：GitHub - tickstep/aliyunpan: 阿里云盘命令行客户端，支持webdav文件服务\n简单使用如下\n（1）linux安装 1 2 3 4 5 6 7 8 9 10 11 cd ~ wget https://github.com/tickstep/aliyunpan/releases/download/v0.1.2/aliyunpan-v0.1.2-linux-amd64.zip unzip aliyunpan-v0.1.2-linux-amd64.zip mv aliyunpan-v0.1.2-linux-amd64 aliyunpan #获取帮助 ~/aliyunpan/aliyunpan --help #查看版本 ~/aliyunpan/aliyunpan -v #进入cli模式（按下图方式获取个人账户的RefreshToken） ~/aliyunpan/aliyunpan #测试了下，仅第一次需要输入，以后可自动登入 需要通过浏览器获取refresh_token。这里以Chrome浏览器为例，其他浏览器类似。 打开 阿里云盘网页 并进行登录，然后F12按键打开浏览器调试菜单，按照下面步骤进行\n（2）文件上传/下载 进入cli模式后，就进入了云盘的操作环境。 对云盘文件的基本操作与linux的shell命令大致相同，比如ls, mkdir, mv, rm\u0026hellip; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ~/aliyunpan/aliyunpan #查看当前登陆账户 who #查看云盘空间配额 quota #下载云盘文件/文件夹到服务器(当前路径) download file/dir --save #下载云盘文件/文件夹到服务器(指定路径) download file/dir --saveto /home/shensuo/ #上传服务器文件到云盘 upload file/dir 云盘路径 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/004%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%96%E7%BD%91%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93--%E5%A5%B6%E7%89%9B%E5%BF%AB%E4%BC%A0%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/","summary":"\u003ch1 id=\"1奶牛快传\"\u003e1、奶牛快传\u003c/h1\u003e\n\u003ch3 id=\"1-linux服务器安装\"\u003e(1) linux服务器安装\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/Mikubill/cowtransfer-uploader/releases\"\u003ehttps://github.com/Mikubill/cowtransfer-uploader/releases\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e选择一个最新的linux版本下载（如果wget下载太慢，就下载的本地电脑，再上传到linux）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e解压即用\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewget https://github.com/Mikubill/cowtransfer-uploader/releases/download/v0.4.21/cowtransfer-uploader_0.4.21_linux_amd64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etar -zxvf cowtransfer-uploader_0.4.21_linux_amd64.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e./cowtransfer-uploader \u003cspan style=\"color:#007f7f\"\u003e#查看帮助文档\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2-将本地文件上传到服务器\"\u003e(2) 将本地文件上传到服务器\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e进入https://cowtransfer.com/，上传本地文件，获取下载链接\u003c/p\u003e","title":"服务器外网文件传输--奶牛快传、阿里云盘"},{"content":"1、定义函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # def语句定义函数 def hello(name): print(\u0026#34;Hello,\u0026#34;, name) # 添加return语句有两个作用 ## (1) 表示函数的结束 ## (2) 指定函数的返回值 def square(number): res = number*number return res square(4) # 可以在函数开头编辑一个文档字符串，用以解释函数功能，可作为函数的一部分储存起来 def square(number): \u0026#39;Calaulate the square of the input number\u0026#39; res = number*number return res help(square) #可以在帮助文档里找到这个字符串 # 定义多个参数 def hello(time,name): print(\u0026#34;Good\u0026#34;,time, \u0026#34;,\u0026#34;, name) hello(name=\u0026#34;LI\u0026#34;,time=\u0026#34;morning\u0026#34;) 2、参数类型 （1）在定义函数时，可以设置参数的默认值。但需要注意的是这类参数需要放到最后。\n1 2 3 4 5 6 def test(x, y, z=3): print(x, y, z) test(1,2) # 1 2 3 test(1,2,4) # 1 2 4 此外还有带一个星号的收集参数与带两个星号的收集关键词参数，暂时用不到。\n（2）在调用函数时，有两种方式，对应两类参数：\n位置参数：仅提供若干值，对应定义函数时参数顺序。因此一定要注意顺序 1 2 3 4 def test(x, y, z): print(x, y, z) test(1,2,3) # 1 2 3 关键字参数：参数名称=值的形式。可以无视定义函数时的参数顺序 1 2 3 4 def test(x, y, z): print(x, y, z) test(y=1,z=2,x=3) # 3 1 2 通常不应该混合使用位置参数与关键字参数\n一个小示例 当传递的参数是一个列表时，可对其进行修改； 如下表示登记学生的成绩。如果已经登记则返回提示，如果没有则需输入成绩。有点类似字典的setdefault方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def add_students(all_stu,stu): \u0026#39;Registration record\u0026#39; had_stu = list(all_stu.keys()) if stu in had_stu: return \u0026#34;The students had grades\u0026#34; else: all_stu[stu] = int(input(\u0026#34;Please input the student\u0026#39;s grade:\u0026#34;)) students = {\u0026#39;A\u0026#39;:59, \u0026#39;B\u0026#39;:72, \u0026#39;C\u0026#39;:90} add_students(students,\u0026#34;A\u0026#34;) # \u0026#39;The students had grades\u0026#39; add_students(students,\u0026#34;D\u0026#34;) students # {\u0026#39;A\u0026#39;: 59, \u0026#39;B\u0026#39;: 72, \u0026#39;C\u0026#39;: 90, \u0026#39;D\u0026#39;: 99} 3、lambda表达式 1 2 3 4 #lambda [arg1 [,arg2,.....argn]]:expression sums = lambda num1, num2: num1 + num2 sums(1,2) # 3 ","permalink":"https://lishensuo.github.io/en/posts/program/004python%E5%9F%BA%E7%A1%80-4%E5%87%BD%E6%95%B0function/","summary":"\u003ch2 id=\"1定义函数\"\u003e1、定义函数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# def语句定义函数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e hello(name):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Hello,\u0026#34;\u003c/span\u003e, name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 添加return语句有两个作用\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) 表示函数的结束\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) 指定函数的返回值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e square(number):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    res = number*number\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e res\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquare(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 可以在函数开头编辑一个文档字符串，用以解释函数功能，可作为函数的一部分储存起来\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e square(number):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;Calaulate the square of the input number\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    res = number*number\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e res\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehelp(square) \u003cspan style=\"color:#007f7f\"\u003e#可以在帮助文档里找到这个字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 定义多个参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e hello(time,name):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Good\u0026#34;\u003c/span\u003e,time, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003e, name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehello(name=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;LI\u0026#34;\u003c/span\u003e,time=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;morning\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2参数类型\"\u003e2、参数类型\u003c/h2\u003e\n\u003cp\u003e（1）在定义函数时，可以设置参数的默认值。但需要注意的是这类参数需要放到最后。\u003c/p\u003e","title":"Python基础-(4)函数Function"},{"content":"1、混淆矩阵相关指标 假设某医生对100个挂号的人进行某疾病的判断，具体情况如下\n前提已知这100人的真实患病情况：60人患病，40人健康 医生根据症状判断(预测)结果为：80人患病，20人健康 真实-患病 真实-健康 预测-患病 50 30 预测-健康 10 10 根据医生的预测结果，将预测为患病定义为阳性(Positive)事件；预测为健康状态为阴性(Negative)事件\n如果医生的预测与挂号人的真实情况一致，则认为是True；否则认为是False。\n于是上面四个数字分别对应四种情况\u0026ndash;\n混淆矩阵 真实-患病 真实-健康 预测-患病 True Positive(TP) False Positive(FP) 预测-健康 False Negative(FN) True Negative(TN) （1）正确率：预测正确的结果占总预测结果的比例。Accuracy\n(50+10)/(50+10+30+10)=0.6 $$ Accuracy = \\frac{TP + TN}{TP + TN + FP + FN} $$\n（2）精确率：在所有预测为阳性的结果里，预测正确的比例。Precision\n50/(50+30) = 0.625 $$ Precision = \\frac{TP}{TP + FP} $$\n（3）召回率：在实际为阳性的数据中，预测正确的比例。也称为敏感度。Sensitivity/Recall\n50/(50+10) = 0.833 $$ Sensitivity /Recall = \\frac{TP}{TP + FN} $$\n（4）特异度：在实际为阴性的数据中，预测正确的比例。Specifity\n10/(10+30) = 0.25 $$ Specifity = \\frac{TN}{TN+FP} $$\n如果医生将判断疾病的标准提高，那么对于医生预测患病的精确率将提高；但是症状不明显的患病人将会判断为健康，即召回率降低。反之如果将判断疾病的标准降低，则精确率降低、召回率增高。\n（5）F1值：综合反映了精确率和召回率两个指标的情况\n2×(0.625×0.833)/(0.625+0.833) = 0.714 $$ F1 = 2\\cdot \\frac{Precision \\cdot Recall}{Precision + Recall} $$\n2、ROC曲线与PR曲线 （1）ROC曲线 在机器学习二分类预测模型的结果通常为0~1之间的概率值。越接近1，表明是阳性的可能性越高。\n通过设定一个阈值（如0.5）作为最终的二分类判断结果，进而计算得到对应的混淆矩阵。\n对于不同阈值（0~1之间）得到的混淆矩阵都可以计算两个指标\n（1）真阳性率True Positive Rate：对于实际患病的人，诊断为患病的概率。对应上面的召回率/敏感度； （2）假阳性率False Positive Rate：对于实际健康的人，诊断为患病的概率。对应上面的（1-特异度）。 对于所有可能阈值，都可以得到一组（假阳性率，真阳性率）数据，可如下绘制出ROC曲线。\n如果诊断标准(阈值)的提高，那么假阳性率与真阳性率都会降低。极端情况，将所有人都判断为健康。 如果诊断标准(阈值)的降低，那么假阳性率与真阳性率都会提高。极端情况，将所有人都判断为患病。 ROC曲线的线下面积总和称为AUC，也称AUROC。一般AUC的取值范围在0.5和1之间。越接近1，表示模型的分类效果越好。\n（2）PR曲线 PR曲线反映了召回率与精确率之间的关系。PR曲线下面积称为AUPR。\n召回率：在实际为阳性的数据中，预测正确的比例。也称为敏感度。即ROC曲线的真阳性指标。 精确率：在所有预测为阳性的结果里，预测正确的比例。 AUROC与AUPR都可以用于机器学习二分类预测模型的评价指标，均适用于正负样本不平衡的数据集。\n当样本数据集中的阴性样本远多于阳性样本时：\n如果关注模型对正负样本正确分类的整体情况，则AUROC更合适。\n如果关注模型对正样本的正确分类情况，则AUPR更合适。\nAUROC与AUPR的主要区别在于前者使用了假阳性指标(FPR)，后者是使用了精确率指标(Precision)\n对于Model-1：FPR=10/(10+990)=0.01；Presion=10/(10+10)=0.5；TPR=1\n对于Model-2：FPR=50/(50+950)=0.05；Precison=10/(10+50)=0.16；TPR=1\n相比于模型1，模型2会将更多的阴性样本预测为阳性。\n但由于阴性样本非常多，导致兼顾正负类预测情况的AUROC变化不明显；\n而AUPR专注与正类样本的分类情况，此时AUPR值会下降较为明显。\n","permalink":"https://lishensuo.github.io/en/posts/basic/005%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80--%E4%BA%8C%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/","summary":"\u003ch1 id=\"1混淆矩阵相关指标\"\u003e1、混淆矩阵相关指标\u003c/h1\u003e\n\u003cp\u003e假设某医生对100个挂号的人进行某疾病的判断，具体情况如下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e前提已知这100人的真实患病情况：60人患病，40人健康\u003c/li\u003e\n\u003cli\u003e医生根据症状判断(预测)结果为：80人患病，20人健康\u003c/li\u003e\n\u003c/ul\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e真实-患病\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e真实-健康\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003cstrong\u003e预测-患病\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e50\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e30\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003cstrong\u003e预测-健康\u003c/strong\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e10\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e10\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e根据医生的预测结果，将预测为患病定义为\u003cu\u003e阳性\u003c/u\u003e(Positive)事件；预测为健康状态为\u003cu\u003e阴性\u003c/u\u003e(Negative)事件\u003c/p\u003e","title":"统计学基础--二分类模型评价指标"},{"content":" 单细胞转录组测序技术历经10余年的发展，目前以高通量的Droplet技术广为应用。其中以10X Genomics公司开发的实验及分析系统最为流行。如下简单学习测序原理、结果以及上游比对流程。\r1、测序原理 （1）如下图所示，首先每个凝胶微珠(Gel Beads)表面提前接上大量定制的DNA片段。该片段主要由3部分组成：10x Barcode、UMI以及Poly(dT)尾巴。\n10x Barcode：长度为16的核苷酸序列，用于区分不同的微珠(细胞)； UMI：长度为10的核苷酸序列，用于区分不同的cDNA分子； Poly(dT)：用于结合mRNA的Poly(A)尾巴； （2）理想情况下，一个微珠会捕捉到一个细胞，并形成油包水的封闭体系。然后在酶反应作用下，裂解细胞，释放的mRNA分子结合到微珠表面的DNA片段上；最后逆转录形成相应的cDNA分子。\n（3）提取所有水相里的cDNA，进行PCR扩增，之后接入illumina高通量双端测序分析。\nRead 1，即R1，通常表示长度为26的10X barcode与UMI标签序列； Read 2，即R2，通常为长度为98的mRNA测序片段。 参考https://www.biostars.org/p/9529864/#9529942，如果下载的R1、R2文件为150bp长度，也可直接分析。 UMI标签主要用于消除PCR扩增带来的误差，即表示细胞裂解是结合到微珠的mRNA分子数（即cDNA分子数）。\nSeurat V2的meta.data最初两列：nUMI， nGenes\n后续更新的Seurat V3,4的列名分别改为：nCount_RNA，nFeature_RNA\n2、cellranger比对 示例数据：GSE178911共4个样本，每个样本有4个lane的比对结果(SRRxxxxxx id)\n（1）原始测序数据fastq.gz\nhttps://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/using/fastq-input\n如上测序原理的双端测序，一个样本通常会产生一对fastq.gz结果； 若同一样本在不同的lane分别测序，则会产生若干对的fastq.gz结果。 如下示例，为样本名为MySample的测序结果。\n1 2 3 4 5 6 7 PROJECT_FOLDER |-- MySample_S1_L001_I1_001.fastq.gz |-- MySample_S1_L001_R1_001.fastq.gz |-- MySample_S1_L001_R2_001.fastq.gz |-- MySample_S1_L002_I1_001.fastq.gz |-- MySample_S1_L002_R1_001.fastq.gz |-- MySample_S1_L002_R2_001.fastq.gz I1文件表示sample index，用于区分不同样本的标签，在后序的比对分析中可不提供。\n在分析公共数据时，可使用aspera或者prefetch方式下载原始数据；并修改成上述的规范文件名。\n（2）cellranger比对环境\nhttps://support.10xgenomics.com/single-cell-gene-expression/software/downloads/latest?\n在上述网址内下载比对软件cellranger与相应物种的参考数据集，解压即可使用。\n1 2 3 4 5 6 7 8 9 10 cellranger-7.1.0/bin/cellranger --version # cellranger cellranger-7.1.0 tree -L 1 refdata-gex-GRCh38-2020-A/ # refdata-gex-GRCh38-2020-A/ # ├── fasta # ├── genes # ├── pickle # ├── reference.json # └── star （3）cellranger比对命令\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 bin=/path/to/cellranger-7.1.0/bin/cellranger ref=/path/to/cellranger-7.1.0/refer/refdata-gex-GRCh38-2020-A fq_dir=/path/to/PROJECT_FOLDER $bin count \\ --fastqs=${fq_dir} \\ --sample=MySample_S1 \\ --transcriptome=$ref \\ --id=MySample_S1 \\ --localcores=10 \\ --no-bam \\ --nosecondary # --fastqs 交代测速数据路径（文件夹名） # --sample 交代待比对样本名的前缀（因为该文件夹内可能有许多样本的测序数据） # --transcriptome 交代参考基因组文件夹 # --id 交代储存结果的文件夹，如果没有会自动创建 # --localcores 多线程 # --no-bam 不生成bam文件(视情况而定：如果进行RNA速率分析等，需要保留bam文件) # --nosecondary 不进行后续分析 ##输出结果一般在 ${id} 的out文件夹 （4）比对结果输出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 tree -L 2 MySample_S1 # MySample_S1 # ├── MySample_S1.mri.tgz # ├── _cmdline # ├── _filelist # ├── _finalstate # ├── _invocation # ├── _jobmode # ├── _log # ├── _mrosource # ├── outs # │ ├── cellsorted_possorted_genome_bam.bam # │ ├── filtered_feature_bc_matrix # │ ├── filtered_feature_bc_matrix.h5 # │ ├── metrics_summary.csv # │ ├── molecule_info.h5 # │ ├── possorted_genome_bam.bam # │ ├── possorted_genome_bam.bam.bai # │ ├── raw_feature_bc_matrix # │ ├── raw_feature_bc_matrix.h5 # │ └── web_summary.html # ├── _perf # ├── SC_RNA_COUNTER_CS # │ ├── CELLRANGER_PREFLIGHT # │ ├── CELLRANGER_PREFLIGHT_LOCAL # │ ├── fork0 # │ ├── FULL_COUNT_INPUTS # │ ├── GET_AGGREGATE_BARCODES_OUT # │ ├── SC_MULTI_CORE # │ ├── _STRUCTIFY # │ └── WRITE_GENE_INDEX # ├── _sitecheck # ├── _tags # ├── _timestamp # ├── _uuid # ├── _vdrkill # └── _versions ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/005%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--cellranger%E6%AF%94%E5%AF%B9/","summary":"\u003cblockquote\u003e\n\u003cp\u003e单细胞转录组测序技术历经10余年的发展，目前以高通量的Droplet技术广为应用。其中以10X Genomics公司开发的实验及分析系统最为流行。如下简单学习测序原理、结果以及上游比对流程。\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/01-technologies.jpg\" alt=\"Tools and techniques for single-cell RNA sequencing data\"  /\u003e\r\n\u003c/p\u003e","title":"单细胞分析工具--cellranger"},{"content":" 面向对象的设计思想是抽象出Class(类)，根据Class创建Instance(实例)。\n类是一个相对抽象的概念，而实例是其具体化。例如将学生视为类，那么李华，王丽等具体的学生就是实例。\n类由属性和方法组成，属性用来描述其特征，例如学生的姓名、成绩等；方法用来描述其拥有的动作行为，例如格式化输出学生的成绩，判断成绩的等级等\n1、创建类与实例 1.1 创建类 使用class关键字定义类，类名的首字母通常大写。\n通过__init__方法创建类的属性，注意第一个参数为self\n创建类的方法时，类似之前的创建函数的方式。注意第一个参数为self，可以调用类自身的属性self.xxx数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Student(): def __init__(self, name, score): self.name = name self.score = score def print_score(self): \u0026#39;格式化输出学生成绩\u0026#39; print(\u0026#39;%s: %s\u0026#39; % (self.name, self.score)) def get_grade(self): \u0026#39;将成绩分为不同的等级\u0026#39; if self.score \u0026gt;= 90: return \u0026#39;A\u0026#39; elif self.score \u0026gt;= 60: return \u0026#39;B\u0026#39; else: return \u0026#39;C\u0026#39; 1.2 创建实例 来源同一类的不同实例的属性一般不同，但都有相同的方法 创建实例后，仍然可以修改实例的属性值，甚至增删属性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #(1)注意需要提供与 __init__ 参数顺序一致的属性数据 stuA = Student(\u0026#34;LiHua\u0026#34;,95) stuB = Student(\u0026#34;WangZi\u0026#34;,88) #(2)查看属性值 stuA.name stuB.score #(3)调用方法 stuA.print_score() ## LiHua: 95 stuB.get_grade() ## \u0026#39;B\u0026#39; #(4)修改属性 stuA.score=100 stuA.score #(5)增删属性 stuA.age = 17 stuA.age ## 17 del stuA.age stuA.age # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # AttributeError: \u0026#39;Student\u0026#39; object has no attribute \u0026#39;age\u0026#39; #(5)查看属性和方法 ##查看所有属性与方法 dir(stuA) # 返回列表，包含所有属性与方法名 ##判断是否有某属性 hasattr(stuA, \u0026#34;name\u0026#34;) # True ##获得对象的属性值，如果没有该属性则返回默认值 getattr(stuA, \u0026#34;newscore\u0026#34;, 404) # 404 2、私有属性 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Student(): def __init__(self, name, score): \u0026#39;双下划线设置私有变量\u0026#39; self.__name = name self.__score = score def get_name(self): \u0026#39;方法仍可以调用私有变量\u0026#39; return self.__name def set_score(self, score): \u0026#39;方法仍可以修改私有变量;通过引入if语句可添加参数检查步骤\u0026#39; self.__score = score def print_score(self): print(\u0026#39;%s: %s\u0026#39; % (self.__name, self.__score)) stuA = Student(\u0026#34;zhangsan\u0026#34;, 66) ##(1) 无法通过正常访问对象属性的方式查看实例的私有属性 stuA.name #无法访问 # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # AttributeError: \u0026#39;Student\u0026#39; object has no attribute \u0026#39;name\u0026#39; stuA.__name #无法访问 # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # AttributeError: \u0026#39;Student\u0026#39; object has no attribute \u0026#39;__name\u0026#39; ##(2)但是仍可以通过方法访问、修改私有属性 stuA.get_name() # \u0026#39;zhangsan\u0026#39; stuA.set_score(99) stuA.print_score() # zhangsan: 99 3、类与子类 3.1 继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #(1)创建类以及类的实例 class Animal(): def __init__(self, name, age): self.name = name self.age = age def run(self): print(self.name,\u0026#39;is running...\u0026#39;) aniA = Animal(\u0026#34;Xiaochai\u0026#34;, 5) aniA.run() ## Xiaochai is running... #(2)创建子类以及子类的实例 class Dog(Animal): def eat(self, food): print(\u0026#34;Look, This is a dog and it is eating\u0026#34;,food) ##继承父类的属性 dogA = Dog(\u0026#34;Xiaobai\u0026#34;,\u0026#34;3\u0026#34;) ##继承父类的方法 dogA.run() # Xiaobai is running... ##调用自己的方法 dogA.eat(\u0026#34;meat\u0026#34;) # Look, This is a dog and it is eating meat 当子类新定义的方法名与从父类继承的方法名相同时，会优先调用前者。\n3.2 多态 定义一个class的时候，我们实际上就定义了一种数据类型。 可以使用isinstance()判断是否为某个类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 a = [1,2,3] isinstance(a, list) # True b = \u0026#39;anything\u0026#39; isinstance(b, str) #True #(1)定义父类 class Animal(): def run(self): print(\u0026#39;Animal is running...\u0026#39;) ##实例化父类 aniA = Animal() ##判断实例的类型 isinstance(aniA, Animal) # True #(2)定义子类 class Dog(Animal): pass ##实例化子类 dogA = Dog() ##判断实例的类型:既属于父类，也属于子类 isinstance(dogA, Dog) # True isinstance(dogA, Animal) # True isinstance(aniA, Dog) # False #(3) 多态的应用之一：编写函数 ##编写一个接受Animal类型的变量 def run_twice(animal): animal.run() animal.run() run_twice(aniA) run_twice(dogA) #任何依赖父类(Animal)作为参数的函数或者方法都可以不加修改地正常运行子类(Dog)，原因就在于多态。 ","permalink":"https://lishensuo.github.io/en/posts/program/005python%E5%9F%BA%E7%A1%80-5%E7%B1%BBclass%E4%B8%8E%E5%AE%9E%E4%BE%8Binstance/","summary":"\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e面向对象的设计思想是抽象出Class(类)，根据Class创建Instance(实例)。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e类是一个相对抽象的概念，而实例是其具体化。例如将学生视为\u003cstrong\u003e类\u003c/strong\u003e，那么李华，王丽等具体的学生就是\u003cstrong\u003e实例\u003c/strong\u003e。\u003c/p\u003e","title":"Python基础-(5)类Class与实例Instance"},{"content":" 重抽样本质上是从观测数据中反复抽取数据，有两种不同用法\n1、Bootstrap （1）Bootstrap的核心是有放回的抽样，常用于估计统计量(例如均值等)置信区间\n在样本数据符合正态分布的情况，可基于中心极限定理使用标准误计算公式计算置信区间。详见之前的笔记002\n在样本数据不符合正态分布或者分布未知的情况下，则可以使用如下的Bootstrap法\n（2）如上所述，Bootstrap使用有放回的抽样方式，抽取等容量的随机样本，重复多次。根据每次得到的新样本，计算相应的统计量。\n计算置信区间的方式：对n次抽样的统计量(均数)结果，分别计算出2.5%分位数与97.5%分位数，这两个值的区间就是样本统计量(均数)的95%置信区间。\n2、置换检验 置换检验permutation test是计算假设检验的显著性(P值)的方式之一。\n如果样本数据符合正态分布，可使用基于极限中心定理的公式计算。如果不符合正态分布，之前提到可以使用秩和检验方法\n例如\n首先计算患者组的均值为13.2，健康组的均值为10，两组均值差为3.2\n接下来使用置换检验方式，评价出差值3.2是否具有显著性。\n编号 P01 P02 P03 P04 P05 H01 H02 H03 组别 患者 患者 患者 患者 患者 健康 健康 健康 结果 12 15 11 14 14 10 11 9 组均值 13.2 13.2 13.2 13.2 13.2 10 10 10 （1）将8个数据打乱、合并为一个数据集\n（2）从中随机抽取(不放回)5个样本作为“患者组”、剩余的3个样本作为“健康组”，计算这新的两组均值差，记录下来\n（3）多次重复步骤（2），产生大量由置换迭代得到的均值差，得到Permutation Test Distribution。\n（4）观察真实均值差3.2在上述Distribution的位置，计算P值。如果真实均值差位于分布尾端，说明这种差异不是由随机性造成的，即具有显著性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 dat = data.frame(score = c(12, 15, 11, 14, 14, 10, 11, 9), group = factor(c(rep(\u0026#34;A\u0026#34;,5), rep(\u0026#34;B\u0026#34;,3)))) dat # score group # 1 12 A # 2 15 A # 3 11 A # 4 14 A # 5 14 A # 6 10 B # 7 11 B # 8 9 B library(coin) oneway_test(score ~ group, data=dat, distribution=\u0026#34;exact\u0026#34;) # Exact Two-Sample Fisher-Pitman Permutation Test # data: score by group (A, B) # Z = 2.0494, p-value = 0.05357 # alternative hypothesis: true mu is not equal to 0 更多置换检验应用方差分析、回归分析等详见https://www.jianshu.com/p/86ec855805d6 ","permalink":"https://lishensuo.github.io/en/posts/basic/006%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80--%E9%87%8D%E6%8A%BD%E6%A0%B7bootstrap%E4%B8%8E%E7%BD%AE%E6%8D%A2%E6%A3%80%E9%AA%8Cpermutation-test/","summary":"\u003cblockquote\u003e\n\u003cp\u003e重抽样本质上是从观测数据中反复抽取数据，有两种不同用法\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1bootstrap\"\u003e1、Bootstrap\u003c/h1\u003e\n\u003cp\u003e（1）Bootstrap的核心是\u003cstrong\u003e有放回的抽样\u003c/strong\u003e，常用于估计统计量(例如均值等)置信区间\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e在样本数据符合正态分布的情况，可基于中心极限定理使用标准误计算公式计算置信区间。详见之前的笔记002\u003c/p\u003e","title":"统计学基础--重抽样Bootstrap与置换检验permutation test"},{"content":" 1 2 3 4 5 6 packageVersion(\u0026#34;Seurat\u0026#34;) # [1] ‘4.0.6’ library(Seurat) library(tidyverse) library(ggplot2) library(clustree) 0、导入数据方式 （1）cellranger比对结果 对每个测序样本数据经cellranger上游比对，产生3个文件，分别是：\nbarcodes.tsv.gz \u0026ndash; 细胞标签 features.tsv.gz \u0026ndash; 基因名 matrix.mtx.gz \u0026ndash; 表达数据 1 2 3 4 5 6 7 8 9 10 11 12 ## GSE166635为例 dir=\u0026#34;./data/HCC2/filtered_feature_bc_matrix/\u0026#34; list.files(dir) #[1] \u0026#34;barcodes.tsv.gz\u0026#34; \u0026#34;features.tsv.gz\u0026#34; \u0026#34;matrix.mtx.gz\u0026#34; #(1) 先使用Read10X()对三文件整合为稀疏表达矩阵 counts \u0026lt;- Read10X(data.dir = dir) #(2) 再使用CreateSeuratObject()创建Seurat对象 scRNA \u0026lt;- CreateSeuratObject(counts = counts) scRNA ## 具体三个文件的格式：https://www.jianshu.com/p/5b26d7bc37b7 （2）直接提供表达矩阵 1 2 3 ## GSE144320为例 scRNA \u0026lt;- CreateSeuratObject(counts = counts) scRNA （3）h5格式文件 1 2 3 4 5 ## GSE138433为例 #(1) 读入表达矩阵 sce \u0026lt;- Read10X_h5(filename = \u0026#34;GSM4107899_LH16.3814_raw_gene_bc_matrices_h5.h5\u0026#34;) #(2) 转为Seurat对象 sce \u0026lt;- CreateSeuratObject(counts = sce) （4）h5ad格式 需要安装，使用SeuratDisk包的两个函数； 先将后h5ad格式转换为h5seurat格式，再使用LoadH5Seurat()函数读取Seurat对象。 1 2 3 4 5 6 #remotes::install_github(\u0026#34;mojaveazure/seurat-disk\u0026#34;) library(SeuratDisk) Convert(\u0026#34;GSE153643_RAW/GSM4648565_liver_raw_counts.h5ad\u0026#34;, \u0026#34;h5seurat\u0026#34;, overwrite = TRUE,assay = \u0026#34;RNA\u0026#34;) scRNA \u0026lt;- LoadH5Seurat(\u0026#34;GSE153643_RAW/GSM4648565_liver_raw_counts.h5seurat\u0026#34;) #注意一下，我之前载入时，表达矩阵被转置了，需要处理一下~ 将Seurat对象转为h5ad格式 1 2 SaveH5Seurat(scRNA, filename = \u0026#34;scRNA.h5Seurat\u0026#34;) Convert(\u0026#34;scRNA.h5Seurat\u0026#34;, dest = \u0026#34;h5ad\u0026#34;) （5）10X PBMC demo https://bioconductor.org/packages/devel/data/experiment/vignettes/TENxPBMCData/inst/doc/TENxPBMCData.html 1 2 3 4 5 6 7 library(TENxPBMCData) library(Seurat) tenx_pbmc3k \u0026lt;- TENxPBMCData(dataset = \u0026#34;pbmc3k\u0026#34;) counts = as.matrix(assay(tenx_pbmc3k, \u0026#34;counts\u0026#34;)) rownames(counts) = rowData(tenx_pbmc3k)$Symbol_TENx colnames(counts) = paste0(\u0026#34;cell-\u0026#34;,1:ncol(counts)) sce = CreateSeuratObject(counts = counts) 1、批量创建Seurat对象 （1）规范化10X文件样本名 每个样本一个文件夹，分别包含三个文件：barcodes.tsv.gz, features.tsv.gz, matrix.mtx.gz\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 list.files(\u0026#34;GSE139324_RAW/\u0026#34;) # [1] \u0026#34;GSM4138110_HNSCC_1_PBMC_barcodes.tsv.gz\u0026#34; \u0026#34;GSM4138110_HNSCC_1_PBMC_genes.tsv.gz\u0026#34; \u0026#34;GSM4138110_HNSCC_1_PBMC_matrix.mtx.gz\u0026#34; # [4] \u0026#34;GSM4138112_HNSCC_2_PBMC_barcodes.tsv.gz\u0026#34; \u0026#34;GSM4138112_HNSCC_2_PBMC_genes.tsv.gz\u0026#34; \u0026#34;GSM4138112_HNSCC_2_PBMC_matrix.mtx.gz\u0026#34; # [7] \u0026#34;GSM4138114_HNSCC_3_PBMC_barcodes.tsv.gz\u0026#34; \u0026#34;GSM4138114_HNSCC_3_PBMC_genes.tsv.gz\u0026#34; \u0026#34;GSM4138114_HNSCC_3_PBMC_matrix.mtx.gz\u0026#34; fs=list.files(\u0026#39;./GSE139324_RAW/\u0026#39;,\u0026#39;^GSM\u0026#39;) samples=str_split(fs,\u0026#39;_\u0026#39;,simplify = T)[,1] %\u0026gt;% unique() samples # [1] \u0026#34;GSM4138110\u0026#34; \u0026#34;GSM4138112\u0026#34; \u0026#34;GSM4138114\u0026#34; dir.create(\u0026#34;data\u0026#34;) for (sp in samples) { # sp = samples[1] sp3 = fs[grepl(sp, fs)] # 顺序很重要 newfolder=paste0(\u0026#34;data/\u0026#34;, sp) dir.create(newfolder,recursive = T) file.copy(paste0(\u0026#34;GSE139324_RAW/\u0026#34;,sp3[1]), paste0(newfolder,\u0026#34;/barcodes.tsv.gz\u0026#34;)) file.copy(paste0(\u0026#34;GSE139324_RAW/\u0026#34;,sp3[2]), paste0(newfolder,\u0026#34;/features.tsv.gz\u0026#34;)) file.copy(paste0(\u0026#34;GSE139324_RAW/\u0026#34;,sp3[3]), paste0(newfolder,\u0026#34;/matrix.mtx.gz\u0026#34;)) } （2）合并多样本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 list.files(\u0026#34;data/\u0026#34;, recursive = T) samples = list.files(\u0026#34;data/\u0026#34;) # [1] \u0026#34;GSM4138110\u0026#34; \u0026#34;GSM4138112\u0026#34; \u0026#34;GSM4138114\u0026#34; dirs = paste0(\u0026#34;data/\u0026#34;,samples) scelist = lapply(samples, function(sp){ # sp = samples[1] print(sp) dirs = paste0(\u0026#34;data/\u0026#34;,sp) sce = Read10X(data.dir = dirs) %\u0026gt;% #读取counts矩阵 CreateSeuratObject(project = sp) %\u0026gt;% #创建seurat对象 RenameCells(add.cell.id = sp) #添加前缀,避免重复 return(sce) }) sce = merge(scelist[[1]], scelist[-1]) head(sce@meta.data) sce = sce %\u0026gt;% PercentageFeatureSet(., \u0026#34;^MT-\u0026#34;, col.name = \u0026#34;percent_mito\u0026#34;) %\u0026gt;% #线粒体基因比例 PercentageFeatureSet(., \u0026#34;^RP[SL]\u0026#34;, col.name = \u0026#34;percent_ribo\u0026#34;) %\u0026gt;% #核糖体基因比例 PercentageFeatureSet(., \u0026#34;^HB[^(P)]\u0026#34;, col.name = \u0026#34;percent_hb\u0026#34;) #血红蛋白基因比例 head(sce@meta.data) （3）过滤细胞/基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 dim(sce) #[1] 33694 4899 #过滤细胞 sce = sce %\u0026gt;% subset(., nFeature_RNA \u0026gt; 500) %\u0026gt;% subset(., percent_mito \u0026lt; 10) %\u0026gt;% subset(., percent_ribo \u0026gt; 3) %\u0026gt;% subset(., percent_hb \u0026lt; 0.1) #过滤基因 sce = sce[rowSums(sce@assays$RNA@counts\u0026gt;0)\u0026gt;3,] dim(sce) #[1] 16334 4751 sce # An object of class Seurat # 16334 features across 4751 samples within 1 assay # Active assay: RNA (16334 features, 0 variable features) 2、标归高降维 （1）标归高 标准化\u0026ndash;归一化\u0026ndash;鉴定高变基因\n1 2 3 4 sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures(nfeatures = 2000) %\u0026gt;% ScaleData(., vars.to.regress = \u0026#34;percent_mito\u0026#34;) （2）降维聚类分群 1 2 3 4 5 6 7 8 sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5,0.8,1)) DimPlot(sce, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;orig.ident\u0026#34;) # clustree(sce@meta.data, prefix = \u0026#34;RNA_snn_res.\u0026#34;) 3、Seurat结构 1 sce = sce_int 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #####表达矩阵##### sce@assays Assays(sce) # [1] \u0026#34;RNA\u0026#34; \u0026#34;CCA\u0026#34; DefaultAssay(sce) DefaultAssay(sce) = \u0026#34;RNA\u0026#34; DefaultAssay(sce) sce@active.assay GetAssayData(sce[[\u0026#34;RNA\u0026#34;]], slot = \u0026#34;counts\u0026#34;) #####细胞meta信息##### sce@meta.data %\u0026gt;% dim() colnames(sce@meta.data) # [1] \u0026#34;orig.ident\u0026#34; \u0026#34;nCount_RNA\u0026#34; \u0026#34;nFeature_RNA\u0026#34; \u0026#34;percent_mito\u0026#34; \u0026#34;percent_ribo\u0026#34; \u0026#34;percent_hb\u0026#34; # [7] \u0026#34;RNA_snn_res.0.01\u0026#34; \u0026#34;RNA_snn_res.0.05\u0026#34; \u0026#34;RNA_snn_res.0.1\u0026#34; \u0026#34;RNA_snn_res.0.2\u0026#34; \u0026#34;RNA_snn_res.0.3\u0026#34; \u0026#34;RNA_snn_res.0.5\u0026#34; # [13] \u0026#34;RNA_snn_res.0.8\u0026#34; \u0026#34;RNA_snn_res.1\u0026#34; \u0026#34;seurat_clusters\u0026#34; \u0026#34;CCA_snn_res.0.01\u0026#34; \u0026#34;CCA_snn_res.0.05\u0026#34; \u0026#34;CCA_snn_res.0.1\u0026#34; # [19] \u0026#34;CCA_snn_res.0.2\u0026#34; \u0026#34;CCA_snn_res.0.3\u0026#34; \u0026#34;CCA_snn_res.0.5\u0026#34; \u0026#34;CCA_snn_res.0.8\u0026#34; \u0026#34;CCA_snn_res.1\u0026#34; head(sce[[]]) table(sce@active.ident) sce = SetIdent(sce, value = \u0026#34;CCA_snn_res.0.1\u0026#34;) Idents(sce_int) \u0026lt;- \u0026#34;CCA_snn_res.0.05\u0026#34; #####降维信息##### names(sce@reductions) #[1] \u0026#34;pca\u0026#34; \u0026#34;umap\u0026#34; DefaultDimReduc(sce) sce@reductions$umap@cell.embeddings %\u0026gt;% head() Embeddings(sce, reduction = \u0026#34;pca\u0026#34;)[1:3,1:3] sce[[\u0026#34;pca\u0026#34;]][1:4,1:4] #####FetchData取关于细胞的任何信息##### FetchData(sce, vars = c(\u0026#34;UMAP_1\u0026#34;,\u0026#34;UMAP_2\u0026#34;)) %\u0026gt;% head() FetchData(sce, vars = c(\u0026#34;nCount_RNA\u0026#34;,\u0026#34;nFeature_RNA\u0026#34;)) %\u0026gt;% head() DefaultAssay(sce) = \u0026#34;RNA\u0026#34; FetchData(sce, vars = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), slot = \u0026#34;data\u0026#34;) %\u0026gt;% head() 4、Seurat可视化 1 2 DefaultAssay(sce)=\u0026#34;RNA\u0026#34; Idents(sce) \u0026lt;- \u0026#34;CCA_snn_res.0.05\u0026#34; （1）VlnPlot 1 2 3 4 # cell info VlnPlot(sce, group.by = \u0026#34;orig.ident\u0026#34;, features = c(\u0026#34;percent_mito\u0026#34;, \u0026#34;nFeature_RNA\u0026#34;), pt.size = 0, ncol = 2) 1 2 3 4 5 6 7 8 9 10 11 12 # gene exp VlnPlot(sce, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, pt.size = 0, ncol = 1) ### 修改展示顺序 # levels(sce_int@active.ident) # sce_int@active.ident = factor(sce_int@active.ident, # levels = c(5,4,3,2,1,0)) ### 山脊图 # RidgePlot(sce_int, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), # assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;) 1 2 3 4 5 6 library(patchwork) VlnPlot(sce,split.by = \u0026#39;orig.ident\u0026#39;, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, pt.size = 0,combine = FALSE) %\u0026gt;% wrap_plots(ncol = 1) 1 2 3 4 Idents(sce) = \u0026#34;RNA_snn_res.0.01\u0026#34; sce$Group = ifelse(sce$orig.ident==\u0026#34;GSM4138110\u0026#34;,\u0026#34;before\u0026#34;,\u0026#34;after\u0026#34;) #二分组变量 VlnPlot(sce, split.by = \u0026#34;Group\u0026#34;, split.plot = TRUE, features = c(\u0026#34;percent_mito\u0026#34;, \u0026#34;nFeature_RNA\u0026#34;)) （2）DotPlot 1 2 3 4 5 6 DotPlot(sce, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), assay = \u0026#34;RNA\u0026#34;) + coord_flip() ### 修改颜色 # DotPlot(sce, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), # assay = \u0026#34;RNA\u0026#34;, cols = c(\u0026#34;lightgrey\u0026#34;,\u0026#34;red\u0026#34;)) 1 2 3 4 genelist = list(set1=c(\u0026#34;CD3D\u0026#34;,\u0026#34;CD3E\u0026#34;,\u0026#34;CD3G\u0026#34;), set2=c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;)) DotPlot(sce, features = genelist, assay = \u0026#34;RNA\u0026#34;, scale = FALSE) （3）Dimplot 1 2 DimPlot(sce, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;CCA_snn_res.0.01\u0026#34;,label = T) 1 2 3 DimPlot(sce, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;CCA_snn_res.0.01\u0026#34;, split.by = \u0026#34;orig.ident\u0026#34;) \u0026amp; NoAxes() （4）FeaturePlot 1 FeaturePlot(sce, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), ncol = 3) 1 2 3 FeaturePlot(sce, features = c(\u0026#34;CD4\u0026#34;,\u0026#34;CD8A\u0026#34;,\u0026#34;CD8B\u0026#34;), split.by = \u0026#34;orig.ident\u0026#34;, ncol = 3, cols = c(\u0026#34;lightgrey\u0026#34;,\u0026#34;red\u0026#34;)) 5、注释细胞类型 marker基因：Dotplot 假设根据CCA_snn_res.0.05分群结果，将6个cluster注释为4中细胞类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Idents(sce) \u0026lt;- \u0026#34;CCA_snn_res.0.05\u0026#34; table(sce@active.ident) # 0 1 2 3 4 5 # 1595 1486 1250 315 56 49 sce$celltype = dplyr::case_when( sce@active.ident %in% c(0,1) ~ \u0026#34;celltypeA\u0026#34;, sce@active.ident %in% c(2) ~ \u0026#34;celltypeB\u0026#34;, sce@active.ident %in% c(3,4) ~ \u0026#34;celltypeC\u0026#34;, sce@active.ident %in% c(5) ~ \u0026#34;celltypeD\u0026#34;) table(sce$celltype) # celltypeA celltypeB celltypeC celltypeD # 3081 1250 371 49 6、差异分析 1 2 3 DefaultAssay(sce)=\u0026#34;RNA\u0026#34; Idents(sce) \u0026lt;- \u0026#34;CCA_snn_res.0.05\u0026#34; table(sce@active.ident) （1）FindAllMarkers 1 2 3 4 5 6 7 8 diff_wilcox = FindAllMarkers(sce, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, only.pos = T) %\u0026gt;% dplyr::group_by(cluster) %\u0026gt;% dplyr::arrange(desc(avg_log2FC), .by_group = T) top_n \u0026lt;- diff_wilcox %\u0026gt;% group_by(cluster) %\u0026gt;% top_n(5, avg_log2FC) DoHeatmap(sce, top_n$gene, size = 3) 1 2 3 4 mapal \u0026lt;- colorRampPalette(RColorBrewer::brewer.pal(11,\u0026#34;RdBu\u0026#34;))(256) DoHeatmap(subset(sce, downsample = 100), top_n$gene, angle = 90,size = 3) + scale_fill_gradientn(colours = rev(mapal)) \u0026amp; NoLegend() （2）FindMarkers 1 2 3 4 5 6 7 8 9 10 11 # 0 vs the other cluster diff_wilcox_cluster0 = FindMarkers(sce, ident.1 = 0, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;) head(diff_wilcox_cluster0) # 0 vs 1 diff_wilcox_cluster0 = FindMarkers(sce, ident.1 = 0, ident.2 = 1, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;) VlnPlot(subset(sce, CCA_snn_res.0.05 %in% c(0,1)), features = c(\u0026#34;RPL11\u0026#34;,\u0026#34;CD2\u0026#34;), assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, group.by = \u0026#34;CCA_snn_res.0.05\u0026#34;, pt.size = 0) 1 2 3 4 5 6 7 8 9 10 # 某一类细胞（celltypeA）在两个样本(GSM4138110,GSM4138112)的差异基因 Idents(sce)=\u0026#34;celltype\u0026#34; markers \u0026lt;- FindMarkers(sce, subset.ident = \u0026#34;celltypeA\u0026#34;, group.by = \u0026#34;orig.ident\u0026#34;, ident.1 = \u0026#34;GSM4138110\u0026#34;, ident.2 = \u0026#34;GSM4138112\u0026#34;) head(markers) VlnPlot(subset(sce, celltype %in% c(\u0026#34;celltypeA\u0026#34;) \u0026amp; orig.ident %in% c(\u0026#34;GSM4138110\u0026#34;,\u0026#34;GSM4138112\u0026#34;)), features = c(\u0026#34;RPS26\u0026#34;,\u0026#34;IGHA1\u0026#34;), assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, group.by = \u0026#34;orig.ident\u0026#34;, pt.size = 0) （3）FindConservedMarkers 1 2 3 4 5 6 7 8 9 10 Idents(sce)=\u0026#34;celltype\u0026#34; # 在每个样本中orig.ident， celltypeA与celltypeB相比均差异表达的基因 markers = FindConservedMarkers(sce, ident.1 = \u0026#34;celltypeA\u0026#34;, ident.2 = \u0026#34;celltypeB\u0026#34;, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, grouping.var = \u0026#34;orig.ident\u0026#34;) # 在每个样本中orig.ident， celltypeA与其它类型细胞相比均差异表达的基因 markers = FindConservedMarkers(sce, ident.1 = \u0026#34;celltypeA\u0026#34;, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;, grouping.var = \u0026#34;orig.ident\u0026#34;) 7、多线程 1 2 3 4 5 6 7 8 9 10 11 12 library(future) #查看初始状态 plan() #设置4个线程 plan(\u0026#34;multiprocess\u0026#34;, workers = 4) options(future.globals.maxSize = 1024^4) plan() #恢复单线程 plan(\u0026#34;sequential\u0026#34;) plan() 8、基因集打分 1 2 3 4 5 6 7 8 9 10 11 12 13 ## (1) Seurat包自带的`AddModuleScore()`打分函数，结果有正负值 sce_pw_score = AddModuleScore(sce, features=pw.list, seed=42) head(sce_pw_score[[]]) ## (2) AUCell包评价基因集活性,结果在0~1之间 BiocManager::install(\u0026#34;AUCell\u0026#34;) library(AUCell) # step1: cells_rankings \u0026lt;- AUCell_buildRankings(sce@assays$RNA@data) # step2： cells_AUC \u0026lt;- AUCell_calcAUC(pw.list, cells_rankings, aucMaxRank=nrow(cells_rankings)*0.1, nCores=5) # step3： sce_pw_auc = getAUC(cells_AUC) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/006%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--seurat4%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epackageVersion(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Seurat\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] ‘4.0.6’\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(Seurat)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggplot2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(clustree)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"0导入数据方式\"\u003e0、导入数据方式\u003c/h3\u003e\n\u003ch4 id=\"1cellranger比对结果\"\u003e（1）cellranger比对结果\u003c/h4\u003e\n\u003cp\u003e对每个测序样本数据经cellranger上游比对，产生3个文件，分别是：\u003c/p\u003e","title":"单细胞分析工具--Seurat4基础流程"},{"content":"1、什么是异常 异常通常是指因各种原因的出错程序代码不能正常运行，从而返回报错信息，中断程序。\n报错信息由两部分组成（1）Traceback：追溯出错的源头（2）异常所属的类，以及提示的上下文。\n1 2 3 4 5 6 1/0 #Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # ZeroDivisionError: division by zero #如上：异常属于ZeroDivisionError，并使用默认的上下文提示division by zero 常见的异常类都属于Exception这个父类，而具体的一些异常类型由它继承而来，一般为****Error 2、捕捉异常 出现异常，程序会立即中断执行。\n如果只是想捕捉并提醒到某个预知的异常，而不影响后续代码的运行，可以使用下面的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ##(1) 预知会出现指定类型的错误，并使用默认的上下文提示异常信息 try: x = 1 y = 0 print(x/y) except ZeroDivisionError as e: print(e) # division by zero ##(2) 预知会出现指定类型的错误，并自定义提示信息 try: x = 1 y = 0 print(x/y) except ZeroDivisionError: print(\u0026#34;The second number cannot be zero!\u0026#34;) # The second number cannot be zero! 当不确定会出现某种预知的类别时 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ##(1) 使用多个except语句 try: x = 1 y = \u0026#34;aaaa\u0026#34; print(x/y) except ValueError as e: print(e) except ZeroDivisionError as e: print(e) except TypeError as e: print(e) # unsupported operand type(s) for /: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; ##(2) 使用元组囊括多种异常类别 try: x = 1 y = \u0026#34;aaaa\u0026#34; print(x/y) except (ValueError, ZeroDivisionError, TypeError) as e: print(e) # unsupported operand type(s) for /: \u0026#39;int\u0026#39; and \u0026#39;str\u0026#39; ##(3) 仅使用except语句，直接捕捉所有异常事件 try: x = 1 y = 0 print(x/y) except: print(\u0026#34;Something wrong happened！\u0026#34;) # Something wrong happened！ 3、搭配其它语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ##(1) raise语句：触发指定类型错误，中断程序执行 def calc(number1, number2, muffled=False): \u0026#39;muffled参数设置为：是否捕捉异常\u0026#39; try: print(number1/number2) except ZeroDivisionError: if muffled: print(\u0026#34;The second number cannot be zero! But you can go on\u0026#34;) else: raise ZeroDivisionError(\u0026#34;The second number cannot be zero! You are stopped\u0026#34;) calc(1,0, muffled=True) #The second number cannot be zero! But you can go on calc(1,0, muffled=False) # Traceback (most recent call last): # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; # File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 9, in calc # ZeroDivisionError: The second number cannot be zero! You are stopped ##(2) else语句：类似if-else语句，如果没报错.... try: x = 10 y = 1 z = x/y except Exception as e: print(e) else: print(\u0026#34;The number you provied is good. And the result is\u0026#34;, z) # The number you provied is good. And the result is 10.0 ","permalink":"https://lishensuo.github.io/en/posts/program/006python%E5%9F%BA%E7%A1%80-6%E5%BC%82%E5%B8%B8error/","summary":"\u003ch3 id=\"1什么是异常\"\u003e1、什么是异常\u003c/h3\u003e\n\u003cp\u003e异常通常是指因各种原因的出错程序代码不能正常运行，从而返回报错信息，中断程序。\u003c/p\u003e\n\u003cp\u003e报错信息由两部分组成（1）Traceback：追溯出错的源头（2）异常所属的类，以及提示的上下文。\u003c/p\u003e","title":"Python基础-(6)捕捉异常Error"},{"content":"1、KS统计量 Kolmogorov-Smirnov Tests\nGene Set Enrichment Analysis\nhttps://github.com/franapoli/signed-ks-test 1 2 3 4 5 6 7 8 9 10 11 12 13 source(\u0026#34;signed-ks-test.R\u0026#34;) # c(\u0026#34;two.sided\u0026#34;, \u0026#34;less\u0026#34;, \u0026#34;greater\u0026#34;) ks = ks.test.2(c(2,10,11,20), 1:100, alternative = \u0026#34;greater\u0026#34;) # Two-sample Kolmogorov-Smirnov test # data: c(2, 10, 11, 20) and 1:100 # D^+ = 0.8, p-value = 0.007277 # alternative hypothesis: the CDF of x lies above that of y ks$ES # [1] 0.8 ks$p.value # [1] 0.007276706 ","permalink":"https://lishensuo.github.io/en/posts/basic/010%E7%BB%9F%E8%AE%A1%E5%AD%A6--%E7%94%9F%E4%BF%A1%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%BB%9F%E8%AE%A1%E6%8C%87%E6%A0%87/","summary":"\u003ch1 id=\"1ks统计量\"\u003e1、KS统计量\u003c/h1\u003e\n\u003cp\u003eKolmogorov-Smirnov Tests\u003c/p\u003e\n\u003cp\u003eGene Set Enrichment Analysis\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/franapoli/signed-ks-test\"\u003ehttps://github.com/franapoli/signed-ks-test\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esource(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;signed-ks-test.R\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# c(\u0026#34;two.sided\u0026#34;, \u0026#34;less\u0026#34;, \u0026#34;greater\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eks = ks.test.2(c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e11\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e), \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  alternative = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;greater\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \tTwo-sample Kolmogorov-Smirnov test\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# data:  c(2, 10, 11, 20) and 1:100\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# D^+ = 0.8, p-value = 0.007277\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# alternative hypothesis: the CDF of x lies above that of y\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eks$ES\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 0.8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eks$p.value\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 0.007276706\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"统计学-生信中常见统计指标"},{"content":"1、加载模块 模块简单来说是用来定义函数、类、变量的python脚本文件。\n模块的分类\n根据来源不同：可分为内置模块、第三方模块以及自建模块。\n无论哪一种模块，都需要放在正确的路径下，让python可以找到，然后才可以成功加载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #查看python解释器默认的寻找目录 import sys, pprint, os pprint.pprint(sys.path) [\u0026#39;\u0026#39;, \u0026#39;/home/shensuo/miniconda3/lib/python38.zip\u0026#39;, \u0026#39;/home/shensuo/miniconda3/lib/python3.8\u0026#39;, \u0026#39;/home/shensuo/miniconda3/lib/python3.8/lib-dynload\u0026#39;, \u0026#39;/home/shensuo/miniconda3/lib/python3.8/site-packages\u0026#39;] ##注意第一个空字符应该表示当前路径 #os.system(\u0026#34;ls /home/shensuo/miniconda3/lib/python3.8\u0026#34;) #如果是自建模块，需要将模块放到上面的路径之一，或者再另添加新的路径(如下代码) sys.path.append(\u0026#34;/home/shensuo/python\u0026#34;) 根据组成不同：可分为简单模块和包两类，二者在加载时有一定的区别 （1）简单模块：就是一个python脚本，里面定义了若干函数等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #加载方式1：加载模块，使用具体某个函数时-- module.function import copy copy.deepcopy() import copy as cp #模块重命名 cp.deepcopy() #加载方式2：加载模块的所有函数，使用具体某个函数时，直接交代函数名 from copy import * deepcopy() #加载方式3：仅加载模块的指定函数 from copy import deepcopy from copy import deepcopy as dpc #函数重命名 （2）包package：将多个py脚本组织在一个目录下；可以有多层，每一层都需要有一个__init__文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #包可以理解为复杂的模块,如下创建了具有两层结构的简单的包 tree package/ # package/ # ├── __init__.py # ├── mod1.py # └── subpack # ├── __init__.py # └── mod2.py #加载第一层 ##(1) #from package import * #第一层的所有模块 from package import mod1 #第一层的指定模块 mod1.print1() ##(2) import package.mod1 package.mod1.print1() ##(3) from package.mod1 import print1 print1() #加载第二层 ##(1) from package.subpack import mod2 #第二层的指定模块 mod2.print2() ##(2) import package.subpack.mod2 package.subpack.mod2.print2() 作为包的文件结构中必须包含 __init__.py文件。它可以仅仅是空白文件，但必须要有，暂且不提。\n2、探索模块 模块包含什么 （1）dir(): 可列出对象的所有属性。对于模块来说，列出所定义的函数、类、变量\n1 2 3 4 5 6 7 #需要先加载 import copy dir(copy) #以下划线开头的，并非给外部使用 [n for n in dir(copy) if not n.startswith(\u0026#34;_\u0026#34;)] ## [\u0026#39;Error\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;deepcopy\u0026#39;, \u0026#39;dispatch_table\u0026#39;, \u0026#39;error\u0026#39;] （2）__all__: 模块自定义变量。返回一个列表，包含for module import *语句所加载的函数\n1 2 3 4 #需要先加载 import copy copy.__all__ ## [\u0026#39;Error\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;deepcopy\u0026#39;] 查看模块的帮助文档 1 2 3 4 5 6 7 8 9 10 11 12 13 #需要先加载 import copy ##（1）help() help(copy) #模块的帮助信息 help(copy.copy) #函数的帮助信息 ##（2）__doc__ print(copy.__doc__) #模块的文档 print(copy.copy.__doc__) #函数的文档 ##（3）__file__ print(copy.__file__) #查看模块的源代码文件储存路径 ","permalink":"https://lishensuo.github.io/en/posts/program/007python%E5%9F%BA%E7%A1%80-7%E6%A8%A1%E5%9D%97%E5%9F%BA%E7%A1%80module/","summary":"\u003ch3 id=\"1加载模块\"\u003e1、加载模块\u003c/h3\u003e\n\u003cp\u003e模块简单来说是用来定义函数、类、变量的python脚本文件。\u003c/p\u003e\n\u003cp\u003e模块的分类\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e根据来源不同：可分为内置模块、第三方模块以及自建模块。\u003c/p\u003e\n\u003cp\u003e无论哪一种模块，都需要放在正确的路径下，让python可以找到，然后才可以成功加载。\u003c/p\u003e","title":"Python基础-(7)模块/包Module"},{"content":"1. sys 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ##(1) sys.argv 给脚本传参 #如下定义一个sys.py脚本 #!/usr/bin/env python import sys print(sys.argv[0]) #第0个参数为脚本名 print(sys.argv[1]) python sys.py first # sys.py # first ##(2) sys.path 一个列表，包含要在其中查找模块的目录名称 sys.path.append() 2. os 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## (1) os.system 执行shell命令 os.system(\u0026#34;pwd\u0026#34;) os.system(\u0026#34;ls -lh\u0026#34;) ## (2) os.path 路径操作相关 os.path.abspath(\u0026#34;.\u0026#34;) #返回绝对路径 os.path.basename(\u0026#34;/home/test/file.txt\u0026#34;) #单独返回文件名 os.path.dirname(\u0026#34;/home/test/file.txt\u0026#34;) #单独返回路径名 os.path.split(\u0026#34;/home/test/file.txt\u0026#34;) #返回由文件名和路径名组成的元组 #(\u0026#39;/home/test\u0026#39;, \u0026#39;file.txt\u0026#39;) os.path.splitext(\u0026#34;file.txt\u0026#34;) #将文件名与后缀名分开 #(\u0026#39;file\u0026#39;, \u0026#39;.txt\u0026#39;) os.path.exists(\u0026#34;/home/test/file.txt\u0026#34;) #判断文件或者目录是否存在 #False ## 此外os模块还支持对目录、文件的常规操作，例如创建、删除、重命名等 3. time 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import time time.sleep(3) #解释器等待指定秒数 time.time() #当前时间至新纪元的秒数(时间戳) # 1649984110.885341 time.localtime() #默认返回当前时间戳的时间元组 time.localtime(100000000) #返回指定时间戳时间元组 # time.struct_time(tm_year=1973, tm_mon=3, tm_mday=3, tm_hour=17, tm_min=46, tm_sec=40, tm_wday=5, tm_yday=62, tm_isdst=0) tuple(time.localtime(100000000)) # 返回tuple # (1973, 3, 3, 17, 46, 40, 5, 62, 0) ###将时间元组格式化输出 time.asctime(time.localtime()) # \u0026#39;Fri Apr 15 08:59:43 2022\u0026#39; ###(1)按自定义格式输出 #常见的item有： %Y-年, %m-月, %d-日, %H-时, %M-分, %S-秒, %a-星期几, %b-英文月份 #全部的item参考：https://www.runoob.com/python/python-date-time.html time.strftime(\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;, time.localtime()) # \u0026#39;2022-04-15 09:12:29\u0026#39; time.strftime(\u0026#34;%a %b %d %H:%M:%S %Y\u0026#34;, time.localtime()) # \u0026#39;Fri Apr 15 09:12:49 2022\u0026#39; ###(2)将格式字符串转换为时间戳 a = \u0026#34;2022-04-15 09:12:29\u0026#34; time.mktime(time.strptime(a,\u0026#34;%Y-%m-%d %H:%M:%S\u0026#34;)) # 1649985149.0 关于时间元组的格式：\n4. random 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from random import * #(1)返回指定区间的一个随机实数 uniform(0,10) #(2)返回指定区间的一个随机整数，注意不包含区间的上边界 randrange(1,5) #不会返回5 randrange(5) #默认为randrange(0, 5) #(3)从给定序列中随机返回一个值，可以是列表、元组、字符串 choice([1,3,5,7]) #(4)从给定序列中随机返回n个不同的元素 sample(range(10),3) # [3,5,6] #(5)打乱给定序列的顺序 a = [1,3,5,7] shuffle(a) a # [7, 5, 1, 3] 可通过设置随机种子random.seed(n)，确保下一次抽样结果与先前相同种子的抽样结果相同。\n5. re （1）正则表达式基础用法见之前的笔记\n（2）尤其注意一点是：反斜杠\\在正则表达式中视为转义符，可以将（1）特殊字符转为普通字符，例如\\*表示匹配字符星号；（2）将普通字符转义为特殊字符，例如\\d 表示匹配任一数字0-9\n（3）由于python字符串也支持转义符，为避免混淆，当正则表达式中需要使用\\时，十分建议使用r'正则表达式'的形式。所见即所得。\nre.match()：给定字符串的起始位置是否与正则表达式匹配 1 2 3 4 5 6 7 8 9 import re re.match(\u0026#34;p\u0026#34;, \u0026#34;python\u0026#34;) # \u0026lt;re.Match object; span=(0, 1), match=\u0026#39;p\u0026#39;\u0026gt; print(re.match(\u0026#34;p\u0026#34;, \u0026#34;www.python\u0026#34;)) # None print(re.match(\u0026#34;w*\u0026#34;, \u0026#34;www.python\u0026#34;)) # \u0026lt;re.Match object; span=(0, 3), match=\u0026#39;www\u0026#39;\u0026gt; re.match()返回的是一个MatchObject对象。当搭配使用圆括号时，可用于提取与指定正则部分匹配的子串，即成为编组group\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 site = \u0026#39;www.123-456789.com\u0026#39; m = re.match(\u0026#39;www\\.(\\d*)\\-(\\d*)\\.com\u0026#39;, site) ## 编组0表示整个模式 m.group(0) # \u0026#39;www.123-456789.com\u0026#39; ## 之后编组的序号取决于左边括号树的编号 m.group(1) # \u0026#39;123\u0026#39; m.group(2) # \u0026#39;456789\u0026#39; ## 括号镶嵌括号 re.match(\u0026#39;www\\.((\\d*)\\-(\\d*))\\.com\u0026#39;, site).group(1) # \u0026#39;123-456789\u0026#39; ## 编组子串的字符串位置索引 m.start(1) # 4 m.end(1) # 7 m.span(1) # (4, 7) re.sub(): 将匹配的模式子串替换为指定的文本 1 2 3 4 5 6 import re # re.sub(正则模式，新子串, 原始字符串) phone = \u0026#34;2004-959-559 # 这是一个国外电话号码\u0026#34; # 删除字符串中的 Python注释 re.sub(r\u0026#39; #.*$\u0026#39;, \u0026#34;\u0026#34;, phone) # \u0026#39;2004-959-559\u0026#39; re.split(): 使用正则表达式分割字符串 1 2 3 4 import re some_words = \u0026#34;aaaa,,,bbb++++ccc---dd\u0026#34; re.split(r\u0026#39;[,\\+\\-]+\u0026#39;, some_words) # [\u0026#39;aaaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccc\u0026#39;, \u0026#39;dd\u0026#39;] re.findall: 返回给定字符串中所有匹配的子串 1 2 3 4 5 6 7 8 9 10 import re some_words = \u0026#34;aaaa,,,bbb++++ccc---dd\u0026#34; re.findall(r\u0026#39;\\w+\u0026#39;, some_words) # [\u0026#39;aaaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccc\u0026#39;, \u0026#39;dd\u0026#39;] re.findall(\u0026#39;[a-z]+\u0026#39;, some_words) # [\u0026#39;aaaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccc\u0026#39;, \u0026#39;dd\u0026#39;] re.findall(r\u0026#39;[,\\+\\-]+\u0026#39;, some_words) # [\u0026#39;,,,\u0026#39;, \u0026#39;++++\u0026#39;, \u0026#39;---\u0026#39;] re.search() 寻找给定字符串中第一个匹配的子串，并且返回的是上述提到的MatchObject对象。\nre.compile(): 将正则表达式转换为模式对象，以实现高效匹配。适用于重复执行同一个正则匹配任务。 1 2 3 4 5 6 7 8 9 10 11 #例如上面的例子 import re regex = re.compile(r\u0026#39;\\w+\u0026#39;) ##可以看到上面提到的函数，都可以应用 [n for n in dir(regex) if not n.startswith(\u0026#34;_\u0026#34;)] # [\u0026#39;findall\u0026#39;, \u0026#39;finditer\u0026#39;, \u0026#39;flags\u0026#39;, \u0026#39;fullmatch\u0026#39;, \u0026#39;groupindex\u0026#39;, \u0026#39;groups\u0026#39;, \u0026#39;match\u0026#39;, # \u0026#39;pattern\u0026#39;, \u0026#39;scanner\u0026#39;, \u0026#39;search\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;sub\u0026#39;, \u0026#39;subn\u0026#39;] some_words = \u0026#34;aaaa,,,bbb++++ccc---dd\u0026#34; regex.findall(some_words) # [\u0026#39;aaaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccc\u0026#39;, \u0026#39;dd\u0026#39;] 6. typing 从3.5版本开始，Python 为函数参数和返回值提供了类型注解的支持。\n参数类型提示：使用 : 后跟类型来指定参数的类型。 返回值类型提示：使用 -\u0026gt; 后跟类型来指定返回值的类型。 基本类型包括： int, float, str, bool\n1 2 def add(x: int, y: int) -\u0026gt; int: return x + y 基于typing模块，定义容器类型， 包括 List, Tuple, Dict, Set等\nOptional[str]: 表示字符串或者None Union[int, str]: 表示整型或者字符串类型 1 2 3 4 5 6 7 8 9 10 11 12 from typing import List, Tuple, Dict def sum_of_elements(numbers: List[int]) -\u0026gt; int: return sum(numbers) # 返回元组，由字符串和整数组成 def get_name_and_age() -\u0026gt; Tuple[str, int]: return \u0026#34;Alice\u0026#34;, 30 # 返回元组，有字典组成。每个字典的key是字符，值是张量 def get_complex_data() -\u0026gt; Tuple[Dict[str, torch.Tensor]]: return \u0026#34;Alice\u0026#34;, 30 7. pathlib Python 3.4 引入的一个模块，用于以面向对象的方式处理文件系统路径。\n1 from pathlib import Path 创建路径对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 当前目录 current_path = Path(\u0026#39;.\u0026#39;) # 指定路径 specific_path = Path(\u0026#39;/path/to/directory\u0026#39;) # 拼接路径 new_file = current_path / \u0026#34;file.txt\u0026#34; print(new_file.name) # 文件名 # \u0026#39;file.txt\u0026#39; print(new_file.stem) # 文件名不含扩展 # \u0026#39;file\u0026#39; print(new_file.suffix) # 文件扩展名 # \u0026#39;txt\u0026#39; print(new_file.parent) # 父目录 # PosixPath(\u0026#39;.\u0026#39;) print(new_file.resolve()) # 绝对路径 new_file.resolve().parent.parent 检查/创建路径 1 2 3 4 5 6 7 8 9 10 11 if specific_path.exists(): print(\u0026#34;Path exists\u0026#34;) if specific_path.is_file(): print(\u0026#34;It\u0026#39;s a file\u0026#34;) if specific_path.is_dir(): print(\u0026#34;It\u0026#39;s a directory\u0026#34;) new_dir = Path(\u0026#39;new_directory\u0026#39;) new_dir.mkdir(exist_ok=True) 8. Enum 在Python中，枚举类型是一种符号化的常量集合； 枚举类一旦在定义后，不可修改或增加新的枚举成员。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from enum import Enum # 定义一个枚举类 class Day(Enum): MONDAY = 1 TUESDAY = 2 WEDNESDAY = 3 THURSDAY = 4 FRIDAY = 5 SATURDAY = 6 SUNDAY = 7 ## (1)访问枚举成员 Day(1) # 通过成员的value访问 Day.MONDAY # 通过成员的name访问 ## (2)枚举成员由name与value两部分组成 Day.MONDAY.name # \u0026#39;MONDAY\u0026#39; Day.MONDAY.value # 1 ## (3)访问所有枚举成员 Day.__members__ # 不可修改的字典类型 # mappingproxy({\u0026#39;MONDAY\u0026#39;: \u0026lt;Day.MONDAY: 1\u0026gt;, # \u0026#39;TUESDAY\u0026#39;: \u0026lt;Day.TUESDAY: 2\u0026gt;, # \u0026#39;WEDNESDAY\u0026#39;: \u0026lt;Day.WEDNESDAY: 3\u0026gt;, # \u0026#39;THURSDAY\u0026#39;: \u0026lt;Day.THURSDAY: 4\u0026gt;, # \u0026#39;FRIDAY\u0026#39;: \u0026lt;Day.FRIDAY: 5\u0026gt;, # \u0026#39;SATURDAY\u0026#39;: \u0026lt;Day.SATURDAY: 6\u0026gt;, # \u0026#39;SUNDAY\u0026#39;: \u0026lt;Day.SUNDAY: 7\u0026gt;}) Day._value2member_map_ # {1: \u0026lt;Day.MONDAY: 1\u0026gt;, # 2: \u0026lt;Day.TUESDAY: 2\u0026gt;, # 3: \u0026lt;Day.WEDNESDAY: 3\u0026gt;, # 4: \u0026lt;Day.THURSDAY: 4\u0026gt;, # 5: \u0026lt;Day.FRIDAY: 5\u0026gt;, # 6: \u0026lt;Day.SATURDAY: 6\u0026gt;, # 7: \u0026lt;Day.SUNDAY: 7\u0026gt;} 9. collections Counter: 统计可迭代对象（e.g. list）的元素的频数 1 2 3 4 5 6 7 8 9 10 11 from collections import Counter data = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;b\u0026#34;] freq = Counter(data) # Counter({\u0026#39;b\u0026#39;: 3, \u0026#39;c\u0026#39;: 2, \u0026#39;a\u0026#39;: 1}) freq[\u0026#34;a\u0026#34;] # 1 freq[\u0026#34;b\u0026#34;] # 3 defaultdict: 访问不存在的键时，不会引发报错。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from collections import defaultdict # 创建一个defaultdict，默认值为0 d = defaultdict(int) # 创建一个defaultdict，默认值为空列表[] d = defaultdict(list) print(d[\u0026#39;key\u0026#39;]) # [] d # defaultdict(list, {\u0026#39;key\u0026#39;: []}) d[\u0026#34;key\u0026#34;].append(10) # defaultdict(list, {\u0026#39;key\u0026#39;: [10]}) d[\u0026#34;new_key\u0026#34;].append(\u0026#34;aw\u0026#34;) # defaultdict(list, {\u0026#39;key\u0026#39;: [10], \u0026#39;new_key\u0026#39;: [\u0026#39;aw\u0026#39;]}) OrderedDict：会记住元素插入的顺序，在迭代时，返回的元素顺序与插入时一致 （PS：Python\u0026gt;3.7版本也会默认支持） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from collections import OrderedDict # 创建一个OrderedDict od = OrderedDict() od[\u0026#39;a\u0026#39;] = 1 od[\u0026#39;b\u0026#39;] = 2 od[\u0026#39;c\u0026#39;] = 3 # 遍历OrderedDict，元素顺序与插入顺序相同 for key, value in od.items(): print(key, value) # a 1 # b 2 # c 3 ","permalink":"https://lishensuo.github.io/en/posts/program/008python%E5%9F%BA%E7%A1%80-8%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97module/","summary":"\u003ch1 id=\"1-sys\"\u003e1. sys\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) sys.argv 给脚本传参\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#如下定义一个sys.py脚本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#!/usr/bin/env python\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e sys\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(sys.argv[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]) \u003cspan style=\"color:#007f7f\"\u003e#第0个参数为脚本名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(sys.argv[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epython sys.py first\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# sys.py\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# first\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2) sys.path 一个列表，包含要在其中查找模块的目录名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esys.path.append()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2-os\"\u003e2. os\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) os.system 执行shell命令\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.system(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;pwd\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.system(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ls -lh\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) os.path 路径操作相关\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.abspath(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;.\u0026#34;\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e#返回绝对路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.basename(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;/home/test/file.txt\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#单独返回文件名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.dirname(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;/home/test/file.txt\u0026#34;\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e#单独返回路径名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.split(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;/home/test/file.txt\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#返回由文件名和路径名组成的元组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(\u0026#39;/home/test\u0026#39;, \u0026#39;file.txt\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.splitext(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;file.txt\u0026#34;\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e#将文件名与后缀名分开\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(\u0026#39;file\u0026#39;, \u0026#39;.txt\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.path.exists(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;/home/test/file.txt\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#判断文件或者目录是否存在\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#False\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 此外os模块还支持对目录、文件的常规操作，例如创建、删除、重命名等\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3-time\"\u003e3. time\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e time\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.sleep(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#解释器等待指定秒数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.time() \u003cspan style=\"color:#007f7f\"\u003e#当前时间至新纪元的秒数(时间戳)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1649984110.885341\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.localtime() \u003cspan style=\"color:#007f7f\"\u003e#默认返回当前时间戳的时间元组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.localtime(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100000000\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#返回指定时间戳时间元组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# time.struct_time(tm_year=1973, tm_mon=3, tm_mday=3, tm_hour=17, tm_min=46, tm_sec=40, tm_wday=5, tm_yday=62, tm_isdst=0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003etuple\u003c/span\u003e(time.localtime(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100000000\u003c/span\u003e)) \u003cspan style=\"color:#007f7f\"\u003e# 返回tuple\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1973, 3, 3, 17, 46, 40, 5, 62, 0)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###将时间元组格式化输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.asctime(time.localtime()) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026#39;Fri Apr 15 08:59:43 2022\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###(1)按自定义格式输出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#常见的item有： %Y-年, %m-月, %d-日, %H-时, %M-分, %S-秒, %a-星期几, %b-英文月份\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#全部的item参考：https://www.runoob.com/python/python-date-time.html\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.strftime(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;%Y-%m-\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e%d\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e %H:%M:%S\u0026#34;\u003c/span\u003e, time.localtime()) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026#39;2022-04-15 09:12:29\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.strftime(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e%a\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e %b \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e%d\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e %H:%M:%S %Y\u0026#34;\u003c/span\u003e, time.localtime()) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026#39;Fri Apr 15 09:12:49 2022\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###(2)将格式字符串转换为时间戳\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;2022-04-15 09:12:29\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etime.mktime(time.strptime(a,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;%Y-%m-\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e%d\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e %H:%M:%S\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1649985149.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e关于时间元组的格式：\u003c/p\u003e","title":"Python基础-(8)常用基础模块Module"},{"content":"一、monocle 参考教程/笔记 （1）http://cole-trapnell-lab.github.io/monocle-release/docs/#constructing-single-cell-trajectories\n（2）http://events.jianshu.io/p/5d6fd4561bc0 单细胞之轨迹分析-2：monocle2 原理解读+实操\n（3）https://www.jianshu.com/p/7c3e4370bd4c\nMonocle introduced the strategy of ordering single cells in pseudotime, placing them along a trajectory corresponding to a biological process such as cell differentiation by taking advantage of individual cell\u0026rsquo;s asynchronous progression of those processes.\n关于monocle包的安装(20230311) 最近使用monocle包的orderCells() 函数出现了问题，发现有人已在github提出了相应的解决方案，并提供了更新后的包的源代码。\nhttps://github.com/cole-trapnell-lab/monocle-release/issues/434 https://github.com/cole-trapnell-lab/monocle-release/files/10134172/monocle_2.26.0.tar.gz\n基于上述，总结安装经验如下\n1 2 3 4 5 6 7 8 9 # step1：按照正常方式安装monocle包(2.26.0),以安装相关依赖包 BiocManager::install(\u0026#34;monocle\u0026#34;) # step2：单独卸载monocle包 remove.packages(\u0026#34;monocle\u0026#34;) # step3: 手动安装上述修改好的monocle包 install.packages(\u0026#34;monocle_2.26.0.tar.gz\u0026#34;, repos = NULL) library(monocle) 0、Seurat前期分析 建议在完成Seurat对象完成前期的细胞注释等步骤后，再无缝对接monocle的分析流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## 下载示例数据 download.file(\u0026#34;https://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;, \u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) untar(\u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) library(Seurat) sce \u0026lt;- Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) sce \u0026lt;- CreateSeuratObject(sce) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.1,0.5,0.8)) # 注释细胞类型(随便虚拟命名) Idents(sce)=\u0026#34;RNA_snn_res.0.5\u0026#34; table(sce@active.ident) sce$celltype = dplyr::case_when( sce@active.ident %in% c(0,1) ~ \u0026#34;celltypeA\u0026#34;, sce@active.ident %in% c(2) ~ \u0026#34;celltypeB\u0026#34;, sce@active.ident %in% c(3,4) ~ \u0026#34;celltypeC\u0026#34;, sce@active.ident %in% c(5,6,7) ~ \u0026#34;celltypeD\u0026#34;) table(sce$celltype) # celltypeA celltypeB celltypeC celltypeD # 1678 352 464 206 sce # An object of class Seurat # 32738 features across 2700 samples within 1 assay # Active assay: RNA (32738 features, 2000 variable features) # 2 dimensional reductions calculated: pca, umap 1、构建cds对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 library(monocle) library(Seurat) #(1) count表达矩阵 expr_matrix = GetAssayData(sce, slot = \u0026#34;counts\u0026#34;) #(2) cell meta注释信息 p_data \u0026lt;- sce@meta.data head(p_data) pd \u0026lt;- new(\u0026#39;AnnotatedDataFrame\u0026#39;, data = p_data) #(3) gene meta注释信息 f_data \u0026lt;- data.frame(gene_short_name = row.names(sce), row.names = row.names(sce)) head(f_data) fd \u0026lt;- new(\u0026#39;AnnotatedDataFrame\u0026#39;, data = f_data) #构建cds对象 cds_pre \u0026lt;- newCellDataSet(expr_matrix, phenoData = pd, featureData = fd, expressionFamily = negbinomial.size()) ##预处理 # Add Size_Factor文库因子 cds_pre \u0026lt;- estimateSizeFactors(cds_pre) cds_pre$Size_Factor %\u0026gt;% head() # [1] 1.120639 2.269514 1.457618 1.221548 0.454088 1.001678 # 计算基因表达量的离散度 cds_pre \u0026lt;- estimateDispersions(cds_pre) head(dispersionTable(cds_pre)) # gene_id mean_expression dispersion_fit dispersion_empirical # 1 AL627309.1 0.0028784954 117.03316 0 # 2 AP006222.2 0.0009931149 324.98138 0 cds_pre # CellDataSet (storageMode: environment) # assayData: 32738 features, 2700 samples # element names: exprs # protocolData: none # phenoData # sampleNames: AAACATACAACCAC-1 AAACATTGAGCTAC-1 ... TTTGCATGCCTCAC-1 # (2700 total) # varLabels: orig.ident nCount_RNA ... Size_Factor (9 total) # varMetadata: labelDescription # featureData # featureNames: MIR1302-10 FAM138A ... AC002321.1 (32738 total) # fvarLabels: gene_short_name # fvarMetadata: labelDescription # experimentData: use \u0026#39;experimentData(object)\u0026#39; # Annotation: 2、选取marker基因 有如下三种选取的方法，可以多试试不同的结果，从而得到满意的结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ### 策略1：marker gene by Seurat Idents(sce) = \u0026#34;celltype\u0026#34; gene_FAM = FindAllMarkers(sce) gene_sle = gene_FAM %\u0026gt;% dplyr::filter(p_val\u0026lt;0.01) %\u0026gt;% pull(gene) %\u0026gt;% unique() ### 策略2：high dispersion gene by monocle gene_Disp = dispersionTable(cds_pre) gene_sle = gene_Disp %\u0026gt;% dplyr::filter(mean_expression \u0026gt;= 0.1, dispersion_empirical \u0026gt;= dispersion_fit) %\u0026gt;% pull(gene_id) %\u0026gt;% unique() ### 策略3：variable(high dispersion) gene by Seurat gene_sle \u0026lt;- VariableFeatures(sce) ###也可以自定义一些基因集 gene_sle = c(..........) ####标记所选择的基因 cds \u0026lt;- setOrderingFilter(cds_pre, gene_sle) 3、降维排序与可视化 3.1 降维排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #降维(关键步骤) cds \u0026lt;- reduceDimension(cds, method = \u0026#39;DDRTree\u0026#39;) #排序,得到轨迹分化相关的若干State cds \u0026lt;- orderCells(cds) #查看发育阶段State与细胞类型的关系 table(cds$State, cds$celltype) # celltypeA celltypeB celltypeC celltypeD # 1 852 3 6 0 # 2 7 334 0 0 # 3 84 4 0 0 # 4 492 10 2 206 # 5 243 1 456 0 查看发育阶段State与拟时间的大致趋势 1 plot(cds$State, cds$Pseudotime) 可以根据上述的探索，自定义认为最适合作为根节点的State 1 2 # cds \u0026lt;- orderCells(cds, root_state = 3) # plot(cds$State, cds$Pseudotime) 3.2 可视化 （1）细胞群 1 2 3 4 5 6 pData(cds) %\u0026gt;% colnames() # [1] \u0026#34;orig.ident\u0026#34; \u0026#34;nCount_RNA\u0026#34; \u0026#34;nFeature_RNA\u0026#34; \u0026#34;RNA_snn_res.0.1\u0026#34; # [5] \u0026#34;RNA_snn_res.0.5\u0026#34; \u0026#34;RNA_snn_res.0.8\u0026#34; \u0026#34;seurat_clusters\u0026#34; \u0026#34;celltype\u0026#34; # [9] \u0026#34;Size_Factor\u0026#34; \u0026#34;Pseudotime\u0026#34; \u0026#34;State\u0026#34; plot_cell_trajectory(cds, color_by = \u0026#34;State\u0026#34;) 1 plot_complex_cell_trajectory(cds, color_by = \u0026#34;State\u0026#34;) 1 2 plot_cell_trajectory(cds, color_by = \u0026#34;celltype\u0026#34;) + facet_wrap(\u0026#34;~celltype\u0026#34;, nrow = 1) 1 plot_cell_trajectory(cds, color_by = \u0026#34;Pseudotime\u0026#34;) （2）基因变化 1 2 3 gene_key = c(\u0026#34;S100A8\u0026#34;,\u0026#34;S100A9\u0026#34;) plot_genes_jitter(cds[gene_key,], grouping = \u0026#34;State\u0026#34;, color_by = \u0026#34;State\u0026#34;) 1 2 plot_genes_violin(cds[gene_key,], grouping = \u0026#34;State\u0026#34;, color_by = \u0026#34;State\u0026#34;) 1 plot_genes_in_pseudotime(cds[gene_key,], color_by = \u0026#34;State\u0026#34;) 4、差异分析 4.1 鉴定轨迹分化相关基因 1 2 3 4 5 6 7 8 9 diff_pseudo \u0026lt;- differentialGeneTest(cds[gene_sle,], cores = 1, fullModelFormulaStr = \u0026#34;~sm.ns(Pseudotime)\u0026#34;) head(diff_pseudo) # status family pval qval gene_short_name use_for_ordering # NKG7 OK negbinomial.size 4.773294e-106 4.876296e-104 NKG7 TRUE # CD79B OK negbinomial.size 1.740103e-20 1.431161e-19 CD79B TRUE table(diff_pseudo$qval\u0026lt;0.05) # FALSE TRUE # 568 1373 选取其中最显著的进行可视化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 diff_pseudo_gene \u0026lt;- diff_pseudo %\u0026gt;% dplyr::arrange(qval) %\u0026gt;% rownames() %\u0026gt;% head(50) p = plot_pseudotime_heatmap(cds[diff_pseudo_gene,], num_clusters = 3, # default 6 return_heatmap=T) #获得具体每个cluster的组成基因 pseudotime_clusters \u0026lt;- cutree(p$tree_row, k = 2) %\u0026gt;% data.frame(gene = names(.), cluster = . ) head(pseudotime_clusters) # gene cluster # S100A9 S100A9 1 # S100A8 S100A8 1 table(pseudotime_clusters$cluster) # 1 2 3 # 45 4 1 4.2 分支点基因变化情况 简单来说，针对某一个分支点(branch)，比较在出现分支后两类细胞的基因表达差异。这类差异包含两个方面（1）与分叉点之前细胞表达的差异；（2）分叉点后的两类细胞间的差异。\n举例来说：对于branch1，出现了State 5与4两个分支点。就来比较相对于State 1,3，这两个分支群细胞的差异性。\n1 2 3 4 5 6 7 BEAM_res \u0026lt;- BEAM(cds[gene_sle], branch_point = 1, cores = 1) BEAM_res \u0026lt;- BEAM_res[order(BEAM_res$qval),] BEAM_res \u0026lt;- BEAM_res[,c(\u0026#34;gene_short_name\u0026#34;, \u0026#34;pval\u0026#34;, \u0026#34;qval\u0026#34;)] head(BEAM_res) # gene_short_name pval qval # GZMB GZMB 1.128213e-111 2.189861e-108 # GNLY GNLY 3.421968e-102 3.321020e-99 可视化理解\n如下图列标注含义理解（1）灰色Pre-branch：分叉点之前的细胞，即State 1,3；（2）红色 Cell fate 1对应State 4（较小的数字State）；（3）蓝色 Cell fate 2对应State 5；\n1 2 3 pData(cds)$gene_sp = log2(exprs(cds)[\u0026#39;CD7\u0026#39;,]+1) plot_cell_trajectory(cds, color_by = \u0026#34;gene_sp\u0026#34;) + facet_wrap(\u0026#34;~State\u0026#34;, nrow = 1) 二、monocle3 0、Seurat前期分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## 下载示例数据 download.file(\u0026#34;https://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;, \u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) untar(\u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) library(Seurat) sce \u0026lt;- Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) sce \u0026lt;- CreateSeuratObject(sce) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.1,0.5,0.8)) # 注释细胞类型(随便虚拟命名) Idents(sce)=\u0026#34;RNA_snn_res.0.5\u0026#34; table(sce@active.ident) sce$celltype = dplyr::case_when( sce@active.ident %in% c(0,1) ~ \u0026#34;celltypeA\u0026#34;, sce@active.ident %in% c(2) ~ \u0026#34;celltypeB\u0026#34;, sce@active.ident %in% c(3,4) ~ \u0026#34;celltypeC\u0026#34;, sce@active.ident %in% c(5,6,7) ~ \u0026#34;celltypeD\u0026#34;) table(sce$celltype) # celltypeA celltypeB celltypeC celltypeD # 1678 352 464 206 sce # An object of class Seurat # 32738 features across 2700 samples within 1 assay # Active assay: RNA (32738 features, 2000 variable features) # 2 dimensional reductions calculated: pca, umap 1、构建cds对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #count表达矩阵 expr_matrix = GetAssayData(sce, slot = \u0026#34;counts\u0026#34;) #cell meta注释信息 p_data \u0026lt;- sce@meta.data head(p_data) # gene meta注释信息 f_data \u0026lt;- data.frame(gene_short_name = row.names(sce), row.names = row.names(sce)) pre_cds \u0026lt;- new_cell_data_set(expr_matrix, cell_metadata = p_data, gene_metadata = f_data) pData(pre_cds) %\u0026gt;% colnames() # [1] \u0026#34;orig.ident\u0026#34; \u0026#34;nCount_RNA\u0026#34; \u0026#34;nFeature_RNA\u0026#34; \u0026#34;RNA_snn_res.0.1\u0026#34; # [5] \u0026#34;RNA_snn_res.0.5\u0026#34; \u0026#34;RNA_snn_res.0.8\u0026#34; \u0026#34;seurat_clusters\u0026#34; \u0026#34;celltype\u0026#34; # [9] \u0026#34;Size_Factor\u0026#34; cds \u0026lt;- preprocess_cds(pre_cds) #标准化+PCA降维 2、UMAP降维 UMAP by monocle3 1 2 3 4 5 6 7 8 9 cds \u0026lt;- reduce_dimension(cds, preprocess_method = \u0026#34;PCA\u0026#34;) head(cds@int_colData$reducedDims$UMAP) # [,1] [,2] # AAACATACAACCAC-1 -3.571852 3.5445674 # AAACATTGAGCTAC-1 -3.765824 -12.2549407 plot_cells(cds, reduction_method=\u0026#34;UMAP\u0026#34;, show_trajectory_graph = FALSE, label_cell_groups = FALSE, color_cells_by=\u0026#34;celltype\u0026#34;) UMAP by Seurat 1 2 3 4 5 6 seurat_umap \u0026lt;- Embeddings(sce, reduction = \u0026#34;umap\u0026#34;)[colnames(cds),] cds@int_colData$reducedDims$UMAP \u0026lt;- seurat_umap head(cds@int_colData$reducedDims$UMAP) # UMAP_1 UMAP_2 # AAACATACAACCAC-1 -3.916352 -8.065296 # AAACATTGAGCTAC-1 -2.270202 20.887603 如果想保持跟之前Seurat的分析可视化结果一致，可以使用第二种结果。后面的分析采用第一种结果\n3、轨迹分析(核心) 1 2 3 4 5 6 7 8 9 10 11 #分群(类似monocle的State) cds \u0026lt;- cluster_cells(cds) #预测轨迹 cds \u0026lt;- learn_graph(cds) #交互式确定root节点，可以选择多个。我这里选择了一个 cds \u0026lt;- order_cells(cds) plot_cells(cds, color_cells_by = \u0026#34;pseudotime\u0026#34;, label_cell_groups = FALSE, label_leaves = FALSE, label_branch_points = FALSE) 参数设置：（1）label_branch_points=TRUE表示branch分支点，用黑色圆圈，白色边框表示；（2）label_leaves=TRUE表示fate分支终点，用灰色圆圈，黑色边框表示 4、鉴定轨迹分化相关基因 Monocle3 introduces a new approach for finding such genes that draws on a powerful technique in spatial correlation analysis, the Moran’s I test. Moran’s I is a measure of multi-directional and multi-dimensional spatial autocorrelation. The statistic tells you whether cells at nearby positions on a trajectory will have similar (or dissimilar) expression levels for the gene being tested. Although both Pearson correlation and Moran’s I ranges from -1 to 1, the interpretation of Moran’s I is slightly different: +1 means that nearby cells will have perfectly similar expression; 0 represents no correlation, and -1 means that neighboring cells will be anti-correlated.\n1 2 3 4 5 6 7 8 9 10 #相对比较耗时 Track_genes \u0026lt;- graph_test(cds, neighbor_graph=\u0026#34;principal_graph\u0026#34;) Track_genes \u0026lt;- Track_genes[,c(5,2,3,4,1,6)] %\u0026gt;% dplyr::arrange(desc(morans_I),q_value) head(Track_genes) # gene_short_name p_value morans_test_statistic morans_I status q_value # TYROBP TYROBP 0 148.7535 0.8395583 OK 0 # S100A8 S100A8 0 146.4378 0.8261901 OK 0 plot_genes_in_pseudotime(cds[Track_genes$gene_short_name[1],] , min_expr=0.5) 1 2 3 4 plot_cells(cds, genes=Track_genes$gene_short_name[1:2], show_trajectory_graph=TRUE, label_cell_groups=FALSE, label_leaves=FALSE) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/008%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--monocle%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90/","summary":"\u003ch1 id=\"一monocle\"\u003e一、monocle\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e参考教程/笔记\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（1）http://cole-trapnell-lab.github.io/monocle-release/docs/#constructing-single-cell-trajectories\u003c/p\u003e","title":"单细胞分析工具--monocle轨迹分析"},{"content":"1、打开文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## (1) r 只能读取。若文件不存在，会报错。 f = open(\u0026#34;test.txt\u0026#34;, \u0026#34;r\u0026#34;) #由于默认mode=\u0026#34;r\u0026#34;， 等价于 f = open(\u0026#34;test.txt\u0026#34;) ##文件对象f具有读取的相关方法 ## (2) w 只能写入。若文件已存在，会覆盖原有内容；若不存在会新建。 f = open(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;) ##文件对象f具有写入的相关方法 ## (3) x 只能写入。若文件已存在，会报错；若不存在会新建。 ## (4) a 只能写入。若文件已存在，会追加；若不存在会新建。 ## (5) r+ 可读可写。若文件不存在会报错；已存在会追加。 f = open(\u0026#34;test.txt\u0026#34;, \u0026#34;r+\u0026#34;) ##文件对象f具有读取和写入的相关方法 ## (6) w+ 可读可写。若文件不存在会新建；已存在会覆盖。 f = open(\u0026#34;test.txt\u0026#34;, \u0026#34;w+\u0026#34;) 在打开文件，进行读取/写入等操作后，待退出时，记得f.close()。\n2、文件读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import os os.system(\u0026#34;cat test.txt\u0026#34;) # hello # world! ##(1) read方法：逐字符读取，默认读取全部文本内容，将换行符转换为 \\n f = open(\u0026#34;test.txt\u0026#34;) f.read() # \u0026#39;hello\\nworld!\\n\u0026#39; f.close() ###read()方式只支持逐字符从头到尾的读一遍，可设置参数每次读几个字符，接续读取 f = open(\u0026#34;test.txt\u0026#34;) f.read(3) #从头到尾读接续3个字符，读完为止 f.close() ##(2) readline()方法：逐行读取，每次返回一行。可设置参数，读取每行的前几个字符 f = open(\u0026#34;test.txt\u0026#34;) f.readline() # \u0026#39;hello\\n\u0026#39; f.close() ### f.readlines()方法：逐行读取，返回一个列表，包含所有行。 3、文件写入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import os f = open(\u0026#34;newfile.txt\u0026#34;, \u0026#34;w\u0026#34;) f.write(\u0026#34;hello\\nworld\\n\u0026#34;) #等价于下面的命令 #f.writelines([\u0026#34;hello\\n\u0026#34;,\u0026#34;world\\n\u0026#34;]) f.close() os.system(\u0026#34;cat newfile.txt\u0026#34;) # hello # world f = open(\u0026#34;newfile.txt\u0026#34;, \u0026#34;a\u0026#34;) f.write(\u0026#34;I am a newer\u0026#34;) f.close() os.system(\u0026#34;cat newfile.txt\u0026#34;) # hello # world # I am a newer 4、with语句 使用with语句打开一个文件并赋予给一个变量。在语句体中执行文件读写操作。语句结束后会自动关闭文件，无需使用close()语句。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ##(1)基础用法 with open(\u0026#34;newfile.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(\u0026#34;aaaa\\nbb\\nccccc\\nd\\n\u0026#34;) os.system(\u0026#34;cat newfile.txt\u0026#34;) # aaaa # bb # ccccc # d ##(2)使用with语句迭代所有行 with open(\u0026#34;newfile.txt\u0026#34;) as f: for line in f.readlines(): print(line.strip(\u0026#34;\\n\u0026#34;)) #去除行末尾的 \\n # aaaa # bb # ccccc # d ##(3)上面的迭代适用于不那么大的文件。如果需要处理特别大的文件，可使用while with open(\u0026#34;newfile.txt\u0026#34;) as f: while True: line = f.readline() #逐行读取 if not line: break #如果空，则停止 print(line.strip(\u0026#34;\\n\u0026#34;)) 5、fileput模块迭代行 延迟行迭代\u0026ndash;因为它只读取实际需要的文本部分。适合于大文件的读取操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import fileinput for line in fileinput.input(\u0026#34;newfile.txt\u0026#34;): print(line.strip(\u0026#34;\\n\u0026#34;)) fileinput.close() # aaaa # bb # ccccc # d #fileinput.filename():返回当前文本的名称 #fileinput.lineno():返回行号 import fileinput for line in fileinput.input(\u0026#34;newfile.txt\u0026#34;): print(\u0026#34;这是第%s行：%s\u0026#34; % (fileinput.lineno(), line.strip(\u0026#34;\\n\u0026#34;))) # 这是第1行：aaaa # 这是第2行：bb # 这是第3行：ccccc # 这是第4行：d 6、pickle保存 如上默认仅支持进行文本文件的读写操作； pickle模块支持大多数python对象的储存与读取，例如字典、机器学习模型等 1 2 3 4 5 6 7 8 9 10 import pickle a = 1 # 保存 with open(\u0026#39;data.pickle\u0026#39;, \u0026#39;wb\u0026#39;) as f: pickle.dump(data, f, protocol=pickle.HIGHEST_PROTOCOL) # 读取 with open(\u0026#39;data.pickle\u0026#39;, \u0026#39;rb\u0026#39;) as f: b = pickle.load(f) ","permalink":"https://lishensuo.github.io/en/posts/program/009python%E5%9F%BA%E7%A1%80-9%E6%96%87%E6%9C%AC%E8%AF%BB%E5%86%99%E4%B8%8Epickle%E4%BF%9D%E5%AD%98/","summary":"\u003ch3 id=\"1打开文件\"\u003e1、打开文件\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) r 只能读取。若文件不存在，会报错。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ef = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test.txt\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;r\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#由于默认mode=\u0026#34;r\u0026#34;， 等价于 f = open(\u0026#34;test.txt\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##文件对象f具有读取的相关方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) w 只能写入。若文件已存在，会覆盖原有内容；若不存在会新建。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ef = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test.txt\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;w\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##文件对象f具有写入的相关方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (3) x 只能写入。若文件已存在，会报错；若不存在会新建。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (4) a 只能写入。若文件已存在，会追加；若不存在会新建。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (5) r+ 可读可写。若文件不存在会报错；已存在会追加。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ef = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test.txt\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;r+\u0026#34;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##文件对象f具有读取和写入的相关方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (6) w+ 可读可写。若文件不存在会新建；已存在会覆盖。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ef = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test.txt\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;w+\u0026#34;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e在打开文件，进行读取/写入等操作后，待退出时，记得\u003ccode\u003ef.close()\u003c/code\u003e。\u003c/p\u003e","title":"Python基础-(9)文本读写与pickle保存"},{"content":"主要参考资料：\n1、https://htmlpreview.github.io/?https://github.com/sqjin/CellChat/blob/master/tutorial/CellChat-vignette.html\n2、https://htmlpreview.github.io/?https://github.com/sqjin/CellChat/blob/master/tutorial/Comparison_analysis_of_multiple_datasets.html\n3、细胞通讯讲座cellchat 生信技能树 jimmy 哔哩哔哩直播 录屏版 https://www.youtube.com/watch?v=kc45au1RhNs\n1、细胞通讯基础知识 1.1 细胞信号传导类型 （1）旁分泌：如下图A，细胞通过释放配体与相邻细胞的受体结合进行交流。\n（2）突触信号：如下图B，神经细胞传递旁分泌信号的方式，配体为神经递质。\n（3）内分泌信号：如下图C，经循环系统（血液），将这些信号(激素)带到身体远端的目标细胞。\n（4）自分泌信号：如下图D，细胞向自身发出信号，释放与自身表面受体结合的配体。\n（5）通过细胞与细胞的接触发出信号，即细胞的膜表面配体与另一细胞的膜表面受体直接结合。\n1.2 配受体结合的影响因素 如下图所示为TGFβ信号通路的传递过程，其中涉及的配受体以及影响因素情况如下\n（1）Ligand配体：TGFβ\n（2）Receptor受体：TGFβ R1，TGFβ R2(多亚基单位subunit)\n（3）Agonist激动剂：THBS1（可能来自配体细胞或者受体细胞）\n（4）Antagonist激动剂：Decrin，FMOD（同上）\n（5）Membrane-bound inhibitory coreceptor膜表面共抑制受体：BAMB1\n（6）Membrane-bound stimulatory coreceptorr膜表面共刺激受体：\n1.3 配受体结合/通讯概率 针对上述配体结合的多种影响因素，CellChat提供了如下计算两个细胞群（i与j）的第k对配受体结合/通讯概率的方法。\n（1）L代表细胞群的配体基因的平均表达水平，如果有多亚基组成，则计算几何平均数；同理，R代表受体基因\n（2）RA表示膜表面共刺激受体表达情况；RI表示膜表面共抑制受体表达情况\n（3）AG表示激动剂的表达情况，AN表示拮抗剂的表达情况\n（4）Kh为常数0.5\n1.4 CellChat的配受体数据库 分为人和老鼠两种，收集自KEGG与文献 根据信号传递方式分为三种（1）Secreted Signaling（2）ECM-Receptor（3）Cell-Cell Contact 其中有很多配受体是复合亚基构成的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 library(CellChat) CellChatDB \u0026lt;- CellChatDB.human # use CellChatDB.mouse if running on mouse data names(CellChatDB) # [1] \u0026#34;interaction\u0026#34; \u0026#34;complex\u0026#34; \u0026#34;cofactor\u0026#34; \u0026#34;geneInfo\u0026#34; head(CellChatDB$interaction,1) %\u0026gt;% t() # TGFB1_TGFBR1_TGFBR2 # interaction_name \u0026#34;TGFB1_TGFBR1_TGFBR2\u0026#34; # pathway_name \u0026#34;TGFb\u0026#34; # ligand \u0026#34;TGFB1\u0026#34; # receptor \u0026#34;TGFbR1_R2\u0026#34; # agonist \u0026#34;TGFb agonist\u0026#34; # antagonist \u0026#34;TGFb antagonist\u0026#34; # co_A_receptor \u0026#34;\u0026#34; # co_I_receptor \u0026#34;TGFb inhibition receptor\u0026#34; # evidence \u0026#34;KEGG: hsa04350\u0026#34; # annotation \u0026#34;Secreted Signaling\u0026#34; # interaction_name_2 \u0026#34;TGFB1 - (TGFBR1+TGFBR2)\u0026#34; table(CellChatDB$interaction$annotation) # Cell-Cell Contact ECM-Receptor Secreted Signaling # 319 421 1199 2、单细胞数据集细胞通讯分析 2.1 构建CellChat对象 需要提供（1）标准化的单细胞表达矩阵[对应Seurat的data slot]（2）细胞类型注释信息 如下是官方文档给出的皮肤组织的单细胞测序数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # load(url(\u0026#34;https://ndownloader.figshare.com/files/25950872\u0026#34;)) data.input = data_humanSkin$data meta = data_humanSkin$meta cell.use = rownames(meta)[meta$condition == \u0026#34;LS\u0026#34;] data.input = data.input[, cell.use] dim(data.input) # [1] 17328 5011 meta = meta[cell.use, ] head(meta,2) # patient.id condition labels # S1_AACTCCCAGAGCTGCA Patient1 LS Inflam. FIB # S1_CAACCAATCCTCATTA Patient1 LS FBN1+ FIB library(CellChat) cellchat \u0026lt;- createCellChat(object = data.input, meta = meta, group.by = \u0026#34;labels\u0026#34;) cellchat # An object of class CellChat created from a single dataset # 17328 genes. # 5011 cells. levels(cellchat@idents) #原始表达数据在data对象里 cellchat@data[1:4,1:4] #原始注释信息在meta对象里 cellchat@meta %\u0026gt;% head() #指定的细胞群注释信息在idents里 table(cellchat@idents) 2.2 分析配受体通讯概率 （1）整合配受体数据库\n1 2 3 4 5 6 7 8 9 10 11 CellChatDB \u0026lt;- CellChatDB.human # use Secreted Signaling CellChatDB.use \u0026lt;- subsetDB(CellChatDB, search = \u0026#34;Secreted Signaling\u0026#34;) cellchat@DB \u0026lt;- CellChatDB.use #提取配受体相关的基因至一个单独的矩阵 dim(cellchat@data.signaling) #[1] 0 0 cellchat \u0026lt;- subsetData(cellchat) dim(cellchat@data.signaling) #[1] 555 5011 （2）分析通讯概率\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ## (1)首先鉴别每个细胞群的高表达(logFC\u0026gt;0)的配受体对基因（差异分析） cellchat@var.features %\u0026gt;% dim() #NULL cellchat \u0026lt;- identifyOverExpressedGenes(cellchat) cellchat@var.features$features.info %\u0026gt;% head(2) # clusters features pvalues logFC pct.1 pct.2 pvalues.adj # CXCL12 APOE+ FIB CXCL12 4.948508e-271 1.6432928 0.691 0.198 2.746422e-268 # DCN APOE+ FIB DCN 7.587647e-186 0.7637475 0.899 0.392 4.211144e-183 table(cellchat@var.features$features.info$clusters) # APOE+ FIB CD40LG+ TC cDC1 cDC2 COL11A1+ FIB # 126 77 55 108 88 # FBN1+ FIB Inflam. DC Inflam. FIB Inflam. TC LC # 139 80 160 81 107 # NKT TC # 56 69 ## (2)然后将这些高表达配受体基因关联的通路整理到LR对象里 cellchat@LR #list() cellchat \u0026lt;- identifyOverExpressedInteractions(cellchat) head(cellchat@LR$LRsig, 1) %\u0026gt;% t() # TGFB1_TGFBR1_TGFBR2 # interaction_name \u0026#34;TGFB1_TGFBR1_TGFBR2\u0026#34; # pathway_name \u0026#34;TGFb\u0026#34; # ligand \u0026#34;TGFB1\u0026#34; # receptor \u0026#34;TGFbR1_R2\u0026#34; # agonist \u0026#34;TGFb agonist\u0026#34; # antagonist \u0026#34;TGFb antagonist\u0026#34; # co_A_receptor \u0026#34;\u0026#34; # co_I_receptor \u0026#34;TGFb inhibition receptor\u0026#34; # evidence \u0026#34;KEGG: hsa04350\u0026#34; # annotation \u0026#34;Secreted Signaling\u0026#34; # interaction_name_2 \u0026#34;TGFB1 - (TGFBR1+TGFBR2)\u0026#34; ## (3) (optinal)再然后根据PPI网络对data.signaling表达矩阵进行diffusion process处理，主要是避免过度的稀疏性 ### useful when analyzing single-cell data with shallow sequencing depth ### because the projection reduces the dropout effects of signaling genes, ### in particular for possible zero expression of subunits of ligands/receptors cellchat@data.project %\u0026gt;% dim() # [1] 0 0 cellchat \u0026lt;- projectData(cellchat, PPI.human) cellchat@data.project %\u0026gt;% dim() # [1] 555 5011 ## (4)之后就可以计算配受体通讯概率 cellchat@net # list() cellchat \u0026lt;- computeCommunProb(cellchat) cellchat@net$prob %\u0026gt;% dim() # [1] 12 12 656 ##表示656个配受体对在12种细胞群之间的通讯概率，显著性 cellchat@net$prob[1:4,1:4,1] # APOE+ FIB FBN1+ FIB COL11A1+ FIB Inflam. FIB # APOE+ FIB 0 0 0 0 # FBN1+ FIB 0 0 0 0 # COL11A1+ FIB 0 0 0 0 # Inflam. FIB 0 0 0 0 cellchat@net$pval[1:4,1:4,1] # APOE+ FIB FBN1+ FIB COL11A1+ FIB Inflam. FIB # APOE+ FIB 1 1 1 1 # FBN1+ FIB 1 1 1 1 # COL11A1+ FIB 1 1 1 1 # Inflam. FIB 1 1 1 1 2.3 基于配受体通讯的衍生分析1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #(1)归纳细胞群之间的通讯 cellchat \u0026lt;- aggregateNet(cellchat) ##有如下两类结果 count,weight cellchat@net$count %\u0026gt;% dim() #[1] 12 12 cellchat@net$count[1:4,1:4] # APOE+ FIB FBN1+ FIB COL11A1+ FIB Inflam. FIB # APOE+ FIB 1 3 1 1 # FBN1+ FIB 1 3 1 1 # COL11A1+ FIB 1 2 1 1 # Inflam. FIB 0 2 0 0 ##summarizing the communication probability. cellchat@net$weight %\u0026gt;% dim() #[1] 12 12 cellchat@net$weight[1:4,1:4] # APOE+ FIB FBN1+ FIB COL11A1+ FIB Inflam. FIB # APOE+ FIB 0.006276293 0.07304813 0.007386033 0.008251458 # FBN1+ FIB 0.004854738 0.05861039 0.005714571 0.006385410 # COL11A1+ FIB 0.003575889 0.01721547 0.004210181 0.004705254 # Inflam. FIB 0.000000000 0.04183220 0.000000000 0.000000000 #(2) 将配受体水平的细胞通讯归纳为通路水平的细胞通讯 ###summarizing all related ligands/receptors cellchat@netP #list() cellchat \u0026lt;- computeCommunProbPathway(cellchat) cellchat@netP$prob %\u0026gt;% dim() # [1] 12 12 13 ##表示13条通路在12种细胞群之间的通讯概率 cellchat@netP$pathways # [1] \u0026#34;MIF\u0026#34; \u0026#34;GALECTIN\u0026#34; \u0026#34;CXCL\u0026#34; \u0026#34;COMPLEMENT\u0026#34; \u0026#34;FGF\u0026#34; # [6] \u0026#34;TNF\u0026#34; \u0026#34;CCL\u0026#34; \u0026#34;GAS\u0026#34; \u0026#34;IL4\u0026#34; \u0026#34;CD40\u0026#34; # [11] \u0026#34;LIGHT\u0026#34; \u0026#34;CSF\u0026#34; \u0026#34;VEGF\u0026#34; tmp = cellchat@netP$prob dimnames(tmp) netP_df = lapply(dimnames(tmp)[[3]], function(x){ # x=dimnames(a)[[3]][1] tmp[,,x] %\u0026gt;% as.data.frame() %\u0026gt;% tibble::rownames_to_column(\u0026#34;Source\u0026#34;) %\u0026gt;% dplyr::mutate(Pathway=x) %\u0026gt;% dplyr::select(Pathway, Source, dplyr::everything()) }) %\u0026gt;% do.call(rbind, .) #查看感兴趣的细胞类型的涉及通路 celltype=c(\u0026#34;DNT_1\u0026#34;,\u0026#34;DNT_2\u0026#34;) idx1 = netP_df$Source %in% celltype idx2 = rowSums(netP_df[,c(-1,-2)])!=0 idx3 = rowSums(netP_df[,celltype,drop=F])!=0 netP_df[idx1 \u0026amp; idx2 | idx3, ] 2.4 分析结果可视化 2.4.1 细胞群水平 1 2 3 4 5 6 7 groupSize \u0026lt;- as.numeric(table(cellchat@idents)) #如下线link的宽度与细胞群之间存在通讯配受体对数目成正比 netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = \u0026#34;Number of interactions\u0026#34;) #也可以设置为与通讯配受体对概率和成正比 #netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, # label.edge= F, title.name = \u0026#34;Interaction weights/strength\u0026#34;) 1 2 3 4 5 6 #如果只想关注某一类细胞群相关的通讯情况 mat \u0026lt;- cellchat@net$weight mat2 \u0026lt;- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat)) mat2[\u0026#34;APOE+ FIB\u0026#34;, ] \u0026lt;- mat[\u0026#34;APOE+ FIB\u0026#34;, ] netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = \u0026#34;APOE+ FIB\u0026#34;) 2.4.2 通路水平 如下示例选择CXCL通路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #(1)netVisual_aggregate()函数支持3种可视化布局，通过设置layout参数 pathways.show \u0026lt;- c(\u0026#34;CXCL\u0026#34;) vertex.receiver = seq(1,3) netVisual_aggregate(cellchat, signaling = pathways.show, vertex.receiver = vertex.receiver, layout = \u0026#34;hierarchy\u0026#34;) # netVisual_aggregate(cellchat, signaling = pathways.show, # vertex.receiver = vertex.receiver, # layout = \u0026#34;circle\u0026#34;) # netVisual_aggregate(cellchat, signaling = pathways.show, # vertex.receiver = vertex.receiver, # layout = \u0026#34;chord\u0026#34;) ##如果使用第3中和弦图的可视化方式，那么可以再进一步指定细胞高层次的分组 # group.cellType \u0026lt;- c(rep(\u0026#34;FIB\u0026#34;, 4), rep(\u0026#34;DC\u0026#34;, 4), rep(\u0026#34;TC\u0026#34;, 4)) # names(group.cellType) \u0026lt;- levels(cellchat@idents) # netVisual_chord_cell(cellchat, signaling = pathways.show, group = group.cellType, # title.name = paste0(pathways.show, \u0026#34; signaling network\u0026#34;)) 1 2 3 4 #(2) netVisual_heatmap()热图 ##列表示Source，行表示Target netVisual_heatmap(cellchat, signaling = pathways.show, color.heatmap = \u0026#34;Reds\u0026#34;) 2.4.3 配受体对水平 1 2 3 4 5 6 7 8 9 ## (1)通路与对应的配受体对 pairLR.CXCL \u0026lt;- extractEnrichedLR(cellchat, signaling = pathways.show, geneLR.return = FALSE) # interaction_name # 1 CXCL12_CXCR4 # 2 CXCL12_ACKR3 ## 可视化在通路的通讯水平中，哪些配受体的作用最大 netAnalysis_contribution(cellchat, signaling = pathways.show) 接下来选取CXCL12_CXCR4配受体对进行可视化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## (2)netVisual_individual() LR.show \u0026lt;- \u0026#39;CXCL12_CXCR4\u0026#39; vertex.receiver = seq(1,2) # a numeric vector. # netVisual_individual(cellchat, signaling = pathways.show, # pairLR.use = LR.show, # vertex.receiver = vertex.receiver, # layout = \u0026#34;hierarchy\u0026#34;) # netVisual_individual(cellchat, signaling = pathways.show, # pairLR.use = LR.show, # vertex.receiver = vertex.receiver, # layout = \u0026#34;circle\u0026#34;) netVisual_individual(cellchat, signaling = pathways.show, pairLR.use = LR.show, vertex.receiver = vertex.receiver, layout = \u0026#34;chord\u0026#34;) 1 2 3 4 5 6 7 8 ## (3)netVisual_bubble()气泡图 ##有点类似的Seurat的dotplot() netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), remove.isolate = FALSE) # #指定通路所包含的配受体 # pairLR.use \u0026lt;- extractEnrichedLR(cellchat, signaling = c(\u0026#34;CCL\u0026#34;,\u0026#34;CXCL\u0026#34;,\u0026#34;FGF\u0026#34;)) # netVisual_bubble(cellchat, sources.use = c(3,4), targets.use = c(5:8), # pairLR.use = pairLR.use, remove.isolate = TRUE) 此外 netVisual_chord_gene()函数支持通路、配受体水平的细胞群通讯和弦图可视化；plotGeneExpression()通路涉及基因在不同细胞群的表达情况可视化，就不展示了。\n2.5 基于配受体通讯的衍生分析2 2.5.1 鉴别senders, receivers等 将细胞群作为节点，细胞群的配受体/通路通讯关系作为有方向、有权重的边则构建了一个细胞通讯网络\n根据节点的出度(out-degree)和，分析细胞群是否为dominant senders 根据节点的入度(in-degree)和，分析细胞群是否为dominant receivers 根据节点的betweenness，centrality 等，计算细胞群是否为重要的dominant mediator、influencer 1 2 3 4 5 cellchat \u0026lt;- netAnalysis_computeCentrality(cellchat, slot.name = \u0026#34;netP\u0026#34;) cellchat@netP$centr %\u0026gt;% names() #(1)概括图 netAnalysis_signalingRole_network(cellchat, signaling = pathways.show, width = 8, height = 2.5, font.size = 10) 1 2 3 4 5 #(2)重点可视化senders, receivers的关系 ##all signaling pathways netAnalysis_signalingRole_scatter(cellchat) ##也可以指定通路 ## netAnalysis_signalingRole_scatter(cellchat, signaling = c(\u0026#34;CXCL\u0026#34;, \u0026#34;CCL\u0026#34;)) 1 2 3 4 5 #(3)所有通路在所有细胞群的出入度可视化 ## which signals contributing most to outgoing signaling of certain cell groups. netAnalysis_signalingRole_heatmap(cellchat, pattern = \u0026#34;outgoing\u0026#34;) # ## which signals contributing most to incoming signaling of certain cell groups. # netAnalysis_signalingRole_heatmap(cellchat, pattern = \u0026#34;incoming\u0026#34;) 2.5.2 模式识别NMF 关于NMF非负矩阵分解：将原始矩阵分解为两个非负的子矩阵，分别称之为系数矩阵与基矩阵；可以结合Bulk RNAseq表达矩阵分解出样本的细胞类型比例组成理解。 在这一步，试分析：哪些通路类似从而属于同一个模式(Pattern)，这些模式主要在哪些细胞类型中高表达。 1 2 3 4 5 library(NMF) library(ggalluvial) selectK(cellchat, pattern = \u0026#34;outgoing\u0026#34;) #time consuming #根据上述结果，提示可能有3个潜在的Pattern cellchat \u0026lt;- identifyCommunicationPatterns(cellchat, pattern = \u0026#34;outgoing\u0026#34;, k = 3) 1 2 #桑基图 netAnalysis_river(cellchat, pattern = \u0026#34;outgoing\u0026#34;) (1) netAnalysis_dot() 可对每个细胞群的出度和进行dotplot可视化\n(2) 以上是对出度out-degree的分析，同理也可以对入度in-degree进行同样的分析。\n3、两个数据集的细胞通讯比较 对来自两种不同生物状态（如对照组与疾病组）的细胞通讯比较分析； 首先需要对每种数据分别跑一遍上述的单细胞数据集细胞通讯分析流程，得到相应的CellChat对象。然后整合，就可以开始比较分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 library(CellChat) library(patchwork) cellchat.NL \u0026lt;- readRDS(url(\u0026#34;https://ndownloader.figshare.com/files/25954199\u0026#34;)) cellchat.LS \u0026lt;- readRDS(url(\u0026#34;https://ndownloader.figshare.com/files/25956518\u0026#34;)) cellchat.NL #17328 2552 cellchat.LS #17328 5011 object.list \u0026lt;- list(NL = cellchat.NL, LS = cellchat.LS) names(object.list) # [1] \u0026#34;NL\u0026#34; \u0026#34;LS\u0026#34; cellchat \u0026lt;- mergeCellChat(object.list, add.names = names(object.list)) #先大致看一下不同生物状态的细胞通讯（数量与强度）差异 #the total number of interactions gg1 \u0026lt;- compareInteractions(cellchat, show.legend = F, group = c(1,2)) #the total interaction strength gg2 \u0026lt;- compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = \u0026#34;weight\u0026#34;) gg1 + gg2 3.1 细胞群水平 计算差异可视化 1 2 3 4 5 6 #(1) netVisual_diffInteraction()弦图 ## 红色表示第二个数据与第一个数据增强，蓝色则表示降低 ## measure = \u0026#34;count\u0026#34; 数目差异 netVisual_diffInteraction(cellchat, weight.scale = T, measure = \u0026#34;count\u0026#34;) # ## measure = \u0026#34;weight\u0026#34; 强度差异 # netVisual_diffInteraction(cellchat, weight.scale = T, measure = \u0026#34;weight\u0026#34;) 1 2 3 4 5 #(2) netVisual_heatmap()热图 #列代表作为source与其它其它细胞类型的差异 #列代表作为target与其它其它细胞类型的差异 netVisual_heatmap(cellchat, measure = \u0026#34;count\u0026#34;) #netVisual_heatmap(cellchat, measure = \u0026#34;weight\u0026#34;) 绘制原图比较差异 这种可视化是控制表示大小的映射(线宽等)在两个数据集的比例尺相同\n1 2 3 4 5 6 7 8 #(1) netVisual_circle 弦图 weight.max \u0026lt;- getMaxWeight(object.list, attribute = c(\u0026#34;idents\u0026#34;,\u0026#34;count\u0026#34;)) par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_circle(object.list[[i]]@net$count, weight.scale = T, label.edge= F, edge.weight.max = weight.max[2], edge.width.max = 12, title.name = paste0(\u0026#34;Number of interactions - \u0026#34;, names(object.list)[i])) } 1 2 3 4 5 6 7 8 9 10 11 12 13 # #简化细胞类型 # weight.max \u0026lt;- getMaxWeight(object.list, slot.name = c(\u0026#34;idents\u0026#34;, \u0026#34;net\u0026#34;, \u0026#34;net\u0026#34;), # attribute = c(\u0026#34;idents\u0026#34;,\u0026#34;count\u0026#34;, \u0026#34;count.merged\u0026#34;)) # par(mfrow = c(1,2), xpd=TRUE) # for (i in 1:length(object.list)) { # netVisual_circle(object.list[[i]]@net$count.merged, weight.scale = T, label.edge= T, # edge.weight.max = weight.max[3], edge.width.max = 12, # title.name = paste0(\u0026#34;Number of interactions - \u0026#34;, names(object.list)[i])) # } # par(mfrow = c(1,2), xpd=TRUE) # netVisual_diffInteraction(cellchat, weight.scale = T, measure = \u0026#34;count.merged\u0026#34;, label.edge = T) # netVisual_diffInteraction(cellchat, weight.scale = T, measure = \u0026#34;weight.merged\u0026#34;, label.edge = T) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #(2) netAnalysis_signalingRole_scatter() ## 比较两组Incoming与Outgoing差异 num.link \u0026lt;- sapply(object.list, function(x) { #细胞群所参与的所有配受体对数目 rowSums(x@net$count) + colSums(x@net$count)-diag(x@net$count) } ) # control the dot size in the different datasets weight.MinMax \u0026lt;- c(min(num.link), max(num.link)) gg \u0026lt;- list() for (i in 1:length(object.list)) { gg[[i]] \u0026lt;- netAnalysis_signalingRole_scatter(object.list[[i]], title = names(object.list)[i], weight.MinMax = weight.MinMax) } patchwork::wrap_plots(plots = gg) 3.2 通路水平 1 2 3 #(1) 总结通路在不同生物状态总体的对比差异 rankNet(cellchat, mode = \u0026#34;comparison\u0026#34;, stacked = F, do.stat = TRUE) # rankNet(cellchat, mode = \u0026#34;comparison\u0026#34;, stacked = T, do.stat = TRUE) 1 2 3 4 5 6 7 8 9 10 #(1) 总结通路在不同生物状态的不同细胞群之间的对比差异 library(ComplexHeatmap) i = 1 #取全集通路 pathway.union \u0026lt;- union(object.list[[i]]@netP$pathways, object.list[[i+1]]@netP$pathways) ht1 = netAnalysis_signalingRole_heatmap(object.list[[i]], pattern = \u0026#34;outgoing\u0026#34;, signaling = pathway.union, title = names(object.list)[i], width = 5, height = 6) ht2 = netAnalysis_signalingRole_heatmap(object.list[[i+1]], pattern = \u0026#34;outgoing\u0026#34;, signaling = pathway.union, title = names(object.list)[i+1], width = 5, height = 6) draw(ht1 + ht2, ht_gap = unit(0.5, \u0026#34;cm\u0026#34;)) #pattern参数可以是下面三选一 #pattern = c(\u0026#34;outgoing\u0026#34;, \u0026#34;incoming\u0026#34;, \u0026#34;all\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 #(2) 基于某一特定通路的对比比较 netVisual_aggregate() pathways.show \u0026lt;- c(\u0026#34;CXCL\u0026#34;) weight.max \u0026lt;- getMaxWeight(object.list, slot.name = c(\u0026#34;netP\u0026#34;), attribute = pathways.show) par(mfrow = c(1,2), xpd=TRUE) for (i in 1:length(object.list)) { netVisual_aggregate(object.list[[i]], signaling = pathways.show, layout = \u0026#34;circle\u0026#34;, edge.weight.max = weight.max[1], edge.width.max = 10, signaling.name = paste(pathways.show, names(object.list)[i])) } #layout = c(\u0026#34;circle\u0026#34;, \u0026#34;hierarchy\u0026#34;, \u0026#34;chord\u0026#34;) 此外 netVisual_heatmap()支持热图的可视化方式\n3.3 配受体水平 1 2 3 4 #(1) netVisual_bubble() ##直接基于两个CellChat所计算的通讯差异的结果 netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), angle.x = 45) 1 2 3 4 5 6 7 8 9 10 11 # #在LS中高表达的配受体 # gg1 \u0026lt;- netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), # comparison = c(1, 2), max.dataset = 2, # title.name = \u0026#34;Increased signaling in LS\u0026#34;, # angle.x = 45, remove.isolate = T) # #在LS中低表达的配受体 # gg2\u0026lt;- netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:11), # comparison = c(1, 2), max.dataset = 1, # title.name = \u0026#34;Decreased signaling in LS\u0026#34;, # angle.x = 45, remove.isolate = T) # gg1 + gg2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #(2) 基于最底层的不同状态下差异基因的配受体差异分析 pos.dataset = \u0026#34;LS\u0026#34; features.name = pos.dataset cellchat \u0026lt;- identifyOverExpressedGenes(cellchat, group.dataset = \u0026#34;datasets\u0026#34;, pos.dataset = pos.dataset, features.name = features.name, only.pos = FALSE, thresh.pc = 0.1, thresh.fc = 0.1, thresh.p = 1) net \u0026lt;- netMappingDEG(cellchat, features.name = features.name) net.up \u0026lt;- subsetCommunication(cellchat, net = net, datasets = \u0026#34;LS\u0026#34;, ligand.logFC = 0.2, receptor.logFC = NULL) head(net.up,2) pairLR.use.up = net.up[, \u0026#34;interaction_name\u0026#34;, drop = F] netVisual_bubble(cellchat, pairLR.use = pairLR.use.up, sources.use = 4, targets.use = c(5:11), comparison = c(1, 2), angle.x = 90, remove.isolate = T, title.name = paste0(\u0026#34;Up-regulated signaling in \u0026#34;, names(object.list)[2])) #同理也是可以可视化下调的配受体对 net.down \u0026lt;- subsetCommunication(cellchat, net = net, datasets = \u0026#34;NL\u0026#34;, ligand.logFC = -0.1, receptor.logFC = -0.1) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/009%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--cellchat%E7%BB%86%E8%83%9E%E9%80%9A%E8%AE%AF%E5%88%86%E6%9E%90/","summary":"\u003cp\u003e主要参考资料：\u003c/p\u003e\n\u003cp\u003e1、https://htmlpreview.github.io/?https://github.com/sqjin/CellChat/blob/master/tutorial/CellChat-vignette.html\u003c/p\u003e","title":"单细胞分析工具--CellChat细胞通讯分析"},{"content":"特殊类变量 在定义类时，Python 提供了一些特殊方法（也称为“魔术方法”或“dunder 方法”，因为它们的名称前后都有双下划线 __, double underscore），这些方法用于为类定义特殊行为。\n1. __init__ 用于类的初始化。 1 2 3 4 class Person: def __init__(self, name, age): self.name = name self.age = age super().__init__ 用来调用父类的初始化方法、以及属性等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Parent: def __init__(self): print(\u0026#34;Parent initialized\u0026#34;) class Child(Parent): def __init__(self): super().__init__() print(\u0026#34;Child initialized\u0026#34;) ## 词汇表示例 from torchtext.vocab import Vocab #类 from torchtext.vocab import vocab #构造函数(字典) from torchtext.vocab import build_vocab_from_iterator #构造函数(可迭代对象) test_obj = build_vocab_from_iterator([[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;]]) isinstance(test_obj, Vocab) # True test_obj.vocab #词汇表内容 Vocab(test_obj.vocab) #直接基于类构建词表 class GeneVocab(Vocab): def __init__( self, custom_vocab ): if not isinstance(custom_vocab, Vocab): raise ValueError(\u0026#34;Bugs\u0026#34;) super().__init__(custom_vocab.vocab) # 本质就是Vocab(custom_vocab.vocab) 2. __str__ 定义对象的“可读”字符串表示，通常用于 print() 或 str() 函数。 1 2 3 4 5 6 7 8 9 10 class Person: def __init__(self, name): self.name = name def __str__(self): return f\u0026#34;Person named {self.name}\u0026#34; person = Person(\u0026#34;Alice\u0026#34;) print(person) # 输出：Person named Alice str(person) # 输出：Person named Alice 3. __len__ 1 2 3 4 5 6 7 8 9 class MyList: def __init__(self, items): self.items = items def __len__(self): return len(self.items) my_list = MyList([1, 2, 3]) print(len(my_list)) # 输出：3 4. __getitem__与__setitem__ __getitem__：使对象支持下标访问，适用于 obj[key] 语法。 __setitem__：设置对象某个下标位置的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MyList: def __init__(self, items): self.items = items def __getitem__(self, index): return self.items[index] def __setitem__(self, index, value): self.items[index] = value my_list = MyList([1, 2, 3]) print(my_list[0]) # 输出：1 my_list[0] = 10 # 调用 __setitem__ print(my_list[0]) # 输出：10 5. __getattr__与__setattr__ __getattr__：当访问不存在的属性时调用。 1 2 3 4 5 6 7 class MyClass: def __getattr__(self, name): return f\u0026#34;{name} attribute does not exist\u0026#34; obj = MyClass() print(obj.some_attr) #some_attr attribute does not exist __setattr__：当设置属性时调用。 1 2 3 4 5 6 7 8 9 class MyClass: def __setattr__(self, name, value): print(f\u0026#34;Setting {name} to {value}\u0026#34;) # 调用父类object的__setattr__方法 super().__setattr__(name, value) obj = MyClass() obj.some_attr = 10 # Setting some_attr to 10 6. __call__ 可以让类的实例像函数一样被调用。 1 2 3 4 5 6 7 8 9 10 11 12 class Adder: def __init__(self, increment): self.increment = increment def __call__(self, x): return x + self.increment # 创建实例 add_five = Adder(5) # 像函数一样调用 result = add_five(10) print(result) # 输出: 15 7. __iter__ 返回一个迭代器对象 1 2 3 4 5 6 7 8 9 10 class MyCollection: def __init__(self, data): self.data = data def __iter__(self): return iter(self.data) # 返回一个内置的迭代器 collection = MyCollection([1, 2, 3]) for item in collection: print(item) 如果你需要自定义迭代器行为（例如复杂的生成逻辑），则需要实现 __next__ 方法。 特殊内置变量 1. __name__ 用于判断模块是被导入还是直接执行。 直接运行py脚本时，__name__ 的值为 \u0026ldquo;__main__\u0026rdquo; 作为模块导入后，__name__ 的值为模块名 2. __doc__ 存储于模块、类或函数的文档字符串（docstring） 1 2 3 4 5 def example(): \u0026#34;\u0026#34;\u0026#34;This is a docstring.\u0026#34;\u0026#34;\u0026#34; pass print(example.__doc__) # 输出: This is a docstring. 3. __file__ 在模块定义内部，表示模块的文件路径。 4. __dict__ 存储对象的属性字典。 1 2 3 4 5 6 class MyClass: def __init__(self): self.attr = 42 obj = MyClass() print(obj.__dict__) # 输出: {\u0026#39;attr\u0026#39;: 42} ","permalink":"https://lishensuo.github.io/en/posts/program/010python-dunder%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E7%89%B9%E6%AE%8A%E6%96%B9%E6%B3%95/","summary":"\u003ch1 id=\"特殊类变量\"\u003e特殊类变量\u003c/h1\u003e\n\u003cp\u003e在定义类时，Python 提供了一些\u003cstrong\u003e特殊方法\u003c/strong\u003e（也称为“魔术方法”或“dunder 方法”，因为它们的名称前后都有双下划线 \u003ccode\u003e__\u003c/code\u003e, double underscore），这些方法用于为类定义特殊行为。\u003c/p\u003e","title":"Python-Dunder双下划线特殊方法"},{"content":" SCENIC全称Single-Cell rEgulatory Network Inference and Clustering，即转录因子分析，用于构建GRN，gene regulatory network基因调控网络。2017年于Nat Methods首次发表R包版本(https://doi:10.1038/nmeth.4463.)，后又于2020年NATURE PROTOCOLS发表python版本(https://doi.org/10.1038/s41596-020-0336-2)，分析速度得到大幅度提升，而分析方法基本相同。\n这篇笔记首先简单了解下分析步骤与原理，然后参考文章提供代码进行实操\n1、TF转录因子 转录因子(Transcription factor)是指能够识别、结合在某基因上游特异核苷酸序列上的蛋白质;\n这类蛋白通过介导RNA聚合酶与DNA模板的结合，从而调控下游靶基因的转录；也可以和其它转录因子形成转录因子复合体来影响基因的转录。\n转录因子特异识别、结合的DNA序列称为转录因子结合位点(Transcription factor binding site,TFBS)，长度在5~20bp范围。由于同一个TF可以调控多个，而其具体结合到每个靶基因的TFBS不完全相同，但具有一定的保守性。\n基于此，使用motif来概括TFBS的特征序列，具体是使用PWM(Postion Weight Matrix)表示。如下例图，即有的位点是某一种特定碱基，而有的位点是多种可能。\n同一个基因上游可能存在多种motif，受到多个TF调控；而同一个TF也可能识别多种motif，从而形成复杂的基因表达转录调控网络。 2、SCENIC分析步骤 2.1 单细胞数据预处理 输入：单细胞测序数据；输出：单细胞表达矩阵 这一步主要就是读入单细胞数据，过滤低质量的细胞、低表达的基因；然后将单细胞count表达矩阵(行名是细胞，列名是基因)存储为csv格式（或者loom）;\n文章建议使用Scanpy预处理，因为更适合大的单细胞数据集。但个人还是更习惯于Seurat的流程。\n2.2 网络推断Network inference 输入：单细胞表达矩阵，转录因子列表；输出：TF-gene.csv文件。第1列是转录因子，第2列是共表达的基因，第3列是共表达强度(weight) 针对转录因子列表里的每一个转录因子，探索在单细胞表达矩阵中哪些基因与之存在共表达关系。\n通过基于树(tree-based)的回归模型，根据转录因子的表达去预测基因的表达情况。具体算法可选择GRNBoost2或者GENIE3，前者的计算效率会更高。\n2.3 得到TF-regulon 输入：上一步得到的TF-gene.csv，motif-gene注释数据，motif-TF注释数据，单细胞表达数据 输出：motif富集结果或者regulon数据 分为如下几个子步骤\n(1) Module generation 首先根据第二步得到的TF-gene.csv文件，计算中TF -module(one Translate factor and its target genes)。scenic提供下面三种思路计算得到。\nBased on a percentile score; the default is to select sets based on the 75th or 90th percentile of a factor’s targets. Based on the top N targets for each factor, with a default of 50 targets. Based on the top N regulators for a target; the default settings select sets of 5, 10, and 50 regulators. 按照如上默认值设置的话，有 2 + 1 + 3 = 6种思路的module结果。所以在最终得到的结果里，可能同一个TF有多个module。 根据调控基因与转录因子的相关性方向可分为 activating module(ρ ≥ +0.03)与 repressing module(ρ ≤ −0.03)。由于负相关模块(TF介导对靶基因的转录抑制)的数量一般较少，默认后续分析只保留正相关的activating module进行后续分析。\n最后可限制module所包含的最少基因数，默认为20。\n(2) Motif enrichment 在提供的motif-gene注释文件中，提供了每个motif的基因排名，即哪些基因的上游区域含有最类似该motif的区域。\n基于此计算出每个module中所富集的motif有哪些。然后根据motif-TF注释数据，判断module 所富集到的motif是否为该module TF的motif。再然后，通过module的motif预测模块中真正的靶基因，去除其中的假阳性或者间接靶点。\n最后通过合并同一个TF的所有保留基因，作为一个Regulon(one TF and its target gene)\n2.4 Regulon活性评分 基于上一步得到的所有Regulon(可认为是Gene Set)，结合单细胞表达矩阵去评价每一个细胞对于每一个Regulon的表达程度评分。\n不同细胞对于同一Regulon的表达活性是可以比较的，但同一细胞的不同Regulon的表达与否是不好比较的。\n文章提供一种分析思路，将Regulon的活性得分二值化，即是否激活(On/Off)。这主要通过对那些具有 bimodal distribution双峰分布曲线的Regulon进行混合高斯分布拟合，确定合适的分割阈值，从而将细胞划分为两种状态。\n原先参考代码是pySCENIC文章里提供的示范代码；如今版本以及数据库均已更新，现主要参考官方手册：\nhttps://pyscenic.readthedocs.io/en/latest/index.html 3、pySCENIC代码实操 原文的预处理步骤是使用Scanpy进行单细胞预处理的，我还是比较熟悉Seurat流程，因此对文章给的代码有所删改。\n3.1 准备conda环境 1 2 3 4 conda create -y -n pyscenic python=3.10 conda activate pyscenic pip install pyscenic 3.2 下载参考数据 （1）motif\u0026ndash;gene注释数据(genome ranking database)\nhttps://resources.aertslab.org/cistarget/databases/ 提供了不同物种以及不同基因组版本的注释数据，可根据需要选择；\n1 2 wget https://resources.aertslab.org/cistarget/databases/homo_sapiens/hg38/refseq_r80/mc_v10_clust/gene_based/hg38_10kbp_up_10kbp_down_full_tx_v10_clust.genes_vs_motifs.rankings.feather wget https://resources.aertslab.org/cistarget/databases/homo_sapiens/hg38/refseq_r80/mc_v10_clust/gene_based/hg38_500bp_up_100bp_down_full_tx_v10_clust.genes_vs_motifs.rankings.feather （2）motif\u0026ndash;TF注释数据\nhttps://resources.aertslab.org/cistarget/motif2tf/ 提供了不同物种的注释数据，可根据需要选择；\n1 wget https://resources.aertslab.org/cistarget/motif2tf/motifs-v10nr_clust-nr.hgnc-m0.001-o0.0.tbl （3）转录因子列表\nhttps://resources.aertslab.org/cistarget/tf_lists/ 提供了不同物种的注释数据，可根据需要选择；\n1 wget https://resources.aertslab.org/cistarget/tf_lists/allTFs_hg38.txt 3.3 示例单细胞表达矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 ##下载单细胞示例数据 # wget http://cf.10xgenomics.com/samples/cell-exp/3.0.0/pbmc_10k_v3/pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz # tar xvf pbmc_10k_v3_filtered_feature_bc_matrix.tar.gz library(Seurat) sce = Read10X(data.dir = \u0026#34;filtered_feature_bc_matrix\u0026#34;) sce = CreateSeuratObject(sce) ## 省略质控相关步骤 sce_count = GetAssayData(sce[[\u0026#34;RNA\u0026#34;]], slot = \u0026#34;counts\u0026#34;) sce_count[1:4,1:4] #行名基因，列名细胞 write.csv(sce_count, file=\u0026#34;sce_count.csv\u0026#34;) Note：\n上面输出、保存的表达矩阵行名是基因，列名是细胞； 而SCENIC分析需要的表达矩阵格式为：行名是细胞，列名是基因； 因此可在之后pyscenic分析时添加参数 \u0026ndash;transpose，进行转置。 3.4 scenic分析(命令行) 分别对应上述的2.2~2.4简介\n1 2 3 4 5 6 7 ## expression matrix f_ex_matrix_csv=/path/to/sce_count.csv ## referrence databases f_db_names=$(ls /path/to/*feather | tr \u0026#34;\\n\u0026#34; \u0026#34; \u0026#34;) f_motif_path=/path/to/motifs-v10nr_clust-nr.hgnc-m0.001-o0.0.tbl f_tfs=/path/to/hs_hgnc_tfs.txt (1) pyscenic grn 1 2 3 4 5 6 7 8 9 pyscenic grn \\ --output adj.tsv \\ --method grnboost2 \\ --transpose \\ ${f_ex_matrix_csv} \\ ${f_tfs} \\ --num_workers 2 head adj.tsv (2) pyscenic ctx 1 2 3 4 5 6 7 8 9 10 11 12 13 pyscenic ctx adj.tsv \\ ${f_db_names} \\ --annotations_fname ${f_motif_path} \\ --expression_mtx_fname ${f_ex_matrix_csv} \\ --transpose \\ --output sce_regulon.gmt \\ --mask_dropouts \\ --mode \u0026#34;dask_multiprocessing\u0026#34; \\ --num_workers 20 less -SN sce_regulon.gmt #每一行是一个regulon：第一列是转录因子，第二列是说明性文字，第三列往后是target gene (3) pyscenic aucell 1 2 3 4 5 6 7 8 pyscenic aucell \\ ${f_ex_matrix_csv} \\ sce_regulon.gmt \\ --transpose \\ --output sce_regulon_AUC.csv \\ --num_workers 20 less -SN regulon_AUC.csv 将AUCell结果二值化：on/off。需要进入python环境 1 2 3 4 5 6 7 8 from pyscenic import binarization import pandas as pd auc_mtx = pd.read_csv(\u0026#34;sce_regulon_AUC.csv\u0026#34;, index_col=\u0026#34;Regulon\u0026#34;) # time consuming auc_binary = binarization.binarize(auc_mtx, num_workers=20) # 结果返回一个tuple，包含两个元素：第一个是二值化后的表达矩阵；第二个是每个转录因子二值化的阈值 auc_binary[0] auc_binary[1] Note :\n（1）输入单细胞表达矩阵也支持loom格式；输出结果中也支持不同类型的数据格式，具体可参看命令帮助文档 。\n（2）官方手册中也提供了多种不同使用方法，例如在python中的分析流程；docker环境中的使用方法。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/010%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--%E8%BD%AC%E5%BD%95%E5%9B%A0%E5%AD%90pyscenic/","summary":"\u003cblockquote\u003e\n\u003cp\u003eSCENIC全称Single-Cell rEgulatory Network Inference and Clustering，即转录因子分析，用于构建GRN，gene regulatory network基因调控网络。2017年于Nat Methods首次发表R包版本(https://doi:10.1038/nmeth.4463.)，后又于2020年NATURE PROTOCOLS发表python版本(\u003ca href=\"https://doi.org/10.1038/s41596-020-0336-2\"\u003ehttps://doi.org/10.1038/s41596-020-0336-2\u003c/a\u003e)，分析速度得到大幅度提升，而分析方法基本相同。\u003c/p\u003e","title":"单细胞分析工具--pySCENIC转录因子分析"},{"content":"在 Python 中，装饰器（decorator）是一种特殊的函数或类，用于在不修改原始代码的情况下，动态地修改或增强函数、方法或类的行为。\n函数：独立的代码块，可以在任何地方定义和调用。\n方法：类中的函数，属于类的实例或类本身。\n类：用于定义对象的蓝图，包含属性和方法。\n下面将记录学习过程中，遇到的常见装饰器用法。\n1. 函数装饰器 在定义普通函数装饰器的过程中，一个装饰器通常是一个函数，接收另一个函数作为参数，并返回一个新的函数。这个新函数包含了对原始函数的调用以及新增的功能。\n1.1 示例用法 无参数示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def my_decorator(func): def wrapper(): print(\u0026#34;Something is happening before the function is called.\u0026#34;) func() print(\u0026#34;Something is happening after the function is called.\u0026#34;) return wrapper @my_decorator def say_hello(): print(\u0026#34;Hello!\u0026#34;) say_hello() # Something is happening before the function is called. # Hello! # Something is happening after the function is called. 有参数示例 （记录日志） 1 2 3 4 5 6 7 8 9 10 11 12 13 def log_decorator(func): def wrapper(*args, **kwargs): print(f\u0026#34;Function {func.__name__} is called with {args} and {kwargs}\u0026#34;) return func(*args, **kwargs) return wrapper @log_decorator def add(a, b): return a + b add(3, 4) # Function add is called with (3, 4) and {} # 7 *args 和 **kwargs 用于处理不定数量的参数。\n前者将可变数量的非关键字参数打包成一个元组； 后者将可变数量的关键字参数打包成一个字典。 2. 方法装饰器 方法装饰器是用于装饰类方法的函数，它们可以在不修改方法代码的情况下扩展或改变方法的行为。\n2.1 @staticmethod与@classmethod @staticmethod：定义静态方法，不需要传递实例 (self) 或类 (cls) 作为参数。 1 2 3 4 5 6 7 8 class Calculator: @staticmethod def add(x, y): return x + y # 直接通过类名 Calculator 调用 add 方法 Calculator.add(5, 3) # 先创建 Calculator 类的一个实例，再通过实例调用 add 方法。 Calculator().add(5, 3) @classmethod：用于定义类方法，类方法的第一个参数是类对象 (cls)，而不是实例 (self)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Point: def __init__(self, x, y): self.x = x self.y = y @classmethod def from_tuple(cls, coords): return cls(coords[0], coords[1]) @classmethod def from_string(cls, coord_string): x, y = map(int, coord_string.split(\u0026#39;,\u0026#39;)) return cls(x, y) # 使用不同的类方法实例化对象 point1 = Point.from_tuple((3, 4)) print(point1.x, point1.y) # 输出：3 4 point2 = Point.from_string(\u0026#34;5,6\u0026#34;) print(point2.x, point2.y) # 输出：5 6 2.2 @property与@xxx.setter @property 将一个方法转换为属性调用，不需要加括号。 @xxx.setter 可以限定修改范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyClass: def __init__(self, value): self._value = value @property def value(self): print(\u0026#34;Hello\u0026#34;) return self._value @value.setter def value(self, new_value): if new_value \u0026lt; 0: #限定条件 raise ValueError(\u0026#34;Value cannot be negative\u0026#34;) self._value = new_value test = MyClass(5) test.value # Hello # 5 test.value = 100 test.value # Hello # 100 3. 类装饰器 通过类装饰器，可以在实例化类对象时，自动地修改类的行为或属性。\n3.1 示例用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def add_method(cls): cls.new_method = lambda self: print(\u0026#34;New method added!\u0026#34;) return cls @add_method class MyClass: def original_method(self): print(\u0026#34;Original method\u0026#34;) obj = MyClass() obj.original_method() # Original method obj.new_method() # New method added! ","permalink":"https://lishensuo.github.io/en/posts/program/011python-%E8%A3%85%E9%A5%B0%E5%99%A8decorator/","summary":"\u003cp\u003e在 Python 中，\u003cstrong\u003e装饰器\u003c/strong\u003e（decorator）是一种特殊的函数或类，用于在不修改原始代码的情况下，动态地修改或增强函数、方法或类的行为。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e函数\u003c/strong\u003e：独立的代码块，可以在任何地方定义和调用。\u003c/p\u003e","title":"Python-装饰器Decorator"},{"content":"Paper：https://www.nature.com/articles/s41587-019-0068-4\ngithub：https://github.com/dpeerlab/Palantir\ntutorial：https://nbviewer.org/github/dpeerlab/Palantir/blob/master/notebooks/Palantir_sample_notebook.ipynb\n简介：Palantir是一个2019年在nature biotechnology提出的用于单细胞数据轨迹推断的Python工具包。根据官方教程，简单学习用法如下。\n0、安装包与准备数据 1）安装python包 根据前期探索，不建议直接使用pip安装(存在bug)，而是下载github的最新源码后安装。 1 2 3 unzip Palantir-master cd Palantir-master pip install . 2）示例数据 需要准备**.h5ad**的单细胞数据（count表达矩阵）格式，官方提供示例数据可直接下载。 1 wget https://dp-lab-data-public.s3.amazonaws.com/palantir/marrow_sample_scseq_counts.h5ad Seurat对象转为h5ad格式，参考笔记：***\n1、加载包与环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import palantir import scanpy as sc import numpy as np import pandas as pd import os # Plotting import matplotlib import matplotlib.pyplot as plt import seaborn as sns import warnings # Inline plotting %matplotlib inline sns.set_style(\u0026#39;ticks\u0026#39;) matplotlib.rcParams[\u0026#39;figure.figsize\u0026#39;] = [4, 4] matplotlib.rcParams[\u0026#39;figure.dpi\u0026#39;] = 100 matplotlib.rcParams[\u0026#39;image.cmap\u0026#39;] = \u0026#39;Spectral_r\u0026#39; warnings.filterwarnings(action=\u0026#34;ignore\u0026#34;, module=\u0026#34;matplotlib\u0026#34;, message=\u0026#34;findfont\u0026#34;) # Reset random seed np.random.seed(5) 2、导入数据与预处理 1 2 3 4 5 6 7 8 9 10 11 12 ## (1) 导入数据 ad = sc.read(\u0026#39;marrow_sample_scseq_counts.h5ad\u0026#39;) ad # AnnData object with n_obs × n_vars = 4142 × 16106 # 4142个细胞，16106个基因 ## (2) 标准化 sc.pp.normalize_per_cell(ad) palantir.preprocess.log_transform(ad) ## (3) 高变基因 sc.pp.highly_variable_genes(ad, n_top_genes=1500, flavor=\u0026#39;cell_ranger\u0026#39;) 降维：PCA → UMAP\n可以使用scanpy包的相关函数，也可以导入Seurat的降维结果，以保证可视化的一致性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ## (1) scanpy #PCA降维 sc.pp.pca(ad) #UMAP降维 sc.pp.neighbors(ad) sc.tl.umap(ad) ## (2) Seurat seurat_pca = pd.read_csv(\u0026#34;marrow_sample_scseq_pca.csv\u0026#34;, index_col=0).values ad.obsm[\u0026#39;X_pca\u0026#39;] = seurat_pca seurat_umap = pd.read_csv(\u0026#34;marrow_sample_scseq_umap.csv\u0026#34;, index_col=0).values ad.obsm[\u0026#39;X_umap\u0026#39;] = seurat_umap ad # AnnData object with n_obs × n_vars = 4142 × 16106 # obs: \u0026#39;n_counts\u0026#39; # var: \u0026#39;highly_variable\u0026#39;, \u0026#39;means\u0026#39;, \u0026#39;dispersions\u0026#39;, \u0026#39;dispersions_norm\u0026#39; # uns: \u0026#39;hvg\u0026#39;, \u0026#39;pca\u0026#39;, \u0026#39;neighbors\u0026#39;, \u0026#39;umap\u0026#39; # obsm: \u0026#39;X_pca\u0026#39;, \u0026#39;X_umap\u0026#39; # varm: \u0026#39;PCs\u0026#39; # obsp: \u0026#39;distances\u0026#39;, \u0026#39;connectivities\u0026#39; pca_projections = pd.DataFrame(ad.obsm[\u0026#39;X_pca\u0026#39;], index=ad.obs_names) umap = pd.DataFrame(ad.obsm[\u0026#39;X_umap\u0026#39;], index=ad.obs_names) # umap可视化 sc.pl.embedding(ad, basis=\u0026#39;umap\u0026#39;) 3、轨迹推断分析 1 2 3 4 5 6 7 8 9 ## (1)Run diffusion maps dm_res = palantir.utils.run_diffusion_maps(pca_projections, n_components=5) ms_data = palantir.utils.determine_multiscale_space(dm_res) ad.layers[\u0026#39;MAGIC_imputed_data\u0026#39;] = palantir.utils.run_magic_imputation(ad, dm_res) #基因表达量可视化 sc.pl.embedding(ad, basis=\u0026#39;umap\u0026#39;, layer=\u0026#39;MAGIC_imputed_data\u0026#39;, color=[\u0026#39;CD34\u0026#39;, \u0026#39;MPO\u0026#39;, \u0026#39;GATA1\u0026#39;, \u0026#39;IRF8\u0026#39;]) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## (2)轨迹推断 # 定义发育起点(required) start_cell = \u0026#39;Run5_164698952452459\u0026#39; # 定义可能的发育终点(optional) terminal_states = pd.Series([\u0026#39;DC\u0026#39;, \u0026#39;Mono\u0026#39;, \u0026#39;Ery\u0026#39;], index=[\u0026#39;Run5_131097901611291\u0026#39;, \u0026#39;Run5_134936662236454\u0026#39;, \u0026#39;Run4_200562869397916\u0026#39;]) # 轨迹推断 pr_res = palantir.core.run_palantir(ms_data, start_cell, num_waypoints=500, terminal_states=terminal_states.index) pr_res.branch_probs.columns = terminal_states[pr_res.branch_probs.columns] # 基本可视化 palantir.plot.plot_palantir_results(pr_res, umap) 4、结果可视化 指定细胞的不同轨迹状态可能性 1 2 cells = [\u0026#39;Run5_164698952452459\u0026#39;, \u0026#39;Run5_170327461775790\u0026#39;, \u0026#39;Run4_121896095574750\u0026#39;, ] palantir.plot.plot_terminal_state_probs(pr_res, cells) 1 palantir.plot.highlight_cells_on_tsne(umap, cells) 指定基因在不同发育路线的变化趋势 1 2 3 4 5 6 7 genes = [\u0026#39;CD34\u0026#39;, \u0026#39;MPO\u0026#39;, \u0026#39;GATA1\u0026#39;, \u0026#39;IRF8\u0026#39;] imp_df = pd.DataFrame(ad[:, genes].layers[\u0026#39;MAGIC_imputed_data\u0026#39;], index=ad.obs_names, columns=genes) gene_trends = palantir.presults.compute_gene_trends( pr_res, imp_df.loc[:, genes]) ## 线图可视化 palantir.plot.plot_gene_trends(gene_trends) 1 2 ## 热图可视化 palantir.plot.plot_gene_trend_heatmaps(gene_trends) 选取特定基因，根据表达模式聚类 1 2 3 4 5 6 7 8 9 genes = ad.var_names[:1000] imp_df = pd.DataFrame(ad[:, genes].layers[\u0026#39;MAGIC_imputed_data\u0026#39;], index=ad.obs_names, columns=genes) gene_trends = palantir.presults.compute_gene_trends(pr_res, imp_df.iloc[:, 0:1000], [\u0026#39;Ery\u0026#39;]) trends = gene_trends[\u0026#39;Ery\u0026#39;][\u0026#39;trends\u0026#39;] gene_clusters = palantir.presults.cluster_gene_trends(trends) palantir.plot.plot_gene_trend_clusters(trends, gene_clusters) 最后如原文所述， 由于自身算法限制，本工具可能不太适合应用于肿瘤细胞生长、迁移等存在dedifferetiate或者trans-differentiate to earlier transcriptional state的发育轨迹推断\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/011%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--palantir%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90-/","summary":"\u003cp\u003ePaper：https://www.nature.com/articles/s41587-019-0068-4\u003c/p\u003e\n\u003cp\u003egithub：https://github.com/dpeerlab/Palantir\u003c/p\u003e","title":"单细胞分析工具--Palantir轨迹分析"},{"content":"tdigest python工具 是一种用于高效计算近似分位数的数据结构和算法。相较于传统的分位数计算方法，tdigest可以实现以较小的内存开销和较快的计算速度，提供近似但足够精确的分位数估计。\nhttps://github.com/CamDavidsonPilon/tdigest\n安装\n1 pip install tdigest 创建对象 1 2 3 from tdigest import TDigest digest = TDigest() 更新对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from numpy.random import random import numpy as np # (1) 逐一更新值 for x in range(100): digest.update(random()) digest # \u0026lt;T-Digest: n=100, centroids=100\u0026gt; digest.n # 100 # (2) 批量更新值 digest.batch_update([1, 2, 3]) # \u0026lt;T-Digest: n=103, centroids=103\u0026gt; digest.batch_update(np.random.randn(5)) # \u0026lt;T-Digest: n=108, centroids=108\u0026gt; 统计分布 1 2 3 4 5 6 7 # 中位数 digest.percentile(50) # 0.4839611675217064 # 平均数 digest.trimmed_mean(0, 100) 保存并加载tdigest对象 1 2 3 4 5 6 7 # save json.dumps(digest.to_dict()) # load digest.update_from_dict({\u0026#39;K\u0026#39;: 25, \u0026#39;delta\u0026#39;: 0.01, \u0026#39;centroids\u0026#39;: [{\u0026#39;c\u0026#39;: 1.0, \u0026#39;m\u0026#39;: 1.0}, {\u0026#39;c\u0026#39;: 1.0, \u0026#39;m\u0026#39;: 2.0}, {\u0026#39;c\u0026#39;: 1.0, \u0026#39;m\u0026#39;: 3.0}]}) ","permalink":"https://lishensuo.github.io/en/posts/program/012python-tdigest%E5%88%86%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1/","summary":"\u003cp\u003e\u003ccode\u003etdigest\u003c/code\u003e python工具  是一种用于高效计算近似分位数的数据结构和算法。相较于传统的分位数计算方法，tdigest可以实现以较小的内存开销和较快的计算速度，提供近似但足够精确的分位数估计。\u003c/p\u003e","title":"Python-tdigest分位数统计"},{"content":" 单细胞数据分析常用的Seurat包也集成了空间转录组的分析流程。\nhttps://satijalab.org/seurat/articles/spatial_vignette.html。\n空间转录组可以简单理解为在2D组织切面的多个采样spot进行测序，同时记录下每个spot在切片中的2维坐标位置。\n在Seurat流程数据分析时可以将一个spot视为一个细胞（实际上还没有达到单细胞分辨率），然后基本可按照一般单细胞数据分析流程。\n0、数据准备 来自10X官方提供的小鼠脑部空间转录组测序数据，分为anterior与posterior两个切片。\n以其中一张切片所包含的数据为例，可分为两部分数据。\n（1）每个spot的基因表达测序数据，基本类似单细胞测序结果格式可以是三元组或者h5格式等\n1 2 3 4 5 6 7 8 list.files(\u0026#34;posterior/\u0026#34;, recursive = TRUE) # [1] \u0026#34;filtered_feature_bc_matrix.h5\u0026#34; # [2] \u0026#34;filtered_feature_bc_matrix/barcodes.tsv.gz\u0026#34; # [3] \u0026#34;filtered_feature_bc_matrix/features.tsv.gz\u0026#34; # [4] \u0026#34;filtered_feature_bc_matrix/matrix.mtx.gz\u0026#34; # [5] \u0026#34;spatial/scalefactors_json.json\u0026#34; # [6] \u0026#34;spatial/tissue_lowres_image.png\u0026#34; # [7] \u0026#34;spatial/tissue_positions_list.csv\u0026#34; （2）每个spot在组织切片中的位置信息\n首先是组织切片图片(tissue_lowres_image.png)，需要查看确认一下图片的分辨率。如下示例图片为600×600 然后是每个spot在实际测序过程中的位置信息。(tissue_positions_list.csv) 第一列：spot的名字，对应于测序数据的spot ID 第二列：1/0，表示是否为组织测序区域 第三、四列：每个spot的相对位置坐标 第五、六列：每个spot在组织图片中的绝对位置（像素单位） 1 2 3 4 5 6 7 spot_meta = read.csv(\u0026#34;posterior/spatial/tissue_positions_list.csv\u0026#34;, header = FALSE) head(spot_meta) #tissue row col imagerow imagecol # V1 V2 V3 V4 V5 V6 # 1 ACGCCTGACACGCGCT-1 0 0 0 1419 1432 # 2 TACCGATCCAACACTT-1 0 1 1 1538 1501 # 3 ATTAAAGCGGACGAGC-1 0 0 2 1419 1570 最后是一个json文件(scalefactors_json.json)，用于记录tissue_positions_list.csv所记录的spot绝对坐标与tissue_lowres_image.png图片的比例关系。以及spot的直径大小。 例如 (1419, 1432)*0.0516=(73.2204, 73.8912)即为在tissue_lowres_image.png中的坐标位置。 1 2 3 4 { \u0026#34;fiducial_diameter_fullres\u0026#34;: 144.59793566029023, \u0026#34;tissue_lowres_scalef\u0026#34;: 0.051635113 } https://github.com/satijalab/seurat/issues/4993\nThere are four scaling factors that 10X provides, but we generally only use the lowres factor. If you\u0026rsquo;re using your own, non-10X data, simply create a fake scalefactors object with scalefactors, making sure that you use the correct factor for lowres. If you coordinates match 1:1 with your image, then your lowres scale factor would be 1\n1、创建Seurat对象 思路：先根据spot基因表达数据创建Seurat对象，然后加入组织图片以及spot的位置信息。\n1.1 分步创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ##(1)构建传统seurat对象 sce = Read10X(\u0026#34;posterior/filtered_feature_bc_matrix/\u0026#34;) %\u0026gt;% CreateSeuratObject(assay = \u0026#34;Spot\u0026#34;) #将assay名设置为Spatial # sce \u0026lt;- Read10X_h5(\u0026#34;posterior/filtered_feature_bc_matrix.h5\u0026#34;) %\u0026gt;% # CreateSeuratObject(assay = \u0026#34;Spatial\u0026#34;) dim(sce) # [1] 32285 3355 # 3355个spot的32285个基因的表达 sce@assays$Spot@counts[1:4,1:4] # 4 x 4 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # AAACAAGTATCTCCCA-1 AAACACCAATAACTGC-1 AAACAGAGCGACTCCT-1 AAACAGCTTTCAGAAG-1 # Xkr4 . . . . # Gm1992 . . . . # Gm19938 . 1 . . # Gm37381 . . . . head(sce@meta.data) # orig.ident nCount_Spot nFeature_Spot # AAACAAGTATCTCCCA-1 SeuratProject 9195 3089 # AAACACCAATAACTGC-1 SeuratProject 33655 6468 # AAACAGAGCGACTCCT-1 SeuratProject 19619 5245 ##(2)加入image信息 image \u0026lt;- Read10X_Image(image.dir = \u0026#34;posterior/spatial/\u0026#34;) image@image %\u0026gt;% dim() # [1] 600 600 3 #image \u0026lt;- image[Cells(x = sce)] image@coordinates %\u0026gt;% head() # tissue row col imagerow imagecol # TGGGACCATTGGGAGT-1 1 7 5 2257 1776 # CCGGTGCGAGTGATAG-1 1 7 7 2257 1914 # TAGCCAGAGGGTCCGG-1 1 7 9 2257 2052 image@scale.factors #储存json信息 DefaultAssay(image) \u0026lt;- \u0026#34;Spot\u0026#34; DefaultAssay(image) sce[[\u0026#34;posterior\u0026#34;]] \u0026lt;- image sce # An object of class Seurat # 32285 features across 3355 samples within 1 assay # Active assay: Spot (32285 features, 0 variable features) # 1 image present: posterior 1.2 一步创建 Load10X_Spatial()函数支持在准备好相应的文件基础上，一步创建出包含image信息的seurat对象\n测序表达数据的h5文件\n1 # [1] \u0026#34;filtered_feature_bc_matrix.h5\u0026#34; 图片及位置信息的spatial文件夹\n1 2 list.files(\u0026#34;posterior/spatial/\u0026#34;) # [1] \u0026#34;scalefactors_json.json\u0026#34; \u0026#34;tissue_lowres_image.png\u0026#34; \u0026#34;tissue_positions_list.csv\u0026#34; 1 2 3 4 5 sce = Load10X_Spatial(data.dir = \u0026#34;./posterior/\u0026#34;,slice = \u0026#34;posterior\u0026#34;) # An object of class Seurat # 32285 features across 3355 samples within 1 assay # Active assay: Spatial (32285 features, 0 variable features) # 1 image present: posterior 2、分析流程与可视化 之后的分析可基本参考Seurat单细胞数据分析流程，完成spot的过滤、标准化、聚类分群、差异分析等；就不过多介绍了。\n主要会在可视化方面有空间转录组自身独特的展示方式。\n2.1 常规分析流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##标准化 sce \u0026lt;- SCTransform(sce,assay = \u0026#34;Spot\u0026#34;) ##降维 sce \u0026lt;- RunPCA(sce) sce \u0026lt;- RunUMAP(sce, dims = 1:30, label = T) ##聚类分群 sce \u0026lt;- FindNeighbors(sce,dims = 1:20) sce \u0026lt;- FindClusters(sce,resolution = 0.1) table(sce$seurat_clusters) # 0 1 2 3 4 5 6 # 1161 659 483 396 235 230 191 ##差异分析 dif \u0026lt;- FindAllMarkers(sce, assay = \u0026#34;Spot\u0026#34;, only.pos = T) sig.dif \u0026lt;- dif%\u0026gt;%group_by(cluster) %\u0026gt;% top_n(n = 5,wt = avg_log2FC) genes \u0026lt;- unique(sig.dif$gene) 2.2 可视化 这里主要记录空间转录组自身独特的展示方式：以测序组织图片为背景，展示spot的聚类信息或者特定基因在每个spot的表达信息。\n1 2 3 4 5 6 7 SpatialDimPlot(sce, alpha = 0.5) SpatialDimPlot(sce, cells.highlight = CellsByIdentities(sce,idents = \u0026#34;1\u0026#34;)) SpatialDimPlot(sce,cells.highlight = CellsByIdentities(sce,idents = c(\u0026#34;0\u0026#34;,\u0026#34;2\u0026#34;)), facet.highlight = T) SpatialDimPlot(sce,cells.highlight = CellsByIdentities(sce,idents = c(\u0026#34;0\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;)), facet.highlight = T) 1 LinkedDimPlot(sce,reduction = \u0026#34;umap\u0026#34;) 1 2 SpatialFeaturePlot(sce,features = genes[1:2],interactive = F) SpatialFeaturePlot(sce,features = genes[1],pt.size=1.5,alpha=c(0.1,1),interactive = T) 1 LinkedFeaturePlot(sce, feature = \u0026#34;Stx1a\u0026#34;) 3、合并多个切片分析 类似合并多个单细胞测序样本分析，此时每个Seurat对象都要有自己的image信息。必要时也可以使用批次校正等工具。\n1 2 3 4 5 6 7 8 9 10 11 anterior1 \u0026lt;- Load10X_Spatial(data.dir = \u0026#34;./Anterior\u0026#34;,slice = \u0026#34;anterior\u0026#34;) posterior1 \u0026lt;- Load10X_Spatial(data.dir = \u0026#34;./posterior/\u0026#34;,slice = \u0026#34;posterior\u0026#34;) dim(anterior1) dim(posterior1) st \u0026lt;- merge(anterior1,posterior1,add.cell.ids = c(\u0026#34;ante\u0026#34;,\u0026#34;post\u0026#34;)) #st \u0026lt;- merge(a,y=c(b,c,d),add.cell.ids = c(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;),project = \u0026#34;four_merged\u0026#34;) SpatialDimPlot(st,label = T,label.size = 3, images = \u0026#34;anterior\u0026#34;) SpatialDimPlot(st,label = T,label.size = 3, images = \u0026#34;posterior\u0026#34;) SpatialDimPlot(st,label = T,label.size = 3, images = c(\u0026#34;anterior\u0026#34;,\u0026#34;posterior\u0026#34;)) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/015%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--seurat%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84/","summary":"\u003cblockquote\u003e\n\u003cp\u003e单细胞数据分析常用的Seurat包也集成了空间转录组的分析流程。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://satijalab.org/seurat/articles/spatial_vignette.html\"\u003ehttps://satijalab.org/seurat/articles/spatial_vignette.html\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e空间转录组可以简单理解为在2D组织切面的多个采样spot进行测序，同时记录下每个spot在切片中的2维坐标位置。\u003c/p\u003e","title":"使用Seurat包分析空间转录组数据"},{"content":" WGCNA是适用于大批量样本的array或者Bulk RNAseq数据的加权基因共表达网络分析。由于单细胞数据的稀疏性，不适用于WGCNA直接分析。hdWGCNA包基于WGCNA包提供了一种针对scRNAseq数据的加权基因共表达网络分析策略。\n官方教程：https://smorabit.github.io/hdWGCNA/articles/basic_tutorial.html\n1、加载包并准备示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 #devtools::install_github(\u0026#39;smorabit/hdWGCNA\u0026#39;, ref=\u0026#39;dev\u0026#39;) library(hdWGCNA) library(WGCNA) library(Seurat) library(clustree) library(dplyr) library(patchwork) # 示例数据 # https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz list.files(\u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) # [1] \u0026#34;barcodes.tsv\u0026#34; \u0026#34;genes.tsv\u0026#34; \u0026#34;matrix.mtx\u0026#34; 2、创建Seurat对象并预处理 执行Seurat的常规流程，包括：创建seurat对象\u0026mdash;标准化、归一化\u0026mdash;高变基因\u0026mdash;降维、聚类分群\u0026mdash;鉴定细胞类型(optional)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sce = Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) %\u0026gt;% CreateSeuratObject() # 32738 features across 2700 samples sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5,0.8,1)) clustree(sce@meta.data, prefix = \u0026#34;RNA_snn_res.\u0026#34;) #colnames(sce@meta.data) table(sce$RNA_snn_res.0.1) # 0 1 2 3 # 1195 698 448 359 Idents(sce) = \u0026#34;RNA_snn_res.0.1\u0026#34; ##如上按照分辨率为0.1的分群结果进行后续的分析 3、创建misc slot，挑选基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 seurat_obj = SetupForWGCNA( sce, gene_select = \u0026#34;fraction\u0026#34;, # the gene selection approach fraction = 0.05, # fraction of cells that a gene needs to be expressed in order to be included wgcna_name = \u0026#34;PBMC\u0026#34; # the name of the hdWGCNA experiment ) # gene_select参数设置过滤基因的方法，还有是 ## (1) \u0026#34;variable\u0026#34; : use the genes stored in the Seurat object’s VariableFeatures. ## (2) \u0026#34;custom\u0026#34; : use genes that are specified in a custom list. str(seurat_obj@misc) # List of 2 # $ active_wgcna: chr \u0026#34;PBMC\u0026#34; # $ PBMC :List of 2 # ..$ wgcna_group: chr \u0026#34;all\u0026#34; # ..$ wgcna_genes: chr [1:3855] \u0026#34;NOC2L\u0026#34; \u0026#34;HES4\u0026#34; \u0026#34;ISG15\u0026#34; \u0026#34;TNFRSF4\u0026#34; ... 4、聚合metacell 将多个细胞表达情况(KNN)合并为一个metacell，可避免单细胞数据的稀疏性。\n\u0026ldquo;多个细胞\u0026quot;需要是来自同一种细胞类型/分群，可通过group.by参数定义依据。\nk参数：in general a lower number for k can be used for small datasets. We generally use k values between 20 and 75.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 seurat_obj \u0026lt;- MetacellsByGroups( seurat_obj = seurat_obj, group.by = c(\u0026#34;RNA_snn_res.0.1\u0026#34;), # specify the columns in seurat_obj@meta.data to group by k = 25, # nearest-neighbors parameter max_shared = 10, # maximum number of shared cells between two metacells ident.group = \u0026#39;RNA_snn_res.0.1\u0026#39; # set the Idents of the metacell seurat object ) seurat_obj \u0026lt;- NormalizeMetacells(seurat_obj) seurat_obj@misc$PBMC$wgcna_metacell_obj # 32738 features across 1524 samples within 1 assay seurat_obj@misc$PBMC$wgcna_metacell_obj@assays$RNA@counts[1:4,1:8] # 4 x 8 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # 0_1 0_2 0_3 0_4 0_5 0_6 0_7 0_8 # MIR1302-10 . . . . . . . . # FAM138A . . . . . . . . # OR4F5 . . . . . . . . # RP11-34P13.7 . . . . . . . . seurat_obj@misc$PBMC$wgcna_metacell_obj@meta.data %\u0026gt;% head # orig.ident nCount_RNA nFeature_RNA RNA_snn_res.0.1 # 0_1 0 2618.96 5880 0 # 0_2 0 2486.00 5858 0 # 0_3 0 1340.56 4306 0 # 0_4 0 2112.12 5388 0 # 0_5 0 2839.04 6073 0 # 0_6 0 2198.44 5407 0 5、共表达网络分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ##(1) 选择一种/多种细胞类型，进行WGCNA分析 seurat_obj \u0026lt;- SetDatExpr( seurat_obj, group_name = c(0,1,2,3), group.by=\u0026#39;RNA_snn_res.0.1\u0026#39; # the metadata column containing the cell type info. This same column should have also been used in MetacellsByGroups ) ##(2) 选择合适的软阈值 seurat_obj \u0026lt;- TestSoftPowers( seurat_obj, setDatExpr = FALSE, # set this to FALSE since we did this above ) plot_list \u0026lt;- PlotSoftPowers(seurat_obj) wrap_plots(plot_list, ncol=2) # power_table \u0026lt;- GetPowerTable(seurat_obj) # head(power_table) 1 2 3 4 5 6 ##(3) 根据上图选择合适的软阈值构建网络 seurat_obj \u0026lt;- ConstructNetwork( seurat_obj, soft_power=8, setDatExpr=FALSE ) PlotDendrogram(seurat_obj, main=\u0026#39;INH hdWGCNA Dendrogram\u0026#39;) 6、模块特征值与hub基因分析 （1）模块组成基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 seurat_obj@misc$PBMC$wgcna_modules %\u0026gt;% head # gene_name module color # NOC2L NOC2L grey grey # HES4 HES4 turquoise turquoise # ISG15 ISG15 turquoise turquoise # TNFRSF4 TNFRSF4 blue blue # SDF4 SDF4 blue blue # UBE2J2 UBE2J2 blue blue table(seurat_obj@misc$PBMC$wgcna_modules$module) # grey turquoise blue brown yellow # 588 1786 1272 133 76 # modules \u0026lt;- GetModules(seurat_obj) # head(modules) （2）每个细胞对于每个模块的特征值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 seurat_obj \u0026lt;- ModuleEigengenes( seurat_obj ) seurat_obj@misc$PBMC$MEs %\u0026gt;% head # blue grey brown turquoise yellow # AAACATACAACCAC-1 4.755930 0.2424180 2.6565029 -5.832575 -2.0906948 # AAACATTGAGCTAC-1 2.388492 1.3106515 -0.3341197 1.172415 8.8764667 # AAACATTGATCAGC-1 5.807490 2.9008702 0.8873175 -1.132285 -1.8973713 # AAACCGTGCTTCCG-1 -6.662387 -0.3072945 -1.5451723 14.692779 0.1159869 # AAACCGTGTATGCG-1 -16.098322 -1.6676024 8.7666564 -4.131657 -0.9371790 # AAACGCACTGGTAC-1 2.064300 -0.1415680 -1.2313300 -2.824847 -1.1698044 # MEs \u0026lt;- GetMEs(seurat_obj, harmonized=FALSE) # head(MEs) （3）鉴定模块内hub基因\u0026ndash; 基因表达与模块特征值的具有高相关性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 seurat_obj \u0026lt;- ModuleConnectivity( seurat_obj ) seurat_obj@misc$PBMC$wgcna_modules[,c(-1,-2,-3)] %\u0026gt;% head # kME_blue kME_grey kME_brown kME_turquoise kME_yellow # NOC2L 0.02851618 0.08360662 0.02041163 0.003048238 0.038497122 # HES4 -0.24225802 0.06869209 -0.08284058 0.117744840 0.326692215 # ISG15 -0.29705821 0.08027215 -0.07240235 0.351103776 0.314836382 # TNFRSF4 0.16100218 0.08589770 0.13010946 -0.002353201 -0.090182722 # SDF4 0.01120696 0.13914234 0.07918151 0.040070556 0.003869467 # UBE2J2 0.03178884 0.07651548 0.04663831 0.008615164 -0.006942615 # p \u0026lt;- PlotKMEs(seurat_obj, ncol=2) # p hub_df \u0026lt;- GetHubGenes(seurat_obj, n_hubs = 10) hub_df # gene_name module kME # 1 RPS27 blue 0.7207118 # 2 RPS12 blue 0.7258250 # 3 CCL5 brown 0.4934812 # 4 B2M brown 0.5294537 # 5 LGALS1 turquoise 0.6477877 # 6 TYROBP turquoise 0.6542149 # 7 HLA-DRA yellow 0.5817169 # 8 HLA-DPA1 yellow 0.5894472 ## 计算每个细胞对于每个模块hub基因的表达活性(module score),可使用seurat包或者Ucell包 seurat_obj \u0026lt;- ModuleExprScore( seurat_obj, n_genes = 25, method=\u0026#39;Seurat\u0026#39; ) seurat_obj@misc$PBMC$module_scores %\u0026gt;% head ## 计算每个细胞对于每个模块hub基因的表达活性(module score),可使用seurat包或者Ucell包 # blue brown turquoise yellow # AAACATACAACCAC-1 3.380281 0.74403040 0.3806462 -0.18699177 # AAACATTGAGCTAC-1 3.035111 0.31949694 0.4019337 1.06061130 # AAACATTGATCAGC-1 2.769994 0.28652286 0.5089602 -0.30358276 # AAACCGTGCTTCCG-1 2.080403 0.07190668 2.6016017 0.45921797 # AAACCGTGTATGCG-1 1.434566 1.07243443 0.9849420 0.14309843 # AAACGCACTGGTAC-1 2.999822 0.25594526 0.6041499 -0.02860217 # library(UCell) # seurat_obj \u0026lt;- ModuleExprScore( # seurat_obj, # n_genes = 25, # method=\u0026#39;UCell\u0026#39; # ) # seurat_obj@misc$PBMC$module_scores %\u0026gt;% head 7、结果可视化 每个细胞对于每个模块的特征值 1 2 3 4 5 6 plot_list \u0026lt;- ModuleFeaturePlot( seurat_obj, features=\u0026#39;MEs\u0026#39;, # plot the hMEs order=TRUE # order so the points with highest hMEs are on top ) wrap_plots(plot_list, ncol=2) 每个细胞对于每个模块hub基因的表达活性 1 2 3 4 5 6 7 8 seurat_obj@misc$PBMC$module_scores %\u0026gt;% head plot_list \u0026lt;- ModuleFeaturePlot( seurat_obj, features=\u0026#39;scores\u0026#39;, # plot the hub gene scores order=\u0026#39;shuffle\u0026#39;, # order so cells are shuffled ucell = TRUE # depending on Seurat vs UCell for gene scoring ) wrap_plots(plot_list, ncol=2) 将细胞对于模块的特征值，整合到seurat的meta.data中 1 2 3 4 5 6 7 8 9 10 MEs \u0026lt;- GetMEs(seurat_obj) mods \u0026lt;- colnames(MEs); mods \u0026lt;- mods[mods != \u0026#39;grey\u0026#39;] seurat_obj@meta.data \u0026lt;- cbind(seurat_obj@meta.data, MEs) p \u0026lt;- DotPlot(seurat_obj, features = mods, group.by = \u0026#39;RNA_snn_res.0.1\u0026#39;) p \u0026lt;- p + coord_flip() + RotatedAxis() + scale_color_gradient2(high=\u0026#39;red\u0026#39;, mid=\u0026#39;grey95\u0026#39;, low=\u0026#39;blue\u0026#39;) p ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/016%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--hdwgcna%E5%85%B1%E8%A1%A8%E8%BE%BE%E7%BD%91%E7%BB%9C/","summary":"\u003cblockquote\u003e\n\u003cp\u003eWGCNA是适用于大批量样本的array或者Bulk RNAseq数据的加权基因共表达网络分析。由于单细胞数据的稀疏性，不适用于WGCNA直接分析。hdWGCNA包基于WGCNA包提供了一种针对scRNAseq数据的加权基因共表达网络分析策略。\u003c/p\u003e","title":"单细胞分析工具--hdWGCNA共表达网络"},{"content":" 基于先前的hECA文献笔记，学习使用python工具ECAUGHT高效提取特定类型的人类单细胞图谱数据。值得注意的是hECA对不同来源数据集仅进行了测序文库的标准化以及log转换，用户可根据特定应用场景进行适当的批次校正处理。\n官方教程：http://eca.xglab.tech/ecaugt/index.html\n1 pip install ECAUGT 1、前期准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 加载包 import sys import pandas as pd import ECAUGT import time import multiprocessing import numpy as np ## 建立API链接 # set parameters endpoint = \u0026#34;https://HCAd-Datasets.cn-beijing.ots.aliyuncs.com\u0026#34; access_id = \u0026#34;LTAI5t7t216W9amUD1crMVos\u0026#34; #enter your id and keys access_key = \u0026#34;ZJPlUbpLCij5qUPjbsU8GnQHm97IxJ\u0026#34; instance_name = \u0026#34;HCAd-Datasets\u0026#34; table_name = \u0026#39;HCA_d\u0026#39; # setup client ECAUGT.Setup_Client(endpoint, access_id, access_key, instance_name, table_name) 2、表型筛选 hECA数据储存方式是行名是细胞id，列名包括基因名(43878) + 表型信息(18)，共43896列的巨大矩阵。\n首先可根据表型信息(meta.data)筛选目标细胞群，常用的两个条件是器官(organ)与细胞(cell_type)类型\n所支持的器官类型 http://eca.xglab.tech/#/organGallery 所支持的细胞类型 http://eca.xglab.tech/#/cellTypeList?viewType=AZ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 如下查询肺组织的T细胞 rows_to_get = ECAUGT.search_metadata(\u0026#34;organ == Lung \u0026amp;\u0026amp; cell_type == T cell\u0026#34;) # 14894 cells found rows_to_get[:5] # [[(\u0026#39;cid\u0026#39;, 2000932)], # [(\u0026#39;cid\u0026#39;, 2000962)], # [(\u0026#39;cid\u0026#39;, 2000971)], # [(\u0026#39;cid\u0026#39;, 2000978)], # [(\u0026#39;cid\u0026#39;, 2000987)]] ## cell id格式为长度为2的元组，第一个元素是\u0026#39;cid\u0026#39;,第二个元素是数字序号 ## 常用逻辑操作符 # \u0026#39;==\u0026#39; means equal # \u0026#39;\u0026lt;\u0026gt;\u0026#39; means unequal # \u0026#39;\u0026amp;\u0026amp;\u0026#39; means AND operation # \u0026#39;||\u0026#39; means OR operation # \u0026#39;!\u0026#39; means not NOT operation 3、下载数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 df_result = ECAUGT.get_columnsbycell_para( rows_to_get = rows_to_get[:20], ## 返回指定细胞id cols_to_get=None, ## 返回指定基因/表型列 col_filter=None, ## 特定基因表达模式 do_transfer = True, ## 是否返回DataFrame格式 thread_num = multiprocessing.cpu_count()-1) df_result.shape # (20, 43896) 43878个基因信息 + 18列表型信息(metadata) genes = df_result.columns[:43878] # 基因名 metaCols = df_result.columns[43878:43878+18] # 表型名 # Index([\u0026#39;cell_id\u0026#39;, \u0026#39;cell_type\u0026#39;, \u0026#39;cl_name\u0026#39;, \u0026#39;donor_age\u0026#39;, \u0026#39;donor_gender\u0026#39;, # \u0026#39;donor_id\u0026#39;, \u0026#39;hcad_name\u0026#39;, \u0026#39;marker_gene\u0026#39;, \u0026#39;organ\u0026#39;, \u0026#39;original_name\u0026#39;, # \u0026#39;region\u0026#39;, \u0026#39;sample_status\u0026#39;, \u0026#39;seq_tech\u0026#39;, \u0026#39;study_id\u0026#39;, \u0026#39;subregion\u0026#39;, # \u0026#39;tissue_type\u0026#39;, \u0026#39;uHAF_name\u0026#39;, \u0026#39;user_id\u0026#39;], # dtype=\u0026#39;object\u0026#39;) meta = df_result.loc[:,metaCols] meta.reset_index(inplace=True) expr = df_result.loc[:,genes] expr.reset_index(inplace=True) expr=expr.drop([\u0026#39;cid\u0026#39;], axis=1) 筛选特定基因表达模式，并返回指定列的细胞数据 1 2 3 4 5 6 7 8 9 10 gene_condition = ECAUGT.set_gene_condition(\u0026#34;PTPRC \u0026gt; 0.1 \u0026amp;\u0026amp; CD3D\u0026gt;=0.1\u0026#34;) df_result = ECAUGT.get_columnsbycell_para( rows_to_get = rows_to_get[:20], cols_to_get=[\u0026#39;CD3D\u0026#39;,\u0026#39;PTPRC\u0026#39;,\u0026#39;donor_id\u0026#39;,\u0026#39;hcad_name\u0026#39;], col_filter=gene_condition, do_transfer = True, thread_num = multiprocessing.cpu_count()-1) df_result.shape # (5, 4) 4、分批下载 若目标细胞群过多，可分成小批量多次下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from tqdm import tqdm import pickle for chunk in tqdm(range(int(1+len(rows_to_get)/500)),ncols=80): # split batches lb, rb = chunk*500, (chunk+1)*500 rows = rows_to_get[lb:rb] if len(rows)\u0026lt;=0:break # download rows from the unified Giant Table (uGT) result = ECAUGT.get_columnsbycell_para(rows_to_get = rows, cols_to_get = None, # download all columns col_filter = None, do_transfer = True, thread_num = 24) result.to_pickle(\u0026#34;__temp_%d_%d.pk\u0026#34;%(lb,rb)) #print(\u0026#34;downloading %d~%d\u0026#34;%(lb, rb)) #print(len(rows)) # load split batches giant_table_list = [] for chunk in tqdm(range(int(1+len(rows_to_get)/500)),ncols=80): lb, rb = chunk*500, (chunk+1)*500 fname = \u0026#34;__temp_%d_%d.pk\u0026#34; % (lb, rb) with open(fname,\u0026#39;rb\u0026#39;) as f: df=pickle.load(f) giant_table_list.append(df) giant_table= giant_table_list[0] for i in range(1, len(giant_table_list)): giant_table = pd.concat([ giant_table, giant_table_list[i] ]) # remove intermediate results del giant_table_list import gc gc.collect() #giant_table.to_pickle(\u0026#34;sorted_tcells_raw.pk\u0026#34;) df_result = giant_table df_result.shape # (14894, 43896) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/017%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--ecaugt%E6%8F%90%E5%8F%96heca%E6%95%B0%E6%8D%AE/","summary":"\u003cblockquote\u003e\n\u003cp\u003e基于先前的hECA文献笔记，学习使用python工具ECAUGHT高效提取特定类型的人类单细胞图谱数据。值得注意的是hECA对不同来源数据集仅进行了测序文库的标准化以及log转换，用户可根据特定应用场景进行适当的批次校正处理。\u003c/p\u003e","title":"单细胞分析工具--ECAUGT提取hECA数据"},{"content":" lambda表达式可用于定义简单的一行式函数，并且可搭配其它函数时有多种衍生用法。\nhttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html\nhttps://www.learncodewithmike.com/2019/12/python-lambda-functions.html\nhttps://pythonviz.com/pandas/3-ways-to-use-pandas-apply-in-python/\n1、基础用法 如下所示，lambda表达式有3个组分\n关键字 lambda 函数所需的参数，根据需要可以有多个 函数表达式，通常就是一行。 1 2 3 4 5 6 7 x = lambda a : a + 10 print(x(5)) x = lambda a, b : a * b print(x(5, 6)) (lambda a, b : a * b)(4, 3) 2、搭配用法 2.1 map()迭代 map()接受两个参数：逐元素进行某个函数的计算，返回相应的结果\n函数，可以使用简洁的lambda表达式 待迭代对象，例如列表 1 2 3 number = [1, 2, 3, 4, 5] list(map(lambda x : x + 5, number)) # [6, 7, 8, 9, 10] 2.2 filter()筛选 map()同样接受两个参数：根据函数的计算的逻辑值结果判断是否保留元素(True)\n函数，输出结果为逻辑值 待筛选对象，例如列表 1 2 3 number = [1, 2, 3, 4, 5] list(filter(lambda x : x \u0026gt; 3, number)) # [4, 5] 2.3 pandas的apply() 类似R语言中的apply(), pandas表格的apply()函数可实现逐行，或者逐列操作 常用的还是逐行操作，例如根据表格已有列的值新增或者修改列。 axis = 1 逐行操作 → 将表格的每一行作为参数传入函数 → 得到对应计算结果，变成一列值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 df = np.random.randint(0,10,(3,2)) df = pd.DataFrame(df, columns=[\u0026#34;col_1\u0026#34;,\u0026#34;col_2\u0026#34;]) # col_1 col_2 # 0 5 3 # 1 3 6 # 2 1 2 #(1)基本用法 df[\u0026#34;new_col\u0026#34;] = df.apply(lambda x: x[\u0026#34;col_1\u0026#34;] + x[\u0026#34;col_2\u0026#34;], axis=1) df.apply(lambda x: x[0] + x[1], axis=1) #与上面等价 #(2)关于result_type参数 df.apply(lambda x: [x[0]+10, x[1]-2], axis=1) # 0 [15, 1] # 1 [13, 4] # 2 [11, 0] df.apply(lambda x: [x[0]+10, x[1]-2], axis=1, result_type=\u0026#34;expand\u0026#34;) # 0 1 # 0 15 1 # 1 13 4 # 2 11 0 df.apply(lambda x: [x[0], x[1]] if x[0]\u0026gt;x[1] else [x[1], x[0]], axis=1, result_type=\u0026#39;expand\u0026#39;) #(3)关于raw参数，默认为False传入的一行式Series格式；改为True则为numpy数组格式 df.apply(lambda x: np.sort(x), axis=1, raw=True) ## axis=0 则是逐列操作，使用的不多，逻辑相同。 上述使用lambda的地方都可改为传统的自定义函数，完成更加复杂的计算需求。\n","permalink":"https://lishensuo.github.io/en/posts/program/015python-lambda%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003elambda表达式可用于定义简单的一行式函数，并且可搭配其它函数时有多种衍生用法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html\"\u003ehttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://www.learncodewithmike.com/2019/12/python-lambda-functions.html\"\u003ehttps://www.learncodewithmike.com/2019/12/python-lambda-functions.html\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://pythonviz.com/pandas/3-ways-to-use-pandas-apply-in-python/\"\u003ehttps://pythonviz.com/pandas/3-ways-to-use-pandas-apply-in-python/\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1基础用法\"\u003e1、基础用法\u003c/h2\u003e\n\u003cp\u003e如下所示，lambda表达式有3个组分\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e关键字 lambda\u003c/li\u003e\n\u003cli\u003e函数所需的参数，根据需要可以有多个\u003c/li\u003e\n\u003cli\u003e函数表达式，通常就是一行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/python-lambda-functions-new.png\" alt=\"Python Lambda Function/Anonymous Function | Hack The Developer\" style=\"zoom: 50%;\" /\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elambda\u003c/span\u003e a : a + \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elambda\u003c/span\u003e a, b : a * b\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(x(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003elambda\u003c/span\u003e a, b : a * b)(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2搭配用法\"\u003e2、搭配用法\u003c/h2\u003e\n\u003ch3 id=\"21-map迭代\"\u003e2.1 map()迭代\u003c/h3\u003e\n\u003cp\u003emap()接受两个参数：逐元素进行某个函数的计算，返回相应的结果\u003c/p\u003e","title":"Python-lambda函数表达式"},{"content":" A cell cycle is a series of events that takes place in a cell as it grows and divides.即描述细胞生长、分裂整个过程中细胞变化过程。最重要的两个特点就是DNA复制、分裂成两个一样的子细胞。对于单细胞转录组数据，可根据相关marker基因的表达水平判断每一个细胞所处的细胞周期状态。此外在分析多数据集间批次效应时，可根据每个数据集中各个细胞周期比例进行判断与校正。\n一、细胞周期阶段 细胞周期相关基础知识具体可参考如下链接：\nhttps://teachmephysiology.com/biochemistry/cell-growth-death/cell-cycle/ https://www.genome.gov/genetics-glossary/Cell-Cycle 细胞周期 _ 搜索结果_哔哩哔哩_Bilibili\n简单来说，一般可分成4个阶段\nG1(gap1)：Cell increases in size(Cellular contents duplicated) S(synthesis) ：DNA replication, each of the 46 chromosomes (23 pairs) is replicated by the cell G2(gap2)：Cell grows more，organelles and proteins develop in preparation for cell division M(mitosis)：\u0026lsquo;Old\u0026rsquo; cell partitions the two copies of the genetic material into the two daughter cells. And the cell cycle can begin again. 在处理单细胞数据时，分析细胞周期可对于生物机制探索或者潜在批次效应判断提供另一种角度的见解。由于细胞周期也是通过cell cycle related protein 调控，即每个阶段有显著的marker基因；通过分析细胞周期有关基因的表达情况，可以对细胞所处周期阶段进行注释。\nNote：在单细胞周期分析时，通常只考虑三个阶段：G1、S、G2M。(即把G2和M当做一个phase)\n如下简单学习分析单细胞细胞周期的两种方法，示例数据集来自10X的PBMC样本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library(Seurat) library(tidyverse) # download.file(\u0026#34;https://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;, # \u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) # untar(\u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) pbmc.data = Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) pbmc = CreateSeuratObject(counts = pbmc.data, project = \u0026#34;pbmc3k\u0026#34;) pbmc = NormalizeData(pbmc) %\u0026gt;% FindVariableFeatures() pbmc = ScaleData(pbmc) %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) DimPlot(pbmc, reduction = \u0026#34;pca\u0026#34;) 二、Seurat包分析 Seurat包细胞周期分析的基本原理类似模块打分。 首先该包定义了S期与G2M期的基因模块，分别对每个单细胞进行打分。 若S期基因模块分数高，则认为细胞处于S期；同理分析G2M期。若二者分数均较低，则认为是G1期。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 str(cc.genes) # List of 2 # $ s.genes : chr [1:43] \u0026#34;MCM5\u0026#34; \u0026#34;PCNA\u0026#34; \u0026#34;TYMS\u0026#34; \u0026#34;FEN1\u0026#34; ... # $ g2m.genes: chr [1:54] \u0026#34;HMGB2\u0026#34; \u0026#34;CDK1\u0026#34; \u0026#34;NUSAP1\u0026#34; \u0026#34;UBE2C\u0026#34; ... ## CellCycleScoring()函数分析细胞周期 pbmc = CellCycleScoring(pbmc, s.features = cc.genes$s.genes, g2m.features = cc.genes$g2m.genes) head(pbmc@meta.data[,c(\u0026#34;S.Score\u0026#34;, \u0026#34;G2M.Score\u0026#34;, \u0026#34;Phase\u0026#34;)]) # S.Score G2M.Score Phase # AAACATACAACCAC-1 0.07721641 -0.027546191 S # AAACATTGAGCTAC-1 -0.02723808 -0.038481308 G1 # AAACATTGATCAGC-1 -0.01832618 0.069915003 G2M # AAACCGTGCTTCCG-1 0.01548134 0.008207127 S # AAACCGTGTATGCG-1 -0.05922341 0.031726222 G2M # AAACGCACTGGTAC-1 -0.05420895 -0.063251247 G1 table(pbmc$Phase) # G1 G2M S # 1437 544 719 结果可视化 1 2 3 4 5 6 7 8 plot(pbmc$S.Score, pbmc$G2M.Score, col=factor(pbmc$Phase), main=\u0026#34;CellCycleScoring\u0026#34;) legend(\u0026#34;topleft\u0026#34;, inset=0.05, title = \u0026#34;cell cycle\u0026#34;, c(\u0026#34;G1\u0026#34;,\u0026#34;S\u0026#34;,\u0026#34;G2M\u0026#34;), pch = c(1), col=c(\u0026#34;black\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;red\u0026#34;)) 1 2 DimPlot(pbmc, reduction = \u0026#34;pca\u0026#34;, group.by = \u0026#34;Phase\u0026#34;) Seurat包提供的cc.genes为人类基因名。如果需分析小鼠数据，可将其转换为鼠源基因名。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## 人工转换（考验网络） convertHumanGeneList \u0026lt;- function(x){ require(\u0026#34;biomaRt\u0026#34;) human = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;hsapiens_gene_ensembl\u0026#34;) mouse = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;mmusculus_gene_ensembl\u0026#34;) genesV2 = getLDS(attributes = c(\u0026#34;hgnc_symbol\u0026#34;), filters = \u0026#34;hgnc_symbol\u0026#34;, values = x , mart = human, attributesL = c(\u0026#34;mgi_symbol\u0026#34;), martL = mouse, uniqueRows=T) humanx \u0026lt;- unique(genesV2[, 2]) print(head(humanx)) return(humanx) } m.s.genes \u0026lt;- convertHumanGeneList(cc.genes$s.genes) m.g2m.genes \u0026lt;- convertHumanGeneList(cc.genes$g2m.genes) ## github下载 # https://github.com/satijalab/seurat/issues/462 三、scran包分析 scran包细胞周期分析的基本原理是 gene pair表达特征比较 首先该包分别提供了三种细胞周期的gene pair表达特征，其中first列表达水平均高于second列。 然后分析每个单细胞的相应gene pair表达水平，比较最符合哪一类细胞周期的特征。 1 2 3 4 5 6 7 8 9 10 11 12 13 library(scran) hs.pairs = readRDS(system.file(\u0026#34;exdata\u0026#34;, \u0026#34;human_cycle_markers.rds\u0026#34;, package=\u0026#34;scran\u0026#34;)) # mm.pairs = readRDS(system.file(\u0026#34;exdata\u0026#34;, \u0026#34;mouse_cycle_markers.rds\u0026#34;, package=\u0026#34;scran\u0026#34;)) names(hs.pairs) # [1] \u0026#34;G1\u0026#34; \u0026#34;S\u0026#34; \u0026#34;G2M\u0026#34; head(hs.pairs$G2M) # first second # 1 ENSG00000100519 ENSG00000065135 # 2 ENSG00000100519 ENSG00000080345 # 3 ENSG00000100519 ENSG00000151914 # 4 ENSG00000100519 ENSG00000085224 # 5 ENSG00000100519 ENSG00000116133 # 6 ENSG00000100519 ENSG00000143924 如上示意，特征数据的基因名为ENSEMBL的ID格式。可根据需要对单细胞表达矩阵的行名进行转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 mt_count = pbmc@assays$RNA@counts mt_count[1:4,1:4] # 4 x 4 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # AAACATACAACCAC-1 AAACATTGAGCTAC-1 AAACATTGATCAGC-1 AAACCGTGCTTCCG-1 # MIR1302-10 . . . . # FAM138A . . . . # OR4F5 . . . . # RP11-34P13.7 . . . . str(rownames(mt_count)) # chr [1:32738] \u0026#34;MIR1302-10\u0026#34; \u0026#34;FAM138A\u0026#34; \u0026#34;OR4F5\u0026#34; \u0026#34;RP11-34P13.7\u0026#34; \u0026#34;RP11-34P13.8\u0026#34; ... ## ID转换 library(org.Hs.eg.db) gene_ids = AnnotationDbi::select(org.Hs.eg.db, keys=rownames(mt_count), columns=c(\u0026#34;ENSEMBL\u0026#34;), keytype=\u0026#34;SYMBOL\u0026#34;) gene_ids = gene_ids %\u0026gt;% na.omit() %\u0026gt;% dplyr::distinct(SYMBOL, .keep_all = T) %\u0026gt;% dplyr::distinct(ENSEMBL, .keep_all = T) mt_count = mt_count[gene_ids$SYMBOL,] rownames(mt_count) = gene_ids$ENSEMBL dim(mt_count) # [1] 18893 2700 细胞周期分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 assignments = scran::cyclone(mt_count, pairs = hs.pairs) names(assignments) # [1] \u0026#34;phases\u0026#34; \u0026#34;scores\u0026#34; \u0026#34;normalized.scores\u0026#34; dim(assignments$normalized.scores) # [1] 2700 3 assignments$normalized.scores[1:3,] # G1 S G2M # 1 0.8118324 0.1865242 0.001643385 # 2 0.4174428 0.5427604 0.039796782 # 3 0.7157215 0.2842785 0.000000000 table(assignments$phases) # G1 G2M S # 2551 60 89 结果可视化 1 2 3 4 5 6 7 scores = t(assignments$scores) colnames(scores)=1:ncol(scores) library(pheatmap) pheatmap(scores, show_colnames = F, annotation_col=data.frame(phase=assignments$phases, row.names = 1:ncol(scores))) 最后比较一下两种方法注释结果的差异\n1 2 3 4 5 6 7 8 9 res_seurat = pbmc$Phase res_scran = assignments$phases tb = table(res_seurat, res_scran) # res_scran # res_seurat G1 G2M S # G1 1350 35 52 # G2M 505 17 22 # S 696 8 15 gplots::balloonplot(tb) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/020%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--%E7%BB%86%E8%83%9E%E5%91%A8%E6%9C%9F%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eA cell cycle is a series of events that takes place in a cell as it grows and divides.即描述细胞生长、分裂整个过程中细胞变化过程。最重要的两个特点就是DNA复制、分裂成两个一样的子细胞。对于单细胞转录组数据，可根据相关marker基因的表达水平判断每一个细胞所处的细胞周期状态。此外在分析多数据集间批次效应时，可根据每个数据集中各个细胞周期比例进行判断与校正。\u003c/p\u003e","title":"单细胞分析工具--细胞周期分析"},{"content":" python内置的threading模块可以实现多任务的多线程并行处理，如下简单记录一下用法。\n参考链接\nhttps://zhuanlan.zhihu.com/p/34004179 https://www.runoob.com/python3/python3-multithreading.html 1、threading 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import threading import random import time def calculate(result): t1 = random.randint(2, 10) t2 = t1-1 print(threading.current_thread().name, \u0026#34;: waiting time is\u0026#34;, t2) #查看当前线程名 time.sleep(t2) threadLock = threading.Lock() threadLock.acquire() #上锁 result.append(t2) #保证只有一个线程对result进行操作 threadLock.release() #解锁 ths = [] #线程列表 result = [] #储存所有线程的结果 print(time.ctime(time.time())) for i in range(5): #相当于调用5个线程 th = threading.Thread(target = calculate, args=(result,), name = \u0026#39;thread {}\u0026#39;.format(i)) #args参数用于传参 th.start() ths.append(th) # 如下循环语句常用来等待所有线程结束后，再执行后面的命令； # 如果不加此语句，会直接继续后面的命令，但之后result也可以得到相同的结果 for th in ths: th.join() print(time.ctime(time.time())) print(result) # Mon Sep 19 10:28:23 2022 #开始时间 # thread 0 : waiting time is 2 # thread 1 : waiting time is 4 # thread 2 : waiting time is 7 # thread 3 : waiting time is 3 # thread 4 : waiting time is 8 # Mon Sep 19 10:28:31 2022 #结束时间，即运行时间为8s # [2, 3, 4, 7, 8] 上面的例子作用是：随机初始化一个数，等待相应的时间后，再加入到同一个列表中。\n（先完成的线程先将初始数加入到列表中）\nthreading.Thread(): 用于定义新的线程，包括线程任务，开始线程等 1 2 3 4 5 6 7 8 # 实例化一个新的线程 ## target参数定义任务函数， args参数提供函数的特定参数， name参数定义该线程的名字 th = threading.Thread(target = , args= , name=) ## start()方法用于启动线程, 之后会默默运行直至结束；可继续后面的命令(可以理解为放后台了) th.start() ## join()方法用于阻塞线程，直至对应线程任务结束后，才可以继续后面的命令 th.join() threading.current_thread(): 当前线程的信息，常放置在任务语句中 1 2 # 查看当前线程的名字 threading.current_thread().name threading.Lock() 线程锁\n当多个线程会对同一个全局变量进行修改时，为避免可能的冲突矛盾时，发挥作用；放置任务语句中需要修改全局变量的语句中。\n1 2 3 4 5 6 threadLock = threading.Lock() threadLock.acquire() #上锁 # 相关修改全局变量的语句 threadLock.release() #解锁 #在上锁与解锁之间的执行，相当于单线程运行 2、multiprocessing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from multiprocessing import Pool import pandas as pd ## 定义函数 def func(i): print(f\u0026#34;No.{i}\u0026#34;) i2 = i*i return [i, i2] ## 多线程执行 def multi_process(): pool = Pool(5) outputs = pool.map(func, range(20)) # print(f\u0026#34;outputs:{outputs}\u0026#34;) return(outputs) res = multi_process() ## 返回结果 res_df = pd.DataFrame(res, columns=[\u0026#34;v1\u0026#34;,\u0026#34;v2\u0026#34;]) res_df.head() ","permalink":"https://lishensuo.github.io/en/posts/program/016python-threading%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003epython内置的threading模块可以实现多任务的多线程并行处理，如下简单记录一下用法。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/t1_p0bram.png\" alt=\"Definitive Guide: Threading in Python Tutorial | DataCamp\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e参考链接\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/34004179\"\u003ehttps://zhuanlan.zhihu.com/p/34004179\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.runoob.com/python3/python3-multithreading.html\"\u003ehttps://www.runoob.com/python3/python3-multithreading.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1threading\"\u003e1、threading\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e threading\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e random\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e time\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e calculate(result):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    t1 = random.randint(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    t2 = t1-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(threading.current_thread().name, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;: waiting time is\u0026#34;\u003c/span\u003e, t2) \u003cspan style=\"color:#007f7f\"\u003e#查看当前线程名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    time.sleep(t2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    threadLock = threading.Lock() \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    threadLock.acquire()  \u003cspan style=\"color:#007f7f\"\u003e#上锁\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    result.append(t2)     \u003cspan style=\"color:#007f7f\"\u003e#保证只有一个线程对result进行操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    threadLock.release()  \u003cspan style=\"color:#007f7f\"\u003e#解锁\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eths = []      \u003cspan style=\"color:#007f7f\"\u003e#线程列表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresult = []   \u003cspan style=\"color:#007f7f\"\u003e#储存所有线程的结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(time.ctime(time.time()))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e i in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e):  \u003cspan style=\"color:#007f7f\"\u003e#相当于调用5个线程\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    th = threading.Thread(target = calculate, args=(result,),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \t\t\t\t\t  name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;thread \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e.format(i))   \u003cspan style=\"color:#007f7f\"\u003e#args参数用于传参\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    th.start()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ths.append(th)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 如下循环语句常用来等待所有线程结束后，再执行后面的命令；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 如果不加此语句，会直接继续后面的命令，但之后result也可以得到相同的结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e th in ths:  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    th.join()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(time.ctime(time.time()))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(result)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Mon Sep 19 10:28:23 2022         #开始时间\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# thread 0 : waiting time is 2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# thread 1 : waiting time is 4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# thread 2 : waiting time is 7\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# thread 3 : waiting time is 3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# thread 4 : waiting time is 8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Mon Sep 19 10:28:31 2022         #结束时间，即运行时间为8s\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [2, 3, 4, 7, 8]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e上面的例子作用是：随机初始化一个数，等待相应的时间后，再加入到同一个列表中。\u003c/p\u003e","title":"Python-threading多线程"},{"content":" 当分析多个样本的单细胞数据集时，其中重要的一步是判断并校正潜在的批次效应。如下简单学习两种单细胞批次效应分析方法，分别基于Seurat与harmony包。\n1、示例数据 来自Seurat提供的包含两个不同处理方式样本的单细胞表达矩阵。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 library(SeuratData) InstallData(\u0026#34;ifnb\u0026#34;) ifnb # An object of class Seurat # 14053 features across 13999 samples within 1 assay # Active assay: RNA (14053 features, 0 variable features) table(ifnb$stim) # CTRL与STIM两个样本 # CTRL STIM # 6548 7451 table(ifnb$seurat_annotations) # 已注释细胞类型 # CD14 Mono CD4 Naive T CD4 Memory T CD16 Mono B CD8 T T activated # 4362 2504 1762 1044 978 814 633 # NK DC B Activated Mk pDC Eryth # 619 472 388 236 132 ifnb = ifnb %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() %\u0026gt;% RunPCA(npcs = 30) %\u0026gt;% RunUMAP(reduction = \u0026#34;pca\u0026#34;, dims = 1:30) ## 如下降维图，两个样本间存在较为明显的批次效应 p1 = DimPlot(ifnb, reduction = \u0026#34;pca\u0026#34;, group.by = \u0026#34;stim\u0026#34;) p2 = DimPlot(ifnb, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;stim\u0026#34;) p1 + p2 2、Seurat包分析 参考教程：https://satijalab.org/seurat/articles/integration_rpca.html\n首先拆分出每个批次对象，分别进行预处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ifnb.list \u0026lt;- SplitObject(ifnb, split.by = \u0026#34;stim\u0026#34;) length(ifnb.list) # [1] 2 ##(1)标准化，鉴定高变基因 ifnb.list \u0026lt;- lapply(X = ifnb.list, FUN = function(x) { x \u0026lt;- NormalizeData(x) x \u0026lt;- FindVariableFeatures(x, selection.method = \u0026#34;vst\u0026#34;, nfeatures = 2000) }) ##(2)鉴定共同的高变基因 features \u0026lt;- SelectIntegrationFeatures(object.list = ifnb.list) str(features) # chr [1:2000] \u0026#34;HBB\u0026#34; \u0026#34;HBA2\u0026#34; \u0026#34;HBA1\u0026#34; \u0026#34;CCL4\u0026#34; \u0026#34;CCL3\u0026#34; \u0026#34;CCL7\u0026#34; \u0026#34;TXN\u0026#34; \u0026#34;GNLY\u0026#34; \u0026#34;PPBP\u0026#34; \u0026#34;APOBEC3B\u0026#34; ... ##(3)归一化，降维 ifnb.list \u0026lt;- lapply(X = ifnb.list, FUN = function(x) { x \u0026lt;- ScaleData(x, features = features) x \u0026lt;- RunPCA(x, features = features) }) 对不同批次的Seurat对象进行校正：首先需要鉴定批次间锚点(Anchor)，然后根据锚点合并样本。 其中，有若干种鉴定锚点的方法可供选择，分别是CCA与RPCA CCA方法：适合样本间细胞类型组成相同，且由于疾病状态或者其它明显影响因素造成较大的批次效应。缺点是容易过度校正，多样本分析比较慢。 RPCA方法：适合样本细胞类型组成有些许差异，且对于多样本处理较快。 1 2 3 4 5 6 7 8 ## (1) 鉴定锚点 anchors \u0026lt;- FindIntegrationAnchors(object.list = ifnb.list, anchor.features = features, reduction = \u0026#34;rpca\u0026#34;) # \u0026#34;cca\u0026#34; ## (2) 合并样本 combined \u0026lt;- IntegrateData(anchorset = anchors) Assays(combined) # [1] \u0026#34;RNA\u0026#34; \u0026#34;integrated\u0026#34; 可视化合并结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 DefaultAssay(combined) \u0026lt;- \u0026#34;integrated\u0026#34; combined \u0026lt;- combined %\u0026gt;% ScaleData(verbose = FALSE) %\u0026gt;% RunPCA(npcs = 30) %\u0026gt;% RunUMAP(reduction = \u0026#34;pca\u0026#34;, dims = 1:30) p1 \u0026lt;- DimPlot(combined, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;stim\u0026#34;) p2 \u0026lt;- DimPlot(combined, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;seurat_annotations\u0026#34;, label = TRUE, repel = TRUE) p1 + p2 如上图，两个样本间大部分细胞类型得到较好的批次校正。但仍有例如CD4 naive/memory有较明显的分离。 k.anchor是FindIntegrationAnchors()的参数之一：值越大(默认为5)，校正批次的力度越大。如下图是k.anchor设置为20的结果。 如下图是使用CCA鉴定锚点的分析结果，相比RPCA的校正结果更加显著。 在单样本数据预处理时，使用SCTransform代替。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ifnb.list \u0026lt;- SplitObject(ifnb, split.by = \u0026#34;stim\u0026#34;) ifnb.list \u0026lt;- lapply(X = ifnb.list, FUN = SCTransform, method = \u0026#34;glmGamPoi\u0026#34;) features \u0026lt;- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 3000) ifnb.list \u0026lt;- PrepSCTIntegration(object.list = ifnb.list, anchor.features = features) ifnb.list \u0026lt;- lapply(X = ifnb.list, FUN = RunPCA, features = features) anchors \u0026lt;- FindIntegrationAnchors(object.list = ifnb.list, normalization.method = \u0026#34;SCT\u0026#34;, anchor.features = features, dims = 1:30, reduction = \u0026#34;rpca\u0026#34;) combined.sct \u0026lt;- IntegrateData(anchorset = anchors, normalization.method = \u0026#34;SCT\u0026#34;, dims = 1:30) 3、harmony分析方法 参考教程：https://portals.broadinstitute.org/harmony/articles/quickstart.html\nharmony是2019年broad团队与Nature Method提出的单细胞样本间批次校正方法，其使用方法可以接入Seurat分析流程，简单方便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 如第一步，已进行标准化等预处理 ifnb = ifnb %\u0026gt;% RunHarmony(\u0026#34;stim\u0026#34;) Reductions(ifnb) # [1] \u0026#34;pca\u0026#34; \u0026#34;umap\u0026#34; \u0026#34;harmony\u0026#34; Embeddings(ifnb, reduction = \u0026#34;harmony\u0026#34;) %\u0026gt;% dim() # [1] 13999 30 Embeddings(ifnb, reduction = \u0026#34;harmony\u0026#34;)[,1:5] %\u0026gt;% head # harmony_1 harmony_2 harmony_3 harmony_4 harmony_5 # AAACATACATTTCC.1 -11.5422398 0.9451146 1.8254414 -0.05006501 0.3120439 # AAACATACCAGAAA.1 -12.0970756 2.4677964 -2.7228544 -0.41740645 -1.6086122 # AAACATACCTCGCT.1 -9.6903638 2.5644996 -0.3257312 -0.85160456 0.4860005 # AAACATACCTGGTA.1 0.8948379 -1.9789529 13.4008741 5.95973200 -1.2721535 # AAACATACGATGAA.1 7.1235140 0.1124901 -1.4078848 -2.58582259 -0.1778708 # AAACATACGGCATT.1 -9.3618540 3.1966899 -3.1654761 -0.89614903 -0.1466429 DimPlot(ifnb2, reduction = \u0026#34;harmony\u0026#34;, group.by = \u0026#34;stim\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/021%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--%E5%A4%9A%E6%A0%B7%E6%9C%AC%E6%89%B9%E6%AC%A1%E6%A0%A1%E6%AD%A3/","summary":"\u003cblockquote\u003e\n\u003cp\u003e当分析多个样本的单细胞数据集时，其中重要的一步是判断并校正潜在的批次效应。如下简单学习两种单细胞批次效应分析方法，分别基于Seurat与harmony包。\u003c/p\u003e","title":"单细胞分析工具--多样本批次校正"},{"content":" SingleCellExperiment是通过SingleCellExperiment包创建的单细胞数据分析对象，已有几十个单细胞R包支持。\n其衍生自SummarizedExperiment，之前在GEO数据挖掘学习时，了解过相关知识，主要是assay与pData两个函数的使用。\n参考文章：https://osca.bioconductor.org/data-infrastructure.html 0、创建sce 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(tidyverse) library(SingleCellExperiment) ## 表达矩阵 # https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE81861\u0026amp;format=file\u0026amp;file=GSE81861%5FCRC%5FNM%5Fepithelial%5Fcells%5FCOUNT%2Ecsv%2Egz nm_count \u0026lt;- read.csv(\u0026#34;GSE81861_CRC_NM_epithelial_cells_COUNT.csv\u0026#34;) %\u0026gt;% tibble::column_to_rownames(\u0026#34;X\u0026#34;) %\u0026gt;% as.matrix() rownames(nm_count) \u0026lt;- sapply(strsplit(rownames(nm_count),\u0026#34;_\u0026#34;),\u0026#34;[\u0026#34;,2) colnames(nm_count) \u0026lt;- sapply(strsplit(colnames(nm_count),\u0026#34;_\u0026#34;),\u0026#34;[\u0026#34;,1) dim(nm_count) # [1] 57241 160 nm_count[1:4,1:4] # RHC4104 RHC6087 RHL2880 RHC5949 # TSPAN6 0 428 66 141 # TNMD 0 0 0 0 # DPM1 0 179 0 1 # SCYL3 465 0 0 0 ## metadata group.dat \u0026lt;- data.frame(group=rep(\u0026#34;nomal\u0026#34;,ncol(nm_count))) ## 创建sce sce \u0026lt;- SingleCellExperiment(assays = list(counts = nm_count), colData = group.dat) sce 1、assay结构 assays 中最基本的是列为sample，行为feature（一般是gene）的表达矩阵。如上代码，创建了名为counts的基础表达矩阵； 后续可以根据需要，增添标准化、归一化等行列名不变的矩阵，相当于在count矩阵基础上“新盖的几层楼”。 1.1 查看矩阵 1 2 3 4 5 6 #根据矩阵名（楼层名）选择查看 assay(sce, \u0026#34;counts\u0026#34;)[1:4,1:4] #或者如下，但我觉得初学者使用第一种方法更能适应对象的结构 #counts(sce)[1:4,1:4] assays(sce) #查看所有的层楼名，目前只有一个 1.2 新添矩阵 一般创建对象时都是引入counts矩阵。根据此基础矩阵可新建相关标准化等矩阵。\n手动计算添加 1 2 3 4 5 6 7 8 counts \u0026lt;- assay(sce, \u0026#34;counts\u0026#34;) libsizes \u0026lt;- colSums(counts) size.factors \u0026lt;- libsizes/mean(libsizes) assay(sce, \u0026#34;logcounts\u0026#34;) \u0026lt;- log2(t(t(counts)/size.factors) + 1) assay(sce, \u0026#34;logcounts\u0026#34;)[1:4,1:4] assays(sce) # List of length 2 # names(2): counts logcounts 利用相关R包可自动添加 1 2 3 4 5 #注意下面自动添加的log标准化矩阵与上面的logcounts一致，可不运行 sce \u0026lt;- scater::logNormCounts(sce) sce assays(sce) #注意是assays，不是assay assay(sce, \u0026#34;logcounts\u0026#34;)[1:4,1:4] 关于assays的命名，我们可以随意命名。为了能够命名有意义并且配合R包之间的接口，官方给了如下的命名建议。 counts: Raw count data, e.g., number of reads or transcripts for a particular gene. normcounts: Normalized values on the same scale as the original counts. For example, counts divided by cell-specific size factors that are centred at unity. logcounts: Log-transformed counts or count-like values. In most cases, this will be defined as log-transformed normcounts, e.g., using log base 2 and a pseudo-count of 1. cpm: Counts-per-million. This is the read count for each gene in each cell, divided by the library size of each cell in millions. tpm: Transcripts-per-million. This is the number of transcripts for each gene in each cell, divided by the total number of transcripts in that cell (in millions).\n2、colData结构 本质上为行名为sample的data.frame，即为细胞添加注释信息 如上，创建对象时，引入了sample的group分组信息 1 2 colData(sce) %\u0026gt;% head() table(sce$group) 2.1 新增colData $符可用于查看colData，也能用于新增。（这一点等同于dataframe） 1 2 sce$anything \u0026lt;- runif(ncol(sce)) colnames(colData(sce)) scater包自动添加 1 2 sce \u0026lt;- scater::addPerCellQC(sce) colData(sce)[, 1:5] 2.2 筛选sample 1 2 sce[, sce$detected \u0026gt; 3000] sce #原来是160个sample 3、rowData结构 参考colData，本质上为行名为feature的data.frame，即为基因添加注释信息。\n可以在创建对象时添加(基因的不同ID)，或者利用scater包添加注释。 1 sce \u0026lt;- scater::addPerFeatureQC(sce) 手动添加可用cbind函数 1 2 rowData(x) \u0026lt;- cbind(rowData(x), feature) #同理colData也类似，但使用$符也很方便 筛选feature 1 2 sce[rownames(nm_count)[c(1:10)], ] sce[1:10, ] Furthermore, there is a special rowRanges slot to hold genomic coordinates in the form of a GRanges or GRangesList. This stores describes the chromosome, start, and end coordinates of the features (genes, genomic regions) in a manner that is easy to query and manipulate via the GenomicRanges framework.\n4、reducedDims 上面三点基本源于SummarizedExperiment对象，但reducedDims是sce对象独有的一点，一般储存PCA，tSNE，uMAP等细胞降维聚类信息； 本质是行名为sample的一组data.frame 1 2 3 4 5 6 7 8 9 sce \u0026lt;- scater::logNormCounts(sce) sce \u0026lt;- scater::runPCA(sce) reducedDim(sce, \u0026#34;PCA\u0026#34;) reducedDim(sce, \u0026#34;PCA\u0026#34;)[1:4,1:4] # PC1 PC2 PC3 PC4 #RHC4104 46.66 -46.44 -9.488 1.79 #RHC6087 -54.38 -6.15 -0.155 13.16 #RHL2880 -7.89 -38.89 -1.319 -2.90 #RHC5949 -53.27 -20.88 -12.089 -7.73 1 2 3 4 5 6 7 8 sce \u0026lt;- scater::runTSNE(sce, perplexity = 0.1) reducedDim(sce, \u0026#34;TSNE\u0026#34;) #可用于绘图的二维坐标信息 reducedDims(sce) #类比assays u \u0026lt;- uwot::umap(t(logcounts(sce)), n_neighbors = 2) reducedDim(sce, \u0026#34;UMAP_uwot\u0026#34;) \u0026lt;- u reducedDims(sce) # Now stored in the object. reducedDim(sce, \u0026#34;UMAP_uwot\u0026#34;) #可用于绘图的二维坐标信息 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/022%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--singlecellexperiment%E5%AF%B9%E8%B1%A1%E6%A0%BC%E5%BC%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eSingleCellExperiment\u003c/code\u003e是通过SingleCellExperiment包创建的单细胞数据分析对象，已有几十个单细胞R包支持。\u003c/p\u003e\n\u003cp\u003e其衍生自\u003ca href=\"https://bioconductor.org/packages/3.11/bioc/vignettes/SummarizedExperiment/inst/doc/SummarizedExperiment.html\"\u003eSummarizedExperiment\u003c/a\u003e，之前在GEO数据挖掘学习时，了解过相关知识，主要是\u003ccode\u003eassay\u003c/code\u003e与\u003ccode\u003epData\u003c/code\u003e两个函数的使用。\u003c/p\u003e","title":"单细胞分析工具--SingleCellExperiment对象格式"},{"content":" inferCNV包可根据肿瘤组织相关的单细胞表达数据，推测肿瘤细胞的拷贝数变异情况，从而完成恶性细胞的鉴定。\n1 2 3 BiocManager::install(\u0026#34;infercnv\u0026#34;) library(infercnv) # 暂时在window安装出现点问题，目前在linux使用conda安装、学习。 1、背景原理 拷贝数变异是指指染色体上大于1 kb的DNA片段的扩增(amplification)或者减少(deletion)，对基因的表达有很大的影响（扩增/降低）。而肿瘤恶性细胞通常伴随着拷贝数变异，通过影响相关基因的表达促进肿瘤发生。 在肿瘤单细胞数据分析过程中，肿瘤细胞类型的注释可通过tumor related marker gene的表达情况(是否高表达)做出判断。而inferCNV可以从拷贝数变异的角度进一步验证肿瘤细胞类型的注释。 inferCNV的算法是在完成肿瘤微环境的细胞类型注释的基础之上，以“Normal”细胞的基因表达情况做对照，计算“tumor”-annotated 细胞中的某些染色体区域的基因表达是否发生明显的增多或减少，从而推测出细胞的拷贝数变异图谱（并可以进一步聚类），从而验证之前的注释结果。 inferCNV从计算步骤来说分为两大步：第一步根据Normal细胞对比，计算得到tumor-like细胞的CNV图谱（preliminary infercnv object）；然后第二步是可选项，包括降噪处理和HMM预测，可分别得到两种结果。 2、输入数据 infercnv分析主要需要三类数据，以R包自带的示例文件为例：\n（1）单细胞表达矩阵\n已完成预处理步骤(过滤低质量细胞等)的单细胞raw count表达矩阵，matrix矩阵格式即可。\n1 2 3 4 5 6 7 8 9 10 11 12 mat_dir = system.file(\u0026#34;extdata\u0026#34;, \u0026#34;oligodendroglioma_expression_downsampled.counts.matrix.gz\u0026#34;, package = \u0026#34;infercnv\u0026#34;) raw_counts = data.table::fread(mat_dir, data.table = F) rownames(raw_counts) = raw_counts[,1] raw_counts = raw_counts[,-1] raw_counts[1:4,1:4] # MGH54_P16_F12 MGH54_P12_C10 MGH54_P11_C11 MGH54_P15_D06 # A2M 0 0.000 0.000 0.000 # A4GALT 0 0.000 0.000 0.000 # AAAS 0 37.008 30.935 21.011 # AACS 0 0.000 0.000 0.000 dim(raw_counts) # [1] 10338 184 （2）细胞类型注释文件 包含两列：第一列是细胞ID(对应表达矩阵的列名)，第二列是细胞类型注释结果； 至少需要包含两种细胞类型：已知正常的细胞类型（免疫细胞、内皮细胞..）、可能为肿瘤细胞的细胞类型（肿瘤细胞、上皮细胞、成纤维细胞\u0026hellip;）； 此外由于肿瘤患者的异质性，不同病人来源的肿瘤细胞的拷贝数变异情况可能差别很大，因此可以在第二列的肿瘤细胞类型进行病源的注释，例如tumor_P1，tumor_P2表示分别来自病人P1、P2的肿瘤细胞。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 anno_file_dir = system.file(\u0026#34;extdata\u0026#34;, \u0026#34;oligodendroglioma_annotations_downsampled.txt\u0026#34;, package = \u0026#34;infercnv\u0026#34;) anno_file = data.table::fread(anno_file_dir, data.table = F, header = F) head(anno_file) dim(anno_file) anno_file$V2 = stringr::str_split(anno_file$V2,\u0026#34;_\u0026#34;,simplify = T)[,1] head(anno_file) # V1 V2 # 1 MGH54_P2_C12 Microglia/Macrophage # 2 MGH36_P6_F03 Microglia/Macrophage # 3 MGH53_P4_H08 Microglia/Macrophage # 4 MGH53_P2_E09 Microglia/Macrophage # 5 MGH36_P5_E12 Microglia/Macrophage # 6 MGH54_P2_H07 Microglia/Macrophage write.table(anno_file, quote = F, row.names = F, col.names = F, sep = \u0026#34;\\t\u0026#34;, file = \u0026#34;anno_file.txt\u0026#34;) （3）基因坐标文件 包含四列，分别为：基因名(对应表达矩阵的行名)、染色体信息、起始位点、终止位点。 https://data.broadinstitute.org/Trinity/CTAT/cnv/ 提供有人类的基因坐标信息，其中genecode_19对应hg19/GRCh37，genecode_v21对应hg38/GRCh38 1 2 3 4 5 6 7 8 9 10 11 12 gene_order_file_dir = system.file(\u0026#34;extdata\u0026#34;, \u0026#34;gencode_downsampled.EXAMPLE_ONLY_DONT_REUSE.txt\u0026#34;, package = \u0026#34;infercnv\u0026#34;) gene_order_file = data.table::fread(gene_order_file_dir, data.table = F, header = F) head(gene_order_file) # V1 V2 V3 V4 # 1 WASH7P chr1 14363 29806 # 2 LINC00115 chr1 761586 762902 # 3 NOC2L chr1 879584 894689 # 4 MIR200A chr1 1103243 1103332 # 5 SDF4 chr1 1152288 1167411 # 6 UBE2J2 chr1 1189289 1209265 write.table(gene_order_file, quote = F, row.names = F, col.names = F, sep = \u0026#34;\\t\u0026#34;, file = \u0026#34;gene_order_file.txt\u0026#34;) 3、示例分析 3.1 构建对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## 模板参数 infercnv_obj = CreateInfercnvObject( #原始count矩阵 raw_counts_matrix=raw_counts_matrix, #细胞类型注释信息 annotations_file=annotations_file, #对应annotations_file里，认为是normal细胞的细胞类型 ref_group_names=c(\u0026#34;celltype1\u0026#34;,\u0026#34;celltype2\u0026#34;) #基因坐标信息 gene_order_file=gene_order_file, #指定上述两个文件的分隔符 delim=\u0026#34;\\t\u0026#34;) ## 示例分析 infercnv_obj = CreateInfercnvObject(raw_counts_matrix=raw_counts, annotations_file=\u0026#34;anno_file.txt\u0026#34;, delim=\u0026#34;\\t\u0026#34;, gene_order_file=\u0026#34;gene_order_file.txt\u0026#34;, ref_group_names=c(\u0026#34;Microglia/Macrophage\u0026#34;, \u0026#34;Oligodendrocytes (non-malignant)\u0026#34;)) 3.2 变异分析 默认计算得到preliminary infercnv object，可分别设置参数交代是否进行进一步降噪(de-noising)或者CNV的HMM预测。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## 模板参数 infercnv_obj = infercnv::run( #上一步构建的infercnv对象 infercnv_obj, #筛选基因的阈值：基因在所有细胞的平均表达量 # use 1 for smart-seq, 0.1 for 10x-genomics cutoff=1, #存储输出结果的文件夹名（每一步的中间文件都会保存） out_dir=\u0026#34;output_dir\u0026#34;, #是否将肿瘤细胞按照病源(病人之间异质性)分群计算CNV图谱 cluster_by_groups=T, #是否降噪处理 denoise=T, #是否利用HMM算法预测CNV状态 HMM=T, #使用的线程数 num_threads = 8) ## 示例分析 infercnv_obj = infercnv::run(infercnv_obj, cutoff=1, out_dir=\u0026#34;infer_out\u0026#34;, cluster_by_groups=TRUE, denoise=T, HMM=F) 3.3 结果解读 如下图为infercnv的分析结果可视化呈现，可分为3部分：上半部分热图、下半部分热图以及左上角的图例\n首先关于左上角的图例：（0，0.5，1，1.5，2）分别表示相对于Normal细胞的染色体区域基因表达量的倍数，红色表示该区域基因量相对增多，蓝色表示该区域基因量相对减少。柱子的长度表示对应区域的多少； 上半部分的热图：表示指定为Normal细胞的表达分布情况，正常情况下应该都是白色，没有明显集中的CNV区域； 下半部分的热图：相对于上半部分的Normal cell，计算的得到的每个tumor-like细胞的CNV图谱；然后根据所有细胞的相似性进行树状图聚类。 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/018%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--infercnv%E6%8B%B7%E8%B4%9D%E6%95%B0%E5%8F%98%E5%BC%82%E9%89%B4%E5%AE%9A/","summary":"\u003cblockquote\u003e\n\u003cp\u003einferCNV包可根据肿瘤组织相关的单细胞表达数据，推测肿瘤细胞的拷贝数变异情况，从而完成恶性细胞的鉴定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBiocManager::install(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;infercnv\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(infercnv)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 暂时在window安装出现点问题，目前在linux使用conda安装、学习。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/infercnv_logo.png\" alt=\"InferCNV\"  /\u003e\r\n\u003c/p\u003e","title":"单细胞分析工具--infercnv拷贝数变异鉴定"},{"content":" scanpy是单细胞数据分析的python工具包，将数据以Anndata对象的格式进行储存。如下将学习Anndata对象操作以及scanpy分析的基础用法。\n1 2 3 import numpy as np import pandas as pd import anndata as ad 1、数据导入 （1）10X的三件套数据 1 2 3 4 5 6 7 8 9 10 # !wget http://cf.10xgenomics.com/samples/cell-exp/1.1.0/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz # tar -xzf pbmc3k_filtered_gene_bc_matrices.tar.gz adata = sc.read_10x_mtx( \u0026#39;filtered_gene_bc_matrices/hg19/\u0026#39;, # the directory with the `.mtx` file var_names=\u0026#39;gene_symbols\u0026#39;) # use gene symbols for the variable names (variables-axis index) adata # AnnData object with n_obs × n_vars = 2700 × 32738 # var: \u0026#39;gene_ids\u0026#39; （2）Seurat对象转换\nhttps://github.com/LuckyMD/Code_snippets/blob/master/Seurat_to_anndata.ipynb\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 同样是上述示例数据，先用R包Seurat处理，储存结果 library(Seurat) pbmc.data = Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) pbmc = CreateSeuratObject(counts = pbmc.data, project = \u0026#34;pbmc3k\u0026#34;) pbmc = NormalizeData(pbmc) %\u0026gt;% FindVariableFeatures() pbmc = pbmc %\u0026gt;% ScaleData() %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = 0.1) head(pbmc@meta.data) saveRDS(pbmc, file = \u0026#34;pbmc.rds\u0026#34;) 1 2 3 4 5 6 7 8 9 ## 准备Python环境 import scanpy as sc import numpy as np import anndata2ri # Activate the anndata2ri conversion between SingleCellExperiment and AnnData anndata2ri.activate() #Loading the rpy2 extension enables cell magic to be used #This runs R code in jupyter notebook cells %load_ext rpy2.ipython 1 2 3 4 5 ## 读入对象 %%R library(Seurat) pbmc = readRDS(\u0026#34;pbmc.rds\u0026#34;) pbmc 1 2 3 4 5 ## 转换对象 %%R -o pbmc_sce #convert the Seurat object to a SingleCellExperiment object pbmc_sce \u0026lt;- as.SingleCellExperiment(pbmc) pbmc_sce 1 2 3 4 5 6 ## 查看转换后的anndata对象 pbmc_sce # AnnData object with n_obs × n_vars = 2700 × 32738 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_RNA\u0026#39;, \u0026#39;nFeature_RNA\u0026#39;, \u0026#39;RNA_snn_res.0.1\u0026#39;, \u0026#39;seurat_clusters\u0026#39;, \u0026#39;ident\u0026#39; # obsm: \u0026#39;X_pca\u0026#39;, \u0026#39;X_umap\u0026#39; # layers: \u0026#39;logcounts\u0026#39; 2、Anndata结构 https://anndata-tutorials.readthedocs.io/en/latest/getting-started.html\n以上述1.2的pbmc_sce对象为例学习anndata结构组成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 adata = pbmc_sce # (1) 矩阵 # ！注意：行是细胞，列是基因。与Seurat读取结果相反！ adata.obs_names #行名(细胞名) adata.var_names #列名(基因名) ## 原始信息以稀疏矩阵形式储存 adata.X print(adata.X) adata.X.todense() adata.layers[\u0026#34;log_transformed\u0026#34;] = np.log1p(adata.X) # adata.layers[\u0026#34;counts\u0026#34;] = adata.X.copy() adata.to_df(layer=\u0026#34;log_transformed\u0026#34;) adata.layers[\u0026#34;X\u0026#34;] = adata.X adata.to_df(layer=\u0026#34;X\u0026#34;) # (2) metadata，按pd.Dataframe格式储存 adata.obs # 细胞的metadata(常用) adata.var # 基因的metadata # (3) 降维数据：多是数组格式，按字典逻辑储存 adata.obsm adata.obsm.keys adata.obsm[\u0026#34;X_umap\u0026#34;] # (4) subset子集 adata[[\u0026#34;Cell_1\u0026#34;, \u0026#34;Cell_10\u0026#34;], [\u0026#34;Gene_5\u0026#34;, \u0026#34;Gene_1900\u0026#34;]] adata[adata.obs.cell_type == \u0026#34;B\u0026#34;] 3、scanpy基础分析 https://scanpy-tutorials.readthedocs.io/en/latest/pbmc3k.html\n以上述1.1的原始读取结果adata对象为例\n（1）质控过滤 1 2 3 4 5 6 7 8 9 10 11 sc.pp.filter_cells(adata, min_genes=200) sc.pp.filter_genes(adata, min_cells=3) adata.var[\u0026#39;mt\u0026#39;] = adata.var_names.str.startswith(\u0026#39;MT-\u0026#39;) sc.pp.calculate_qc_metrics(adata, qc_vars=[\u0026#39;mt\u0026#39;], percent_top=None, log1p=False, inplace=True) # sc.pl.violin(adata, # [\u0026#39;n_genes_by_counts\u0026#39;, \u0026#39;total_counts\u0026#39;, \u0026#39;pct_counts_mt\u0026#39;], # jitter=0.4, multi_panel=True) adata = adata[adata.obs.n_genes_by_counts \u0026lt; 2500, :] adata = adata[adata.obs.pct_counts_mt \u0026lt; 5, :] （2）标准化 1 2 3 4 sc.pp.normalize_total(adata, target_sum=1e4) sc.pp.log1p(adata) sc.pp.scale(adata, max_value=10) sc.pp.regress_out(adata, [\u0026#39;total_counts\u0026#39;, \u0026#39;pct_counts_mt\u0026#39;]) （3）降维分群 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## 高变基因 sc.pp.highly_variable_genes(adata) adata.var ## PCA降维 sc.tl.pca(adata) adata.obsm[\u0026#34;X_pca\u0026#34;].shape sc.pl.pca(adata) # 默认按X_pca的降维结果可视化 sc.pl.pca(adata, color=\u0026#39;CST3\u0026#39;) ## UMAP降维 sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40) sc.tl.umap(adata) sc.pl.umap(adata) ## 分群 sc.tl.leiden(adata, resolution=0.5,key_added=\u0026#34;cluster\u0026#34;) adata.obs sc.pl.umap(adata, color=[\u0026#39;cluster\u0026#39;]) （4）保存 1 adata.write(\u0026#34;your_data.h5ad\u0026#34;) 2024-12-15\nLoompy 是一个用于管理、存储和处理大规模单细胞基因表达数据的 Python 库，可以与Scanpy，Seurat等兼容。其中Loom 格式专门用于高效地存储稀疏矩阵及其相关的元数据。\nhttps://linnarssonlab.org/loompy/ https://github.com/linnarsson-lab/loompy 下面学习其基本用法\u0026mdash;\n1 2 3 import scanpy as sc import loompy import numpy as np anndata保存为loom文件 1 2 3 4 5 6 7 8 9 adata = sc.read_h5ad(\u0026#34;demo_adata.h5ad\u0026#34;) # 添加一个Layer adata.layers[\u0026#34;count\u0026#34;] = adata.X.copy() # 选择需要保存的row/col metadata adata.var = adata.var[[\u0026#34;feature_id\u0026#34;]] adata.obs = adata.obs[[\u0026#34;raw_sum\u0026#34;]] # 最后保存： adata.write_loom(\u0026#34;./demo_adata.loom\u0026#34;) 与anndata的两点区别：\nloom储存的矩阵，row代表基因，column代表细胞。这anndata正好相反 loom储存更加高效，占用硬盘空间相比h5df格式，可显著节约内存。 scanpy读取loom文件 直接读取为anndata对象\n1 2 adata = sc.read_loom(\u0026#34;./demo_adata.loom\u0026#34;) adata loompy读取loom文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # (1) 两种方式读取，后者适用于在交互式环境操作 with loompy.connect(\u0026#34;filename.loom\u0026#34;) as ds: # do something with the connection object ds ds = loompy.connect(\u0026#34;filename.loom\u0026#34;) # do something with the connection object ds ds.close() # (2) Layers ds.layers.keys() # [\u0026#39;\u0026#39;, \u0026#39;count\u0026#39;] ds[:4,:4] ds[\u0026#34;count\u0026#34;][:4,:4] # (3) row/col attribute ds.ra.keys() # [\u0026#39;ensembl_id\u0026#39;, \u0026#39;var_names\u0026#39;] ds.ca.keys() # [\u0026#39;n_counts\u0026#39;, \u0026#39;obs_names\u0026#39;] ds[:, ds.ca.n_counts \u0026lt; 3000].shape # (4) map func ds.map([np.mean, np.std], axis=1) # (5) scan: 对每个batch细胞分别处理 for (ix, selection, view) in ds.scan(axis=1, batch_size=1024): print(view.shape) break ds.close() 在使用过程中，遇到numpy\u0026gt;2.0的版本冲突问题。根据提示，修改源码即可。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/023%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--scanpy%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003escanpy是单细胞数据分析的python工具包，将数据以Anndata对象的格式进行储存。如下将学习Anndata对象操作以及scanpy分析的基础用法。\u003c/p\u003e","title":"单细胞分析工具--scanpy基础用法(anndata,loom格式)"},{"content":" SingleR包是在单细胞数据分析时用于细胞类型自动注释的常用工具。其基本原理是使用已有细胞标签的参考转录组数据集的表达谱，基于相似性原则注释未知单细胞数据的细胞类型。\n注释工具包：SingleR\n教程：http://bioconductor.org/books/release/SingleRBook/\n1 BiocManager::install(\u0026#34;SingleR\u0026#34;) 参考数据集：celldex\n教程：http://bioconductor.org/packages/release/data/experiment/vignettes/celldex/inst/doc/userguide.html\n1 BiocManager::install(\u0026#34;celldex\u0026#34;) 1 2 3 4 library(Seurat) library(SingleR) library(celldex) library(tidyverse) 1、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # download.file(\u0026#34;https://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;, # \u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) # untar(\u0026#34;pbmc3k_filtered_gene_bc_matrices.tar.gz\u0026#34;) pbmc.data = Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) pbmc = CreateSeuratObject(counts = pbmc.data, project = \u0026#34;pbmc3k\u0026#34;) pbmc = NormalizeData(pbmc) %\u0026gt;% FindVariableFeatures() pbmc = ScaleData(pbmc) %\u0026gt;% RunPCA() %\u0026gt;% FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = 0.1) table(pbmc$seurat_clusters) # 0 1 2 3 4 # 1201 684 450 351 14 2、基础用法 参考(ref)/待注释(test)数据集可以是matrix矩阵格式或者SummarizedExperiment对象； ref数据集必须经log+normalization标准化处理；test数据集可以是raw count或者相关标准化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ## test data norm_count = GetAssayData(pbmc, slot=\u0026#34;data\u0026#34;) dim(norm_count) # [1] 32738 2700 ## ref data ref = HumanPrimaryCellAtlasData() class(ref) # [1] \u0026#34;SummarizedExperiment\u0026#34; assays(ref) # List of length 1 # names(1): logcounts ## 基础用法 pred = SingleR(test = norm_count, ref = ref, labels = ref$label.main, de.method = \u0026#34;classic\u0026#34;, #default assay.type.test = \u0026#34;logcounts\u0026#34;, #default assay.type.ref = 1 ) head(pred) # DataFrame with 5 rows and 4 columns # scores labels delta.next pruned.labels # \u0026lt;matrix\u0026gt; \u0026lt;character\u0026gt; \u0026lt;numeric\u0026gt; \u0026lt;character\u0026gt; # 0 0.301403:0.700602:0.647725:... T_cells 0.2341943 T_cells # 1 0.263423:0.660054:0.679101:... Monocyte 0.3058609 Monocyte # 2 0.286134:0.653668:0.604933:... NK_cell 0.0535253 NK_cell # 3 0.271754:0.749707:0.629452:... B_cell 0.2487106 B_cell # 4 0.186824:0.387932:0.419774:... Platelets 0.1113118 Platelets 如上，SingleR默认为每一个细胞单独进行细胞注释。相关细节如下\u0026ndash;\n（1）labels标签提供ref数据集的细胞标签，一般celldex数据集均提供main与fine两种分辨率；\n（2）assay.type.test/ref交代对应数据集的格式，默认均为\u0026rsquo;logcounts\u0026rsquo;。如果是SummarizedExperiment则设置数字交代logcounts所处assay的序号。\n3、进阶用法 （1）可视化注释分数 1 plotScoreHeatmap(pred) 如下图的行标签表示参数数据集的全部细胞类型，列标签表示SingleR的注释结果。\n（2）按cluster为单位进行注释 1 2 3 4 5 6 pred = SingleR(test = norm_count, ref = ref, clusters = pbmc$seurat_clusters, labels = ref$label.main) pbmc$singleR_cluster = pred$labels[match(pbmc$seurat_clusters, rownames(pred))] （3）若参考数据集为单细胞转录组，建议修改 de.method 1 2 3 4 pred = SingleR(test = norm_count, ref = ref, labels = ref$label.main, de.method = \u0026#34;wilcox\u0026#34;) （4）多线程注释 1 2 3 4 pred = SingleR(test = norm_count, ref = ref, labels = ref$label.main, BPPARAM=MulticoreParam(8)) （5）先训练模型，再用于注释 1 2 3 4 5 6 7 8 9 10 11 12 ## 需确保训练数据与待测试数据的基因名一致 int_G = intersect(rownames(ref), rownames(norm_count)) # 训练模型 trained = trainSingleR( ref = ref[int_G,], labels = ref[int_G,]$label.main) # 模型注释 pred = classifySingleR( test = norm_count[int_G,], trained = trained) 4、celldex概况 人类参考数据集 小鼠参考数据集 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/019%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--singler%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A/","summary":"\u003cblockquote\u003e\n\u003cp\u003eSingleR包是在单细胞数据分析时用于细胞类型自动注释的常用工具。其基本原理是使用已有细胞标签的参考转录组数据集的表达谱，基于相似性原则注释未知单细胞数据的细胞类型。\u003c/p\u003e","title":"单细胞分析工具--SingleR细胞类型注释"},{"content":" RNA velocity(RNA速率)分析是基于单细胞转录组测序数据分析细胞发育状态动力学的方法。简单来说，该模型根据测序read片段属于unspliced pre-mrna以及spliced mature mrna的比例推测单细胞的发育轨迹。 高比例的unspliced pre-mrna的占比越高，velocity速率越大，表明在之后阶段中将产生高表达趋势。\n如下将主要学习分析流程，算法原理可参考原始论文：\n2018 | Natue | DOI: 10.1038/s41586-018-0414-6 2020 | Nature Biotechnology |DOI: 10.1038/s41587-020-0591-3 分析流程参考教程：\n上游比对：https://velocyto.org/velocyto.py/index.html 下游分析：https://smorabit.github.io/tutorials/8_velocyto/ 1、上游比对 单细胞测序技术有很多，如下以常用的10X genomics的测序结果为例。 首先根据原始测序结果fastq.gz，经10X官方的cellranger软件进行比对（使用方法参考之前笔记） 根据filtered_feature_bc_matrix 文件夹结果使用Seurat包进行单细胞常规分析； 根据比对的bam文件，使用velocyto软件分别识别出比对到unspliced与spliced mRNA。 示例数据是GSE178911中的GSM5400792样本，为人体急性髓系白血病（AML）骨髓细胞。已经过cellranger比对，结果保存在201008_D0_scRNA_fastq文件夹。\n1 2 3 4 5 6 7 8 9 10 11 12 13 tree -L 1 ./201008_D0_scRNA_fastq/outs/ # ./201008_D0_scRNA_fastq/outs/ # ├── cellsorted_possorted_genome_bam.bam # ├── filtered_feature_bc_matrix # ├── filtered_feature_bc_matrix.h5 # ├── filtered_feature_bc_matrix.tar.gz # ├── metrics_summary.csv # ├── molecule_info.h5 # ├── possorted_genome_bam.bam # ├── possorted_genome_bam.bam.bai # ├── raw_feature_bc_matrix # ├── raw_feature_bc_matrix.h5 # └── web_summary.html 1.1 velocyto分析 1 2 3 4 5 6 7 8 9 10 # (1) 参考下面链接，建立软件环境 # https://velocyto.org/velocyto.py/install/index.html # (2) 准备三份数据 ## 10X比对结果文件夹 cellranger_outDir=/path/to/201008_D8Ven_scRNA_fastq ## 10X参考数据集中的gtf文件 cellranger_gtf=/path/to/refdata-gex-GRCh38-2020-A/genes/genes.gtf ## 重复序列注释文件(optiona;) rmsk_gtf=/path/to/hg38_repeat_rmsk.gtf rmsk_gtf下载链接：https://genome.ucsc.edu/cgi-bin/hgTables?hgsid=611454127_NtvlaW6xBSIRYJEBI0iRDEWisITa\u0026amp;clade=mammal\u0026amp;org=Human\u0026amp;db=0\u0026amp;hgta_group=allTracks\u0026amp;hgta_track=rmsk\u0026amp;hgta_table=rmsk\u0026amp;hgta_regionType=genome\u0026amp;position=\u0026amp;hgta_outputType=gff\u0026amp;hgta_outFileName=mm10_rmsk.gtf\n1 2 3 4 5 6 7 # (3) 开始分析 velocyto run10x -m $rmsk_gtf $cellranger_outDir $cellranger_gtf # (4) 分析结果 tree ./201008_D0_scRNA_fastq/velocyto/ # ./201008_D0_scRNA_fastq/velocyto/ # └── 201008_D0_scRNA_fastq.loom 如上，每个样本都会产生一个loom文件结果。\n1.2 Seurat分析 使用Seurat包完成基本分析，主要包括UMAP降维与分群两步 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(Seurat) library(tidyverse) counts = Read10X(\u0026#34;filtered_feature_bc_matrix/\u0026#34;) sce = CreateSeuratObject(counts) dim(sce) # [1] 36601 6005 sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures(nfeatures = 2000) %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.5)) table(sce$seurat_clusters) # 0 1 2 3 4 5 6 7 8 9 # 1250 1077 827 621 599 541 397 386 215 92 DimPlot(sce) saveRDS(sce, file = \u0026#34;sce.rds\u0026#34;) 2、下游分析 以下在jupyter notebook中执行\n2.1 读入数据 参考之前scanpy学习笔记，导入Seurat对象为Anndata 1 2 3 4 5 6 7 8 9 ## 准备Python环境 import scanpy as sc import numpy as np import anndata2ri # Activate the anndata2ri conversion between SingleCellExperiment and AnnData anndata2ri.activate() #Loading the rpy2 extension enables cell magic to be used #This runs R code in jupyter notebook cells %load_ext rpy2.ipython 1 2 3 4 %%R library(Seurat) sce = readRDS(\u0026#34;./201008_D0_scRNA_fastq/sce.rds\u0026#34;) sce 1 2 3 4 %%R -o adata #convert the Seurat object to a SingleCellExperiment object adata = as.SingleCellExperiment(sce) adata 1 2 3 4 5 adata # AnnData object with n_obs × n_vars = 6005 × 36601 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_RNA\u0026#39;, \u0026#39;nFeature_RNA\u0026#39;, \u0026#39;RNA_snn_res.0.5\u0026#39;, \u0026#39;seurat_clusters\u0026#39;, \u0026#39;ident\u0026#39; # obsm: \u0026#39;X_pca\u0026#39;, \u0026#39;X_umap\u0026#39; # layers: \u0026#39;logcounts\u0026#39; 读入velocyto分析的loom文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import scvelo as scv import scanpy as sc import numpy as np import pandas as pd import anndata as ad ldata1 = scv.read(\u0026#39;./201008_D0_scRNA_fastq/velocyto/201008_D0_scRNA_fastq.loom\u0026#39;) # AnnData object with n_obs × n_vars = 6005 × 36601 # var: \u0026#39;Accession\u0026#39;, \u0026#39;Chromosome\u0026#39;, \u0026#39;End\u0026#39;, \u0026#39;Start\u0026#39;, \u0026#39;Strand\u0026#39; # layers: \u0026#39;matrix\u0026#39;, \u0026#39;ambiguous\u0026#39;, \u0026#39;spliced\u0026#39;, \u0026#39;unspliced\u0026#39; ## 修改细胞名barcode，与Seurat保持一致 barcodes = [bc.split(\u0026#39;:\u0026#39;)[1] for bc in ldata1.obs.index.tolist()] barcodes = [bc[0:len(bc)-1] + \u0026#39;-1\u0026#39; for bc in barcodes] barcodes # [\u0026#39;AACAAGACATGCGGTC-1\u0026#39;, # \u0026#39;AACAGGGCACGACCTG-1\u0026#39;, # \u0026#39;AAAGAACGTTATGTGC-1\u0026#39;, # \u0026#39;AACAACCAGCAATAAC-1\u0026#39;, # \u0026#39;AACAAGAGTCTCTCCA-1\u0026#39;] ldata1.obs.index = barcodes ldata1.var_names_make_unique() 合并上述两个数据 1 2 3 4 5 6 7 8 9 adata = scv.utils.merge(adata, ldata1) adata # AnnData object with n_obs × n_vars = 6005 × 36591 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_RNA\u0026#39;, \u0026#39;nFeature_RNA\u0026#39;, \u0026#39;RNA_snn_res.0.5\u0026#39;, \u0026#39;seurat_clusters\u0026#39;, \u0026#39;ident\u0026#39;, \u0026#39;initial_size_unspliced\u0026#39;, \u0026#39;initial_size_spliced\u0026#39;, \u0026#39;initial_size\u0026#39; # var: \u0026#39;Accession\u0026#39;, \u0026#39;Chromosome\u0026#39;, \u0026#39;End\u0026#39;, \u0026#39;Start\u0026#39;, \u0026#39;Strand\u0026#39; # obsm: \u0026#39;X_pca\u0026#39;, \u0026#39;X_umap\u0026#39; # layers: \u0026#39;logcounts\u0026#39;, \u0026#39;matrix\u0026#39;, \u0026#39;ambiguous\u0026#39;, \u0026#39;spliced\u0026#39;, \u0026#39;unspliced\u0026#39; sc.pl.umap(adata, color=\u0026#39;seurat_clusters\u0026#39;, legend_loc=\u0026#39;on data\u0026#39;) 2.2 scvelo速率分析 （1）统计每个cluster的spliced与unspliced比例 1 scv.pl.proportions(adata, groupby=\u0026#39;seurat_clusters\u0026#39;) （2）速率分析 1 2 3 4 5 6 7 8 9 10 11 12 13 scv.pp.filter_and_normalize(adata) scv.pp.moments(adata) scv.tl.velocity(adata, mode=\u0026#39;stochastic\u0026#39;) scv.tl.velocity_graph(adata) adata # AnnData object with n_obs × n_vars = 6005 × 36591 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_RNA\u0026#39;, \u0026#39;nFeature_RNA\u0026#39;, \u0026#39;RNA_snn_res.0.5\u0026#39;, \u0026#39;seurat_clusters\u0026#39;, \u0026#39;ident\u0026#39;, \u0026#39;initial_size_unspliced\u0026#39;, \u0026#39;initial_size_spliced\u0026#39;, \u0026#39;initial_size\u0026#39;, \u0026#39;n_counts\u0026#39; # var: \u0026#39;Accession\u0026#39;, \u0026#39;Chromosome\u0026#39;, \u0026#39;End\u0026#39;, \u0026#39;Start\u0026#39;, \u0026#39;Strand\u0026#39;, \u0026#39;gene_count_corr\u0026#39;, \u0026#39;velocity_gamma\u0026#39;, \u0026#39;velocity_qreg_ratio\u0026#39;, \u0026#39;velocity_r2\u0026#39;, \u0026#39;velocity_genes\u0026#39; # uns: \u0026#39;seurat_clusters_colors\u0026#39;, \u0026#39;neighbors\u0026#39;, \u0026#39;velocity_params\u0026#39; # obsm: \u0026#39;X_pca\u0026#39;, \u0026#39;X_umap\u0026#39; # layers: \u0026#39;logcounts\u0026#39;, \u0026#39;matrix\u0026#39;, \u0026#39;ambiguous\u0026#39;, \u0026#39;spliced\u0026#39;, \u0026#39;unspliced\u0026#39;, \u0026#39;Ms\u0026#39;, \u0026#39;Mu\u0026#39;, \u0026#39;velocity\u0026#39;, \u0026#39;variance_velocity\u0026#39; # obsp: \u0026#39;distances\u0026#39;, \u0026#39;connectivities\u0026#39; （3）速率分析结果可视化 1 2 3 scv.pl.velocity_embedding_grid(adata, basis=\u0026#39;umap\u0026#39;, color=\u0026#39;seurat_clusters\u0026#39;, scale=0.25) # 可通过多个参数调整图形(箭头)细节展示 1 2 3 scv.pl.velocity_embedding_stream(adata, basis=\u0026#39;umap\u0026#39;, color=\u0026#39;seurat_clusters\u0026#39;) # 可通过多个参数调整图形(箭头)细节展示 1 2 3 4 5 6 scv.tl.rank_velocity_genes(adata, groupby=\u0026#39;seurat_clusters\u0026#39;, min_corr=.3) df = scv.DataFrame(adata.uns[\u0026#39;rank_velocity_genes\u0026#39;][\u0026#39;names\u0026#39;]) df.head() scv.pl.scatter(adata, df[\u0026#39;2\u0026#39;][:3], frameon=True, color=\u0026#39;seurat_clusters\u0026#39;, size=10, linewidth=1.5) 1 2 scv.tl.velocity_pseudotime(adata) # 由0到1 scv.pl.scatter(adata, color=\u0026#39;velocity_pseudotime\u0026#39;, cmap=\u0026#39;gnuplot\u0026#39;) 1 2 3 scv.tl.paga(adata, groups=\u0026#39;seurat_clusters\u0026#39;) scv.pl.paga(adata, basis=\u0026#39;umap\u0026#39;, size=50, alpha=.1, min_edge_width=2, node_size_scale=1.5) （4）特定细胞群速率分析 1 2 3 cur_celltypes = [\u0026#34;0\u0026#34;] adata_subset = adata[adata.obs[\u0026#39;seurat_clusters\u0026#39;].isin(cur_celltypes)] sc.pl.umap(adata_subset) 1 2 3 4 5 6 sc.pp.neighbors(adata_subset, n_neighbors=15, use_rep=\u0026#39;X_pca\u0026#39;) scv.pp.filter_and_normalize(adata_subset) scv.pp.moments(adata_subset) scv.tl.recover_dynamics(adata_subset) scv.pl.velocity_embedding_stream(adata_subset, basis=\u0026#39;umap\u0026#39;) 1 2 3 4 df = adata_subset.var df = df[(df[\u0026#39;fit_likelihood\u0026#39;] \u0026gt; .1) \u0026amp; df[\u0026#39;velocity_genes\u0026#39;] == True] top_genes = adata_subset.var[\u0026#39;fit_likelihood\u0026#39;].sort_values(ascending=False).index[:300] scv.pl.scatter(adata_subset, basis=top_genes[:15], ncols=5, frameon=True) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/024%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--rnavelocity%E9%80%9F%E7%8E%87%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eRNA velocity(RNA速率)分析是基于单细胞转录组测序数据分析细胞发育状态动力学的方法。简单来说，该模型根据测序read片段属于\u003cstrong\u003eunspliced pre-mrna\u003c/strong\u003e以及\u003cstrong\u003espliced mature mrna\u003c/strong\u003e的比例推测单细胞的发育轨迹。 高比例的\u003cstrong\u003eunspliced pre-mrna\u003c/strong\u003e的占比越高，velocity速率越大，表明在之后阶段中将产生高表达趋势。\u003c/p\u003e","title":"单细胞分析工具--RNAvelocity速率分析"},{"content":" Python有不少解释器，默认使用的是CPython。而IPython，interactive python可以提供交互式开发环境；是Jupyter的内核。如果要使用Jupyter，使用的就是IPython开发环境。\n1、In/Out ipython的特征之一是命令的前缀类似：In[1]；而输出结果的前缀类似：Out[1]。\n前者称为输入单元格(input cell)，可以输入单行/多行命令；后者称为输出单元格(output cell)。\nIn对象本质上是个列表，按顺序记录所有的命令；Out对象本质是一个字典，将输入数字映射到相应的输出。\n1 2 3 4 5 6 7 8 9 In [1]: a=1 In [2]: test=\u0026#34;hello\u0026#34; In [3]: 1+1 #如上为历史记录 print(In) # [\u0026#39;\u0026#39;, \u0026#39;a=1\u0026#39;, \u0026#39;test=\u0026#34;hello\u0026#34;\u0026#39;, \u0026#39;1+1\u0026#39;, \u0026#39;print(In)\u0026#39;] print(Out) # {3: 2} 如上，并不是所有的输入单元格都有输出内容。比较特殊的是print()语句本质是没有输出的，尽管它的功能是打印一些语句。\n2、?问号 1 2 3 4 5 6 7 8 9 10 11 12 ## (1) 对象名(函数/方法)+?：获取简要帮助文档 len? range? list.append? ## (2) 正则表达式+?：列出当前命令空间中，所有符合匹配条件的对象名 anynumber = 123 anyway = \u0026#34;test\u0026#34; an*? # any # anynumber # anyway 3、%百分号 %command：行魔法；%%command：单元魔法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## (1) %paste: 复制粘贴别人带有提示符前缀的代码块( %cpaste:交互式多行复制) ## (2) %run ***.py: 在python环境执行python脚本 ## (3) %timeit: 计算代码运行时间(%%timeit: 计算多行代码运行时间) %timeit print(\u0026#34;hello, world\u0026#34;) # 12.1 µs ± 137 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each) ## (4) %history 查看历史命令 ## (5) %automagic 是否简化 行魔法 命令的前缀% %automagic # Automagic is ON, % prefix IS NOT needed for line magics. ## (5) 其它魔法函数 %lsmagic #列出所有的魔法函数 %timeit? #获取某一个魔法函数的帮助文档 4、执行shell命令 之前了解到在python中可使用os模块的system方法执行shell命令。 在ipython解释器中，对于一些常用shell命令，可直接使用%command。例如%cd,%pwd，%mkdir newfolder等等，可通过%lsmagic 查看 在%automagic设置为On的状态下，可以不写前缀%，就完全像shell命令一样 1 2 3 4 5 6 7 8 9 10 11 12 13 %ls # Miniconda3-latest-Linux-x86_64.sh Untitled.ipynb miniconda3/ test/ pwd # \u0026#39;/home/shensuo\u0026#39; nowpath=%pwd print(nowpath) # /home/shensuo conda info --envs # #conda environments: # # # base * /home/shensuo/miniconda3 ","permalink":"https://lishensuo.github.io/en/posts/program/020python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-ipython%E9%AD%94%E6%B3%95%E5%91%BD%E4%BB%A4/","summary":"\u003cblockquote\u003e\n\u003cp\u003ePython有不少解释器，默认使用的是CPython。而IPython，interactive python可以提供交互式开发环境；是Jupyter的内核。如果要使用Jupyter，使用的就是IPython开发环境。\u003c/p\u003e","title":"Python数据科学-(1)IPython的特点"},{"content":" CytoTRACE是根据单细胞表达矩阵推断细胞分化轨迹的工具，目前提供网页端与R包两种形式。如下。简单学习其R包用法。\n官方手册：https://cytotrace.stanford.edu/ 发表论文：DOI: 10.1126/science.aax0249 1、安装R包 根据官方手册，需要手动R包文件，自行安装。如下笔记在Linux的R环境中进行学习。\nR包下载：https://cytotrace.stanford.edu/CytoTRACE_0.3.3.tar.gz 1 devtools::install_local(\u0026#34;CytoTRACE_0.3.3.tar.gz\u0026#34;) 如上，首先会自动安装若干依赖R包。如果未能成功安装，可单独使用conda安装，例如sva等\n1 2 conda install -c bioconda bioconductor-sva conda install -c conda-forge r-ncdf4 安装python模块：针对多样本的轨迹分析函数需要用到两个python模块，需要安装 1 2 pip install scanoramaCT pip install numpy 在如上的scanoramaCT安装过程中也会下载若干依赖包。若安装失败，同样可单独conda安装。例如：\n1 conda install -c conda-forge python-annoy 2、CytoTRACE分析 CytoTRACE包架构很简单，包含两个分析函数、两个绘图函数，以及其余的4个示例数据。\n（1）输入数据\n原始单细胞count表达矩阵：行名为基因名，列名为细胞名的dataframe/matrix； 细胞类型标签：字符串格式。值表示注释的细胞类型；名字对应表达矩阵的行名。 降维坐标(optional)：dataframe格式，包含两列。行名对应表达矩阵的列名。 （2）CytoTRACE()单样本分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 dim(marrow_10x_expr) # [1] 13526 3427 length(marrow_10x_pheno) # [1] 3427 head(table(marrow_10x_pheno)) # Erythrocytes Erythroid progenitors and erythroblasts # 142 268 # Granulocyte progenitors Granulocytes # 330 770 # Immature B cells Macrophages # 299 222 ## 多线程分析 results = CytoTRACE(marrow_10x_expr, ncores = 8, subsamplesize = 1000) length(results) # 8 如上，分析结果是长度为8的列表格式，其中比较重要的前三项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## (1) 第一项表示：每个细胞的轨迹分数，取值范围在0~1。越接近0，分化潜能越大；反之越小。 head(results[[1]]) # 10X_P7_2_AAACCTGCAGTAACGG 10X_P7_2_AAACGGGAGGACGAAA 10X_P7_2_AAACGGGAGGTACTCT # 0.62346760 0.35901926 0.73555166 # 10X_P7_2_AAACGGGAGGTGCTTT 10X_P7_2_AAACGGGAGTCGAGTG 10X_P7_2_AAAGATGAGCTTCGCG # 0.09457093 0.23467601 0.42644483 ## (2) 第二项表示：每个细胞的分化潜能的排名 # 10X_P7_2_AAACCTGCAGTAACGG 10X_P7_2_AAACGGGAGGACGAAA 10X_P7_2_AAACGGGAGGTACTCT # 713 411 841 # 10X_P7_2_AAACGGGAGGTGCTTT 10X_P7_2_AAACGGGAGTCGAGTG 10X_P7_2_AAAGATGAGCTTCGCG # 109 269 488 ## (3) 第三项表示：每个基因表达与细胞群分化轨迹相关性 head(results[[3]]) # Rpl4 Eef1a1 Rps5 Rps3a Rpl13a Rps4x # 0.9234229 0.9225254 0.9222174 0.9216470 0.9196403 0.9161128 ## 具体每项意义可通过函数帮助文档获取 ?CytoTRACE （3）iCytoTRACE() 多样本分析 1 2 3 4 5 6 datasets \u0026lt;- list(marrow_10x_expr, marrow_plate_expr) multi_results \u0026lt;- iCytoTRACE(datasets, ncores = 8, subsamplesize = 1000) ## 分析结果同样是长度为8的列表格式 ## 具体每项意义可通过函数帮助文档获取 ?iCytoTRACE 3、结果可视化 以上述的CytoTRACE()函数分析结果results为例\n（1）plotCytoTRACE 函数会自动绘制两个图形，并保存在特定路径； 如未提供embedding，函数自动采用tsne降维。 1 2 3 4 5 6 7 plotCytoTRACE( cyto_obj = results, phenotype = marrow_10x_pheno, #细胞类型注释 # gene = \u0026#34;Kit\u0026#34;, #是否映射特定基因表达 emb = NULL, #是否提供细胞降维坐标 outputDir = \u0026#34;./\u0026#34; #图片储存路径 ) plotCytoGenes 1 2 3 4 5 6 plotCytoGenes( cyto_obj = results, numOfGenes = 10, colors = c(\u0026#34;darkred\u0026#34;, \u0026#34;navyblue\u0026#34;), outputDir = \u0026#34;./\u0026#34; ) 如上图形均可根据分析结果数据自行绘制，或者添加到Seura对象的meta.data中进行可视化。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/025%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--cytotrace%E8%BD%A8%E8%BF%B9%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCytoTRACE\u003c/strong\u003e是根据单细胞表达矩阵推断细胞分化轨迹的工具，目前提供网页端与R包两种形式。如下。简单学习其R包用法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e官方手册：https://cytotrace.stanford.edu/\u003c/li\u003e\n\u003cli\u003e发表论文：\u003ca href=\"https://doi.org/10.1126/science.aax0249\"\u003eDOI: 10.1126/science.aax0249\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230126190048340.png\" alt=\"image-20230126190048340\" style=\"zoom: 80%;\" /\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1安装r包\"\u003e1、安装R包\u003c/h2\u003e\n\u003cp\u003e根据官方手册，需要手动R包文件，自行安装。如下笔记在Linux的R环境中进行学习。\u003c/p\u003e","title":"单细胞分析工具--CytoTRACE轨迹分析"},{"content":" NumPy,Numerical Python创建的ndarray数组在某些方面与Python中的list对象很相似；但是二者还是很多区别，比如数据类型一致性的要求、维度等。\nArray的保存与加载\n1 2 3 4 5 6 import numpy as np data = np.array([1, 2, 3, 4, 5]) # 保存 np.save(\u0026#39;my_array.npy\u0026#39;, data) # 加载 loaded_data = np.load(\u0026#39;my_array.npy\u0026#39;) Torch.tensor的保存与加载\n1 2 3 4 5 6 import torch tensor = torch.randn(3, 4) # Save torch.save(tensor, \u0026#39;tensor.pt\u0026#39;) # Load loaded_tensor = torch.load(\u0026#39;tensor.pt\u0026#39;) 1、创建数组对象 储存为数组的数据要求具有相同的数据类型，在创建数组时需要指定是哪种数据类型；\nNumPy支持多种数据类型，常见的有整型int64(默认), int32, int16,int8；浮点型float64(默认), float32, float16,float8\n1.1 list转为数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ##(1) 普通list转为一维数组 import numpy as np np.array([1,2,3,4,5]) #如果列表内元素为整数，则默认为int64 # array([1, 2, 3, 4, 5]) np.array([1,2,3,4,5], dtype=int) #若指定数据类型为int，同样默认为int64 np.array([1,2,3,4,5], dtype=\u0026#34;int32\u0026#34;) #指定为其它数据类型 # array([1, 2, 3, 4, 5], dtype=int32) np.array([1,2,3,4,5], dtype=\u0026#34;float64\u0026#34;) # array([1., 2., 3., 4., 5.]) np.array(range(1,6)) # array([1, 2, 3, 4, 5]) ##(2) 嵌套列表转为二维数组 np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]]) # array([[ 1, 2, 3, 4], # [ 5, 6, 7, 8], # [ 9, 10, 11, 12]]) # 一个子列表视为1行 np.array([range(1,5), range(5,9), range(9,13)]) 数组有.tolist方法将其转为list对象\n1.2 特定模式数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import numpy as np ##(1) 创建全0数组，第一个参数交代维度，第二个参数交代数据类型 np.zeros(5, dtype=int) np.zeros((2,4), dtype=float) #np.ones与之类似，创建全1数组 ##(2) 创建有序一维数组 np.arange(5) # array([0, 1, 2, 3, 4]) np.linspace(1,5, num=9) # array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. ]) ##(3) 创建random随机分布数组 np.random.random(5) #0 1之间随机分布 # array([0.48928279, 0.76854168, 0.70242817, 0.13372169, 0.4132587 ]) np.random.randint(0,5,(2,3)) #指定整数区间随机分布 # array([[2, 1, 2], # [3, 4, 4]]) np.random.normal(0, 1, 5) #正态分布 # array([-2.16054171, -0.40716729, 0.19965792, -1.00849158, 0.36834892]) np.random.randn(10) #返回10个符合0,1正态分布的随机数 np.random.randn(1,2) #返回1行2列，符合0,1正态分布的随机数 np.random.choice(range(10),5,replace=False) # array([3, 6, 5, 1, 0]) ##随机种子 #方式(1) np.random.seed(42) np.random.random(5) #方式(2) np.random.RandomState(42).random(5) ## (4) 单位矩阵 np.eye(3) # array([[1., 0., 0.], # [0., 1., 0.], # [0., 0., 1.]]) ## 一个矩阵与相应的单位矩阵进行矩阵乘法运算，值不变 np.array_equal(t4, np.matmul(t4, torch.eye(3))) # True 1 2 3 4 5 6 import torch torch.randn(2, 3, 4).shape # torch.Size([2, 3, 4]) torch.normal(0, 1, (3,)).shape # torch.Size([3]) 1.3 数据类型转换 1 2 3 4 5 6 7 np.array([1, 2, 3]).dtype # dtype(\u0026#39;int64\u0026#39;) np.array([1, 2, 3]).astype(float).dtype # dtype(\u0026#39;float64\u0026#39;) np.array([1, 2, 3]).astype(np.float32).dtype # dtype(\u0026#39;float32\u0026#39;) np.array([1, 2, 3]).astype(np.int32).dtype 1 2 3 4 5 6 7 8 9 10 11 12 import torch torch.tensor([1, 2, 3]).dtype # torch.int64 torch.tensor([1, 2, 3]).to(torch.float16).dtype # torch.float16 torch.tensor([1, 2, 3]).to(torch.int16).dtype # torch.int16 torch.tensor([1, 2, 3]).long() #int64 torch.tensor([1, 2, 3]).int() #int32 torch.tensor([1, 2, 3]).float() #float32 torch.tensor([1, 2, 3]).double() #float64 2、数组维度转换 查看 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import numpy as np test = np.arange(6) # array([0, 1, 2, 3, 4, 5]) ##(1) 查看数量 test.size # 6 ##(2) 查看维度 test.ndim # 1 ##(3) 查看每个维度的大小 test.shape # (6,) reshape转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ##(4) 维度转换 #转换为2行3列的新数组 test.reshape((2,3)) # array([[0, 1, 2], # [3, 4, 5]]) #转换为1行6列的行向量二维数组 test.reshape((1,6)) test.reshape((1,-1)) # array([[0, 1, 2, 3, 4, 5]]) #转换为6行1列的列向量二维数组 test.reshape((6,1)) test.reshape((-1,1)) # array([[0], # [1], # [2], # [3], # [4], # [5]]) #二维转为一维 test.reshape((6,1)).reshape((6,)) test.reshape((6,1)).reshape((-1)) test.reshape((6,1)).ravel() #array([0, 1, 2, 3, 4, 5]) #二维行列转换 test.reshape((2,3)).T #array([[0, 3], # [1, 4], # [2, 5]]) # 任意维度的转换 test.transpose(1, 0) #轴1与轴0交换 reshape操作：不改变数据顺序，可将将多维数据展平成一维，或将一维数据恢复为多维。\ntranspose操作：数据的轴交换。 例如，将图像数据从 (height, width, channels) 转换为 (channels, height, width)\n其它（20241013补充） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 test = np.random.randn(2, 1, 5) test.shape # (2, 1, 5) test.squeeze(axis = 1).shape # (2, 5) np.expand_dims(test, 0).shape # (1, 2, 1, 5) ## torch import torch test = torch.randn(2, 1, 5) test.squeeze(dim = 1).shape # torch.Size([2, 5]) test.unsqueeze(dim = 0).shape # torch.Size([1, 2, 1, 5]) repeat复制 1 2 3 4 5 6 7 8 test = np.random.randn(3, 4) test.repeat(2, axis=1).shape # (3, 8) ## torch的操作方式不同 t3 = torch.randn(2, 1, 3) t3.repeat(1, 2, 2).shape # torch.Size([2, 2, 6]) 3、索引与切片 3.1 一维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ##(1)索引操作返回单个数值 import numpy as np aa=np.array([1,2,3,4,5]) aa[1] # 2 ###列表索引返回数组 aa[[0,2,3]] # array([1, 3, 4]) ##(2)切片操作返回子数组 aa[0:2] # array([1, 2]) aa[3:] # array([4, 5]) 3.2 二维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ##(1)索引操作返回单个数值 import numpy as np bb=np.array([[1,2,3],[4,5,6]]) bb[0,0] # 1 bb[1,2] # 6 ##(2)数组切片返回子数组 bb[:,0:2] #第1,2列 # array([[1, 2], # [4, 5]]) bb[1,:] #第2行 # array([4, 5, 6]) ###列表索引 bb[:,[0,2]] #第1,3列 bb[[1],:] #第2行 bb[[1]] #第2行(列表索引) bb[:2] #第1、2行(切片) 4、数组计算 4.1 基础算数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import numpy as np np.add # + np.subtract # - np.negative # 相反数 np.abs # 绝对值 np.multipy # × np.divide # / np.floor_divide # // , 7//2=3 np.mod # % , 7%2 =1 np.power # ** , 2**3=8 np.exp # 底数为e的指数运算 np.log2 # log2(x) a1=np.array([1,2,3]) np.add(a1, 10) # array([11, 12, 13]) np.power(3,a1) # array([ 3, 9, 27]) ##如果是二维数组，也是同样对所有数操作 4.2 基础统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 np.sum #和 np.mean #均值 np.std #标准差 np.var #方差 np.min #最小值 np.argmin #最小值的索引 np.median #中位数 np.percentile #百分位数 ##(1) 一维数组 a1=np.array([1,2,3]) np.sum(a1) # 6 np.argmin(a1) # 0 ##(2) 二维数组 b1=np.arange(0,6).reshape((2,3)) #array([[0, 1, 2], # [3, 4, 5]]) ##按列统计：如下计算每一列的均值 np.mean(b1, axis=0) #array([1.5, 2.5, 3.5]) ##按行统计：如下计算每一行的均值 np.mean(b1, axis=1) #array([1., 4.]) 对于numpy提供的基础统计函数，都对应有每一个array实例的方法名。例如b1.mean(), a1.sum\n4.3 数组与数组运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ##(1) 一维数组 与 一维数组: 长度需要相同 import numpy as np a1 = np.array([1,2,3]) a2 = np.array([4,5,6]) a1 + a2 ##(2) 二维数组 与 二维数组 b1=np.arange(0,6).reshape((2,3)) #2行3列 #列数相同，纵向扩展 b2=np.array([100,101,102]).reshape((1,3)) #1行3列 b1 + b2 # array([[100, 102, 104], # [103, 105, 107]]) #行数相同，横向扩展 b3=np.array([100,101]).reshape((2,1)) #2行1列 b1 + b3 # array([[100, 101, 102], # [104, 105, 106]]) b2 + b3 #Error 5、逻辑数组 运算符：==\t!=\t\u0026lt;\t\u0026lt;=\t\u0026gt;\t\u0026gt;= 布尔运算符：\u0026amp;与 |或 ~否。使用布尔运算符时，对每一个子运算需要括号括起来。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import numpy as pd ##(1) 通过比较运算符产生布尔数组 x = np.arange(5) # array([0, 1, 2, 3, 4]) x \u0026gt; 2 # array([False, False, False, True, True]) y = np.arange(6).reshape((2,3)) # array([[0, 1, 2], # [3, 4, 5]]) y == 2 # array([[False, False, True], # [False, False, False]]) ##(2) 统计布尔数组结果： # True=1，False=0 #np.any : 有一个True即为True #np.all : 全为True才为True np.sum(x\u0026gt;2) #2 np.any(x\u0026gt;2) #True np.sum(y==1, axis=0) # array([0, 1, 0]) np.all(y\u0026gt;=1, axis=0) # array([False, True, True]) ##(3)使用布尔数组筛选数组 x[x\u0026gt;2] # array([3, 4]) y[y\u0026gt;=2] # array([2, 3, 4, 5]) y[:,np.any(y\u0026gt;=4,axis=0)] # array([[1, 2], # [4, 5]]) 如上已经有多种方法可用于取数组子集：索引，切片，布尔值。这些方法可以混合使用。\n6、数组排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ##(1) 一维数组 import numpy as np x1 = np.random.choice(range(10),5,replace=False) # array([0, 8, 4, 9, 3]) #### np.sort() np.sort(x1) #array([0, 3, 4, 8, 9]) np.sort(x1)[::-1] #array([9, 8, 4, 3, 0]) #### np.argsort() np.argsort(x1) #array([0, 4, 2, 1, 3]) #如上结果中：第一个元素是数组中最小元素的索引值，第二个是次小元素的索引值...以此类推 ##(2) 二维数组 ###每行/列都排序：但这样处理的后果是行列关系将会打乱 x2 = np.random.choice(range(20),9,replace=False).reshape((3,3)) # array([[16, 5, 14], # [ 0, 10, 12], # [19, 8, 18]]) np.sort(x2, axis=0) # array([[ 0, 5, 12], # [16, 8, 14], # [19, 10, 18]]) ###如下：按第一列值大小，调整整行顺序 x2[np.argsort(x2[:,0]),:] # array([[ 0, 10, 12], # [16, 5, 14], # [19, 8, 18]]) 7、拼接与分割 7.1 维度不变 一维 1 2 3 4 5 6 7 8 9 10 11 ##(1)拼接多个数组 import numpy as np a1=np.array([1,2,3]) a2=np.array([4,5,6,7]) np.concatenate([a1, a2]) # array([1, 2, 3, 4, 5, 6, 7]) ##(2)分割一个数组 np.split(a2,[1]) # [array([4]), array([5, 6, 7])] s1, s2 = np.split(a2,[1]) 二(高)维数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 b1=np.arange(0,6).reshape((2,3)) b2=np.arange(10,16).reshape((2,3)) ##(1)上下拼接数组 np.concatenate([b1, b2], axis=0).shape # (4, 3) np.vstack([b1, b2]).shape # (4, 3) ##(2)左右拼接数组 np.concatenate([b1, b2], axis=1).shape # (2, 6) np.hstack([b1, b2]).shape # (2, 6) b3=np.arange(0,12).reshape((3,4)) ##(3)按行分割数组 np.split(b3, [1], axis=0) #[array([[0, 1, 2, 3]]), # array([[ 4, 5, 6, 7], # [ 8, 9, 10, 11]])] s1,s2=np.split(b3, [1], axis=0) np.vsplit(b3, [1]) ##(4)按列分割数组 np.split(b3, [2], axis=1) s1,s2=np.split(b3, [2], axis=1) np.hsplit(b3, [2]) 7.2 维度变化 1 2 3 4 5 6 7 8 9 b1=np.arange(0,6).reshape((2,3)) b2=np.arange(10,16).reshape((2,3)) np.stack([b1, b2]).shape # (2, 2, 3) np.stack([b1, b2],axis=1).shape # (2, 2, 3) np.stack([b1, b2],axis=2).shape # (2, 3, 2) ","permalink":"https://lishensuo.github.io/en/posts/program/021python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-numpy%E6%95%B0%E7%BB%84torch%E5%BC%A0%E9%87%8F/","summary":"\u003cblockquote\u003e\n\u003cp\u003eNumPy,Numerical Python创建的ndarray数组在某些方面与Python中的list对象很相似；但是二者还是很多区别，比如数据类型一致性的要求、维度等。\u003c/p\u003e","title":"Python数据科学-(2)Numpy数组(torch张量)"},{"content":" cellphonedb是基于配受体对表达水平，分析单细胞数据中不同细胞类型间相互作用的Python工具。其于2020年在nature protocols发表，目前工具包版本以更新到3.1.0，配受体数据库已更新到4版本。如下将简单学习该软件的用法及结果可视化方法。\n原始论文 2020 | nature protocols | 10.1038/s41596-020-0292-x 2021 | nature genetics | 10.1038/s41588-021-00972-2 官方手册 https://github.com/ventolab/CellphoneDB https://github.com/ventolab/CellphoneDB/blob/master/Docs/RESULTS-DOCUMENTATION.md https://github.com/ventolab/CellphoneDB/blob/master/notebooks/0_prepare_your_data_from_Seurat.ipynb 扩展可视化工具 https://ktplotspy.readthedocs.io/en/latest/notebooks/tutorial.html 1、输入数据 如下图所示，目前cellphonedb可主要实现三种分析模式。第一种直接分析细胞对之间配受体表达水平，第二种方式在前者基础上进一步计算显著P值。第三种则结合了细胞类型的差异基因。\n此次主要学习第二种分析模式，需要提供两类文件：单细胞表达矩阵，细胞类型注释结果。\n单细胞表达矩阵 （1）支持格式包括：.h5ad(scannpy)，10X三文件(mtx/barcode/features)，以及txt等纯文本；对于大型单细胞数据，推荐使用前两者； （2）推荐使用标准化后的count标准矩阵，不需要scale归一化处理； （3）该工具仅支持人类基因名(ensembl, symbol)，其它物种需要同源转换。 细胞类型注释结果 （1）包含两列信息的文本文件，可支持.csv, .txt,.tsv等 （2）第一列的列名是Cell，对应表达矩阵的细胞名；第二列的列名是cell_type，表示注释细胞类型。 2、示例数据 10X官方提供的PBMC3K单细胞测序数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 library(Seurat) library(tidyverse) # https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k count = Read10X(\u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) sce = CreateSeuratObject(count) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures(nfeatures = 2000) %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = 0.1) table(sce$seurat_clusters) # 0 1 2 3 4 # 1201 684 450 351 14 ## (1) 重新保存10X三文件，prepared_10X文件夹中 dir.create(\u0026#34;prepared_10x\u0026#34;) writeMM(sce@assays$RNA@data, file = \u0026#39;prepared_10x/matrix.mtx\u0026#39;) write(x = rownames(sce@assays$RNA@data), file = \u0026#34;prepared_10x/features.tsv\u0026#34;) write(x = colnames(sce@assays$RNA@data), file = \u0026#34;prepared_10x/barcodes.tsv\u0026#34;) ## (2) 保存细胞类型注释结果 sce$cell_type = paste0(\u0026#34;cluster\u0026#34;,sce$seurat_clusters) sce$Cell = rownames(sce@meta.data) df = sce@meta.data[, c(\u0026#39;Cell\u0026#39;, \u0026#39;cell_type\u0026#39;)] write.table(df, file =\u0026#39;prepared_meta.tsv\u0026#39;, sep = \u0026#39;\\t\u0026#39;, quote = F, row.names = F) ## (3) 保存当前seurat对象，用于扩展可视化 saveRDS(sce, file = \u0026#34;sce.rds\u0026#34;) 将上述的结果(1个文件夹，2个文件)保存到后面的cellphonedb分析环境\n3、cellphonedb分析 （1）建立cellphonedb分析环境 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## python版本建议使用3.7 conda create -n cellphonedb python=3.7 -y conda activate cellphonedb conda install -c r r-base rpy2 -y conda install r-pheatmap r-ggplot2 -y conda install -c conda-forge markupsafe=2.0.1 -y pip install cellphonedb cellphonedb --help # Commands: # database # method # plot # query cellphonedb method --help # Commands: # analysis # degs_analysis # statistical_analysis 如上，cellphonedb工具提供4个子命令，其中method用于细胞通讯分析的方法选择。\n后续分析选择statistical_analysis模式，用于计算P值\n（2）cellphonedb分析及结果 1 2 3 4 5 6 cellphonedb method statistical_analysis \\ --output-path pbmc_out \\ --counts-data hgnc_symbol \\ --threshold 0.1 \\ --threads 10 \\ prepared_meta.tsv prepared_10x 该命令有较多参数可以设置，具体可参考官方手册。如上所示列出了觉得比较重要的4个参数。\n--output-path ：输出文件夹名，默认为out\n--counts-data：表达矩阵基因基因名格式，默认为ensembl --threshold：只有细胞类型的相应配受体表达百分比超过阈值才会分析，默认为0.1\n--threads：多线程设置，默认为4\n1 2 ls ./pbmc_out # deconvoluted.txt means.txt pvalues.txt significant_means.txt 如上结果里， means.txt与pvalues.txt表示两两细胞类型之间配受体对的平均表达水平与显著性P值。\nsignificant_means.txt结合上述两个结果表示具有显著意义(至少在一种)的两两细胞类型之间配受体对的平均表达水平。\n如下所示，考虑到配受体对的有向性，对于同一配受体对，会分析所有的细胞类型组合(n*n)可能。\nid_cp_interaction、interacting_pair表示配受体对的代号与组成；\npartner_a、gene_a表示组成A的蛋白标识符、基因名；同理表示组成B；\nreceptor_a 表示组成A是否为受体；其它列含义可参看官方手册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 sig_m = read.table(\u0026#34;./pbmc_out/significant_means.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=T, check.names=F) t(sig_m[1,]) # 1 # id_cp_interaction \u0026#34;CPI-SS0E292C126\u0026#34; # interacting_pair \u0026#34;KLRB1_CLEC2D\u0026#34; # partner_a \u0026#34;simple:Q12918\u0026#34; # partner_b \u0026#34;simple:Q9UHP7\u0026#34; # gene_a \u0026#34;KLRB1\u0026#34; # gene_b \u0026#34;CLEC2D\u0026#34; # secreted \u0026#34;False\u0026#34; # receptor_a \u0026#34;True\u0026#34; # receptor_b \u0026#34;True\u0026#34; # annotation_strategy \u0026#34;curated\u0026#34; # is_integrin \u0026#34;False\u0026#34; # rank \u0026#34;0.04\u0026#34; # cluster0|cluster0 NA # cluster0|cluster1 NA # cluster0|cluster2 NA # cluster0|cluster3 NA # cluster0|cluster4 NA # cluster1|cluster0 NA # cluster1|cluster1 NA # cluster1|cluster2 NA # cluster1|cluster3 NA # cluster1|cluster4 NA # cluster2|cluster0 \u0026#34;0.291\u0026#34; # cluster2|cluster1 NA # cluster2|cluster2 NA # cluster2|cluster3 NA # cluster2|cluster4 NA # cluster3|cluster0 NA # cluster3|cluster1 NA # cluster3|cluster2 NA # cluster3|cluster3 NA # cluster3|cluster4 NA # cluster4|cluster0 NA # cluster4|cluster1 NA # cluster4|cluster2 NA # cluster4|cluster3 NA # cluster4|cluster4 NA 4、结果可视化 4.1 cellphonedb可视化 细胞类型间通讯热图，需要提供cellphonedb分析结果路径以及细胞类型注释结果 1 2 3 4 5 6 7 8 9 10 cellphonedb plot heatmap_plot \\ --pvalues-path ./pbmc_out/pvalues.txt \\ --output-path ./pbmc_out \\ --count-name heatmap_count.pdf \\ --log-name heatmap_log_count.pdf \\ --count-network-name count_network.txt \\ --interaction-count-name interaction_count.txt \\ ./prepared_meta.tsv # 根据是否log转换，会产生两张热图 配受体对的点图，需要提供cellphonedb分析结果路径 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 默认将所有配受体对的所有细胞类型组合进行可视化 cat rows.txt # KLRB1_CLEC2D # NRG1_MS4A4A # CLEC2B_KLRF1 # NCR3_BAG6 # CD40_CD40LG # NRG1_LSR cat columns.txt # cluster0|cluster0 # cluster0|cluster1 # cluster0|cluster2 # cluster0|cluster3 # cluster0|cluster4 cellphonedb plot dot_plot \\ --means-path ./pbmc_out/means.txt \\ --pvalues-path ./pbmc_out/pvalues.txt \\ --output-path ./pbmc_out \\ --output-name plot.pdf \\ --rows rows.txt \\ --columns columns.txt 4.2 ktplotspy可视化 上述cellphonedb提供的可视化方法较为简单，难以调整绘图细节。ktplotspy工具包可针对cellphonedb分析结果提供较为丰富的绘图方案。由于依赖包冲突，需要单独为ktplotspy单独创建一个conda环境。\n（1）创建conda环境 1 2 3 4 conda create -n cellphonedb_plot python notebook -y conda install -c bioconda r-seurat bioconductor-singlecellexperiment conda install -c bioconda anndata anndata2ri pip install ktplotspy 后续在jupyter notebook中操作、分析\n（2）导入数据：seurat对象转为anndata格式，并读入cellphonedb分析结果 1 2 3 4 5 6 7 8 import os import anndata as ad import pandas as pd import ktplotspy as kpy import matplotlib.pyplot as plt import anndata2ri anndata2ri.activate() %load_ext rpy2.ipython 1 2 3 4 %%R library(Seurat) sce = readRDS(\u0026#34;sce.rds\u0026#34;) sce 1 2 3 4 %%R -o anndata #convert the Seurat object to a SingleCellExperiment object anndata \u0026lt;- as.SingleCellExperiment(sce) anndata 1 2 3 4 5 6 7 8 9 anndata # AnnData object with n_obs × n_vars = 2700 × 32738 # obs: \u0026#39;orig.ident\u0026#39;, \u0026#39;nCount_RNA\u0026#39;, \u0026#39;nFeature_RNA\u0026#39;, \u0026#39;RNA_snn_res.0.1\u0026#39;, \u0026#39;seurat_clusters\u0026#39;, \u0026#39;cell_type\u0026#39;, \u0026#39;Cell\u0026#39;, \u0026#39;ident\u0026#39; # obsm: \u0026#39;X_pca\u0026#39;, \u0026#39;X_umap\u0026#39; # layers: \u0026#39;logcounts\u0026#39; means = pd.read_csv(\u0026#39;pbmc_out/means.txt\u0026#39;, sep = \u0026#39;\\t\u0026#39;) pvals = pd.read_csv(\u0026#39;pbmc_out/pvalues.txt\u0026#39;, sep = \u0026#39;\\t\u0026#39;) decon = pd.read_csv(\u0026#39;pbmc_out/deconvoluted.txt\u0026#39;, sep = \u0026#39;\\t\u0026#39;) （3）绘制热图 1 2 3 4 5 6 7 8 kpy.plot_cpdb_heatmap( adata=adata, pvals=pvals, celltype_key=\u0026#34;cell_type\u0026#34;, figsize = (5,5), # symmetrical = False, title = \u0026#34;Sum of significant interactions\u0026#34; ) （4）绘制点图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 kpy.plot_cpdb( adata=adata, cell_type1=\u0026#34;cluster0\u0026#34;, # cell_type1=\u0026#34;cluster[0,1]\u0026#34;, # this means culster0 and cluster1 cell_type2=\u0026#34;.\u0026#34;, # this means all cell-types means=means, pvals=pvals, celltype_key=\u0026#34;cell_type\u0026#34;, genes=[\u0026#34;CD44\u0026#34;], figsize = (10,5), # highlight_col = \u0026#34;red\u0026#34;, # highlight_size = 1, 将所有显著的配受体对标识圆环的宽度相同 default_style = True, title = \u0026#34;Interactions Dotplot\u0026#34; ) # cell_type1与cell_type2并无先后顺序的区别 （5）绘制弦图 1 2 3 4 5 6 7 8 9 10 11 12 kpy.plot_cpdb_chord( adata=adata, cell_type1=\u0026#34;.\u0026#34;, cell_type2=\u0026#34;.\u0026#34;, means=means, pvals=pvals, deconvoluted=decon, celltype_key=\u0026#34;cell_type\u0026#34;, genes=[\u0026#34;CD44\u0026#34;], edge_cmap=plt.cm.coolwarm, figsize=(6,6) ) 1 2 3 4 5 6 7 8 9 ## 可设置face_col_dict参数，修改每个条带的颜色 face_col_dict={ \u0026#34;cluster0\u0026#34;: \u0026#34;brown\u0026#34;, \u0026#34;cluster1\u0026#34;: \u0026#34;grey\u0026#34;, \u0026#34;cluster2\u0026#34;: \u0026#34;orange\u0026#34;, \u0026#34;cluster3\u0026#34;: \u0026#34;pink\u0026#34;, \u0026#34;cluster4\u0026#34;: \u0026#34;cyan\u0026#34;, }, edge_col_dict={\u0026#34;CD44-TYROBP\u0026#34;: \u0026#34;red\u0026#34;, \u0026#34;CD44-LGALS9\u0026#34;: \u0026#34;blue\u0026#34;} ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/026%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--cellphonedb%E7%BB%86%E8%83%9E%E9%80%9A%E8%AE%AF%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003ecellphonedb是基于配受体对表达水平，分析单细胞数据中不同细胞类型间相互作用的Python工具。其于2020年在nature protocols发表，目前工具包版本以更新到3.1.0，配受体数据库已更新到4版本。如下将简单学习该软件的用法及结果可视化方法。\u003c/p\u003e","title":"单细胞分析工具--cellphonedb细胞通讯分析"},{"content":" Pandas相比Numpy数组支持行列标签、多种数据类型，类似R语言中data.frame数据框。\n1、Pandas结构 1.1 Series：有索引的一维数组 1.1.1 创建Series对象 通过pd.Serise函数创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ##(1) 通过index参数设置索引 import pandas as pd data = pd.Series([1,2,3,4,5], index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;]) #a 1 #b 2 #c 3 #d 4 #e 5 #dtype: int64 ##(2)如不设置index参数，则索引默认为 range(len) data1 = pd.Series([1,2,3,4,5]) ##(3)也可以以字典的形式创建，键值分别对应索引与值 data2 = pd.Series({\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3,\u0026#39;d\u0026#39;:4,\u0026#39;e\u0026#39;:5}) 1.1.2 Series对象操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import pandas as pd data = pd.Series([1,2,3,4,5], index=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;d\u0026#39;,\u0026#39;e\u0026#39;]) ##(1) 提取Series的一维数组与索引标签 data.values # array([1, 2, 3, 4, 5]) data.index # Index([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], dtype=\u0026#39;object\u0026#39;) ##(2) 按显示索引取Series子集 data[\u0026#39;a\u0026#39;] data[\u0026#39;a\u0026#39;:\u0026#39;c\u0026#39;] data[[\u0026#34;a\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;e\u0026#34;]] data[data\u0026gt;3] data.loc[\u0026#34;a\u0026#34;:\u0026#34;c\u0026#34;] ##(3) 按隐式索引取Series子集 data[0] data[0:3] data[[0,2,4]] data.iloc[1:3] .loc与.iloc的作用主要体现在：Series的index也是数值型时，容易与隐式索引混淆。\n1.2 DataFrame：多个Series对象组成 DataFrame对象可以认为是多个等长、索引值对应相同的Series对象组成\n1.2.1 创建DataFrame对象 通过pd.DataFrame创建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ##(1) 单个Series转为DataFrame,通过columns参数设置列名 import pandas as pd s1 = pd.Series({\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3,\u0026#39;d\u0026#39;:4,\u0026#39;e\u0026#39;:5}) d1 = pd.DataFrame(s1, columns=[\u0026#34;col_01\u0026#34;]) # col_01 #a 1 #b 2 #c 3 #d 4 #e 5 ##(2) 多个相同索引的Series对象构成的字典 s2 = pd.Series({\u0026#39;a\u0026#39;:\u0026#34;Dog\u0026#34;,\u0026#39;b\u0026#39;:\u0026#34;Cat\u0026#34;,\u0026#39;c\u0026#39;:\u0026#34;Pig\u0026#34;,\u0026#39;d\u0026#39;:\u0026#34;Cow\u0026#34;,\u0026#39;e\u0026#39;:\u0026#34;Sheep\u0026#34;}) pd.DataFrame({\u0026#34;col_1\u0026#34;:s1, \u0026#34;col_2\u0026#34;:s2}) ##(3) 通过字典列表创建：每个子字典代表一行；键名表示列名，可通过index设置行名 pd.DataFrame([{\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3}, {\u0026#39;a\u0026#39;:2,\u0026#39;b\u0026#39;:4,\u0026#39;c\u0026#39;:6}], index=[\u0026#34;XiaoLi\u0026#34;,\u0026#34;XiaoWang\u0026#34;]) # a b c #XiaoLi 1 2 3 #XiaoWang 2 4 6 ##(4) 将NumPy二维数组转为DataFrame import numpy as np pd.DataFrame(np.random.randint(0,10,(2,3)), columns=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;], index=[\u0026#39;sp1\u0026#39;,\u0026#39;sp2\u0026#39;]) 1.2.2 DataFrame对象操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import pandas as pd import numpy as np s1 = pd.Series(np.random.choice(10,5,replace=False), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) s2 = pd.Series(np.random.randint(60,100,5), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) s3 = pd.Series([\u0026#39;class01\u0026#39;,\u0026#39;class01\u0026#39;,\u0026#39;class02\u0026#39;,\u0026#39;class02\u0026#39;,\u0026#39;class02\u0026#39;], index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) df = pd.DataFrame({\u0026#39;Grade\u0026#39;:s1,\u0026#34;Score\u0026#34;:s2,\u0026#34;Class\u0026#34;:s3}) # Grade Score Class #stuA 3 95 class01 #stuB 9 96 class01 #stuC 1 85 class02 #stuD 5 76 class02 #stuE 8 70 class02 ##(0) 初步探索 df.head() df.info() #表格概述信息 df.dtypes #每列的数据类型 df.shape df.size df.values #返回二维数组 df.T #行列转换 ##(1)获取行、列名（均为Index对象）以及值 df.index #行名 df.columns #列名 ##(2)返回列 df[\u0026#39;Grade\u0026#39;] df.Grade df[[\u0026#39;Grade\u0026#39;,\u0026#39;Score\u0026#39;]] df.loc[:,\u0026#39;Grade\u0026#39;:\u0026#39;Class\u0026#39;] df.iloc[:,0:3] df[\u0026#39;newCol\u0026#39;] = 0 ##(3)返回行 df.loc[\u0026#39;stuA\u0026#39;:\u0026#39;stuC\u0026#39;,:] df.loc[df[\u0026#34;Score\u0026#34;]\u0026gt;80,:] df.loc[[\u0026#39;stuA\u0026#39;,\u0026#39;stuC\u0026#39;],:] df.iloc[1:3,:] df[1:3] df.iloc[[0,2,4],:] df[df.Grade\u0026gt;5] #筛选符合条件的行 ##注意：如果仅取DataFrame的一行/一列，会返回为Serires对象；可加上中括号，返回为DataFrame df[[\u0026#39;Grade\u0026#39;]] df.loc[[\u0026#39;stuC\u0026#39;],:] 1.3 Index索引=列名+行名 1.3.1 Index索引对象 如上Series有索引，DataFrame有行、列的索引。可以为数值型(int)或者字符型(object)\n一方面Index可以认为是一维数组（不可改变其内容和顺序）；另一方面拥有集合对象的相关操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import pandas as pd idx = pd.Index([1,2,3,4,5]) # Int64Index([1, 2, 3, 4, 5], dtype=\u0026#39;int64\u0026#39;) ##(1) 数组相关操作 idx[0] #支持一维数组的各种取值方式 list(idx) #转为普通列表 ##(2) 集合相关操作 idx2 = pd.Index([4,5,6,7]) idx.intersection(idx2) # Int64Index([4, 5], dtype=\u0026#39;int64\u0026#39;) idx.union(idx2) 1.3.2 Index索引修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import pandas as pd import numpy as np s1 = pd.Series(np.random.choice(10,3,replace=False), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;]) s2 = pd.Series(np.random.randint(60,100,3), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;]) s3 = pd.Series([\u0026#39;class01\u0026#39;,\u0026#39;class01\u0026#39;,\u0026#39;class02\u0026#39;], index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;]) s4 = pd.Series([\u0026#39;Zhang\u0026#39;,\u0026#39;Li\u0026#39;,\u0026#39;Liu\u0026#39;], index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;]) df = pd.DataFrame({\u0026#39;Grade\u0026#39;:s1,\u0026#34;Score\u0026#34;:s2,\u0026#34;Class\u0026#34;:s3,\u0026#34;Name\u0026#34;:s4}) # Grade Score Class Name #stuA 0 60 class01 Zhang #stuB 8 65 class01 Li #stuC 2 80 class02 Liu ##(1)修改列名 df.rename(columns = {\u0026#34;Grade\u0026#34;:\u0026#34;Level\u0026#34;}) # {\u0026#34;Old_name\u0026#34;:\u0026#34;New_name\u0026#34;} ##(2)将特定列变成行名 df.set_index(\u0026#34;Name\u0026#34;) ##(3)将行名变为列 df[\u0026#34;ID\u0026#34;] = df.index 2、缺失值处理 None是一个python对象，表示缺失值。在数组中属于object类型(字符串属于object类型) NaN是有numpy定义的缺失值，属于浮点型数据 2.1 numpy中的缺失值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import numpy as np import pandas as pd ##(1) None缺失值 n1 = np.array([1,2,3,None]) # array([1, 2, 3, None], dtype=object) n1.min() # TypeError n1.astype(np.float64) #array([ 1., 2., 3., nan]) ##(2) NaN缺失值 n2 = np.array([1,2,3,np.nan]) # array([ 1., 2., 3., nan]) # dtype(\u0026#39;float64\u0026#39;) #含nan的一般统计运算都会返回nan值 n2.min() # nan #可使用针对处理含有nan的numpy数据 np.nanmin(n1) # 1.0 2.2 Pandas处理缺失值 pandas将None也视为np.nan，即浮点类型的缺失值。记录为NaN 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 pd.Series([1,np.nan,3, None]) #0 1.0 #1 NaN #2 3.0 #3 NaN #dtype: float64 #当pandas整型数据中出现一个缺失值时，会自动转为浮点型数据 s1 = pd.Series(np.random.choice(10,5,replace=False), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) s2 = pd.Series(np.random.randint(60,100,5), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) s3 = pd.Series([\u0026#39;class01\u0026#39;,\u0026#39;class01\u0026#39;,\u0026#39;class02\u0026#39;,\u0026#39;class02\u0026#39;,\u0026#39;class02\u0026#39;], index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) df = pd.DataFrame({\u0026#39;Grade\u0026#39;:s1,\u0026#34;Score\u0026#34;:s2,\u0026#34;Class\u0026#34;:s3}) df.iloc[2,0:2]=None df.iloc[4,1]=np.nan # Grade Score Class # stuA 1.0 91.0 class01 # stuB 3.0 61.0 class01 # stuC NaN NaN class02 # stuD 0.0 94.0 class02 # stuE 7.0 NaN class02 ##(1)判断缺失值 df.isnull() #是否为缺失值 df.notnull() #是否为非缺失值 ##(2)去除缺失值 df.dropna() #删除含有缺失值的整行数据 # axis=1 :删除含有缺失值的整列数据 # how :默认为\u0026#39;any\u0026#39;;\u0026#39;all\u0026#39;表示全为缺失值才删除 ##(3)填补缺失值 df.fillna(10) #固定值填充 df.fillna(method=\u0026#39;ffill\u0026#39;) #使用缺失值前面的数据填充 df.fillna(method=\u0026#39;bfill\u0026#39;) #使用缺失值后面的数据填充 3、Pandas运算与统计 3.1 Pandas运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import pandas as pd import numpy as np ##(1)整体算数运算：适用于介绍的np算法运算, 不影响原有结构 s1 = pd.Series({\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3,\u0026#39;d\u0026#39;:4,\u0026#39;e\u0026#39;:5}) #a 1 #b 2 #c 3 #d 4 #e 5 #dtype: int64 df1 = pd.DataFrame(np.random.randint(0,10,(2,3)), columns=[\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;], index=[\u0026#39;sp1\u0026#39;,\u0026#39;sp2\u0026#39;]) # a b c #sp1 5 9 4 #sp2 6 3 4 np.log(s1 + 1) df1 / 10 ##(2)Series之间索引对齐运算：即使顺序不同，按照索引一一对应计算 s2 = pd.Series({\u0026#39;a\u0026#39;:1,\u0026#39;d\u0026#39;:4,\u0026#39;e\u0026#39;:5,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3}) s1 + s2 #如果索引不一致，按全集处理，用NaN填充 s3 = pd.Series({\u0026#39;a\u0026#39;:1,\u0026#39;d\u0026#39;:4,\u0026#39;e\u0026#39;:5}) s1 + s3 ##(3)DataFrame与Series(行/列)之间运算 #按行 ss1 = pd.Series({\u0026#39;a\u0026#39;:1,\u0026#39;b\u0026#39;:2,\u0026#39;c\u0026#39;:3}) df1 - ss1 #所有行相减 df1.loc[[\u0026#34;sp1\u0026#34;],:]=df1.loc[[\u0026#34;sp1\u0026#34;],:]-ss1 #特定行相减 #按列 ss2 = pd.Series({\u0026#39;sp1\u0026#39;:10,\u0026#39;sp2\u0026#39;:20}) df1.subtract(ss2, axis=0) #所有列相减 df1.loc[:,\u0026#34;a\u0026#34;] = df1.loc[:,\u0026#34;a\u0026#34;] - ss2 #特定列相减 如上，Series之间或者DataFrame与Series按行按列之间计算时，会考虑索引对齐的问题；如果索引不一致，会取全集，用NaN填补。如果Series/DataFrame是与数组/列表运算，则必须保持运算双方维度一致，并且按顺序计算。\n3.2 Pandas统计 1 2 3 4 5 6 7 8 9 10 11 12 13 import pandas as pd import numpy as np df = pd.DataFrame(np.random.randint(0,100,(10,6)), index= [\u0026#34;stu%s\u0026#34; % (x) for x in range(10)], columns=[\u0026#34;col1\u0026#34;,\u0026#34;col2\u0026#34;,\u0026#34;col3\u0026#34;,\u0026#34;col4\u0026#34;,\u0026#34;col5\u0026#34;,\u0026#34;col6\u0026#34;]) df[\u0026#34;Group\u0026#34;] = [\u0026#34;Group%s\u0026#34; % (x) for x in list(\u0026#34;A\u0026#34;*5 + \u0026#34;B\u0026#34;*5)] df.head() # col1 col2 col3 col4 col5 col6 Group # stu0 0 30 31 72 20 2 GroupA # stu1 11 47 47 53 92 80 GroupA # stu2 47 39 11 25 78 57 GroupA # stu3 15 90 57 28 90 54 GroupA # stu4 30 9 92 85 40 7 GroupA Pandas内置常用数值列统计方法有 count() 计(行)数（但是会忽略NA值，需要格外注意）\nfirst(), last() 第一项与最后一项\nsum() 求和\nmean(), median(), min(), max()\nstd(), var(), mad()\ndescribe() 可以计算每一列的若干常用统计值\n3.2.1 基础统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ##(1)数值列统计方法默认只会对数值列统计 df.col1.sum() # 349 df.mean() # col1 34.9 # col2 39.8 # col3 54.2 # col4 34.9 # col5 64.4 # col6 43.5 # dtype: float64 df.describe() # col1 col2 col3 col4 col5 col6 # count 10.000000 10.000000 10.000000 10.000000 10.000000 10.0000 # mean 34.900000 39.800000 54.200000 34.900000 64.400000 43.5000 # std 23.811528 24.548365 31.688764 27.404176 31.885908 26.7426 # min 0.000000 9.000000 2.000000 1.000000 11.000000 2.0000 # 25% 17.250000 23.250000 35.000000 19.000000 42.250000 28.2500 # 50% 31.000000 36.000000 56.500000 28.500000 78.000000 50.0000 # 75% 50.750000 47.000000 78.500000 48.250000 89.250000 56.2500 # max 70.000000 90.000000 92.000000 85.000000 99.000000 80.0000 ##(2)统计分类 df.Group.value_counts() #频数 df.Group.value_counts(normalize=True) #百分比 df.Group.unique() #唯一值 df.describe(include=[\u0026#34;O\u0026#34;]) #分别统计所有字符串列 pd.crosstab(df.Group, df.Group) #类似R语言的table() 3.2.2 分组统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ##(1) 指定DataFrame表格中的表示分组信息的列，进行分组统计 df.groupby(\u0026#39;Group\u0026#39;)[\u0026#34;col2\u0026#34;].mean() #根据分组列，分组统计1列的值 # Group # GroupA 43.0 # GroupB 36.6 # Name: col2, dtype: float64 df.groupby(\u0026#39;Group\u0026#39;, as_index=False).mean() #根据分组列，分组统计所有列的值 df.groupby(\u0026#39;Group\u0026#39;)[\u0026#34;col2\u0026#34;].agg([\u0026#34;min\u0026#34;,\u0026#34;max\u0026#34;]) #根据分组列，分组统计1列的多个指标 df.groupby(\u0026#39;Group\u0026#39;)[\u0026#34;col2\u0026#34;].describe() #根据分组列，分组统计1列的多个指标 ##(2) 指定其它能够表示分组信息的，列表、Serises、字典等进行分组统计 Class = [\u0026#34;Class01\u0026#34;,\u0026#34;Class01\u0026#34;,\u0026#34;Class01\u0026#34;,\u0026#34;Class02\u0026#34;,\u0026#34;Class02\u0026#34;,\u0026#34;Class02\u0026#34;, \u0026#34;Class03\u0026#34;,\u0026#34;Class03\u0026#34;,\u0026#34;Class03\u0026#34;,\u0026#34;Class03\u0026#34;] df.groupby(Class)[\u0026#34;col2\u0026#34;].mean() # Class01 38.666667 # Class02 55.333333 # Class03 29.000000 # Name: col2, dtype: float64 3.3 Pandas排序 1 2 3 4 5 6 7 8 9 10 11 import pandas as pd import numpy as np df = pd.DataFrame(np.random.randint(0,100,(10,6)), index= [\u0026#34;stu%s\u0026#34; % (x) for x in range(10)], columns=[\u0026#34;col1\u0026#34;,\u0026#34;col2\u0026#34;,\u0026#34;col3\u0026#34;,\u0026#34;col4\u0026#34;,\u0026#34;col5\u0026#34;,\u0026#34;col6\u0026#34;]) df[\u0026#34;Group\u0026#34;] = [\u0026#34;Group%s\u0026#34; % (x) for x in list(\u0026#34;A\u0026#34;*5 + \u0026#34;B\u0026#34;*5)] df.sort_values(\u0026#34;col1\u0026#34;) #按照指定列升序排列 df.sort_values(\u0026#34;col1\u0026#34;, ascending=False) #按照指定列降序排列 df.sort_values([\u0026#34;col1\u0026#34;, \u0026#34;col2\u0026#34;], ascending=[True, False]) 4、字符串列处理 Pandas为DataFrame对象的字符串列(也包括Series对象)提供了str属性，提供了许多向量化处理字符串的方法，其中很多与Python的字符串方法相似。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import pandas as pd import numpy as np s1 = pd.Series(list(\u0026#34;ABBAC\u0026#34;), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) s2 = pd.Series(np.random.randint(60,100,5), index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) s3 = pd.Series([\u0026#39;class01\u0026#39;,\u0026#39;class01\u0026#39;,\u0026#39;class02\u0026#39;,\u0026#39;class02\u0026#39;,\u0026#39;class02\u0026#39;], index=[\u0026#34;stuA\u0026#34;,\u0026#39;stuB\u0026#39;,\u0026#39;stuC\u0026#39;,\u0026#39;stuD\u0026#39;,\u0026#39;stuE\u0026#39;]) df = pd.DataFrame({\u0026#39;Grade\u0026#39;:s1,\u0026#34;Score\u0026#34;:s2,\u0026#34;Class\u0026#34;:s3}) # Grade Score Class # stuA A 84 class01 # stuB B 68 class01 # stuC B 84 class02 # stuD A 78 class02 # stuE C 74 class02 ##(1) Python处理字符串方法 \u0026#34;level \u0026#34; + df.Grade df.Grade.str.len() df.Class.str.upper() df.Class.str.split(\u0026#34;0\u0026#34;) # stuA [class, 1] # stuB [class, 1] # stuC [class, 2] # stuD [class, 2] # stuE [class, 2] # Name: Class, dtype: object ##(2) 正则化处理字符串，类似 re 模块 df.Class.str.match(\u0026#39;([A-Za-z]+)\u0026#39;) #返回逻辑值 df.Class.str.extract(\u0026#39;([A-Za-z]+)\u0026#39;) #提取匹配子字符串 ##(3) 切片取值等 df.Class.str[0:3] df.Class.str.split(\u0026#34;0\u0026#34;).str.get(0) df.Class.str.split(\u0026#34;0\u0026#34;).str[0] 5、DataFrame筛选与修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import pandas as pd import numpy as np df = pd.DataFrame(np.random.randint(0,100,(10,6)), index= [\u0026#34;stu%s\u0026#34; % (x) for x in range(10)], columns=[\u0026#34;col1\u0026#34;,\u0026#34;col2\u0026#34;,\u0026#34;col3\u0026#34;,\u0026#34;col4\u0026#34;,\u0026#34;col5\u0026#34;,\u0026#34;col6\u0026#34;]) df[\u0026#34;Group\u0026#34;] = [\u0026#34;Group%s\u0026#34; % (x) for x in list(\u0026#34;A\u0026#34;*3 + \u0026#34;B\u0026#34;*3 + \u0026#34;C\u0026#34;*4)] df.head() # col1 col2 col3 col4 col5 col6 Group # stu0 13 24 72 45 58 77 GroupA # stu1 93 29 67 38 95 7 GroupA # stu2 32 85 54 34 51 84 GroupA # stu3 16 92 36 10 51 67 GroupB # stu4 78 69 96 32 1 87 GroupB #### 下述默认是指筛选到符合条件的行 ##(1) 数值列筛选 df[df.col1\u0026gt;80] ##(2) 字符串列筛选 ##可结合正则表达式匹配筛选 df[df.Group==\u0026#34;GroupA\u0026#34;] ##(3) 多个条件筛选 df[(df.col1\u0026gt;50) \u0026amp; (df.Group==\u0026#34;GroupA\u0026#34;)] ##(4) 筛选特定范围的值 df[df.Group.isin([\u0026#34;GroupA\u0026#34;,\u0026#34;GroupB\u0026#34;])] df[~df.Group.isin([\u0026#34;GroupA\u0026#34;,\u0026#34;GroupB\u0026#34;])] # ~ 表示逻辑 非 ##(5) query语句 df.query(\u0026#39;col1\u0026gt;50 and Group==\u0026#34;GroupC\u0026#34;\u0026#39;) ##(6) 去重 df.drop_duplicates([\u0026#34;Group\u0026#34;]) ##直接删除指定列 df.drop([column], axis=1) ##直接删除指定行 df.drop([index]) 1 2 3 4 5 6 7 8 9 10 11 12 13 ##(1) replace替换 df.Group.unique() # array([\u0026#39;GroupA\u0026#39;, \u0026#39;GroupB\u0026#39;, \u0026#39;GroupC\u0026#39;], dtype=object) ##一对一替换 df[\u0026#34;Group\u0026#34;].replace(\u0026#34;GroupA\u0026#34;,\u0026#34;GroupC\u0026#34;).unique() # array([\u0026#39;GroupC\u0026#39;, \u0026#39;GroupB\u0026#39;], dtype=object) ##多对一替换 df[\u0026#34;Group\u0026#34;].replace([\u0026#34;GroupA\u0026#34;,\u0026#34;GroupB\u0026#34;],\u0026#34;GroupC\u0026#34;).unique() # array([\u0026#39;GroupC\u0026#39;], dtype=object) ##(2) map替换 df[\u0026#34;Group\u0026#34;].map({\u0026#34;GroupA\u0026#34;:\u0026#34;class01\u0026#34;, \u0026#34;GroupB\u0026#34;:\u0026#34;class02\u0026#34;, \u0026#34;GroupC\u0026#34;:\u0026#34;class03\u0026#34;}).unique() # array([\u0026#39;class01\u0026#39;, \u0026#39;class02\u0026#39;, \u0026#39;class03\u0026#39;], dtype=object) 6、DataFrame合并 6.1 pd.concat 对于Series对象的合并比较简单，容易；\npd.concat合并两个DataFrame时，适合于这两个DataFrame的行名或列名索引完全相同，大部分相同的情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 import numpy as np import pandas as pd df1 = pd.DataFrame(np.random.randint(0, 20, (3,4)), columns=[\u0026#39;col1\u0026#39;,\u0026#39;col2\u0026#39;,\u0026#39;col3\u0026#39;,\u0026#39;col4\u0026#39;], index=[\u0026#39;sp1\u0026#39;,\u0026#39;sp2\u0026#39;,\u0026#39;sp3\u0026#39;]) # col1 col2 col3 col4 # sp1 11 10 19 13 # sp2 6 13 18 10 # sp3 5 14 6 10 df2 = pd.DataFrame(np.random.randint(0, 20, (2,4)), columns=[\u0026#39;col1\u0026#39;,\u0026#39;col2\u0026#39;,\u0026#39;col3\u0026#39;,\u0026#39;col4\u0026#39;], index=[\u0026#39;sp4\u0026#39;,\u0026#39;sp5\u0026#39;]) # col1 col2 col3 col4 # sp4 11 2 0 2 # sp5 11 19 12 4 df3 = pd.DataFrame(np.random.randint(0, 20, (2,4)), columns=[\u0026#39;col1\u0026#39;,\u0026#39;col2\u0026#39;,\u0026#39;col3\u0026#39;,\u0026#39;col4\u0026#39;], index=[\u0026#39;sp3\u0026#39;,\u0026#39;sp4\u0026#39;]) # col1 col2 col3 col4 # sp3 13 5 3 15 # sp4 7 2 2 13 df4 = pd.DataFrame(np.random.randint(0, 20, (2,4)), columns=[\u0026#39;col3\u0026#39;,\u0026#39;col4\u0026#39;,\u0026#39;col5\u0026#39;,\u0026#39;col6\u0026#39;], index=[\u0026#39;sp4\u0026#39;,\u0026#39;sp5\u0026#39;]) # col3 col4 col5 col6 # sp4 11 1 2 15 # sp5 18 2 5 18 df5 = pd.DataFrame(np.random.randint(0, 6, (3,2)), columns=[\u0026#39;col5\u0026#39;,\u0026#39;col6\u0026#39;], index=[\u0026#39;sp1\u0026#39;,\u0026#39;sp2\u0026#39;,\u0026#39;sp3\u0026#39;]) # col5 col6 # sp1 0 5 # sp2 5 3 # sp3 2 0 ##(1)普通合并--列名相同，行名不同，上下合并 pd.concat([df1, df2]) ##(2)普通合并--行名相同，列名不同，左右合并 pd.concat([df1, df5], axis=1) ##(3)上下合并时，忽略索引重复 pd.concat([df1, df3]) #允许存在重复行名 pd.concat([df1, df3]).reset_index() pd.concat([df1, df3], verify_integrity=True) #有重复行名会报错 pd.concat([df1, df3], ignore_index=True) #重命名所有列名去重 ##(4)上下合并时，列名不完全一致 pd.concat([df1, df4]) #默认保留全集列名 pd.concat([df1, df4], join=\u0026#39;inner\u0026#39;) #仅保留交集索引 6.2 pd.merge 类似R语言中dplyr包的join系列函数；\n主要用于两个DataFrame有相同列的情况。\n6.2.1 有相同列，列名相同 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 df1 = pd.DataFrame([{\u0026#39;Stu\u0026#39;:\u0026#34;XiaoLi\u0026#34;,\u0026#39;Grade\u0026#39;:2,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoSun\u0026#34;,\u0026#39;Grade\u0026#39;:1,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoAi\u0026#34;,\u0026#39;Grade\u0026#39;:3,\u0026#39;Class\u0026#39;:\u0026#39;C02\u0026#39;}]) # Stu Grade Class # 0 XiaoLi 2 C01 # 1 XiaoSun 1 C01 # 2 XiaoAi 3 C02 df2 = pd.DataFrame([{\u0026#39;Class\u0026#39;:\u0026#34;C01\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Zhou\u0026#34;}, {\u0026#39;Class\u0026#39;:\u0026#34;C02\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Wu\u0026#34;}]) # Class Teacher # 0 C01 Mr.Zhou # 1 C02 Mr.Wu ##如上会自动按照Class列合并两个DataFrmae pd.merge(df1, df2) #等价于 pd.merge(df1, df2, on=\u0026#34;Class\u0026#34;) 当两个DataFrame中不同含义的列碰巧具有相同的列名时，可进行重命名加以区分 1 2 3 4 5 6 7 df1 = pd.DataFrame([{\u0026#39;Stu\u0026#39;:\u0026#34;XiaoLi\u0026#34;,\u0026#39;Grade\u0026#39;:2,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoSun\u0026#34;,\u0026#39;Grade\u0026#39;:1,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoAi\u0026#34;,\u0026#39;Grade\u0026#39;:3,\u0026#39;Class\u0026#39;:\u0026#39;C02\u0026#39;}]) df2 = pd.DataFrame([{\u0026#39;Class\u0026#39;:\u0026#34;C01\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Zhou\u0026#34;,\u0026#39;Grade\u0026#39;:\u0026#39;A\u0026#39;}, {\u0026#39;Class\u0026#39;:\u0026#34;C02\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Wu\u0026#34;,\u0026#39;Grade\u0026#39;:\u0026#39;B\u0026#39;}]) pd.merge(df1, df2, on=\u0026#34;Class\u0026#34;) pd.merge(df1, df2, on=\u0026#34;Class\u0026#34;, suffixes=[\u0026#34;_stu\u0026#34;,\u0026#34;_class\u0026#34;]) 6.2.2 有相同列，列名不同 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##(1) 指定列名合并 df1 = pd.DataFrame([{\u0026#39;Stu\u0026#39;:\u0026#34;XiaoLi\u0026#34;,\u0026#39;Grade\u0026#39;:2,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoSun\u0026#34;,\u0026#39;Grade\u0026#39;:1,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoAi\u0026#34;,\u0026#39;Grade\u0026#39;:3,\u0026#39;Class\u0026#39;:\u0026#39;C02\u0026#39;}]) df2 = pd.DataFrame([{\u0026#39;Room\u0026#39;:\u0026#34;C01\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Zhou\u0026#34;}, {\u0026#39;Room\u0026#39;:\u0026#34;C02\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Wu\u0026#34;}]) #如上df1的Class列与df2的Room列表示相同的含义 pd.merge(df1, df2, left_on=\u0026#34;Class\u0026#34;, right_on=\u0026#34;Room\u0026#34;) pd.merge(df1, df2, left_on=\u0026#34;Class\u0026#34;, right_on=\u0026#34;Room\u0026#34;).drop(\u0026#34;Room\u0026#34;, axis=1) ##(2)指定索引合并 df2.set_index(\u0026#34;Room\u0026#34;, inplace=True) # Teacher # Room # C01 Mr.Zhou # C02 Mr.Wu pd.merge(df1, df2, left_on=\u0026#34;Class\u0026#34;, right_index=True) 6.2.3 列的内容不完全相同 当两个DataFrame的相同列的内容不完全时，可设置pd.merge()的how参数进行不同的合并，可选inner(default), left, right, outer\n类似R包dplyr的inner_join(), left_join(), right_join(), full_join()函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 ##以其中的how=\u0026#34;left\u0026#34;为例 df1 = pd.DataFrame([{\u0026#39;Stu\u0026#39;:\u0026#34;XiaoLi\u0026#34;,\u0026#39;Grade\u0026#39;:2,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoSun\u0026#34;,\u0026#39;Grade\u0026#39;:1,\u0026#39;Class\u0026#39;:\u0026#39;C01\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoAi\u0026#34;,\u0026#39;Grade\u0026#39;:3,\u0026#39;Class\u0026#39;:\u0026#39;C02\u0026#39;}, {\u0026#39;Stu\u0026#39;:\u0026#34;XiaoHe\u0026#34;,\u0026#39;Grade\u0026#39;:3,\u0026#39;Class\u0026#39;:\u0026#39;C03\u0026#39;},]) df2 = pd.DataFrame([{\u0026#39;Class\u0026#39;:\u0026#34;C01\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Zhou\u0026#34;}, {\u0026#39;Class\u0026#39;:\u0026#34;C02\u0026#34;,\u0026#39;Teacher\u0026#39;:\u0026#34;Mr.Wu\u0026#34;}]) pd.merge(df1, df2, how=\u0026#34;left\u0026#34;) # Stu Grade Class Teacher # 0 XiaoLi 2 C01 Mr.Zhou # 1 XiaoSun 1 C01 Mr.Zhou # 2 XiaoAi 3 C02 Mr.Wu # 3 XiaoHe 3 C03 NaN 7、DataFrame导入与导出 1 2 3 4 5 6 7 8 9 10 import numpy as np import pandas as pd df = pd.DataFrame(np.random.randint(0, 20, (3,4)), columns=[\u0026#39;col1\u0026#39;,\u0026#39;col2\u0026#39;,\u0026#39;col3\u0026#39;,\u0026#39;col4\u0026#39;], index=[\u0026#39;sp1\u0026#39;,\u0026#39;sp2\u0026#39;,\u0026#39;sp3\u0026#39;]) # col1 col2 col3 col4 # sp1 11 10 19 13 # sp2 6 13 18 10 # sp3 5 14 6 10 7.1 导出 1 2 3 4 5 6 7 8 9 df.to_csv(\u0026#39;test.csv\u0026#39;) df.to_csv(\u0026#39;test.txt\u0026#39;, sep=\u0026#34;\\t\u0026#34;) #指定分隔符 df.to_csv(\u0026#39;test.csv\u0026#39;, index=False) #不保存行名 df.to_csv(\u0026#39;test.csv\u0026#39;, header=False) #不保存列名 df.to_excel(\u0026#39;test.xlsx\u0026#39;) #需要提前安装openpyxl模块 df.to_excel(\u0026#39;test.xlsx\u0026#39;,sheet_name=\u0026#39;Sheet1\u0026#39;) #自定义保存的sheet名称 df. 7.2 导入 1 2 3 4 5 6 7 8 9 df0 = pd.read_csv(\u0026#39;./test.txt\u0026#39;) #默认第一行为列名，且没有行名 df0 = pd.read_csv(\u0026#39;./test.txt\u0026#39;, sep=\u0026#34;\\t\u0026#34;) #指定分隔符 df0 = pd.read_csv(\u0026#39;./test.csv\u0026#39;, header=None) #不设置列名 df0 = pd.read_csv(\u0026#39;./test.csv\u0026#39;, names=list(\u0026#34;ABCD\u0026#34;)) #自定义列名 df0 = pd.read_csv(\u0026#39;./test.csv\u0026#39;, index_col=0) #指定第一列(索引为0)作为行名 df0 = pd.read_csv(\u0026#39;./test.csv\u0026#39;, index_col=\u0026#34;col1\u0026#34;) #指定列作为行名 df0 = pd.read_excel(\u0026#39;test.xlsx\u0026#39;) 8、长宽转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data = { \u0026#39;Name\u0026#39;: [\u0026#39;Alice\u0026#39;, \u0026#39;Bob\u0026#39;], \u0026#39;Math\u0026#39;: [85, 90], \u0026#39;English\u0026#39;: [92, 88] } df_wide = pd.DataFrame(data) # Name Math English # 0 Alice 85 92 # 1 Bob 90 88 ## (1) 宽变长 df_long = df_wide.melt(id_vars=[\u0026#39;Name\u0026#39;], var_name=\u0026#39;Subject\u0026#39;, value_name=\u0026#39;Score\u0026#39;) # Name Subject Score # 0 Alice Math 85 # 1 Bob Math 90 # 2 Alice English 92 # 3 Bob English 88 ## (2) 长变宽 df_wide = df_long.pivot(index=\u0026#39;Name\u0026#39;, columns=\u0026#39;Subject\u0026#39;, values=\u0026#39;Score\u0026#39;) # Subject English Math # Name # Alice 92 85 # Bob 88 90 ","permalink":"https://lishensuo.github.io/en/posts/program/022python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-pandas%E8%A1%A8%E6%A0%BC/","summary":"\u003cblockquote\u003e\n\u003cp\u003ePandas相比Numpy数组支持行列标签、多种数据类型，类似R语言中data.frame数据框。\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-b4c441acfb525f6e.png\" alt=\"img\" style=\"zoom: 33%;\" /\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1pandas结构\"\u003e1、Pandas结构\u003c/h1\u003e\n\u003ch2 id=\"11-series有索引的一维数组\"\u003e1.1 Series：有索引的一维数组\u003c/h2\u003e\n\u003ch3 id=\"111-创建series对象\"\u003e1.1.1 创建Series对象\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e通过\u003ccode\u003epd.Serise\u003c/code\u003e函数创建\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) 通过index参数设置索引\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata = pd.Series([\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e], index=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;c\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;d\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;e\u0026#39;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#a    1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#b    2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#c    3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#d    4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#e    5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#dtype: int64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2)如不设置index参数，则索引默认为 range(len)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata1 = pd.Series([\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(3)也可以以字典的形式创建，键值分别对应索引与值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata2 = pd.Series({\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;c\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;d\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;e\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"112-series对象操作\"\u003e1.1.2 Series对象操作\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata = pd.Series([\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e], index=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;c\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;d\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;e\u0026#39;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) 提取Series的一维数组与索引标签\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata.values\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# array([1, 2, 3, 4, 5])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata.index\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Index([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;], dtype=\u0026#39;object\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2) 按显示索引取Series子集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e] \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;c\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;c\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;e\u0026#34;\u003c/span\u003e]]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[data\u0026gt;\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata.loc[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e:\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;c\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(3) 按隐式索引取Series子集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata.iloc[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003e.loc\u003c/code\u003e与\u003ccode\u003e.iloc\u003c/code\u003e的作用主要体现在：Series的index也是数值型时，容易与隐式索引混淆。\u003c/p\u003e","title":"Python数据科学-(3)Pandas表格"},{"content":" R包DoubletFinder可用于检测基于Droplet单细胞测序技术(10X)的双细胞。如下简单学习识别原理以用法。\n原始论文：https://doi.org/10.1016/j.cels.2019.03.003 官方手册：https://github.com/chris-mcginnis-ucsf/DoubletFinder 视频教程：https://www.youtube.com/watch?v=NqvAS4HgmrE 1 2 remotes::install_github(\u0026#39;chris-mcginnis-ucsf/DoubletFinder\u0026#39;) library(DoubletFinder) Bug in Seurat v4: could not find function \u0026ldquo;paramSweep_v3\u0026rdquo; https://github.com/chris-mcginnis-ucsf/DoubletFinder/issues/184\n1 remotes::install_github(\u0026#39;https://github.com/ekernf01/DoubletFinder\u0026#39;, force = T) 1、原理简介 如下示意图可分为4个步骤 （1）根据随机两个单细胞的平均表达水平模拟出若干artificial doublet；\n（2）从模拟双细胞的角度，计算出这些模拟双细胞的最近邻细胞群；\n（3）从真实单细胞数据角度，计算每个细胞与模拟双细胞群的距离\u0026quot;pANN\u0026quot;;\n（4）最后通过期望的双细胞比例，设置\u0026quot;pANN\u0026quot;阈值，划分出双细胞群。\n在上述计算过程中涉及3个重要参数 （1）pN：模拟出的artificial doublet数量。不同取值对识别结果影响不大，默认为0.25。\n（2）pK：计算每个双细胞的最近邻居细胞数量，不同取值对识别结果影响很大，需结合数据选最佳值。\n（3）nExp：期望的双细胞群比例。如下图所示(10X v3.1)，不同测序数据体量的预期占比不同。\n例如对于10000个细胞的单细胞表达矩阵， 当pN=0.25、pK=0.1、nExp=0.08，表示如下含义：\n（1）随机模拟出3333个双细胞(总共13333)；（2）计算每个模拟双细胞的1333个最近邻细胞；\n（3）最终期望识别出800个双细胞。\n双细胞群根据组成细胞的转录相似性可分为如下两大类\n（1）heterotypic doublets ：doublets formed from transcriptionally-distinct cell states \u0026ndash; but is insensitive to homotypic doublets\n（2）homotypic doublets ：doublets formed from transcriptionally-similar cell states\n作者认为上述识别算法适合于检测heterotypic doublets，因此在计算过程中有必要考虑homotypic doublets所占比例的影响。\n2、计算过程 示例数据：10X官方提供的PBMC8K测序数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/pbmc8k untar(\u0026#34;pbmc8k_filtered_gene_bc_matrices.tar.gz\u0026#34;) counts = Read10X(\u0026#34;filtered_gene_bc_matrices/GRCh38/\u0026#34;) sce = CreateSeuratObject(counts) dim(sce) # [1] 33694 8381 ## (1) 预处理：质控过滤 + 降维分群 library(Seurat) library(tidyverse) sce = PercentageFeatureSet(sce, \u0026#34;^MT-\u0026#34;, col.name = \u0026#34;percent_mito\u0026#34;) sce = sce %\u0026gt;% subset(., nFeature_RNA \u0026gt; 500) %\u0026gt;% subset(., nCount_RNA \u0026gt; 800) %\u0026gt;% subset(., percent_mito \u0026lt; 10) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = 0.1) table(sce$seurat_clusters) # 0 1 2 3 4 5 6 7 # 2330 2039 1230 1142 970 339 213 108 DimPlot(sce, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;orig.ident\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## (2) DoubletFinder分析 library(DoubletFinder) # 首先获得最佳的pK值 sweep.res.list \u0026lt;- paramSweep_v3(sce, PCs = 1:30, sct = FALSE) sweep.stats \u0026lt;- summarizeSweep(sweep.res.list, GT = FALSE) bcmvn \u0026lt;- find.pK(sweep.stats) pk_best = bcmvn %\u0026gt;% dplyr::arrange(desc(BCmetric)) %\u0026gt;% dplyr::pull(pK) %\u0026gt;% .[1] %\u0026gt;% as.character() %\u0026gt;% as.numeric() # [1] 0.28 ggplot(bcmvn, aes(x=pK, y=BCmetric, group=1)) + geom_point() + geom_line() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 然后估算出双细胞群中，homotypic doublets的比例(optional) annotations \u0026lt;- sce$seurat_clusters homotypic.prop \u0026lt;- modelHomotypic(annotations) # [1] 0.1928876 # 根据10X V3.1,对于8K+的单细胞数据，期望的双细胞占比为7%左右 nExp_poi \u0026lt;- round(0.07*nrow(sce@meta.data)) #586 nExp_poi.adj \u0026lt;- round(nExp_poi*(1-homotypic.prop)) #473 # 最后根据上述参数(pN=0.25, pK=0.28, nExp=0.07), 识别出双细胞 sce \u0026lt;- doubletFinder_v3(sce, PCs = 1:30, pN = 0.25, pK = pk_best, nExp = nExp_poi, # nExp = nExp_poi.adj, reuse.pANN = FALSE, sct = FALSE) head(sce@meta.data[,c(\u0026#34;pANN_0.25_0.28_586\u0026#34;, \u0026#34;DF.classifications_0.25_0.28_586\u0026#34;)]) # pANN_0.25_0.28_586 DF.classifications_0.25_0.28_586 # AAACCTGAGCATCATC-1 0.21824 Singlet # AAACCTGAGCTAACTC-1 0.35488 Singlet # AAACCTGAGCTAGTGG-1 0.18624 Singlet # AAACCTGCACATTAGC-1 0.10816 Singlet # AAACCTGCACTGTTAG-1 0.34528 Singlet # AAACCTGCATAGTAAG-1 0.35904 Singlet DimPlot(sce, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;DF.classifications_0.25_0.28_586\u0026#34;) VlnPlot(sce, group.by = \u0026#34;DF.classifications_0.25_0.28_586\u0026#34;, features = c(\u0026#34;nCount_RNA\u0026#34;, \u0026#34;nFeature_RNA\u0026#34;), pt.size = 0, ncol = 2) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/027%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--doubletfinder%E8%AF%86%E5%88%AB%E5%8F%8C%E7%BB%86%E8%83%9E/","summary":"\u003cblockquote\u003e\n\u003cp\u003eR包DoubletFinder可用于检测基于Droplet单细胞测序技术(10X)的双细胞。如下简单学习识别原理以用法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e原始论文：https://doi.org/10.1016/j.cels.2019.03.003\u003c/li\u003e\n\u003cli\u003e官方手册：https://github.com/chris-mcginnis-ucsf/DoubletFinder\u003c/li\u003e\n\u003cli\u003e视频教程：https://www.youtube.com/watch?v=NqvAS4HgmrE\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eremotes::install_github(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;chris-mcginnis-ucsf/DoubletFinder\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(DoubletFinder)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eBug in Seurat v4: could not find function \u0026ldquo;paramSweep_v3\u0026rdquo;\n\u003ca href=\"https://github.com/chris-mcginnis-ucsf/DoubletFinder/issues/184\"\u003ehttps://github.com/chris-mcginnis-ucsf/DoubletFinder/issues/184\u003c/a\u003e\u003c/p\u003e","title":"单细胞分析工具--DoubletFinder识别双细胞"},{"content":"1、启动方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import matplotlib.pyplot as plt %matplotlib inline import numpy as np ##(1)在普通python解释器/python脚本中 x = np.linspace(0,10,100) plt.plot(x, np.sin(x), \u0026#39;-\u0026#39;) plt.show() ##(2)在ipython解释器中 %matplotlib #只需声明一次 x = np.linspace(0,10,100) plt.plot(x, np.sin(x), \u0026#39;-\u0026#39;) ##(3)在jupyter中 %matplotlib inline #只需声明一次 x = np.linspace(0,10,100) plt.plot(x, np.sin(x), \u0026#39;-\u0026#39;) 下述命令均在jupyter中学习\n2、绘图基础 2.1 基本原则 首先需要明白画板figure与坐标系axes的关系\n（1）基于matplot方式绘图时，必须首先创建画板(显式或隐式的方法)\n（2）一个画板可以只绘制一张图(axis)，也可以划分为多个子图(axes)\n（3）一张图内可以同时叠加多种图形类型，比如线图、点图等\n（1）关于创建画板 plt.figure()可以显示地创建新画板，以及默认的一个axes 使用plt.***系列绘图函数 首先会寻找当前活跃的画板与Axes，然后在其基础上继续绘图 若没有找到，则会隐式地创建一个新画板，以及默认的一个axes 基于axes对象的绘图方法可针对特定Axes实例进行一对一的绘图 使用axes绘图方法时，会定义当前活跃的axes；之后可继续使用plt.***系列函数 1 2 3 4 5 6 7 8 9 10 11 12 13 ##(1) 显式创建画板 # 显式创建画板，并赋值给fig变量，可以方便后续图片调用与保存等 fig = plt.figure() # 仅显式创建画板，不赋值；不会影响后面的绘图 # plt.figure() # 若直接在画板绘图，默认画板仅包含一张图 plt.plot([1,2],[2,1]) ##(2) 隐式创建画板 #若事先没有定义画板 #plt绘图函数会自动创建一个画板和一个axes plt.plot([1,2],[2,1]) 若使用plt.***继续绘图前没有创建画板时\n若之前已有活跃的画板，会继续在叠加图形 1 2 3 plt.figure() plt.plot([1,2],[2,1]) plt.plot([1,2],[1,2]) 若目前都没有画板，或者想另建一个画板 1 2 3 4 5 6 #隐式创建画板 plt.plot([1,2],[2,1]) #显式另创建画板 plt.figure() plt.plot([1,2],[1,2]) （2）多子图绘图模式 方法1：首先创建画板，然后划分子图 1 2 3 4 5 6 7 8 9 ## (1) .add_subplot() 方法 fig = plt.figure() ax1 = fig.add_subplot(2,1,1) ax1.plot([1,2],[-1,-2]) plt.plot([1,2],[1,2]) #在当前活跃的axes中绘图 ax2 = fig.add_subplot(2,1,2) ax2.plot([1,2],[-2,-1]) plt.plot([1,2],[2,1]) #在当前活跃的axes中绘图 plt.***系列广义绘图函数会在当前活跃的画板/axes上画图(如没有，会创建)\nax.***系列基于对象的绘图函数会点对点的在指定axes中进行绘图\n1 2 3 4 5 6 7 8 9 ## (2) plt.subplot() 函数 fig = plt.figure() ax1 = plt.subplot(2,1,1) ax1.plot([1,2],[-1,-2]) plt.plot([1,2],[1,2]) ax2 = plt.subplot(2,1,2) ax2.plot([1,2],[-2,-1]) plt.plot([1,2],[2,1]) 方法2：直接创建含有若干子图的画板 1 2 3 fig, ax = plt.subplots(1,2) ax[0].plot([1,2],[-1,-2]) ax[1].plot([1,2],[1,2]) 当然也适用于画板中仅包含一张图的情况。\n2.2 基于plt接口的常用方式 plt.plot() : 最基础绘图命令，用于绘制点图、线图\nplt.title(), plt.xlabel(), plt.ylabel() : 用于设置总标题、x轴标题、y轴标题\nplt.xlim(), plt.ylim() , plt.axis(): 用于设置x轴与y轴的范围\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import matplotlib.pyplot as plt %matplotlib inline import numpy as np x = np.linspace(0,10,100) ##(1) 极简绘图 plt.plot(x, np.sin(x), \u0026#39;-\u0026#39;) ##(2) 可多图叠加在一个坐标轴体系 plt.plot(x, np.sin(x), \u0026#39;-\u0026#39;) plt.plot(x, np.cos(x), \u0026#39;--\u0026#39;) ##(3) 应用上述参数 fig1 = plt.figure() plt.plot(x, x, \u0026#39;-\u0026#39;) plt.xlim(1,5) plt.ylim(2,6) # plt.axis([1,5,2,6]) plt.xlabel(\u0026#34;AA\u0026#34;) plt.ylabel(\u0026#34;BB\u0026#34;) plt.title(\u0026#34;TITLE\u0026#34;) fig1 #展示图片 fig1.savefig(\u0026#34;test.png\u0026#34;) #保存图片 from IPython.display import Image Image(\u0026#34;test.png\u0026#34;) #读取图片 2.3 基于对象接口的常用方式 上面所说大部分plt命令都可转为对象的方法。相比之下更加灵活、尤其在绘制多子图时。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import matplotlib.pyplot as plt %matplotlib inline import numpy as np x = np.linspace(0,10,100) ##(1) 基础 x = np.linspace(0,10,100) ax = plt.axes() #轴+标签 ax.plot(x, x+1) ##(2) 部分与plt函数名有出入的对象方法 ax = plt.axes() ax.plot(x, x+1) ax.set_xlim(1,5) ax.set_ylim(2,6) ax.set_xlabel(\u0026#34;AA\u0026#34;) ax.set_ylabel(\u0026#34;BB\u0026#34;) ax.set_title(\u0026#34;TITLE\u0026#34;) ##(3) 通过set方法提前设置绘图属性 ax = plt.axes() ax.set(xlabel=\u0026#34;AA\u0026#34;, ylabel=\u0026#34;BB\u0026#34;, title=\u0026#34;TITLE\u0026#34;, xlim=(1,5), ylim=(2,6)) ax.plot(x, x+1) 3、plt.plot绘制线图与点图 （1）线图 plt.plot()默认绘制线图\ncolor参数设置颜色(也适用于后面的绘图)，linestyle参数设置线型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import matplotlib.pyplot as plt import numpy as np %matplotlib inline x = np.linspace(0,10,100) ##(1) color #可以是标准颜色名称，十六进制颜色代码，颜色简写等 #‘b’-blue;‘g’-green; ‘r’-red;‘c’-cyan;‘m’-magenta;‘y’-yellow;‘k’-black;‘w’-white plt.plot(x, x+1, color=\u0026#34;red\u0026#34;) plt.plot(x, x+2, color=\u0026#34;#7fc97f\u0026#34;) plt.plot(x, x+3, color=\u0026#34;k\u0026#34;) ##(2) linestyle #可以是标准线型名称，或者符号表示 plt.plot(x, x+1, linestyle=\u0026#34;-\u0026#34;) # solid(default) plt.plot(x, x+2, linestyle=\u0026#34;--\u0026#34;) # dashed plt.plot(x, x+3, linestyle=\u0026#34;:\u0026#34;) # dotted （2）点图 通过设置marker参数设置点的形状，以表明绘制点图\n1 2 3 4 5 6 7 import matplotlib.pyplot as plt import numpy as np %matplotlib inline x = np.linspace(0, 10, 20) plt.plot(x, x+1, \u0026#39;o\u0026#39;) # circle plt.plot(x, x+2, \u0026#39;.\u0026#39;) # point plt.plot(x, x+3, \u0026#39;,\u0026#39;) # pixel plt.scatter绘制散点图 c表示点的属性映射点的颜色集，可配合cmap参数使用；s表示点的属性映射点的大小\n1 2 3 4 5 6 7 import matplotlib.pyplot as plt import numpy as np %matplotlib inline x = np.linspace(0, 10, 20) colors = np.random.random(20) # plt.cm.get_cmap(\u0026#34;coolwarm\u0026#34;) #预先查看示例 plt.scatter(x, x+1, c=colors, cmap = plt.cm.coolwarm) 在https://www.osgeo.cn/matplotlib/tutorials/colors/colormaps.html，可查看plt.cm所提供的所有颜色系列。\n4、修饰绘图细节 （1）绘图主题 python的style模块提供了一组用于绘制特定风格主题的图形\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import matplotlib as mpl import matplotlib.pyplot as plt import numpy as np %matplotlib inline print(plt.style.available[0:10]) # [\u0026#39;Solarize_Light2\u0026#39;, # \u0026#39;_classic_test_patch\u0026#39;, # \u0026#39;_mpl-gallery\u0026#39;, # \u0026#39;_mpl-gallery-nogrid\u0026#39;, # \u0026#39;bmh\u0026#39;, # \u0026#39;classic\u0026#39;, # \u0026#39;dark_background\u0026#39;, # \u0026#39;fast\u0026#39;, # \u0026#39;fivethirtyeight\u0026#39;, # \u0026#39;ggplot\u0026#39;] #只需在绘图前声明，会改变之后所有绘图的风格 plt.style.use(\u0026#34;classic\u0026#34;) x = np.linspace(0,10,20) plt.plot(x, x+1) （2）图例 plt.legend默认按照每个plot的label标签绘制legend\nloc 修改legend的位置，默认为“best” ncol 修改列数；fontsize 字体大小；title 设置标题 1 2 3 4 5 6 x = np.linspace(0,10,100) plt.plot(x, x+1, label=\u0026#34;group-1\u0026#34;) plt.plot(x, np.sin(x), label=\u0026#34;group-2\u0026#34;) #plt.legend() plt.legend(loc=\u0026#34;best\u0026#34;, ncol=2, fontsize = 12,title=\u0026#34;legend title\u0026#34;) （3）文本注释 plt.text：前两个参数设置注释文本的坐标，第三个参数交代注释文本内容，之后的参数对文本的格式属性进行调节，其中ha可以调整注释文本相对于坐标点的位置，默认为左对齐。\n1 2 3 4 5 6 7 8 9 10 11 x = np.linspace(0,10,20) plt.plot(x, x+1,\u0026#34;o\u0026#34;) plt.text(2,2,\u0026#34;Annotation1\u0026#34;, size=12, color=\u0026#34;red\u0026#34;) plt.text(8,8,\u0026#34;Annotation-ha-center\u0026#34;, ha=\u0026#39;center\u0026#39;) ##如上默认在所提供的坐标位置处进行注释 ##如果想按坐标轴相对左下角的位置进行注释，可使用ax方式绘图，设置transform参数 ax = plt.axes() ax.plot(x, x+1) plt.text(4,4,\u0026#34;Annotation-ha-center\u0026#34;, transform=ax.transData) #默认按照坐标 plt.text(0.2,0.8,\u0026#34;Annotation-ha-center\u0026#34;, transform=ax.transAxes) #相对坐标原点的位置 plt.annotate：可在注释文本加上箭头标注\n1 2 3 4 5 6 7 8 ## 第一个参数设置注释的文本 ## xy参数设置箭头指向的坐标 ## xytext参数设置箭头起点的坐标 ## arrowprops参数以字典的形式设置箭头的样式 x = np.linspace(0,10,20) plt.plot(x, x,\u0026#34;o\u0026#34;) plt.annotate(\u0026#34;This is point(2,2)\u0026#34;, xy=(2,2), xytext=(3,8), arrowprops=dict(facecolor=\u0026#34;black\u0026#34;)) 关于箭头，还有很多细节的调整，包括粗细、方向、曲度等等。\n（4）坐标轴刻度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ##(1) log单位的坐标轴刻度 ax = plt.axes(xscale=\u0026#39;log\u0026#39;, yscale=\u0026#39;log\u0026#39;) ax.plot(x, x) ##(2) 移除坐标轴的刻度线与标签 ax = plt.axes() ax.plot(x, x) ax.yaxis.set_major_locator(plt.NullLocator()) #移除y轴的刻度线与标签 ax.xaxis.set_major_formatter(plt.NullFormatter()) #仅移除x轴的标签 ##(3) 设置坐标轴的刻度线数量 ax = plt.axes() ax.plot(x, x) ax.yaxis.set_major_locator(plt.MaxNLocator(3)) 如上记录的Matplotlib的基本使用方式。关于绘图类型仅学习了点图与线图的绘制方式，实际上其支持许多种绘图类型。\nSeaborn是在Matplotlib基础上开发的一套新的绘图包。相对Matplotlib来说，Seaborn的绘图代码更加简洁、美观；更加可以使用dataframe数据绘制。(感觉可以对应于R语言中的ggplot)。\n","permalink":"https://lishensuo.github.io/en/posts/program/023python%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6-matplotlib%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003ch1 id=\"1启动方式\"\u003e1、启动方式\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e plt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e%matplotlib inline\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1)在普通python解释器/python脚本中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = np.linspace(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplt.plot(x, np.sin(x), \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;-\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplt.show()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2)在ipython解释器中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e%matplotlib                   \u003cspan style=\"color:#007f7f\"\u003e#只需声明一次\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = np.linspace(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplt.plot(x, np.sin(x), \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;-\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(3)在jupyter中               \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e%matplotlib inline            \u003cspan style=\"color:#007f7f\"\u003e#只需声明一次\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = np.linspace(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplt.plot(x, np.sin(x), \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;-\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e下述命令均在jupyter中学习\u003c/p\u003e","title":"Python数据科学-(4)Matplotlib可视化"},{"content":" MAST，全称Model-based Analysis of Single-cell Transcriptomics，是2015年于Genome Biology发表的R包工具，主要用于单细胞数据的差异表达分析。参看官方教程，简单记录用法如下。\n原始论文：https://genomebiology.biomedcentral.com/articles/10.1186/s13059-015-0844-5\nGithub：https://github.com/RGLab/MAST\n官方手册：http://bioconductor.org/packages/release/bioc/vignettes/MAST/inst/doc/MAITAnalysis.html\n1 BiocManager::install(\u0026#34;MAST\u0026#34;) 1 2 library(MAST) library(tidyverse) 1、示例数据 经细胞因子刺激前后的MAITs细胞的单细胞表达数据，使用MAST包分析其差异表达基因。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 data(maits, package=\u0026#39;MAST\u0026#39;) dim(maits$expressionmat) #共96个细胞 # [1] 96 16302 maits$expressionmat[1:4,1:4] head(maits$cdat) #细胞注释数据 head(maits$fdat) #基因注释数据 ##整理表达矩阵，使用symbol作为基因名 idx = -which(duplicated(maits$fdat$symbolid)) maits$fdat = maits$fdat[idx,] maits$fdat = maits$fdat[,-1] rownames(maits$fdat) = maits$fdat$symbolid maits$expressionmat = maits$expressionmat[,idx] colnames(maits$expressionmat) = rownames(maits$fdat) dim(maits$expressionmat) # [1] 96 15077 maits$expressionmat[1:4,1:4] # WASH7P FAM138F LOC100132062 LOC100133331 # 1-MAIT-Stim-C05_S91 0 0.08406426 3.7158934 6.829215 # 1-MAIT-Stim-C07_S70 0 0.12432814 0.0000000 0.000000 # 1-MAIT-Stim-C08_S68 0 1.79077204 0.0000000 0.000000 # 1-MAIT-Stim-C10_S95 0 1.71369581 0.2141248 0.000000 head(maits$fdat) # entrez symbolid # WASH7P 653635 WASH7P # FAM138F 641702 FAM138F # LOC100132062 100132062 LOC100132062 2、构建SingleCellAssay对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 sca = FromMatrix(t(maits$expressionmat), maits$cdat, maits$fdat) ## 方便演示，随机筛选出2000个基因 sca = sca[unique(sample(rownames(sca),2000)),] dim(sca) # [1] 16302 96 ## (1) 目标分组 table(colData(sca)$condition) # Stim Unstim # 47 49 ## 将Unstim设置为参考组 cond\u0026lt;-factor(colData(sca)$condition) cond\u0026lt;-relevel(cond,\u0026#34;Unstim\u0026#34;) colData(sca)$condition\u0026lt;-cond ## (2) 考虑一个协变量因素 summary(colData(sca)$cngeneson) # Min. 1st Qu. Median Mean 3rd Qu. Max. # -0.17159 -0.02578 0.01408 0.00000 0.05943 0.15415 ## (3) 模拟一个分类变量分组因素 set.seed(123) colData(sca)$region = sample(letters[1:3], ncol(sca), replace=T) table(colData(sca)$region) # a b c #32 31 33 3、回归分析 MAST做差异分析的主要优势在于可以校正多种协变量因素，如下演示几种常用的用法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## (1) 校正cngeneson协变量:默认参数 zlmCond \u0026lt;- zlm(~condition + cngeneson, sca, method=\u0026#34;bayesglm\u0026#34;, ebayes=TRUE) summaryCond \u0026lt;- summary(zlmCond, doLRT=\u0026#39;conditionStim\u0026#39;) summaryDt \u0026lt;- summaryCond$datatable levels(summaryDt$contrast) # [1] \u0026#34;conditionStim\u0026#34; \u0026#34;(Intercept)\u0026#34; \u0026#34;cngeneson\u0026#34; ## (2) 校正cngeneson与region协变量:默认参数 zlmCond \u0026lt;- zlm(~condition + cngeneson + region, sca, method = \u0026#34;bayesglm\u0026#34;, ebayes=TRUE) summaryCond \u0026lt;- summary(zlmCond, doLRT=\u0026#39;conditionStim\u0026#39;) summaryDt \u0026lt;- summaryCond$datatable levels(summaryDt$contrast) # [1] \u0026#34;conditionStim\u0026#34; \u0026#34;(Intercept)\u0026#34; \u0026#34;cngeneson\u0026#34; \u0026#34;regionb\u0026#34; \u0026#34;regionc\u0026#34; ## (3) 校正cngeneson协变量，将region认为是随机因素 zlmCond \u0026lt;- zlm(~condition + cngeneson + (1|region), sca, method = \u0026#34;glmer\u0026#34;, ebayes=FALSE) summaryCond \u0026lt;- summary(zlmCond, doLRT=\u0026#39;conditionStim\u0026#39;) summaryDt \u0026lt;- summaryCond$datatable levels(summaryDt$contrast) # [1] \u0026#34;conditionStim\u0026#34; \u0026#34;(Intercept)\u0026#34; \u0026#34;cngeneson\u0026#34; 汇总差异基因结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 df_pval = summaryDt %\u0026gt;% dplyr::filter(contrast==\u0026#39;conditionStim\u0026#39;) %\u0026gt;% dplyr::filter(component==\u0026#39;H\u0026#39;) %\u0026gt;% dplyr::select(primerid, `Pr(\u0026gt;Chisq)`) df_logfc = summaryDt %\u0026gt;% dplyr::filter(contrast==\u0026#39;conditionStim\u0026#39;) %\u0026gt;% dplyr::filter(component==\u0026#39;logFC\u0026#39;) %\u0026gt;% dplyr::select(primerid, coef, ci.hi, ci.lo) df_stat = dplyr::inner_join(df_logfc, df_pval) %\u0026gt;% dplyr::rename(\u0026#34;symbol\u0026#34;=\u0026#34;primerid\u0026#34;) %\u0026gt;% dplyr::rename(\u0026#34;pval\u0026#34;=\u0026#34;Pr(\u0026gt;Chisq)\u0026#34;,\u0026#34;logFC\u0026#34;=\u0026#34;coef\u0026#34;) %\u0026gt;% dplyr::mutate(\u0026#34;fdr\u0026#34; = p.adjust(pval)) %\u0026gt;% dplyr::arrange(fdr) head(df_stat) # symbol logFC ci.hi ci.lo pval fdr # 1: NDUFV2 7.522343 8.8016689 6.2430166 2.586874e-18 5.109075e-15 # 2: KIF9 -0.225052 0.1273536 -0.5774576 1.760028e-16 3.474294e-13 # 3: DUSP1 -6.513010 -5.2606967 -7.7653235 8.668938e-15 1.710382e-11 # 4: VCP 5.155219 6.2345839 4.0758540 1.530723e-13 3.018586e-10 # 5: SARS 5.577095 6.8474645 4.3067258 1.216538e-12 2.397796e-09 # 6: HSPD1 6.261077 7.6919267 4.8302277 1.969255e-12 3.879433e-09 上述第3种差异分析方式在一些文献中经常提及，主要用于避免不同样本来源对差异分析造成的影响，例如下面两篇文章。\n（1）The landscape of immune dysregulation in Crohn’s disease revealed through single-cell transcriptomic profiling in the ileum and colon\n（2）Diverse human astrocyte and microglial transcriptional responses to Alzheimer’s pathology\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/030%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--mast%E5%B7%AE%E5%BC%82%E5%9F%BA%E5%9B%A0%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eMAST，全称Model-based Analysis of Single-cell Transcriptomics，是2015年于Genome Biology发表的R包工具，主要用于单细胞数据的差异表达分析。参看官方教程，简单记录用法如下。\u003c/p\u003e","title":"单细胞分析工具--MAST差异基因分析"},{"content":" Scissor是2022年发表在Nature Biotechnology的一个单细胞数据分析工具包。该包通过纳入Bulk表达与表型数据，试图分析与样本表型(正/负)高度相关的单细胞亚群。\n原始论文：https://doi.org/10.1038/s41587-021-01091-3 官方手册：https://github.com/sunduanchen/Scissor R包安装 1 devtools::install_github(\u0026#39;sunduanchen/Scissor\u0026#39;) 简介：该包首先基于表达数据计算每个单细胞与bulk样本的相关性，筛选相关性较好的细胞群；然后进一步结合表型信息，通过回归模型并加上惩罚项选出最相关的亚群。之后基于两类亚群(正/负相关)可通过差异分析、通路分析、signature分析以及单细胞相关高级分析对该亚群进行多角度的个性分析。具体可参考原论文的分析示例。 0、示例数据 参考官方手册，使用肺腺癌(LUAD)示例数据如下：\n（1）单细胞表达数据 1 2 3 4 5 6 7 # https://xialab.s3-us-west-2.amazonaws.com/Duanchen/Scissor_data/scRNA-seq.RData load(\u0026#34;./scRNA-seq.RData\u0026#34;) dim(sc_dataset) # [1] 33694 4102 #上述为matrix格式，需要转为seurat对象并完成预处理 ?Seurat_preprocessing sc_dataset = Seurat_preprocessing(sc_dataset, verbose = F) （2）生存相关的bulk数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##表达矩阵 # https://xialab.s3-us-west-2.amazonaws.com/Duanchen/Scissor_data/TCGA_LUAD_exp1.RData load(\u0026#34;./TCGA_LUAD_exp1.RData\u0026#34;) dim(bulk_dataset) # [1] 56716 471 ##表型信息 # https://xialab.s3-us-west-2.amazonaws.com/Duanchen/Scissor_data/TCGA_LUAD_survival.RData load(\u0026#34;./TCGA_LUAD_survival.RData\u0026#34;) all(colnames(bulk_dataset) == bulk_survival$TCGA_patient_barcode) # [1] TRUE phenotype \u0026lt;- bulk_survival[,2:3] colnames(phenotype) \u0026lt;- c(\u0026#34;time\u0026#34;, \u0026#34;status\u0026#34;) head(phenotype) # time status # 1 1158 0 # 2 121 1 # 3 607 0 （2）分类相关的bulk数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 表达矩阵 # https://xialab.s3-us-west-2.amazonaws.com/Duanchen/Scissor_data/TCGA_LUAD_exp2.RData load(\u0026#34;./TCGA_LUAD_exp2.RData\u0026#34;) dim(bulk_dataset) # [1] 56716 498 ## 表型信息 # https://xialab.s3-us-west-2.amazonaws.com/Duanchen/Scissor_data/TCGA_LUAD_TP53_mutation.RData load(\u0026#34;./TCGA_LUAD_TP53_mutation.RData\u0026#34;) table(TP53_mutation) # 0 1 # 243 255 phenotype \u0026lt;- TP53_mutation tag \u0026lt;- c(\u0026#39;wild-type\u0026#39;, \u0026#39;TP53 mutant\u0026#39;) 1、函数用法 1 2 library(Scissor) ?Scissor() Scissor()是该包的核心分析函数，相关参数与注意事项如下：\n1.1 输入数据 首先依次输入3类数据：\n（1）bulk_dataset ：Bulk多样本表达矩阵； （2）sc_dataset ：sc_dataset单细胞表达数据，建议使用预处理的Seurat对象； （3）phenotype ： Bulk多样本表型数据。 1.2 模型参数 （1）alpha ：表示对回归模型的惩罚项；值越大，最终选择的细胞数越少。 （2）cutoff ：表示预期最大的选择细胞数比例，用以指导优化alpha参数 （3）family ： 表示回归模型的类型。gaussian-线性回归；binomial-二分类；cox-生存预后 默认alpha=NULL, cutoff=0.2，训练模型时从小到大遍历alpha值，直至达到cutoff所设的阈值。\n此外也可以指定alpha为一个或多个候选值，进行遍历。\n1.3 临时文件 （1）Save_file ：用以保存训练模型所需的中间数据，节省第二次训练的时间；包括如下5项 Expression_bulk - bulk表达矩阵 Expression_cell - 单细胞表达矩阵 network - 单细胞相似度网络 X - 每个细胞与每个bulk样本的相关性网络 Y - bulk表型数据 （2）Load_file ：第二次训练时直接加载上次保存的中间数据，用以节省时间 2、生存相关亚群 1 2 3 4 5 6 7 8 9 10 11 12 infos1 = Scissor(bulk_dataset, sc_dataset, phenotype, family = \u0026#34;cox\u0026#34;, alpha = NULL, cutoff = 0.2, Save_file = \u0026#39;Scissor_LUAD_survival.RData\u0026#39;) str(infos1) # List of 4 # $ para :List of 3 # ..$ alpha : num 0.01 # ..$ lambda: num 0.156 # ..$ family: chr \u0026#34;cox\u0026#34; # $ Coefs : num [1:4102] 0 0 0 0 0 ... # $ Scissor_pos: chr [1:573] \u0026#34;AAACGGGAGTCCATAC_19\u0026#34; \u0026#34;AAACGGGTCACATACG_19\u0026#34; \u0026#34;AAAGTAGAGGAGCGAG_19\u0026#34; \u0026#34;AAAGTAGCAACTGCTA_18\u0026#34; ... # $ Scissor_neg: chr [1:20] \u0026#34;AACGTTGCAAGCCCAC_16\u0026#34; \u0026#34;AACTCTTTCGAACTGT_20\u0026#34; \u0026#34;ACGAGCCCAACACCTA_20\u0026#34; \u0026#34;ACGCCAGTCCTCCTAG_20\u0026#34; ... 如上，Scissor分析结果包含4项内容：（1）训练参数；（2）每个细胞与bulk样本的回归系数；（3）**Scissor+**细胞标签；（4）**Scissor-**细胞标签； 对于Scissor+与Scissor-两类亚群，需结合表型信息进行解读。在这里：Scissor+表示与预后较差表型相关；Scissor-则与之相反。 1 2 3 4 5 6 7 8 9 Scissor_select \u0026lt;- rep(0, ncol(sc_dataset)) names(Scissor_select) \u0026lt;- colnames(sc_dataset) Scissor_select[infos1$Scissor_pos] \u0026lt;- 1 Scissor_select[infos1$Scissor_neg] \u0026lt;- 2 sc_dataset \u0026lt;- AddMetaData(sc_dataset, metadata = Scissor_select, col.name = \u0026#34;scissor\u0026#34;) # 0 1 2 # 3509 573 20 DimPlot(sc_dataset, reduction = \u0026#39;umap\u0026#39;, group.by = \u0026#39;scissor\u0026#39;, cols = c(\u0026#39;grey\u0026#39;,\u0026#39;indianred1\u0026#39;,\u0026#39;royalblue\u0026#39;)) 3、TP53相关亚群 1 2 3 4 5 6 7 8 9 10 11 12 13 infos2 \u0026lt;- Scissor(bulk_dataset, sc_dataset, phenotype, tag = tag, family = \u0026#34;binomial\u0026#34;, alpha = NULL, cutoff = 0.2, Save_file = \u0026#34;Scissor_LUAD_TP53_mutation.RData\u0026#34;) str(infos2) Scissor_select \u0026lt;- rep(0, ncol(sc_dataset)) names(Scissor_select) \u0026lt;- colnames(sc_dataset) Scissor_select[infos2$Scissor_pos] \u0026lt;- 1 Scissor_select[infos2$Scissor_neg] \u0026lt;- 2 sc_dataset \u0026lt;- AddMetaData(sc_dataset, metadata = Scissor_select, col.name = \u0026#34;scissor\u0026#34;) DimPlot(sc_dataset, reduction = \u0026#39;umap\u0026#39;, group.by = \u0026#39;scissor\u0026#39;, cols = c(\u0026#39;grey\u0026#39;,\u0026#39;indianred1\u0026#39;,\u0026#39;royalblue\u0026#39;)) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/031%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--scissor%E8%A1%A8%E5%9E%8B%E7%9B%B8%E5%85%B3%E4%BA%9A%E7%BE%A4%E9%89%B4%E5%AE%9A/","summary":"\u003cblockquote\u003e\n\u003cp\u003eScissor是2022年发表在Nature Biotechnology的一个单细胞数据分析工具包。该包通过纳入Bulk表达与表型数据，试图分析与样本表型(正/负)高度相关的单细胞亚群。\u003c/p\u003e","title":"单细胞分析工具--Scissor表型相关亚群鉴定"},{"content":" R包MARVEL是由牛津大学MRC Weatherall分子医学研究所团队开发的，用于分析单细胞水平的可变剪切事件。相关文章于2023年1月在Nucleic Acids Research期刊发表，在其github页面分享了MARVEL工具的分析流程，在此学习、记录如下。\nPape：https://doi.org/10.1093/nar/gkac1260 Github：https://github.com/wenweixiong/MARVEL Plate pipeline：https://wenweixiong.github.io/MARVEL_Plate.html Droplet pipeline：https://wenweixiong.github.io/MARVEL_Droplet.html 可变剪切\n关于可变剪切(Alternative splicing，AS)的基础，可以参看一篇中文教程；其中关于基因结构组成，可以参考之前的笔记。\n过去，针对Bulk RNA-seq数据的可变剪切分析工具已经有很多，例如之前学习的IsoformSwitchAnalyzeR包。MARVEL是个人目前了解到的第一个针对单细胞转录数据AS分析工具。\n单细胞数据类型\nAS分析的核心是通过检测比对到splice junction位点的read（例如，跨越两个外显子）进行分析。 目前主流的单细胞测序技术主要分为Droplet-based 10X方法与Plate-based Smart-seq方法。 10X技术由于仅对cDNA的3\u0026rsquo;端部分进行测序，只能对该区域涉及的splice junction进行分析，且无法具体分析事件类型 Smart-seq技术虽然通量低，但是全长转录本的单细胞测序原理，可以进行更为深入的AS分析。 一、Plate-based pipeline 1、上游分析 1.1 工作环境 两个同级的目录（1）basic：参考数据以及代码脚本 （2）proj1：具体的分析项目文件\n后续分析均在 proj1/ 路径下操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 tree basic/ -L 2 # basic/ # ├── gtf # │ ├── gencode.v31.annotation.gtf # │ ├── GRCh38.primary_assembly.genome.fa # │ ├── Log.out # │ ├── rsem_index # │ └── star_index # ├── rscript_Anno_SJ_rMATs.R # ├── rscript_bedtools_input.R # └── single_sample_upstream.sh tree proj1/ -L 2 # proj1/ # ├── SJ_phenoData.txt # └── work # ├── fq # ├── intron # ├── merge # ├── rmats # ├── rsem # └── star 1.2 conda环境 1 2 3 4 5 6 7 # 名为marvel_plate的分析环境 conda create -n marvel_plate python=3.7 conda activate marvel_plate conda install -c hcc aspera-cli conda install -c bioconda star=2.7.1a rmats=4.1.0 -y conda install -c bioconda bedtools samtools rsem -y conda install -c r r-base r-essentials r-tidyverse -y 1.2 准备数据 （1）测序数据\n官方手册分析了如下数据集的 192个单细胞数据，以其中一个演示流程 1 2 3 4 5 6 7 8 9 10 11 # https://www.ebi.ac.uk/ena/browser/view/ERR1562083 id=ERR1562083 # id=$1 mkdir -p ./work/fq/${id} ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/marvel_plate/etc/asperaweb_id_dsa.openssh \\ era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/00${id:0-1}/${id}/${id}_1.fastq.gz ./work/fq/${id} ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/marvel_plate/etc/asperaweb_id_dsa.openssh \\ era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/00${id:0-1}/${id}/${id}_2.fastq.gz ./work/fq/${id} （2）基因组数据\n在 ./basic/gtf 目录下 https://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_31/ 1 2 3 4 5 6 7 8 9 10 11 12 13 ## STAR索引 STAR --runMode genomeGenerate \\ --genomeDir star_index \\ --genomeFastaFiles GRCh38.primary_assembly.genome.fa \\ --sjdbGTFfile gencode.v31.annotation.gtf \\ --runThreadN 40 ## RSEM索引 rsem-prepare-reference \\ --gtf gencode.v31.annotation.gtf \\ --star -p 20 \\ GRCh38.primary_assembly.genome.fa \\ rsem_index/hg38 （3）教程数据\n官方教程提供了各个分析步骤的示范文件，可供之后分析作为参考。 http://datashare.molbiol.ox.ac.uk/public/wwen/MARVEL/Tutorial/Plate/Data.zip 1 2 ls Data # GTF MARVEL rMATS R Object RSEM SJ 1.3 分析步骤 1.3.1 单样本4步分析 （1）单样本STAR比对\n将每个样本的Fastq文件使用STAR软件进行比对，产生每个splice junction count matrix\n1 2 # Reference less -SN ./Data/SJ/SJ.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 mkdir -p ./work/star/${id} ref_idx_star=../basic/gtf/star_index ref_gtf=../basic/gtf/gencode.v31.annotation.gtf echo ${id} is runing...... #1st pass mode STAR --runThreadN 16 \\ --genomeDir ${ref_idx_star} \\ --readFilesCommand zcat \\ --readFilesIn ./work/fq/${id}/${id}_1.fastq.gz ./work/fq/${id}/${id}_2.fastq.gz \\ --outFileNamePrefix ./work/star/${id}/${id}. \\ --outSAMtype None #2nd pass mode STAR --runThreadN 16 \\ --genomeDir ${ref_idx_star} \\ --readFilesCommand zcat \\ --readFilesIn ./work/fq/${id}/${id}_1.fastq.gz ./work/fq/${id}/${id}_2.fastq.gz \\ --outFileNamePrefix ./work/star/${id}/${id}. \\ --sjdbFileChrStartEnd ./work/star/${id}/*SJ.out.tab \\ --sjdbGTFfile ${ref_gtf} \\ --outSAMtype BAM SortedByCoordinate \\ --outSAMattributes NH HI AS nM XS \\ --quantMode TranscriptomeSAM （2）单样本rMATs注释\n根据上述比对BAM结果，注释出每个基因(转录本)涉及的可变剪切事件类型。使用rMATs软件，可注释出5种类型：SE、RI、MXE、A5SS、A3SS。\n1 2 3 4 5 6 7 find ./Data/rMATS/ -name *featureData.txt # ./Data/rMATS/SE/SE_featureData.txt # ./Data/rMATS/A3SS/A3SS_featureData.txt # ./Data/rMATS/MXE/MXE_featureData.txt # ./Data/rMATS/RI/RI_featureData.txt # ./Data/rMATS/A5SS/A5SS_featureData.txt less -SN ./Data/rMATS/SE/SE_featureData.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mkdir -p ./work/rmats/${id} echo ${id} is running...... echo \u0026#34;./work/star/${id}/${id}.Aligned.sortedByCoord.out.bam\u0026#34; \u0026gt; ./work/star/${id}/BAM_fls.txt rmats.py \\ --b1 ./work/star/${id}//BAM_fls.txt \\ --gtf ${ref_gtf} \\ --od ./work/rmats/${id} \\ --tmp ./work/rmats/${id}/tmp \\ -t paired \\ --readLength 125 \\ --variable-read-length \\ --nthread 16 \\ --statoff # readLength参考如下 # zcat ./work/fq/${id}_1.fastq.gz | awk \u0026#39;{if(NR%4==2) print NR\u0026#34;\\t\u0026#34;$0\u0026#34;\\t\u0026#34;length($0)}\u0026#39; | less （3）单样本Intron矩阵\n统计Reads对于每个内含子的比对情况，逐碱基累加作为比对结果。\n1 2 # reference less -SN Data/MARVEL/PSI/RI/Counts_by_Region.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mkdir -p ./work/intron/${id} echo ${id} is running...... samtools view -H ./work/star/${id}/${id}.Aligned.sortedByCoord.out.bam | \\ grep SQ | cut -f 2 | awk \u0026#39;{ sub(/^SN:/, \u0026#34;\u0026#34;); print;}\u0026#39; \u0026gt; ./work/star/${id}/sorted_chr_in_bam.txt # 预定义R脚本，生成bedtools计算所需的两个文件：染色体大小以及内含子坐标 # https://github.com/lishensuo/utils/blob/main/marvel/rscript_bedtools_input.R Rscript ../basic/rscript_bedtools_input.R ${id} bedtools coverage \\ -g ./work/intron/${id}/hg38.chrom.sizes.txt \\ -split \\ -sorted \\ -a ./work/intron/${id}/RI_Coordinates_sorted.bed \\ -b ./work/star/${id}/${id}.Aligned.sortedByCoord.out.bam \u0026gt; \\ ./work/intron/${id}/intron_count.txt \\ -d （4）单样本gene矩阵\n最后需要对基因表达水平进行定量。教程推荐使用RSEM软件，并进行TPM类似的标准化处理\n1 2 # reference less -SN ./Data/RSEM/TPM.txt 1 2 3 4 5 6 7 8 mkdir -p ./work/rsem/${id} rsem-calculate-expression \\ --bam \\ --paired-end \\ -p 16 \\ ./work/star/${id}/${id}.Aligned.toTranscriptome.out.bam \\ ../basic/gtf/rsem_index/hg38 \\ ./work/rsem/${id}/${id} （1）如上，由于4步的分析过程中产生的中间数据可能超过数百兆；且SMART-seq往往涉及成百上千的细胞。为节约空间，可在每个样本分析完成后，删除不必要的数据。\n1 2 3 4 5 rm ./work/fq/${id}/${id}* rm ./work/star/${id}/*bam rm -rf ./work/rmats/${id}/tmp/* rm ./work/rsem/${id}/${id}.transcript.bam rm ./work/rsem/${id}/${id}.isoforms.results （2）多样本批量后台运行方式\n1 2 3 4 5 6 7 8 9 cat ../basic/single_sample_upstream.sh chmod u+x ../basic/single_sample_upstream.sh # 单样本测试 # ../basic/single_sample_upstream.sh ERR1562273 # parallel多线程批量运行 nohup parallel -j 5 ../basic/single_sample_upstream.sh {} ::: \\ $(grep -v \u0026#34;sample\u0026#34; ./SJ_phenoData.txt | awk \u0026#39;{print $1}\u0026#39;) \\ 1\u0026gt; ./work/single_sample_upstream.log 2\u0026gt;\u0026amp;1 \u0026amp; 1.3.2 整合多样本结果 即分步整合上游4个步骤中的每个步骤的所有样本结果；均使用R语言完成\n1 2 3 4 library(tidyverse) library(parallel) sample_meta = data.table::fread(\u0026#34;./SJ_phenoData.txt\u0026#34;,data.table=F) samples=sample_meta$sample.id step1: 汇总剪切位点矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 sj.list = mclapply(samples, function(sample){ sj_sp = data.table::fread(paste0(\u0026#34;./work/star/\u0026#34;,sample,\u0026#34;/\u0026#34;,sample,\u0026#34;.SJ.out.tab\u0026#34;), data.table=F) if(nrow(sj_sp)==0) return(NULL) sj_sp = sj_sp %\u0026gt;% dplyr::mutate(`coord.intron`=paste0(V1,\u0026#34;:\u0026#34;,V2,\u0026#34;:\u0026#34;,V3)) %\u0026gt;% dplyr::select(`coord.intron`, V7) colnames(sj_sp)[2] = sample return(sj_sp) },mc.cores=10) names(sj.list) = samples sj.list = sj.list[!unlist(lapply(sj.list, is.null))] sj_res = sj.list[[1]] for(x in sj.list[-1]){ sj_res = dplyr::full_join(sj_res, x) } for(sample in setdiff(samples,names(sj.list))){ sj_res[,sample]=NA } dim(sj_res) write.table(sj_res, file=paste0(\u0026#34;./work/merge/SJ.txt\u0026#34;), quote=F, row.names=F, sep=\u0026#34;\\t\u0026#34;) step2:整理AS注释结果 这一步最为复杂，需要理解每一种剪切事件的定义以及正负链的差异 参考官方示意：https://wenweixiong.github.io/Splicing_Nomenclature 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # https://github.com/lishensuo/utils/blob/main/marvel/rscript_Anno_SJ_rMATs.R source(paste0(\u0026#34;../basic/rscript_Anno_SJ_rMATs.R\u0026#34;)) AS_types = c(\u0026#34;SE\u0026#34;, \u0026#34;RI\u0026#34;, \u0026#34;MXE\u0026#34;, \u0026#34;A3SS\u0026#34;, \u0026#34;A5SS\u0026#34;) for(AS_type in AS_types){ # AS_type = AS_types[1] print(AS_type) fls_AS = list.files(paste0(\u0026#34;./work/rmats\u0026#34;), pattern=paste0(\u0026#34;fromGTF.\u0026#34;,AS_type,\u0026#34;.txt\u0026#34;), recursive=T, full.name=T) if (AS_type==\u0026#34;SE\u0026#34;){ func = se_func } else if (AS_type==\u0026#34;RI\u0026#34;){ func = ri_func } else if (AS_type==\u0026#34;MXE\u0026#34;){ func = mxe_func } else if (AS_type==\u0026#34;A3SS\u0026#34;){ func = a3ss_func } else if (AS_type==\u0026#34;A5SS\u0026#34;){ func = a5ss_func } df_AS = mclapply(fls_AS, function(fls){ rmats_AS = data.table::fread(fls, data.table=F) rmats_AS = rmats_AS %\u0026gt;% dplyr::mutate(tran_id = func(.)) %\u0026gt;% dplyr::rename(gene_id=GeneID,gene_short_name=geneSymbol) %\u0026gt;% dplyr::select(tran_id, gene_id, gene_short_name) return(rmats_AS) },mc.cores=10) %\u0026gt;% do.call(rbind, .) %\u0026gt;% dplyr::distinct() write.table(df_AS, row.names=F, sep=\u0026#34;\\t\u0026#34;,quote=F, file=paste0(\u0026#34;./work/merge/as_\u0026#34;,AS_type,\u0026#34;_featureData.txt\u0026#34;)) } step3：汇总intron矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 int_mt.list = mclapply(samples, function(sample){ # sample = samples[1] int_mt = data.table::fread(paste0(\u0026#34;./work/intron/\u0026#34;,sample,\u0026#34;/intron_count.txt\u0026#34;)) int_mt = int_mt %\u0026gt;% dplyr::mutate(`coord.intron`=paste(V1,V2,V3, sep=\u0026#34;:\u0026#34;)) %\u0026gt;% dplyr::group_by(coord.intron) %\u0026gt;% dplyr::summarize(count=sum(V5)) %\u0026gt;% dplyr::select(coord.intron, count) %\u0026gt;% as.data.frame() colnames(int_mt)[2] = sample return(int_mt) },mc.cores=10) intron_res = int_mt.list[[1]] for(x in int_mt.list[-1]){ intron_res = dplyr::full_join(intron_res, x) } dim(intron_res) write.table(intron_res, file=paste0(\u0026#34;./work/merge/intron_count_by_region.txt\u0026#34;), quote=F, row.names=F, sep=\u0026#34;\\t\u0026#34;) 汇总gene矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 gene_mt.list = mclapply(samples, function(sample){ fls=paste0(\u0026#34;./work/rsem/\u0026#34;,sample,\u0026#34;/\u0026#34;,sample,\u0026#34;.genes.results\u0026#34;) gene_mt = data.table::fread(fls, data.table=F) %\u0026gt;% dplyr::select(gene_id, TPM) colnames(gene_mt)[2] = sample return(gene_mt) },mc.cores=10) gene_res = gene_mt.list[[1]] for(x in gene_mt.list[-1]){ gene_res = dplyr::full_join(gene_res, x) } dim(gene_res) write.table(gene_res, file=paste0(\u0026#34;./work/merge/rsem_tpm.txt\u0026#34;),, quote=F, row.names=F, sep=\u0026#34;\\t\u0026#34;) 2、下游分析 后续根据教程提供的数据学习，需要安装的主要的MARVEL包以及其它辅助分析包，具体可参考教程。\n1 2 # 建议再单独建立一个conda R环境 install.packages(\u0026#34;MARVEL\u0026#34;) 2.1 创建marvel对象 需要准备七类文件，读入为R语言对象\n样本表型data.frame：第一列名为sample.id 剪切位点计数矩阵：第一列名为coord.intron 剪切事件类型注释列表：由数据框包装而出的list，每个数据库至少包含tran_id与gene_id 内含子计数矩阵：第一列名为coord.intron 基因表达矩阵：经标准化处理(RPKM/FPKM/TPM)，暂时不要log转换 基因类型data.frame：至少包含3列，gene_id, gene_short_name, gene_type 上游分析所用到的GTF数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 library(tidyverse) library(MARVEL) # (1) 细胞表型分组 df.pheno = data.table::fread(\u0026#34;./SJ_phenoData.txt\u0026#34;,data.table=F) # (2) Gene文件 df.tpm \u0026lt;- read.table(\u0026#34;./work/merge/rsem_tpm.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) dim(df.tpm) # (3) GTF文件 gtf \u0026lt;- data.table::fread(\u0026#34;../basic/gtf/gencode.v31.annotation.gtf\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=FALSE, na.strings=\u0026#34;NA\u0026#34;,quote=\u0026#34;\\\u0026#34;\u0026#34;) %\u0026gt;% as.data.frame() # (4) Gene类型 gene.feature = subset(gtf, V3==\u0026#34;gene\u0026#34;) df.tpm.feature \u0026lt;- str_split(gene.feature$V9, \u0026#34;;\u0026#34;, simplify=T) %\u0026gt;% as.data.frame() %\u0026gt;% dplyr::mutate(gene_id=str_match(V1, \u0026#39;\u0026#34;(.*)\u0026#34;\u0026#39;)[,2]) %\u0026gt;% dplyr::mutate(gene_short_name=str_match(V3, \u0026#39;\u0026#34;(.*)\u0026#34;\u0026#39;)[,2]) %\u0026gt;% dplyr::mutate(gene_type=str_match(V2, \u0026#39;\u0026#34;(.*)\u0026#34;\u0026#39;)[,2]) %\u0026gt;% dplyr::select(gene_id, gene_short_name, gene_type) %\u0026gt;% dplyr::filter(gene_id %in% df.tpm$gene_id) df.tpm.feature = df.tpm.feature[match(df.tpm$gene_id, df.tpm.feature$gene_id),] rownames(df.tpm.feature) = seq(nrow(df.tpm.feature)) # (5) SJ文件 sj = data.table::fread(\u0026#34;./work/merge/SJ.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE, na.strings=\u0026#34;NA\u0026#34;) %\u0026gt;% as.data.frame() dim(sj) # (6) AS文件 df.feature.list = lapply(c(\u0026#34;SE\u0026#34;, \u0026#34;MXE\u0026#34;, \u0026#34;RI\u0026#34;, \u0026#34;A5SS\u0026#34;, \u0026#34;A3SS\u0026#34;), function(x){ # x = \u0026#34;SE\u0026#34; df.feature = read.table(paste0(\u0026#34;./work/merge/as_\u0026#34;,x,\u0026#34;_featureData.txt\u0026#34;), sep=\u0026#34;\\t\u0026#34;, header=TRUE, na.strings=\u0026#34;NA\u0026#34;) %\u0026gt;% dplyr::distinct(tran_id, .keep_all=TRUE) %\u0026gt;% dplyr::left_join(df.tpm.feature) return(df.feature) }) names(df.feature.list) \u0026lt;- c(\u0026#34;SE\u0026#34;, \u0026#34;MXE\u0026#34;, \u0026#34;RI\u0026#34;, \u0026#34;A5SS\u0026#34;, \u0026#34;A3SS\u0026#34;) # (7) Intron文件 df.intron.counts \u0026lt;- data.table::fread(\u0026#34;./work/merge/intron_count_by_region.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE, na.strings=\u0026#34;NA\u0026#34;) %\u0026gt;% as.data.frame() dim(df.intron.counts) ## MARVEL object marvel \u0026lt;- CreateMarvelObject(SpliceJunction=sj, SplicePheno=df.pheno, SpliceFeature=df.feature.list, IntronCounts=df.intron.counts, GeneFeature=df.tpm.feature, Exp=df.tpm, GTF=gtf ) 2.2 预处理步骤 （1）基因表达log转换\n1 2 3 4 5 marvel \u0026lt;- TransformExpValues(MarvelObject=marvel, offset=1, transformation=\u0026#34;log2\u0026#34;, threshold.lower=1 ) （2）检测额外AS事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 如果基因表达水平整体较低，则不考虑该基因的可变剪切事件 # min.expr:判定单个细胞是否表达基因的阈值 # min.cells: 基于上述条件，判定细胞群表达该基因的阈值 marvel \u0026lt;- DetectEvents(MarvelObject=marvel, min.cells=50, #细胞群的表达百分比 min.expr=1, #认为细胞表达该基因的阈值 track.progress=FALSE, EventType=\u0026#34;AFE\u0026#34; ) marvel \u0026lt;- DetectEvents(MarvelObject=marvel, min.cells=50, min.expr=1, track.progress=FALSE, EventType=\u0026#34;ALE\u0026#34; ) length(marvel$SpliceFeature) # 7 （3）计算PSI值\n计算一个基因对于特定剪切事件的PSI值，这是后续分析的基础\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 # CoverageThreshold: 支持该剪切事件的最小reads数，小于该阈值标记为NA # UnevenCoverageMultiplier: 针对SE与MXE marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, UnevenCoverageMultiplier=10, EventType=\u0026#34;SE\u0026#34; ) marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, UnevenCoverageMultiplier=10, EventType=\u0026#34;MXE\u0026#34; ) marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, EventType=\u0026#34;RI\u0026#34;, thread=4 # only support RI ) marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, EventType=\u0026#34;A5SS\u0026#34; ) marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, EventType=\u0026#34;A3SS\u0026#34; ) marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, EventType=\u0026#34;AFE\u0026#34; ) marvel \u0026lt;- ComputePSI(MarvelObject=marvel, CoverageThreshold=10, EventType=\u0026#34;ALE\u0026#34; ) （4）保存中间结果\n首先检查不同矩阵与对应的meta行列名信息一致 1 2 3 4 marvel \u0026lt;- CheckAlignment(MarvelObject=marvel, level=\u0026#34;SJ\u0026#34;) marvel \u0026lt;- CheckAlignment(MarvelObject=marvel, level=\u0026#34;splicing\u0026#34;) marvel \u0026lt;- CheckAlignment(MarvelObject=marvel, level=\u0026#34;gene\u0026#34;) marvel \u0026lt;- CheckAlignment(MarvelObject=marvel, level=\u0026#34;splicing and gene\u0026#34;) 可进一步选取感兴趣的细胞群 1 2 3 4 5 6 7 index.1 \u0026lt;- which(df.pheno$cell.type %in% c(\u0026#34;iPSC\u0026#34;, \u0026#34;Endoderm\u0026#34;)) index.2 \u0026lt;- which(df.pheno$qc.seq==\u0026#34;pass\u0026#34;) index \u0026lt;- intersect(index.1, index.2) sample.ids \u0026lt;- df.pheno[index, \u0026#34;sample.id\u0026#34;] marvel \u0026lt;- SubsetSamples(MarvelObject=marvel, sample.ids=sample.ids ) 保存中间结果，方便后续分析 1 2 3 4 save(marvel, file=\u0026#34;./MARVEL2.RData\u0026#34;) # 后续以官方提供的示例数据学习 # load(\u0026#34;../Data/MARVEL.RData\u0026#34;) 2.3 细胞群AS特征分析 以其中84个iPSC细胞群进行演示\n1 2 3 sample.ids = marvel$SplicePheno %\u0026gt;% dplyr::filter(cell.type==\u0026#34;iPSC\u0026#34;) %\u0026gt;% dplyr::pull(sample.id) （1）AS类型占比\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 marvel \u0026lt;- CountEvents(MarvelObject=marvel, sample.ids=sample.ids, min.cells=25 ) # 对于一个基因至少有25个细胞的AS PSI值为非缺失值，则判定发生了可变剪切事件 marvel$N.Events$Table # event_type freq pct # 1 SE 5270 40.1523810 # 3 RI 2030 15.4666667 # 6 AFE 1789 13.6304762 # 5 A3SS 1746 13.3028571 # 4 A5SS 1494 11.3828571 # 7 ALE 724 5.5161905 # 2 MXE 72 0.5485714 marvel$N.Events$Plot # ggplot绘图体系，下同 （2）AS modality\n判断细胞群中每个基因的每种可变剪切的PSI分布类型，如下可分为7类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 marvel \u0026lt;- AssignModality(MarvelObject=marvel, sample.ids=sample.ids, min.cells=25, seed=1 ) marvel$Modality$Results[1:5, c(\u0026#34;tran_id\u0026#34;, \u0026#34;event_type\u0026#34;, \u0026#34;gene_id\u0026#34;, \u0026#34;gene_short_name\u0026#34;, \u0026#34;modality.bimodal.adj\u0026#34;)] table(marvel$Modality$Results$modality.bimodal.adj, marvel$Modality$Results$event_type) # A3SS A5SS AFE ALE MXE RI SE # Bimodal 20 7 4 6 0 4 17 # Excluded.Dispersed 386 484 538 189 18 783 1260 # Excluded.Primary 289 282 477 101 22 712 1049 # Included.Dispersed 563 385 372 237 12 352 1685 # Included.Primary 439 291 346 176 17 47 1184 # Middle 9 10 9 3 2 51 15 # Multimodal 40 35 43 12 1 81 60 后续有两种统计方式：仅按modality分，同时按modality与AS type分。以后者作为演示 1 2 3 4 5 6 7 8 9 10 11 12 marvel \u0026lt;- PropModality(MarvelObject=marvel, modality.column=\u0026#34;modality.bimodal.adj\u0026#34;, modality.type=\u0026#34;extended\u0026#34;, event.type=c(\u0026#34;SE\u0026#34;, \u0026#34;MXE\u0026#34;, \u0026#34;RI\u0026#34;, \u0026#34;A5SS\u0026#34;, \u0026#34;A3SS\u0026#34;, \u0026#34;AFE\u0026#34;, \u0026#34;ALE\u0026#34;), across.event.type=TRUE, prop.test=\u0026#34;chisq\u0026#34;, prop.adj=\u0026#34;fdr\u0026#34;, xlabels.size=8 ) marvel$Modality$Prop$BarChart$Stats head(marvel$Modality$Prop$BarChart$Table) marvel$Modality$Prop$BarChart$Plot 2.4 细胞群差异分析 （1）差异基因分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 cell.group.g1 = marvel$SplicePheno %\u0026gt;% dplyr::filter(cell.type==\u0026#34;iPSC\u0026#34;) %\u0026gt;% dplyr::pull(sample.id) # (reference) cell.group.g2 = marvel$SplicePheno %\u0026gt;% dplyr::filter(cell.type==\u0026#34;Endoderm\u0026#34;) %\u0026gt;% dplyr::pull(sample.id) marvel \u0026lt;- CompareValues(MarvelObject=marvel, cell.group.g1=cell.group.g1, cell.group.g2=cell.group.g2, min.cells=3, method=\u0026#34;wilcox\u0026#34;, method.adjust=\u0026#34;fdr\u0026#34;, level=\u0026#34;gene\u0026#34;, show.progress=FALSE ) marvel$DE$Exp$Table[1:5, ] （2）差异AS分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # time consuming marvel \u0026lt;- CompareValues(MarvelObject=marvel, cell.group.g1=cell.group.g1, cell.group.g2=cell.group.g2, min.cells=25, method=c(\u0026#34;ad\u0026#34;, \u0026#34;dts\u0026#34;), #同时使用两种的推荐差异方法 method.adjust=\u0026#34;fdr\u0026#34;, level=\u0026#34;splicing\u0026#34;, event.type=c(\u0026#34;SE\u0026#34;, \u0026#34;MXE\u0026#34;, \u0026#34;RI\u0026#34;, \u0026#34;A5SS\u0026#34;, \u0026#34;A3SS\u0026#34;, \u0026#34;ALE\u0026#34;, \u0026#34;AFE\u0026#34;), show.progress=FALSE ) names(marvel$DE$PSI$Table) head(marvel$DE$PSI$Table[[\u0026#34;ad\u0026#34;]]) head(marvel$DE$PSI$Table[[\u0026#34;dts\u0026#34;]]) （3）差异基因\u0026amp;AS分析\n对差异可变剪切的基因执行基因表达差异分析 1 2 3 4 5 6 7 8 9 10 11 12 13 marvel \u0026lt;- CompareValues(MarvelObject=marvel, cell.group.g1=cell.group.g1, cell.group.g2=cell.group.g2, psi.method=c(\u0026#34;ad\u0026#34;, \u0026#34;dts\u0026#34;), psi.pval=c(0.10, 0.10), psi.delta=0, method.de.gene=\u0026#34;wilcox\u0026#34;, method.adjust.de.gene=\u0026#34;fdr\u0026#34;, downsample=FALSE, show.progress=FALSE, level=\u0026#34;gene.spliced\u0026#34; ) head(marvel$DE$Exp.Spliced$Table) 对于上述差异分析结果均可快速火山图，标记marker基因等\n2.5 差异AS进阶分析 （1）差异PSI分类\nExplicit：明显的变化；Implicit：有限的变化；Restricted：微小的变化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 marvel \u0026lt;- ModalityChange(MarvelObject=marvel, method=c(\u0026#34;ad\u0026#34;, \u0026#34;dts\u0026#34;), psi.pval=c(0.10, 0.10) ) table(marvel$DE$Modality$Table$modality.change) # Explicit Implicit Restricted # 161 280 1113 head(marvel$DE$Modality$Table) marvel$DE$Modality$Plot cell.group.list \u0026lt;- list(\u0026#34;iPSC\u0026#34;=cell.group.g1, \u0026#34;Endoderm\u0026#34;=cell.group.g2 ) tran_id \u0026lt;- \u0026#34;chr3:129171771:129171634|129171655:-@chr3:129171446:129171538\u0026#34; # tran_id \u0026lt;- \u0026#34;chr6:21596763:21598248:+@chr6:21598321:21599378\u0026#34; # tran_id \u0026lt;- \u0026#34;chr3:109337464:109337652:-@chr3:109333920|109333993:109333870\u0026#34; marvel \u0026lt;- PlotValues(MarvelObject=marvel, cell.group.list=cell.group.list, feature=tran_id, xlabels.size=5, level=\u0026#34;splicing\u0026#34;, min.cells=25 ) marvel$adhocPlot$PSI （2）差异基因与AS\nCoordinated：基因高表达，相应的PSI也增高； Opposing：基因表达与PSI变化方向相反； Isoform-switching ：基因表达不变，PSI发生变化 Complex：其它复杂情况 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 marvel \u0026lt;- IsoSwitch(MarvelObject=marvel, method=c(\u0026#34;ad\u0026#34;, \u0026#34;dts\u0026#34;), psi.pval=c(0.10, 0.10), psi.delta=0, gene.pval=0.10, gene.log2fc=0.5 ) marvel$DE$Cor$Plot head(marvel$DE$Cor$Table_Raw) table(marvel$DE$Cor$Table$cor) # Coordinated Opposing Iso-Switch Complex # 192 158 331 113 ## 以Coordinated的DHX9与相应的AFE剪切事件为例 # gene df.feature \u0026lt;- marvel$GeneFeature gene_id \u0026lt;- df.feature[which(df.feature$gene_short_name==\u0026#34;DHX9\u0026#34;), \u0026#34;gene_id\u0026#34;] marvel \u0026lt;- PlotValues(MarvelObject=marvel, cell.group.list=cell.group.list, feature=gene_id, maintitle=\u0026#34;gene_short_name\u0026#34;, xlabels.size=7, level=\u0026#34;gene\u0026#34; ) plot.1_gene \u0026lt;- marvel$adhocPlot$Exp # Splicing tran_id \u0026lt;- \u0026#34;chr1:182839347:182839456|182839734:182839935:+@chr1:182842545:182842677\u0026#34; marvel \u0026lt;- PlotValues(MarvelObject=marvel, cell.group.list=cell.group.list, feature=tran_id, xlabels.size=7, level=\u0026#34;splicing\u0026#34;, min.cells=25 ) plot.1_splicing \u0026lt;- marvel$adhocPlot$PSI library(patchwork) plot.1_gene + plot.1_splicing （3）NMD预测\nnonsense-mediated decay (NMD)无义介导的mRNA降解预测 相比对照组，观测组所剪切的外显子可能由于包含premature stop codons (PTCs)，导致编码提前结束，从而进一步使得表达量降低。 本质上是对可产生PTC的可变剪切与下调基因取交集。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 marvel \u0026lt;- ParseGTF(MarvelObject=marvel) marvel \u0026lt;- FindPTC(MarvelObject=marvel, method=c(\u0026#34;ad\u0026#34;, \u0026#34;dts\u0026#34;), pval=c(0.10, 0.10), delta=5 ) marvel \u0026lt;- PropPTC(MarvelObject=marvel, xlabels.size=8, show.NovelSJ.NoCDS=FALSE, #仅展示Non PTC与PTC prop.test=\u0026#34;chisq\u0026#34; ) marvel$NMD$PTC.Prop$Table[1:5, ] marvel \u0026lt;- CompareExpr(MarvelObject=marvel, xlabels.size=8 ) marvel$NMD$NMD.Expr$Plot marvel \u0026lt;- AnnoVolcanoPlot(MarvelObject=marvel, anno=FALSE, xlabel.size=7 ) marvel$NMD$AnnoVolcanoPlot$Plot marvel$NMD$AnnoVolcanoPlot$Table 二、Drop-baed pipeline 1、上游分析 1.1 conda环境 1 2 3 4 5 conda create -n marvel_drop conda activate marvel_drop conda install -c hcc aspera-cli conda install -c bioconda STAR=2.7.8a samtools 1.2 下载数据 （1）测序数据\n官方教程分析了GSE130731的4个10X单细胞测序结果，以其中的两个作为学习的示例(SRR9008752,SRR9008753) https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE130731 1 2 3 4 5 6 7 8 9 10 ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/marvel/etc/asperaweb_id_dsa.openssh \\ era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR900/003/SRR9008752/SRR9008752_1.fastq.gz ./work/fq/ ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/marvel/etc/asperaweb_id_dsa.openssh \\ era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR900/003/SRR9008753/SRR9008753_2.fastq.gz ./work/fq/ mv ./work/fq/SRR9008753_1.fastq.gz ./work/fq/SRR9008753_S1_L001_R1_001.fastq.gz mv ./work/fq/SRR9008753_2.fastq.gz ./work/fq/SRR9008753_S1_L001_R2_001.fastq.gz （2）基因组数据\n还是在 ./basic/gtf 文件夹下，构建starsolo版本的索引文件。\ncellranger软件及相关数据下载参考之前的笔记。\n1 2 3 4 5 6 STAR \\ --runMode genomeGenerate \\ --runThreadN 20 \\ --genomeDir ./starsolo_index \\ --genomeFastaFiles GRCh38.primary_assembly.genome.fa \\ --sjdbGTFfile gencode.v31.annotation.gtf （3）教程数据\nhttp://datashare.molbiol.ox.ac.uk/public/wwen/MARVEL/Tutorial/Droplet/Data.zip 1 2 ls Data/ # Gene_SingCellaR Gene_STARsolo GTF R Object SJ_STARsolo 1.3 比对分析 （1）cellranger\n使用cellranger软件初次比对产生bam文件，该软件用法可参考之前的笔记\n1 2 3 4 5 6 7 8 9 10 11 12 13 bin=/home/lishensuo/Softerware/cellranger-7.1.0/bin/cellranger ref=/home/lishensuo/Softerware/cellranger-7.1.0/refer/refdata-gex-GRCh38-2020-A fq_dir=/home/lishensuo/STUDY/marvel/proj2/work/fq sample=SRR9008752 ${bin} count --id=${sample} \\ --fastqs=${fq_dir} \\ --sample=${sample} \\ --localcores=10 \\ --transcriptome=${ref} mkdir -p ./work/cellranger mv ${sample} ./work/cellranger/${sample} （2）STARsolo\n使用STAR软件针对单细胞数据的模式，分析其基因表达以及剪切位点矩阵\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # https://kb.10xgenomics.com/hc/en-us/articles/115004506263-What-is-a-barcode-whitelist- # Cell Ranger 4 and later: cellranger-x.y.z/lib/python/cellranger/barcodes/ # Cell Ranger 3 and earlier: cellranger-x.y.z/cellranger-cs/x.y.z/lib/python/cellranger/barcodes/ ls /home/lishensuo/Softerware/cellranger-7.1.0/lib/python/cellranger/barcodes/ whitelist=/home/lishensuo/Softerware/cellranger-7.1.0/lib/python/cellranger/barcodes/737K-august-2016.txt sample=SRR9008752 STAR --runThreadN 16 \\ --genomeDir ../basic/gtf/starsolo_index \\ --soloType CB_UMI_Simple \\ --readFilesIn ./work/cellranger/${sample}/outs/possorted_genome_bam.bam \\ --readFilesCommand samtools view -F 0x100 \\ --readFilesType SAM SE \\ --soloInputSAMattrBarcodeSeq CR UR \\ --soloInputSAMattrBarcodeQual CY UY \\ --soloCBwhitelist ${whitelist} \\ --soloFeatures Gene SJ mkdir ./work/star/${sample} mv Aligned.out.sam Log.final.out Log.out Log.progress.out SJ.out.tab ./Solo.out mv Solo.out ./work/star/${sample} 2、下游分析 2.1 整理比对结果 1 2 3 4 5 6 library(tidyverse) library(Seurat) library(R.utils) # ※ library(Matrix) samples=c(\u0026#34;SRR9008752\u0026#34;,\u0026#34;SRR9008753\u0026#34;) （1）Raw gene count\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 dir.create(\u0026#34;./work/gene\u0026#34;) dir.create(\u0026#34;./work/gene/raw\u0026#34;) dir.create(\u0026#34;./work/gene/norm\u0026#34;) sce.list = lapply(samples, function(x){ print(x) fls = list.files(paste0(\u0026#34;./work/star/\u0026#34;,x,\u0026#34;/Solo.out/Gene/filtered\u0026#34;), full.name=T) if(length(grep(\u0026#34;gz\u0026#34;,fls))!=3){ for(fl in fls){ gzip(fl, remove=FALSE) } } count = Read10X(paste0(\u0026#34;./work/star/\u0026#34;,x,\u0026#34;/Solo.out/Gene/filtered\u0026#34;)) sce = CreateSeuratObject(count) sce = RenameCells(sce, add.cell.id=x) sce$Group = x return(sce) }) names(sce.list) = samples # 若多个样本则合并处理 sce = merge(sce.list[[1]], sce.list[-1]) table(sce$Group) count_merge = sce@assays$RNA@counts dim(count_merge) writeMM(count_merge, file = \u0026#39;./work/gene/raw/matrix.mtx\u0026#39;) count_merge_phe = sce@meta.data %\u0026gt;% tibble::rownames_to_column(\u0026#34;cell.id\u0026#34;) %\u0026gt;% dplyr::select(cell.id) # 仅需要1列 write.table(count_merge_phe, sep=\u0026#34;\\t\u0026#34;, row.names=F, file=\u0026#34;./work/gene/raw/phenoData.txt\u0026#34;) count_merge_feat = data.frame(gene_short_name=rownames(sce)) write.table(count_merge_feat, sep=\u0026#34;\\t\u0026#34;, row.names=F, file=\u0026#34;./work/gene/raw/featureData.txt\u0026#34;) （2）Norm gene count\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sce = NormalizeData(sce) count_merge_norm = Matrix::Matrix(exp(sce@assays$RNA@data)-1, sparse=T) # 非log转换 count_merge_norm[1:4,1:4] writeMM(count_merge_norm, file = \u0026#39;./work/gene/norm/matrix_normalised.mtx\u0026#39;) count_merge_norm_phe = sce@meta.data %\u0026gt;% tibble::rownames_to_column(\u0026#34;cell.id\u0026#34;) %\u0026gt;% dplyr::select(cell.id, Group) # 需要细胞分组等表型信息 write.table(count_merge_norm_phe, sep=\u0026#34;\\t\u0026#34;, row.names=F, file=\u0026#34;./work/gene/norm/phenoData.txt\u0026#34;) count_merge_norm_feat = data.frame(gene_short_name=rownames(sce)) write.table(count_merge_norm_feat, sep=\u0026#34;\\t\u0026#34;, row.names=F, file=\u0026#34;./work/gene/norm/featureData.txt\u0026#34;) （3）Raw SJ count\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 dir.create(\u0026#34;./work/sj/raw\u0026#34;) # 整理SJ meta for(x in samples){ sj_name = data.table::fread(paste0(\u0026#34;./work/star/\u0026#34;,x,\u0026#34;/Solo.out/SJ.out.tab\u0026#34;), data.table=F) %\u0026gt;% dplyr::mutate(coord.intron=paste(V1, V2, V3, sep=\u0026#34;:\u0026#34;)) %\u0026gt;% dplyr::select(coord.intron) write.table(sj_name, sep=\u0026#34;\\t\u0026#34;, row.names=F, col.names=F, quote=F, file=paste0(\u0026#34;./work/star/\u0026#34;,x,\u0026#34;/Solo.out/SJ/raw/features.tsv\u0026#34;)) } sce_sj.list = lapply(samples, function(x){ # x=\u0026#34;SRR15319877\u0026#34; print(x) fls = list.files(paste0(\u0026#34;./work/star/\u0026#34;,x,\u0026#34;/Solo.out/SJ/raw\u0026#34;), full.name=T) if(length(grep(\u0026#34;gz\u0026#34;,fls))!=3){ for(fl in fls){ gzip(fl, remove=FALSE) } } count = Read10X(paste0(\u0026#34;./work/star/\u0026#34;,x,\u0026#34;/Solo.out/SJ/raw\u0026#34;),gene.column=1) sce_sj = CreateSeuratObject(count) sce_sj = RenameCells(sce_sj, add.cell.id=x) sce_sj = sce_sj[,colnames(sce.list[[x]])] return(sce_sj) }) sce_sj = merge(sce_sj.list[[1]], sce_sj.list[-1]) sj_count_merge = sce_sj@assays$RNA@counts writeMM(sj_count_merge, file = \u0026#39;./work/sj/raw/matrix.mtx\u0026#39;) sj_count_merge_phe = sce_sj@meta.data %\u0026gt;% tibble::rownames_to_column(\u0026#34;cell.id\u0026#34;) %\u0026gt;% dplyr::select(cell.id) # 仅需要1列 write.table(sj_count_merge_phe, sep=\u0026#34;\\t\u0026#34;, row.names=F, file=\u0026#34;./work/sj/raw/phenoData.txt\u0026#34;) sj_count_merge_feat = data.frame(coord.intron=rownames(sce_sj)) %\u0026gt;% dplyr::mutate(coord.intron=gsub(\u0026#34;-\u0026#34;,\u0026#34;_\u0026#34;, coord.intron)) write.table(sj_count_merge_feat, sep=\u0026#34;\\t\u0026#34;, row.names=F, file=\u0026#34;./work/sj/raw/featureData.txt\u0026#34;) （4）Cell dimension reduction\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dir.create(\u0026#34;./work/umap\u0026#34;) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() %\u0026gt;% Seurat::RunPCA() %\u0026gt;% Seurat::RunUMAP(dims = 1:30) umap_embed = sce@reductions$umap@cell.embeddings %\u0026gt;% as.data.frame() %\u0026gt;% tibble::rownames_to_column(\u0026#34;cell.id\u0026#34;) %\u0026gt;% dplyr::rename(x=UMAP_1, y=UMAP_2) write.table(umap_embed, row.names=F, sep=\u0026#34;\\t\u0026#34;, file=\u0026#34;./work/umap/UMAP_coordinate.txt\u0026#34;) 2.2 创建marvel对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # (1) norm gene的三文件 df.gene.norm \u0026lt;- readMM(\u0026#34;./work/gene/norm/matrix_normalised.mtx\u0026#34;) df.gene.norm.pheno \u0026lt;- read.table(\u0026#34;./work/gene/norm/phenoData.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) df.gene.norm.feature \u0026lt;- read.table(\u0026#34;./work/gene/norm/featureData.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) # (2) raw gene的三文件 df.gene.count \u0026lt;- readMM(\u0026#34;./work/gene/raw/matrix.mtx\u0026#34;) df.gene.count.pheno \u0026lt;- read.table(\u0026#34;./work/gene/raw/phenoData.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) df.gene.count.feature \u0026lt;- read.table(\u0026#34;./work/gene/raw/featureData.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) # (3) SJ gene的三文件 df.sj.count \u0026lt;- readMM(\u0026#34;./work/sj/raw/matrix.mtx\u0026#34;) df.sj.count.pheno \u0026lt;- read.table(\u0026#34;./work/sj/raw/phenoData.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) df.sj.count.feature \u0026lt;- read.table(\u0026#34;./work/sj/raw/featureData.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) rownames(df.sj.count) = df.sj.count.feature[,1] colnames(df.sj.count) = df.sj.count.pheno[,1] # (4) 细胞降维 df.coord \u0026lt;- read.table(\u0026#34;./work/umap/UMAP_coordinate.txt\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=TRUE) # (5) GTF gtf \u0026lt;- data.table::fread(\u0026#34;../basic/gtf/gencode.v31.annotation.gtf\u0026#34;, sep=\u0026#34;\\t\u0026#34;, header=FALSE) %\u0026gt;% as.data.frame() ## 由于不同来源gtf版本差异而踩的坑，需要修改如下 gtf$V9 = gsub(\u0026#34;gene_type\u0026#34;,\u0026#34;gene_biotype\u0026#34;,gtf$V9) gtf$V1 = gsub(\u0026#34;chr\u0026#34;,\u0026#34;\u0026#34;,gtf$V1) library(MARVEL) marvel \u0026lt;- CreateMarvelObject.10x(gene.norm.matrix=df.gene.norm, gene.norm.pheno=df.gene.norm.pheno, gene.norm.feature=df.gene.norm.feature, gene.count.matrix=df.gene.count, gene.count.pheno=df.gene.count.pheno, gene.count.feature=df.gene.count.feature, sj.count.matrix=df.sj.count, sj.count.pheno=df.sj.count.pheno, sj.count.feature=df.sj.count.feature, pca=df.coord, gtf=gtf ) 2.3 预处理步骤 筛选有效的剪切位点 1 2 3 4 5 6 7 8 9 10 11 12 13 # 注释基因类型 marvel \u0026lt;- AnnotateGenes.10x(MarvelObject=marvel) head(marvel$gene.metadata) ## SJ涉及两边分属一个蛋白编码基因 marvel \u0026lt;- AnnotateSJ.10x(MarvelObject=marvel) #基因类型 head(marvel$sj.metadata) marvel \u0026lt;- ValidateSJ.10x(MarvelObject=marvel) #同一基因 head(marvel$sj.metadata) marvel \u0026lt;- FilterGenes.10x(MarvelObject=marvel, gene.type=\u0026#34;protein_coding\u0026#34; #蛋白基因 ) head(marvel$sj.metadata) 分析基因在细胞群的表达率以及SJ在细胞群的发生率 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 cell.group.list = split(marvel$sample.metadata$cell.id,marvel$sample.metadata$Group) ## 基因在细胞群的表达率 marvel \u0026lt;- PlotPctExprCells.Genes.10x(MarvelObject=marvel, cell.group.g1=cell.group.list[[1]], cell.group.g2=cell.group.list[[2]], min.pct.cells=5 ) head(marvel$pct.cells.expr$Gene$Data) p1 = marvel$pct.cells.expr$Gene$Plot ## 剪切位点在不同细胞群的发生率 marvel \u0026lt;- PlotPctExprCells.SJ.10x(MarvelObject=marvel, cell.group.g1=cell.group.list[[1]], cell.group.g2=cell.group.list[[2]], min.pct.cells.genes=5, min.pct.cells.sj=5, downsample=TRUE, downsample.pct.sj=10 # 抽样10%分析 ) head(marvel$pct.cells.expr$SJ$Data) p2 = marvel$pct.cells.expr$SJ$Plot library(patchwork) p1 + p2 保存中间结果 1 2 marvel \u0026lt;- CheckAlignment.10x(MarvelObject=marvel) save(marvel, file=\u0026#34;***.rda\u0026#34;) 2.4 SJ差异分析 （1）差异SJ与基因\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 首先分析差异SJ marvel \u0026lt;- CompareValues.SJ.10x(MarvelObject=marvel, cell.group.g1=cell.group.list[[1]], cell.group.g2=cell.group.list[[2]], min.pct.cells.genes=10, #至少10%细胞表达 min.pct.cells.sj=10, #至少10%细胞剪切 min.gene.norm=1.0, seed=1, n.iterations=100, downsample=TRUE, #根据样本量少的一组下采样 show.progress=FALSE ) ## 然后进一步分析差异基因 marvel \u0026lt;- CompareValues.Genes.10x(MarvelObject=marvel, show.progress=FALSE ) head(marvel$DE$SJ$Table) （2）SJ与基因关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 marvel \u0026lt;- IsoSwitch.10x(MarvelObject=marvel, pval.sj=0.05, delta.sj=5, min.gene.norm=1.0, pval.adj.gene=0.05, log2fc.gene=0.5 ) head(marvel$SJ.Gene.Cor$Data[,c(\u0026#34;coord.intron\u0026#34;, \u0026#34;gene_short_name\u0026#34;, \u0026#34;cor.complete\u0026#34;)]) marvel$SJ.Gene.Cor$Proportion$Table # sj.gene.cor freq pct # 2 Coordinated 26 8.387097 # 4 Opposing 54 17.419355 # 3 Iso-Switch 226 72.903226 # 1 Complex 4 1.290323 marvel$SJ.Gene.Cor$Proportion$Plot 降维可视化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # Plot cell groups marvel \u0026lt;- PlotValues.PCA.CellGroup.10x(MarvelObject=marvel, cell.group.list=cell.group.list[c(1,4)], legendtitle=\u0026#34;Cell group\u0026#34;, type=\u0026#34;tsne\u0026#34; ) plot_group \u0026lt;- marvel$adhocPlot$PCA$CellGroup # Plot gene expression marvel \u0026lt;- PlotValues.PCA.Gene.10x(MarvelObject=marvel, gene_short_name=\u0026#34;VIM\u0026#34;, color.gradient=c(\u0026#34;grey\u0026#34;,\u0026#34;cyan\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;red\u0026#34;), type=\u0026#34;tsne\u0026#34; ) plot_gene \u0026lt;- marvel$adhocPlot$PCA$Gene # Plot PSI marvel \u0026lt;- PlotValues.PCA.PSI.10x(MarvelObject=marvel, coord.intron=\u0026#34;chr10:17235390:17235845\u0026#34;, min.gene.count=3, log2.transform=FALSE, color.gradient=c(\u0026#34;grey\u0026#34;,\u0026#34;cyan\u0026#34;,\u0026#34;green\u0026#34;,\u0026#34;yellow\u0026#34;,\u0026#34;red\u0026#34;), type=\u0026#34;tsne\u0026#34; ) plot_sj \u0026lt;- marvel$adhocPlot$PCA$PSI library(patchwork) p = plot_group + plot_gene + plot_sj 2.5 特定基因分析 （1）分组表达\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 该基因在不同阶段的表达 marvel \u0026lt;- adhocGene.TabulateExpression.Gene.10x(MarvelObject=marvel, cell.group.list=cell.group.list, gene_short_name=\u0026#34;TPM2\u0026#34;, min.pct.cells=10, downsample=TRUE ) marvel$adhocGene$Expression$Gene$Table marvel$adhocGene$Expression$Gene$Plot # 该基因的不同剪切位点在不同阶段的count表达 marvel \u0026lt;- adhocGene.TabulateExpression.PSI.10x(MarvelObject=marvel, min.pct.cells=10 ) head(marvel$adhocGene$Expression$PSI$Table) marvel$adhocGene$Expression$PSI$Plot （2）组间差异\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 组间两两差异 marvel \u0026lt;- adhocGene.DE.Gene.10x(MarvelObject=marvel) marvel \u0026lt;- adhocGene.DE.PSI.10x(MarvelObject=marvel) results \u0026lt;- marvel$adhocGene$DE$PSI$Data head(results) # 选择特定SJ绘图 # SJ-1 # Define SJ coord.intron \u0026lt;- results[which(results$figure.column==\u0026#34;SJ-1\u0026#34;), \u0026#34;coord.intron\u0026#34;] coord.intron \u0026lt;- unique(coord.intron) coord.intron marvel \u0026lt;- adhocGene.PlotDEValues.10x(MarvelObject=marvel, coord.intron=coord.intron, log2fc.gene=0.5, delta.sj=5, label.size=2, point.size=2, xmin=-2.0, xmax=2.0, ymin=-25, ymax=25 ) marvel$adhocGene$DE$VolcanoPlot$Plot 使用wiggleplotr包可视化某剪切位点在基因不同转录本的可视化 1 2 3 4 5 6 7 8 9 10 11 # http://datashare.molbiol.ox.ac.uk/public/wwen/wiggleplotr_1.18.0.tar.gz #install.packages(\u0026#34;wiggleplotr_1.18.0.tar.gz\u0026#34;, repos = NULL, type=\u0026#34;source\u0026#34;) marvel \u0026lt;- adhocGene.PlotSJPosition.10x(MarvelObject=marvel, coord.intron=coord.intron, rescale_introns=FALSE, show.protein.coding.only=TRUE, anno.label.size=1.5 ) marvel$adhocGene$SJPosition$Plot ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/032%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--marvel%E5%8D%95%E7%BB%86%E8%83%9E%E5%8F%AF%E5%8F%98%E5%89%AA%E5%88%87/","summary":"\u003cblockquote\u003e\n\u003cp\u003eR包MARVEL是由牛津大学MRC Weatherall分子医学研究所团队开发的，用于分析单细胞水平的可变剪切事件。相关文章于2023年1月在Nucleic Acids Research期刊发表，在其github页面分享了MARVEL工具的分析流程，在此学习、记录如下。\u003c/p\u003e","title":"单细胞分析工具--MARVEL单细胞可变剪切"},{"content":" scCustomize包由来自波士顿儿童医院/哈佛医学院的博士后Samuel E. Marsh编写。该包基于Seurat，提供了若干便捷、高效的可视化方法。根据官方教程学习其中感兴趣的用法。\nhttps://github.com/samuel-marsh/scCustomize/ https://samuel-marsh.github.io/scCustomize/index.html 0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 sce \u0026lt;- pbmc3k.SeuratData::pbmc3k.final sce$sample_id \u0026lt;- sample(c(\u0026#34;sample1\u0026#34;, \u0026#34;sample2\u0026#34;, \u0026#34;sample3\u0026#34;), size = ncol(sce), replace = TRUE) sce$treatment \u0026lt;- sample(c(\u0026#34;before\u0026#34;, \u0026#34;after\u0026#34;), size = ncol(sce), replace = TRUE) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() sce = sce %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% #RunTSNE FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5,0.8,1)) 1、高变基因 可设置参数，加标签 1 2 VariableFeaturePlot_scCustom(seurat_object = sce, num_features = 5, label = TRUE, repel = TRUE) 2、小提琴图 1 2 3 4 5 6 7 Idents(sce) = \u0026#34;RNA_snn_res.0.01\u0026#34; gene_list_plot \u0026lt;- VariableFeatures(sce)[1:5] p1 = Stacked_VlnPlot(seurat_object = sce, features = gene_list_plot, x_lab_rotate = TRUE) p2 = Stacked_VlnPlot(seurat_object = sce, features = gene_list_plot, plot_spacing = 0.3) p3 = Stacked_VlnPlot(seurat_object = sce, features = gene_list_plot, split.by = \u0026#34;sample_id\u0026#34;) p4 = Stacked_VlnPlot(seurat_object = sce, features = gene_list_plot, split.by = \u0026#34;treatment\u0026#34;, split.plot=TRUE) (p1 | p2) / (p3 | p4) 3、聚类点图 1 2 3 4 5 6 7 8 Idents(sce) = \u0026#34;RNA_snn_res.0.2\u0026#34; all_markers \u0026lt;- FindAllMarkers(object = sce) top5_markers \u0026lt;- Extract_Top_Markers(marker_dataframe = all_markers, num_genes = 5, named_vector = FALSE, make_unique = TRUE) Clustered_DotPlot(seurat_object = sce, features = top5_markers) # 左 Clustered_DotPlot(seurat_object = sce, features = top5_markers, k = 6) # 右 4、降维相关可视化 （1）FeaturePlot_scCustom：低于特定阈值的基因不映射连续颜色 1 FeaturePlot_scCustom(seurat_object = sce, features = \u0026#34;PTPRC\u0026#34;, na_cutoff=2) （2）DimPlot_scCustom：迷你版坐标轴 1 DimPlot_scCustom(seurat_object = sce, figure_plot = TRUE) （3）Cluster_Highlight_Plot：单独显示特定细胞群 1 2 3 4 5 6 Idents(sce) = \u0026#34;RNA_snn_res.0.1\u0026#34; p1 = Cluster_Highlight_Plot(seurat_object = sce, cluster_name = \u0026#34;0\u0026#34;, highlight_color = \u0026#34;red\u0026#34;, background_color = \u0026#34;lightgray\u0026#34;) p2 = Cluster_Highlight_Plot(seurat_object = sce, cluster_name = c(2,3), highlight_color = c(\u0026#34;red\u0026#34;,\u0026#34;blue\u0026#34;), background_color = \u0026#34;lightgray\u0026#34;) p1 | p2 5、自定义颜色 （1）连续型变量：默认为viridis_plasma_dark_high，其它可选包括 viridis_plasma_light_high viridis_magma_dark_high viridis_magma_light_high viridis_inferno_dark_high viridis_inferno_light_high viridis_dark_high viridis_light_high 1 2 PalettePlot(pal = viridis_plasma_dark_high) # FeaturePlot_scCustom(seurat_object = sce, colors_use = viridis_magma_dark_high, features = \u0026#34;CD3E\u0026#34;) （2）离散型变量：单变量-\u0026ldquo;dodgerblue\u0026rdquo;；双变量-NavyAndOrange()；\u0026lt;36-\u0026ldquo;polychrome\u0026rdquo;；\u0026gt;36\u0026ndash;\u0026ldquo;varibow\u0026rdquo;(shuffle)。其它包括 alphabet (24) alphabet2 (24) glasbey (32) polychrome (36) stepped (24) ditto_seq (40) varibow (Dynamic) 1 PalettePlot(pal = DiscretePalette_scCustomize(num_colors = 10, palette = \u0026#34;polychrome\u0026#34;)) 1 PalettePlot(pal = DiscretePalette_scCustomize(num_colors = 10, palette = \u0026#34;ditto_seq\u0026#34;, shuffle_pal = TRUE)) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/033%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--sccustomize%E5%8C%85%E6%94%B9%E8%BF%9Bseurat%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003cblockquote\u003e\n\u003cp\u003escCustomize包由来自波士顿儿童医院/哈佛医学院的博士后Samuel E. Marsh编写。该包基于Seurat，提供了若干便捷、高效的可视化方法。根据官方教程学习其中感兴趣的用法。\u003c/p\u003e","title":"单细胞分析工具--scCustomize包改进Seurat可视化"},{"content":" 来自密歇根大学医学院的计算医学与生物信息学部的LanaX.Garmire(拉娜·加米尔)团队近日于Nature Communication发表一篇基于单细胞转录组数据药物重定向研究的研究，并开发了相关R包。如下简单学习下该方法的原理以及R包使用方法。\nPaper：ASGARD is A Single-cell Guided Pipeline to Aid Repurposing of Drugs Date：10 February 2023 DOI：https://doi.org/10.1038/s41467-023-36637-3 Github：https://github.com/lanagarmire/Asgard 1、算法简介 （1）基本的计算思路与CMAP方法类似，即疾病的差异基因方向与药物干扰细胞系方向相反；\n（2）使用对照组与疾病组单细胞数据分析每个细胞亚群的差异基因及其候选药物列表；\n（3）合并不同细胞群的结果，得到单药物对于所有细胞群的综合打分，以评价其重定向的潜力。\n（4）单药-单细胞群的打分\n预先将疾病细胞群差异基因由低到高排序，而药物干扰基因由高到低排序。如果排序完全相反则认为药物越好； 该包采用了β分布，计算了同一基因的在疾病/药物的排名最小值/最大值的出现的概率，进而求出P值(Min-P)； 如果P值小的基因越多，表明基因在疾病与药物的排名一致性越好。 设定一定的阈值（默认为0.05）计算所有药物实验结果P值显著的基因数； 由于一个药物可因浓度剂量等涉及多种实验，所以再进一步根据KS统计量计算单药的P值，作为单药对于单细胞群的打分。 （5）单药-多细胞群打分。\n按如下公式计算综合得分，其中考虑3项因素：细胞群比例， 单药对于细胞群的P值，药物可逆转的细胞群差异基因比例。 基于单药对于不同细胞群的P值计算出fisher-based combined P值作为综合得分的P值。 2、文章概述 实验数据集主要包括3个（1）乳腺癌（2）白血病（3）COVID-19\n（1） 差异基因分析方法：文章首先测试对于不同数据哪一种差异基因分析工具最终计算得到的AUC指标最高(FDA或临床报道作为阳性药)\nLimma：Bayes，trend，voom\nSeurat：Wilcox，t-test，LR\nDEseq2：Wald，LRT\nedgeR：LRT，QLF\n如下图发现，limma-bayes方法结果针对3个数据集均较优，后面的差异分析将使用这种分析方法。\n（2）对比基于Bulk RNA-seq数据的重定向方法（CLUE，DrInsight），将单细胞数据转换成pseudobulk RNA-Seq data。\n如下图发现ASGARD在三个数据集中均表现最优。\n（3）对比另外两种同样基于单细胞数据的重定向方法，由于后两者只能针对单独cluster进行预测，所以仅使用ASGARD的cluster预测模式。尽管如此，仍然发现ASGARD在3种数据集中均表现最优。\n（4）之后文章就ASGARD对于上述3种数据集的预测Top药物结合文献、靶点通路等角度说明预测结果的可靠性；具体可参考原文。\n3、R包用法 1 2 3 library(tidyverse) library(Seurat) library(Asgard) 3.1 准备数据 药物数据：下载CMAP数据后，然后按细胞系所属的组织器官系统拆分成若干类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## linux下载 # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE70nnn/GSE70138/suppl/GSE70138_Broad_LINCS_cell_info_2017-04-28.txt.gz # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE70nnn/GSE70138/suppl/GSE70138_Broad_LINCS_Level5_COMPZ_n118050x12328_2017-03-06.gctx.gz # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE70nnn/GSE70138/suppl/GSE70138_Broad_LINCS_sig_info_2017-03-06.txt.gz # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE70nnn/GSE70138/suppl/GSE70138_Broad_LINCS_gene_info_2017-03-06.txt.gz # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE92nnn/GSE92742/suppl/GSE92742_Broad_LINCS_cell_info.txt.gz # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE92nnn/GSE92742/suppl/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx.gz # wget https://ftp.ncbi.nlm.nih.gov/geo/series/GSE92nnn/GSE92742/suppl/GSE92742_Broad_LINCS_sig_info.txt.gz ## 拆分数据，只需完成一次即可（已上传至网盘） # PrepareReference(cell.info=\u0026#34;GSE70138_Broad_LINCS_cell_info_2017-04-28.txt\u0026#34;, # gene.info=\u0026#34;GSE70138_Broad_LINCS_gene_info_2017-03-06.txt\u0026#34;, # GSE70138.sig.info = \u0026#34;GSE70138_Broad_LINCS_sig_info_2017-03-06.txt\u0026#34;, # GSE92742.sig.info = \u0026#34;GSE92742_Broad_LINCS_sig_info.txt\u0026#34;, # GSE70138.gctx = \u0026#34;GSE70138_Broad_LINCS_Level5_COMPZ_n118050x12328_2017-03-06.gctx\u0026#34;, # GSE92742.gctx = \u0026#34;GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, # Output.Dir = \u0026#34;DrugReference/\u0026#34; # ) 疾病数据：github给了原文分析所用的乳腺癌数据，这里简单以PBMC3K模拟一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #devtools::install_github(\u0026#39;satijalab/seurat-data\u0026#39;) SeuratData::InstallData(\u0026#34;pbmc3k\u0026#34;) data(\u0026#34;pbmc3k\u0026#34;) sce = pbmc3k sce$celltype = as.character(sce$seurat_annotations) # 以其中4种T细胞亚类为例 sce = sce[, str_detect(sce$celltype,\u0026#34;CD\u0026#34;)] set.seed(42) sce$sample \u0026lt;- sample(c(\u0026#34;before\u0026#34;, \u0026#34;after\u0026#34;), size = ncol(sce), replace = TRUE) table(sce$celltype, sce$sample) # after before # CD14+ Mono 236 244 # CD8 T 133 138 # Memory CD4 T 234 249 # Naive CD4 T 358 339 Case=c(\u0026#34;before\u0026#34;) Control=c(\u0026#34;after\u0026#34;) 3.2 细胞亚群DEG 该包Github首页教程中给出了全部4种差异分析的方法，这里以Seurat包的默认方法为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 DefaultAssay(sce) \u0026lt;- \u0026#34;RNA\u0026#34; Gene.list \u0026lt;- list() C_names \u0026lt;- NULL for(i in unique(sce@meta.data$celltype)){ # i = unique(sce@meta.data$celltype)[1] Idents(sce) \u0026lt;- \u0026#34;celltype\u0026#34; c_cells \u0026lt;- subset(sce, celltype == i) Idents(c_cells) \u0026lt;- \u0026#34;sample\u0026#34; C_data \u0026lt;- FindMarkers(c_cells, ident.1 = Case, ident.2 = Control) C_data_for_drug \u0026lt;- data.frame(row.names=row.names(C_data),score=C_data$avg_log2FC,adj.P.Val=C_data$p_val_adj,P.Value=C_data$p_val) ##for Seurat version \u0026gt; 4.0, please use avg_log2FC instead of avg_logFC Gene.list[[i]] \u0026lt;- C_data_for_drug C_names \u0026lt;- c(C_names,i) } names(Gene.list) \u0026lt;- C_names lapply(Gene.list, head) 3.3 药物干扰DEG 这里随机以乳腺组织为例 1 2 3 4 5 6 7 my_gene_info\u0026lt;-read.table(file=\u0026#34;DrugReference/breast_gene_info.txt\u0026#34;,sep=\u0026#34;\\t\u0026#34;,header = T,quote = \u0026#34;\u0026#34;) my_drug_info\u0026lt;-read.table(file=\u0026#34;DrugReference/breast_drug_info.txt\u0026#34;,sep=\u0026#34;\\t\u0026#34;,header = T,quote = \u0026#34;\u0026#34;) drug.ref.profiles = GetDrugRef(drug.response.path = \u0026#39;DrugReference/breast_rankMatrix.txt\u0026#39;, probe.to.genes = my_gene_info, drug.info = my_drug_info) # 包含两个元素的列表：[1] 药物的meta信息 [2] 药物的干扰基因排名结果 # 值得注意的是每个药物会因不同浓度，不同剂量等有不同的实验结果 3.4 细胞群药物 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Drug.ident.res = GetDrug(gene.data = Gene.list, CEG.threshold = 0.05, #判定每个基因是否显著的阈值 drug.ref.profiles = drug.ref.profiles, repurposing.unit = \u0026#34;drug\u0026#34;, connectivity = \u0026#34;negative\u0026#34;, #从小到大开始排序 drug.type = \u0026#34;FDA\u0026#34;) #c(\u0026#34;FDA\u0026#34;,\u0026#34;compounds\u0026#34;,\u0026#34;all\u0026#34;) head(Drug.ident.res[[1]]) # Drug.name Drug.id P.value FDR # 1 imatinib BRD-K92723993 1.491597e-07 0.0001971891 # 2 palbociclib BRD-K51313569 5.449091e-05 0.0360184923 # 3 auranofin BRD-A79465854 5.385982e-04 0.2373422941 # 4 nilotinib BRD-K81528515 8.217091e-04 0.2715748734 # 5 mebendazole BRD-K77987382 2.515145e-03 0.6650042235 # 6 guaifenesin BRD-A90515964 3.726919e-03 0.8211644934 str(Asgard::FDA.drug) # chr [1:4014] \u0026#34;lepirudin\u0026#34; \u0026#34;cetuximab\u0026#34; \u0026#34;dornase alfa\u0026#34; \u0026#34;denileukin diftitox\u0026#34; ... 3.5 药物综合分数 由于随机模拟数据的原因，且算法(已经向GITHUB issue)的问题，如下结果的Drug.therapeutic.score均为NAN。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 GSE92742.gctx.path=\u0026#34;GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34; GSE70138.gctx.path=\u0026#34;GSE70138_Broad_LINCS_Level5_COMPZ_n118050x12328_2017-03-06.gctx\u0026#34; Tissue=\u0026#34;breast\u0026#34; Drug.score\u0026lt;-DrugScore(SC.integrated=sce, Gene.data=Gene.list, Cell.type=NULL, Drug.data=Drug.ident.res, FDA.drug.only=TRUE, Case=Case, Tissue=Tissue, GSE92742.gctx=GSE92742.gctx.path, GSE70138.gctx=GSE70138.gctx.path) head(Drug.score) # Drug.therapeutic.score P.value FDR # abiraterone NaN 0.1164141 0.999979 # acamprosate NaN 0.3386581 0.999979 # acarbose NaN 0.4719701 0.999979 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/034%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--asgard%E5%8D%95%E7%BB%86%E8%83%9E%E8%8D%AF%E7%89%A9%E9%87%8D%E5%AE%9A%E5%90%91/","summary":"\u003cblockquote\u003e\n\u003cp\u003e来自密歇根大学医学院的计算医学与生物信息学部的LanaX.Garmire(拉娜·加米尔)团队近日于Nature Communication发表一篇基于单细胞转录组数据药物重定向研究的研究，并开发了相关R包。如下简单学习下该方法的原理以及R包使用方法。\u003c/p\u003e","title":"单细胞分析工具--Asgard单细胞药物重定向"},{"content":" 根据平时的文献阅读，汇总前人注释单细胞数据的细胞类型所使用的marker gene，以供后续研究参考。（持续更新）\n1、Tumor B cell：CD79A*[1-3]，CD79B[1,3]，CD19[1,3]，MS4A1[2,3]，IGKC[1]，MZB1[2]*\nT cell：CD3C*[1,2]，CD3E[1,2]，TRAG[1]，CD3G[1]，CD2[2]*\nEpithelial(Tumor) cell：EPCAM*[1,3]，KRT18[1,3]，CD24[1,2]，KRT19[1,3]，PAX8[1]，SCGB2A2[2]，KRT5[3]，KRT15[3]*\nFibroblast(CAF)：COL1A1*[1-3]，DCN[1-3]，COL1A2[1]，COL3A1[3]，BGN[1]，POSTN[1]，C1R[2]*\nMeyloid cell：CD68*[1-3]，LYZ[1-3]，MARCO[1]，AIF1[1]，TYROBP[2]，MS4A6A[3]，CD1E[3]，IL3RA[3]，LAMP3[3]*\nNK cell：NCR1*[1]，NCAM[1]，KLRC1[1]，KLRC3[1]*\nEndothelial cell：CLDN5*[1,2]，PECAM1[1]，VWF[1]，FLT1[2]，RAMP2[2]*\nMast cell：CPA3*[1,2]，CMA1[1]，MS4A2[1]，TPSAB1[2]，TPSB2[2]*\n[1] High-grade serous tubo-ovarian cancer refined with single-cell RNA sequencing: specific cell subtypes influence survival and determine molecular subtype classification（DOI: 10.1186/s13073-021-00922-x）34238352\n[2] A single-cell map of intratumoral changes during anti-PD1 treatment of patients with breast cancer（DOI: 10.1038/s41591-021-01323-8） 33958794\n[3] Single-cell transcriptomics reveals regulators underlying immune cell diversity and immune subtypes associated with prognosis in nasopharyngeal carcinoma（DOI: 10.1038/s41422-020-0374-x） 32686767\n1 2 3 4 5 6 7 8 9 10 ## PBMC genes_to_check = c(\u0026#39;CD3D\u0026#39;, \u0026#39;CD3E\u0026#39;, \u0026#39;CD3G\u0026#39;, # T cell \u0026#39;CD4\u0026#39;,\u0026#39;CD8A\u0026#39;,\u0026#39;CD8B\u0026#39;, # CD4 /CD8 \u0026#39;GZMB\u0026#39;, \u0026#39;GZMK\u0026#39;,\u0026#39;PRF1\u0026#39;, # cytotoxicity \u0026#39;CD19\u0026#39;, \u0026#39;CD79A\u0026#39;, \u0026#39;MS4A1\u0026#39;, # B cell \u0026#39;CD68\u0026#39;, \u0026#39;CD163\u0026#39;, \u0026#39;CD14\u0026#39;, #Monocytes and macrophages \u0026#39;S100A9\u0026#39;, \u0026#39;S100A8\u0026#39;, \u0026#39;MMP19\u0026#39;,# monocyte \u0026#39;KLRB1\u0026#39;,\u0026#39;NCR1\u0026#39;, # NK \u0026#39;MZB1\u0026#39; # Plasma cells ) 2、Brain Neuron：SYT1*[1]，SNAP25[1]，GRIN1[1]* Excitatory：SLC17A7*[1]，CAMK2A[1]，NRGN[1]* Inhibitory：GAD1*[1]，GAD2[1]* Microglia：CD74*[1]，CSF1R[1]，C3[1]* Astroglia：AQP4*[1]、GFAP[1]* Oligodendrocyte：MBP*[1]，MOBP[1]，PLP1[1]* Endothelial：FLT1*[1]，CLDN5[1]* [1] Single-cell transcriptomic analysis of Alzheimer’s disease（DOI: 10.1038/s41586-019-1195-2）\n3、Bowel Immune Paper ：The landscape of immune dysregulation in Crohn’s disease revealed through single-cell transcriptomic profiling in the ileum and colon\nDOI ：https://doi.org/10.1016/j.immuni.2023.01.002\n（1）Epithelial ：EPCAM, KRT8, KRT18\nEnterocyte肠上皮：RBP2, ANPEP,FABP2 Stem cell：LGR5, ASCL2, SMOC2, RGMB, OLFM4 Goblet cell 杯状细胞：CLCA1, SPDEF, FCGBP, ZG16, MUC2 Paneth cell 潘氏细胞：DEFA5,DEFA6, REG3A Tuft cell 簇细胞：LRMP, SH2D6 Enteroendocrine cell肠内分泌细胞：CHGA, CHGB, NEUROD1 Cycling ：UBE2C, TOP2A, MKI67, HMGB2 （2）Stromal ：CDH5, COL1A1, COL1A2, COL6A2, VWF\nFibroblast成纤维细胞：ADAMDEC1, PDGFRA, BMP4 Myofibroblasts成肌纤维细胞：TAGLN, ACTG2 Lymphatics淋巴：CCL21, TFF3 Endothelial cell ：CD36, DARC/ACKR1 Pericyte周皮细胞：NOTCH3, MCAM/CD146, RGS5 Glial cell：FOXD3, MPZ, CDH19, PLP1, SOX10, S100B, ERBB3 （3）Immune：CD45/PTPRC, CD3D, CD3G, CD3E, CD79A, CD79B, CD14, CD16, CD68, CD83, CSF1R, FCER1G\nT cell ：CD3D, CD3G, CD3E CD8 T ：CD8A, CD8B CD4 T ：CD4 Innate lymphoid cells (ILCs)先天性淋巴样细胞：RORC, IL1R1, IL23R, KIT, TNFSF4, PCDH9 NK：EOMES, PRF1, NKG7 B cell ： CD79A, MS4A1/CD20, CD19 Plasma cell ：SDC1, MZB1, SSR4, XBP1 B cell ：BANK, MS4A1/CD30, ADAM28, VPREB3 Germinal Center (GC) 生发中心B cell ：LRMP, GPT2, PAG1 Myeloid ：CD14, CD16, HLA-DR Mast cell ：GATA2, CPA3, HPGDS classical Macrophages：CD163, C1QB, C1QC classical Monocytes：FCN1, S100A4, S100A6 dendritic cell，DC1 ：CLEC9A, XCR1 dendritic cell，DC2 ： CLEC10A, FCER1A ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/028%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--%E5%9F%BA%E4%BA%8E%E6%96%87%E7%8C%AE%E7%9A%84%E7%BB%86%E8%83%9E%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8Amarker/","summary":"\u003cblockquote\u003e\n\u003cp\u003e根据平时的文献阅读，汇总前人注释单细胞数据的细胞类型所使用的marker gene，以供后续研究参考。（持续更新）\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1tumor\"\u003e1、Tumor\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eB cell\u003c/strong\u003e：CD79A*[1-3]\u003cem\u003e，CD79B\u003c/em\u003e[1,3]\u003cem\u003e，CD19\u003c/em\u003e[1,3]\u003cem\u003e，MS4A1\u003c/em\u003e[2,3]\u003cem\u003e，IGKC\u003c/em\u003e[1]\u003cem\u003e，MZB1\u003c/em\u003e[2]*\u003c/p\u003e","title":"单细胞分析工具--基于文献的细胞类型注释marker"},{"content":" scSTAR是由复旦大学附属中山医院郝洁研究员等人开发的单细胞分析工具包，于2023年2月发表在Briefings in Bioinformatics。该包更加准确地实现同一细胞类型在不同组(正常/疾病)的变化情况下，细胞内部亚型异质性的变化捕捉，在单细胞数据挖掘领域提供新的视角。\nPaper：https://doi.org/10.1093/bib/bbad062 Github：https://github.com/Hao-Zou-lab/scSTAR 1、文章概述 示例1：小鼠年老过程中CD4+ T细胞的亚型变化过程\nnaive CD4+ T cells from youg and old mice\n使用scSTRA分为5类亚群\nTcm Tem：main in young mice Texh: main in old mice 其它两类 结论： a shift from effective to exhausted functions during ageing.\n示例2：小鼠年老过程中某一T细胞亚型的比例分布\nactivated CD4+ T cells from young and old mice 根据Cdc23基因是否表达，进一步分为Cdc23+ 与 Cdc23- 两类 使用scSTAR分成3个亚群：scS_0/scS_1/scS_2 scS_1主要包括了Cdc23+，并且主要来自young mice scS_2主要包括了Cdc23-，并且主要来自oldmice 结论：Cdc23 may play a role in antiageing activities. 示例3：鉴定出促癌作用的eTreg亚型\n从正常组织与肺腺癌数据中提取了739个Treg细胞 使用scSTAR分为5个亚群：C1-C5 C1与C3亚群的marker基因与病人生存具有较好的相关性 在肝癌数据中得到了相似的发现 结论：active Treg subtypes in the tumour microenvironment 示例4：预测黑色素瘤免疫治疗反应的相关亚型\n经免疫治疗前后的黑色素瘤样本中的5410个CD8+ T细胞； 使用scSTAR将治疗前的CD8+ T分为6个亚群 在non-responder组中(C4+C6)/(C1+C2+C5)比值远高于responder组 结论：(C4+C6)/(C1+C2+C5)比值对于免疫治疗预后相关 2、R包用法 本质用法可以理解为对来自两个样本(正常/疾病)的单细胞数据进行“校正批次”\n（1）安装、加载相关R包 1 2 3 4 5 6 library(R.matlab) library(tsne) library(pls) # https://github.com/Hao-Zou-lab/scSTAR/blob/main/scSTAR_0.1.1.0.tar.gz # install.packages(\u0026#34;scSTAR_0.1.1.0.tar.gz\u0026#34;, repos = NULL, type=\u0026#34;source\u0026#34;) library(scSTAR) （2）准备log2处理的count矩阵。这里使用示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 extdir = system.file(\u0026#34;extdata\u0026#34;,package=\u0026#34;scSTAR\u0026#34;) data = readMat(paste0(extdir,\u0026#39;/demo_data.mat\u0026#39;)) geneList = as.matrix(unlist(data$geneList)) data1 = as.matrix((data$data1)) dim(data1) # [1] 18825 1078 rownames(data1) = geneList colnames(data1) = paste0(\u0026#34;d1_cell\u0026#34;,seq(ncol(data1))) data2 = as.matrix((data$data2)) dim(data2) # [1] 18825 1388 rownames(data2) = geneList colnames(data2) = paste0(\u0026#34;d2_cell\u0026#34;,seq(ncol(data2))) （3）scSTAR分析步骤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## step-1: 挑选基因 data = cbind(data1, data2) idx_OGFSC = filter_gene(data, nBins = 20, plot_option = 1)$OGFSC_idx length(idx_OGFSC) # [1] 6683 head(idx_OGFSC) # [1] 5 6 10 11 12 17 Ctr_filtered = data1[idx_OGFSC,] Case_filtered = data2[idx_OGFSC,] ## step-2: 鉴定细胞并\u0026#34;校正\u0026#34; anchorCells = findAnchors(Ctr_filtered, Case_filtered, 3) # When PLScomp = 0, the number of PLScomp can be automatically estimated. # suggest 3-5 out = scSTAR(Ctr_filtered, Case_filtered, anchorCells, PLScomp = 4) names(out) # [1] \u0026#34;Case_kinetics\u0026#34; \u0026#34;idx_DE_up\u0026#34; \u0026#34;Ctr_corrected\u0026#34; \u0026#34;Case_corrected\u0026#34; \u0026#34;Ctr_kinetics\u0026#34; \u0026#34;idx_DE_down\u0026#34; # 查看函数帮助文档，了解每个的含义 （4）使用Seurat进行聚类等相关分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 data2 = cbind(out$Case_kinetics, out$Ctr_kinetics) rownames(data2) = geneList[idx_OGFSC] dim(data2) # [1] 6683 2466 library(Seurat) library(tidyverse) sce = Seurat::CreateSeuratObject(data2) sce@assays$RNA@data = data2 sce = sce %\u0026gt;% FindVariableFeatures() %\u0026gt;% ScaleData() %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) # DimPlot(sce, reduction = \u0026#34;umap\u0026#34;) sce = sce %\u0026gt;% FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.01, 0.05, 0.1)) diff_wilcox = FindAllMarkers(sce, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;data\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/035%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--scstar%E6%8C%96%E6%8E%98%E5%88%86%E7%BB%84%E6%A0%B7%E6%9C%AC%E7%BB%86%E8%83%9E%E4%BA%9A%E5%9E%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003escSTAR是由复旦大学附属中山医院郝洁研究员等人开发的单细胞分析工具包，于2023年2月发表在Briefings in Bioinformatics。该包更加准确地实现同一细胞类型在不同组(正常/疾病)的变化情况下，细胞内部亚型异质性的变化捕捉，在单细胞数据挖掘领域提供新的视角。\u003c/p\u003e","title":"单细胞分析工具--scSTAR挖掘分组样本细胞亚型"},{"content":" 原始论文：https://www.nature.com/articles/s41592-019-0667-5 官方手册：https://github.com/saeyslab/nichenetr 1 2 # install.packages(\u0026#34;devtools\u0026#34;) devtools::install_github(\u0026#34;saeyslab/nichenetr\u0026#34;) 0、原理简介 （1）NicheNet是2020年于Nature method提出的单细胞数据细胞通讯分析工具。相比于cellphoneDB等工具，NicheNet进一步考虑了受体被激活后的信号传导与下游靶基因的差异表达情况。\n（2）如下图所示，NicheNet的核心思路是根据receiver cell的特定基因集，寻找最有可能的上游配体以及相应的sender cell。其中有如下要点\n特定基因集，原文称为gene set of interest，即细胞通讯最终所影响的基因(target gene)；一般表示receiver cell受外界影响因素而产生的差异表达基因(e.g. 造模前后、给药前后)。 根据上述特定基因集的定义，一般需要前后对照的单细胞数据才能进行NicheNet分析 NicheNet预测潜在上游配体的核心思路是计算配体所影响的下游基因与受体细胞所观测的特定基因集的相似性。如果相似性高，则认为是潜在的配体。 在分析时，仅根据所在细胞类型对于配/受体表达比例界定是否表达，之后的分析将不会再考虑其表达情况； 1、数据准备 NicheNet基础分析时需要准备如下的3个输入数据。其由人类基因相关数据库整理而成；对于小鼠单细胞数据分析，可（1）直接将人基因名进行同源转换；（2）根据小鼠相关数据库，自己整理出下面的文件。\n配体-靶基因数据\nhttps://zenodo.org/record/3260758/files/ligand_target_matrix.rds\n1 2 3 4 5 6 7 8 9 10 ligand_target_matrix = readRDS(\u0026#34;ligand_target_matrix.rds\u0026#34;) # target genes in rows, ligands in columns dim(ligand_target_matrix) # [1] 25345 688 ligand_target_matrix[1:4,1:4] # CXCL1 CXCL2 CXCL3 CXCL5 # A1BG 0.0003534343 0.0004041324 0.0003729920 0.0003080640 # A1BG-AS1 0.0001650894 0.0001509213 0.0001583594 0.0001317253 # A1CF 0.0005787175 0.0004596295 0.0003895907 0.0003293275 # A2M 0.0006027058 0.0005996617 0.0005164365 0.0004517236 配体-受体数据\nhttps://zenodo.org/record/3260758/files/lr_network.rds\n1 2 3 4 5 6 7 8 9 lr_network = readRDS(\u0026#34;lr_network.rds\u0026#34;) dim(lr_network) # [1] 12651 4 head(lr_network) # from to source database # 1 CXCL1 CXCR2 kegg_cytokines kegg # 2 CXCL2 CXCR2 kegg_cytokines kegg # 3 CXCL3 CXCR2 kegg_cytokines kegg # 4 CXCL5 CXCR2 kegg_cytokines kegg 互作权重数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 weighted_networks = readRDS(\u0026#34;weighted_networks.rds\u0026#34;) # (1)interactions and their weights in the ligand-receptor + signaling network head(weighted_networks$lr_sig) # from to weight # 1 A1BG ABCC6 0.42164389 # 2 A1BG ACE2 0.10074109 # 3 A1BG ADAM10 0.09698978 # (2)interactions and their weights in the gene regulatory network head(weighted_networks$gr) # from to weight # 1 A1BG A2M 0.02944793 # 2 AAAS GFAP 0.02904173 # 3 AADAC CYP3A4 0.04215706 2、基础分析 参考官方手册，可直接从单细胞表达矩阵开始分析；也可以基于Seurat格式进行分析。如下将采取后者进行学习。\nhttps://github.com/saeyslab/nichenetr/blob/master/vignettes/seurat_wrapper.md 1 2 3 library(nichenetr) library(Seurat) # please update to Seurat V4 library(tidyverse) （1）示例数据 经LCMV感染前后的腹股沟淋巴结的单细胞测序数据，数据已完成细胞类型注释等分析。\nhttps://zenodo.org/record/3531889/files/seuratObj.rds\n分析目的：发现在LCMV感染后，哪些细胞类型的哪些配体参与到CD8 T细胞内的基因表达变化。\n1 2 3 4 5 6 7 seuratObj = readRDS(\u0026#34;seuratObj.rds\u0026#34;) table(seuratObj$celltype) # B CD4 T CD8 T DC Mono NK Treg # 382 2562 1645 18 90 131 199 table(seuratObj$aggregate) # LCMV SS # 3886 1141 （2）函数参数 NicheNet的基础分析可由包装好的nichenet_seuratobj_aggregate()函数一次性完成，因此参数较多；下面简单介绍下其中重要的参数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 nichenet_seuratobj_aggregate( seurat_obj = seuratObj, # Seurat对象，其active.ident需设置为细胞类型 expression_pct = 0.10, # 界定细胞类型是否表达配/受体的比例阈值，默认为0.1 organism = \u0026#34;mouse\u0026#34;, # 交代物种信息，默认为人类 c(\u0026#34;human\u0026#34;,\u0026#34;mouse\u0026#34;) #Group condition_colname = \u0026#34;aggregate\u0026#34;, # 交代分组的meta名 condition_oi = \u0026#34;LCMV\u0026#34;, condition_reference = \u0026#34;SS\u0026#34;, # 交代实验组与对照组名 # receiver receiver = \u0026#34;CD8 T\u0026#34;, # 交代receiver细胞类型 geneset = \u0026#34;DE\u0026#34;, # 判断特定基因集的方法，默认使用全部差异基因(oi/ref)c(\u0026#34;DE\u0026#34;,\u0026#34;up\u0026#34;,\u0026#34;down\u0026#34;) lfc_cutoff = 0.25, # 判断差异基因的阈值 # sender sender = c(\u0026#34;CD4 T\u0026#34;,\u0026#34;Treg\u0026#34;, \u0026#34;Mono\u0026#34;, \u0026#34;NK\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;DC\u0026#34;), #设置可能的sender cell top_n_targets = 200, #每个ligand最多考虑200个target gene top_n_ligands = 20, #给出最有可能的20个上游ligand cutoff_visualization = 0.33, #设置可视化ligand-target scores的阈值 # refer data ligand_target_matrix = ligand_target_matrix, lr_network = lr_network, weighted_networks = weighted_networks, ) receiver参数可以是多种细胞类型，会对每一种单独分析，将结果整合为list\nsender参数设置为all时考虑所有细胞类型为sender，包括receiver(自分泌)；设置为undefined时，则不考虑细胞类型。\n（3）结果解读 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Idents(seuratObj)=\u0026#34;celltype\u0026#34; ligand_target_matrix = readRDS(\u0026#34;ligand_target_matrix.rds\u0026#34;) lr_network = readRDS(\u0026#34;lr_network.rds\u0026#34;) weighted_networks = readRDS(\u0026#34;weighted_networks.rds\u0026#34;) nichenet_output = nichenet_seuratobj_aggregate( seurat_obj = seuratObj, expression_pct = 0.10, organism = \u0026#34;mouse\u0026#34;, # #Group condition_colname = \u0026#34;aggregate\u0026#34;, condition_oi = \u0026#34;LCMV\u0026#34;, condition_reference = \u0026#34;SS\u0026#34;, # receiver receiver = \u0026#34;CD8 T\u0026#34;, geneset = \u0026#34;DE\u0026#34;, lfc_cutoff = 0.25, # sender sender = c(\u0026#34;CD4 T\u0026#34;,\u0026#34;Treg\u0026#34;, \u0026#34;Mono\u0026#34;, \u0026#34;NK\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;DC\u0026#34;), top_n_ligands = 20, top_n_targets = 200, cutoff_visualization = 0.33, # refer data ligand_target_matrix = ligand_target_matrix, lr_network = lr_network, weighted_networks = weighted_networks, ) 排名靠前的ligand\n主要根据pearson列进行排名，该值越高表明ligand的target基因富集到receiver细胞的差异基因集中。如手册中提到，若该值高于0.1，则可认为是显著的富集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 nichenet_output$ligand_activities # # A tibble: 44 × 7 # test_ligand auroc aupr aupr_corrected pearson rank bona_fide_ligand # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;lgl\u0026gt; # 1 Ebi3 0.690 0.211 0.128 0.229 1 FALSE # 2 Il15 0.589 0.112 0.0286 0.0800 2 TRUE # 3 Crlf2 0.555 0.122 0.0380 0.0757 3 FALSE nichenet_output$top_ligands # [1] \u0026#34;Ebi3\u0026#34; \u0026#34;Il15\u0026#34; \u0026#34;Crlf2\u0026#34; \u0026#34;Tgfb1\u0026#34; \u0026#34;App\u0026#34; \u0026#34;Ptprc\u0026#34; \u0026#34;H2-M3\u0026#34; \u0026#34;Icam1\u0026#34; # [9] \u0026#34;Cxcl10\u0026#34; \u0026#34;Ccl5\u0026#34; \u0026#34;Cxcl11\u0026#34; \u0026#34;Adam17\u0026#34; \u0026#34;H2-T23\u0026#34; \u0026#34;Cxcl9\u0026#34; \u0026#34;Cxcl16\u0026#34; \u0026#34;Sema4d\u0026#34; # [17] \u0026#34;Calr\u0026#34; \u0026#34;C3\u0026#34; \u0026#34;Mif\u0026#34; \u0026#34;Pkd1\u0026#34; ## 相关可视化 # ligand在不同细胞类型的表达 nichenet_output$ligand_expression_dotplot # ligand在感染前后的差异表达 nichenet_output$ligand_differential_expression_heatmap ligand对应的target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # ligand-target score nichenet_output$ligand_target_matrix %\u0026gt;% .[1:10,1:6] nichenet_output$ligand_target_df %\u0026gt;% head nichenet_output$top_targets ## 可视化 # ligand-target score热图 ichenet_output$ligand_target_heatma # 靶基因在reciver细胞类型中的差异表达 DotPlot(seuratObj %\u0026gt;% subset(idents = \u0026#34;CD8 T\u0026#34;), features = nichenet_output$top_targets %\u0026gt;% rev(), split.by = \u0026#34;aggregate\u0026#34;) + RotatedAxis() VlnPlot(seuratObj %\u0026gt;% subset(idents = \u0026#34;CD8 T\u0026#34;), features = c(\u0026#34;Zbp1\u0026#34;,\u0026#34;Ifit3\u0026#34;,\u0026#34;Irf7\u0026#34;), split.by = \u0026#34;aggregate\u0026#34;, pt.size = 0, combine = FALSE) ## 上述的综合可视化 nichenet_output$ligand_activity_target_heatmap ligand对应的receptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # ligand-receptor score nichenet_output$ligand_receptor_matrix %\u0026gt;% .[1:10,1:6] nichenet_output$ligand_receptor_df nichenet_output$top_receptors ## 可视化 # ligand-receptor score热图 nichenet_output$ligand_receptor_heatmap # receptor在receiver细胞类型的差异表达 nichenet_output$top_receptors # ligand与receptor的注释来源可靠性 nichenet_output$ligand_receptor_matrix_bonafide nichenet_output$ligand_receptor_df_bonafide nichenet_output$ligand_receptor_heatmap_bonafide 查看特定基因集 1 2 nichenet_output$geneset_oi nichenet_output$background_expressed_genes %\u0026gt;% length() 衍生可视化：可将ligand-target或者ligand-receptor的关系绘制成弦图，具体可参考：https://github.com/saeyslab/nichenetr/blob/master/vignettes/seurat_wrapper_circos.md\n3、衍生分析 （1）信号路径可视化 对基础分析结果得到的感兴趣上游配体与预测靶基因之间的信号传递过程进行网络可视化\n数据准备：路径分析主要用到前两个文件；后3个文件主要用于数据来源/类型注释 1 2 3 4 5 6 7 8 9 10 11 12 # https://zenodo.org/record/3260758/files/weighted_networks.rds weighted_networks = readRDS(\u0026#34;weighted_networks.rds\u0026#34;) # https://zenodo.org/record/3260758/files/ligand_tf_matrix.rds ligand_tf_matrix = readRDS(\u0026#34;ligand_tf_matrix.rds\u0026#34;) # https://zenodo.org/record/3260758/files/lr_network.rds lr_network = readRDS(\u0026#34;lr_network.rds\u0026#34;) # https://zenodo.org/record/3260758/files/signaling_network.rds sig_network = readRDS(\u0026#34;signaling_network.rds\u0026#34;) # https://zenodo.org/record/3260758/files/gr_network.rds gr_network = readRDS(\u0026#34;gr_network.rds\u0026#34;) 路径分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ## 交代感兴趣的配体与受体 ligands_all = \u0026#34;TGFB3\u0026#34; # 可以是多个 targets_all = c(\u0026#34;TGFBI\u0026#34;,\u0026#34;LAMC2\u0026#34;,\u0026#34;TNC\u0026#34;) ## 分析/提取路径 active_signaling_network = get_ligand_signaling_path( ligand_tf_matrix = ligand_tf_matrix, ligands_all = ligands_all, targets_all = targets_all, weighted_networks = weighted_networks) lapply(active_signaling_network, head) # $sig # # A tibble: 6 × 3 # from to weight # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; # 1 IRAK1 PELI2 1.54 # 2 IRAK1 SMAD3 0.608 # 3 IRAK1 STAT3 0.676 # $gr # # A tibble: 6 × 3 # from to weight # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; # 1 SMAD1 TGFBI 0.0877 # 2 SMAD2 LAMC2 0.0587 # 3 SMAD2 TGFBI 0.0521 ## 权重标准化 active_signaling_network_min_max = active_signaling_network active_signaling_network_min_max$sig = active_signaling_network_min_max$sig %\u0026gt;% mutate(weight = ((weight-min(weight))/(max(weight)-min(weight))) + 0.75) active_signaling_network_min_max$gr = active_signaling_network_min_max$gr %\u0026gt;% mutate(weight = ((weight-min(weight))/(max(weight)-min(weight))) + 0.75) 可视化（在linux环境好像不能绘制，window版本可以） 1 2 3 4 5 6 7 8 9 10 11 12 13 ## 转为dgr_graph对象 graph_min_max = diagrammer_format_signaling_graph( signaling_graph_list = active_signaling_network_min_max, ligands_all = ligands_all, targets_all = targets_all, sig_color = \u0026#34;indianred\u0026#34;, gr_color = \u0026#34;steelblue\u0026#34;) ## 可视化 DiagrammeR::render_graph(graph_min_max, output=\u0026#34;visNetwork\u0026#34;, # graph, visNetwork layout = \u0026#34;tree\u0026#34; # nicely, circle, tree, kk, and fr ) 保存为cytoscape输入文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ## 边edge信息(权重) bind_rows(active_signaling_network$sig %\u0026gt;% mutate(layer = \u0026#34;signaling\u0026#34;), active_signaling_network$gr %\u0026gt;% mutate(layer = \u0026#34;regulatory\u0026#34;)) %\u0026gt;% head # # A tibble: 6 × 4 # from to weight layer # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; # 1 IRAK1 PELI2 1.54 signaling # 2 IRAK1 SMAD3 0.0608 signaling # 3 IRAK1 STAT3 0.676 signaling ## 边edge注释来源信息 data_source_network = infer_supporting_datasources( signaling_graph_list = active_signaling_network, lr_network = lr_network, sig_network = sig_network, gr_network = gr_network) head(data_source_network) # # A tibble: 6 × 5 # from to source database layer # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 SMAD1 TGFBI regnetwork_source regnetwork regulatory # 2 SMAD1 TGFBI Remap_5 Remap regulatory # 3 SMAD2 LAMC2 harmonizome_CHEA harmonizome_gr regulatory ## 节点node类型(4种) all_genes = data_source_network[,c(\u0026#34;from\u0026#34;,\u0026#34;to\u0026#34;)] %\u0026gt;% as.matrix() %\u0026gt;% reshape2::melt() %\u0026gt;% .[,3] %\u0026gt;% unique() specific_annotation_tbl = bind_rows( tibble(gene = ligands_all, annotation = \u0026#34;ligand\u0026#34;), tibble(gene = targets_all, annotation = \u0026#34;target\u0026#34;), tibble(gene = all_genes %\u0026gt;% setdiff(c(targets_all,ligands_all)) %\u0026gt;% intersect(lr_network$to %\u0026gt;% unique()), annotation = \u0026#34;receptor\u0026#34;), tibble(gene = all_genes %\u0026gt;% setdiff(c(targets_all,ligands_all)) %\u0026gt;% intersect(gr_network$from %\u0026gt;% unique()) %\u0026gt;% setdiff(all_genes %\u0026gt;% intersect(lr_network$to %\u0026gt;% unique())), annotation = \u0026#34;transcriptional regulator\u0026#34;)) non_specific_annotation_tbl = tibble( gene = all_genes %\u0026gt;% setdiff(specific_annotation_tbl$gene), annotation = \u0026#34;signaling mediator\u0026#34;) bind_rows(specific_annotation_tbl,non_specific_annotation_tbl) %\u0026gt;% count(annotation) # # A tibble: 5 × 2 # annotation n # \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; # 1 ligand 1 # 2 receptor 1 # 3 signaling mediator 7 # 4 target 3 # 5 transcriptional regulator 1 （2）自定义基因集 分析场景：在头颈部鳞状细胞癌单细胞数据中，在成纤维细胞群中发现可诱导肿瘤细胞pEMT程序基因集表达的ligand。\nstep1 准备数据 1 2 3 4 5 6 7 8 9 10 # ligand-target ligand_target_matrix = readRDS(\u0026#34;ligand_target_matrix.rds\u0026#34;) # ligand-receptor lr_network = readRDS(\u0026#34;lr_network.rds\u0026#34;) # 单细胞数据 hnscc_expression = readRDS(\u0026#34;hnscc_expression.rds\u0026#34;) expression = hnscc_expression$expression sample_info = hnscc_expression$sample_info # contains meta-information about the cells tumors_remove = c(\u0026#34;HN10\u0026#34;,\u0026#34;HN\u0026#34;,\u0026#34;HN12\u0026#34;, \u0026#34;HN13\u0026#34;, \u0026#34;HN24\u0026#34;, \u0026#34;HN7\u0026#34;, \u0026#34;HN8\u0026#34;,\u0026#34;HN23\u0026#34;) step2 定位成纤维细胞与肿瘤细胞 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 成纤维细胞表达信息 CAF_ids = sample_info %\u0026gt;% filter(`Lymph node` == 0 \u0026amp; !(tumor %in% tumors_remove) \u0026amp; `non-cancer cell type` == \u0026#34;CAF\u0026#34;) %\u0026gt;% pull(cell) #404 expressed_genes_CAFs = expression[CAF_ids,] %\u0026gt;% apply(2,function(x){10*(2**x - 1)}) %\u0026gt;% apply(2,function(x){log2(mean(x) + 1)}) %\u0026gt;% .[. \u0026gt;= 4] %\u0026gt;% names() # 6706\t## 肿瘤恶性细胞表达信息 malignant_ids = sample_info %\u0026gt;% filter(`Lymph node` == 0 \u0026amp; !(tumor %in% tumors_remove) \u0026amp; `classified as cancer cell` == 1) %\u0026gt;% pull(cell) #1388 expressed_genes_malignant = expression[malignant_ids,] %\u0026gt;% apply(2,function(x){10*(2**x - 1)}) %\u0026gt;% apply(2,function(x){log2(mean(x) + 1)}) %\u0026gt;% .[. \u0026gt;= 4] %\u0026gt;% names() # 6351 step3 确定基因集 1 2 3 4 5 6 7 # pEMT基因集(靶基因) pemt_geneset = readr::read_tsv(\u0026#34;pemt_signature.txt\u0026#34;, col_names = \u0026#34;gene\u0026#34;) %\u0026gt;% pull(gene) %\u0026gt;% .[. %in% rownames(ligand_target_matrix)] # 背景基因集(受体细胞表达) background_expressed_genes = expressed_genes_malignant %\u0026gt;% .[. %in% rownames(ligand_target_matrix)] step4 候选配受体对 1 2 3 4 5 6 7 8 9 10 11 12 # 在CAF里表达的ligand ligands = lr_network %\u0026gt;% pull(from) %\u0026gt;% unique() expressed_ligands = intersect(ligands,expressed_genes_CAFs) # 在tumor里表达的receptor receptors = lr_network %\u0026gt;% pull(to) %\u0026gt;% unique() expressed_receptors = intersect(receptors,expressed_genes_malignant) # 符合最低条件的候选ligand-receptor pair potential_ligands = lr_network %\u0026gt;% filter(from %in% expressed_ligands \u0026amp; to %in% expressed_receptors) %\u0026gt;% pull(from) %\u0026gt;% unique() head(potential_ligands) step5 根据靶基因重合，预测ligand活性 1 2 3 4 5 6 7 8 9 10 11 ligand_activities = predict_ligand_activities( geneset = pemt_geneset, background_expressed_genes = background_expressed_genes, ligand_target_matrix = ligand_target_matrix, potential_ligands = potential_ligands) ligand_activities %\u0026gt;% arrange(-pearson) best_upstream_ligands = ligand_activities %\u0026gt;% top_n(20, pearson) %\u0026gt;% arrange(-pearson) %\u0026gt;% pull(test_ligand) head(best_upstream_ligands) # [1] \u0026#34;PTHLH\u0026#34; \u0026#34;CXCL12\u0026#34; \u0026#34;AGT\u0026#34; \u0026#34;TGFB3\u0026#34; \u0026#34;IL6\u0026#34; \u0026#34;INHBA\u0026#34; step6 根据Top20 ligand预测基因是否为pEMT相关基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 k = 3 # 3-fold n = 5 # 2 rounds pemt_gene_predictions_top20_list = seq(n) %\u0026gt;% lapply(assess_rf_class_probabilities, folds = k, geneset = pemt_geneset, background_expressed_genes = background_expressed_genes, ligands_oi = best_upstream_ligands, ligand_target_matrix = ligand_target_matrix) target_prediction_performances_cv = pemt_gene_predictions_top20_list %\u0026gt;% lapply(classification_evaluation_continuous_pred_wrapper) %\u0026gt;% bind_rows() %\u0026gt;% mutate(round=seq(1:nrow(.))) dim(target_prediction_performances_cv) # [1] 5 11 # 预测Top 5%的基因中 根据真实标签的两类基因的均分 target_prediction_performances_discrete_cv %\u0026gt;% filter(true_target) %\u0026gt;% .$fraction_positive_predicted %\u0026gt;% mean() ## [1] 0.25 target_prediction_performances_discrete_cv %\u0026gt;% filter(!true_target) %\u0026gt;% .$fraction_positive_predicted %\u0026gt;% mean() ## [1] 0.04769076 # fisher\u0026#39;s test target_prediction_performances_discrete_fisher = pemt_gene_predictions_top20_list %\u0026gt;% lapply(calculate_fraction_top_predicted_fisher, quantile_cutoff = 0.95) target_prediction_performances_discrete_fisher %\u0026gt;% unlist() %\u0026gt;% mean() ## [1] 5.647773e-10 （3）单细胞配体活性 假设：对于一个单细胞表达信息，如果sender配体的下游receiver靶基因高表达（相较其它细胞）；则推测该配体有较高的活性。\n分析数据同上面的肿瘤数据，并且分析过程中一直到确定候选ligand-receptor步骤一致(step1~4)\nstep5：计算单细胞配体活性（receiver细胞中受sender cell配体调控的活性） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 对受体细胞表达信息进行标准化 expression_scaled = expression[malignant_ids,background_expressed_genes] %\u0026gt;% scale_quantile() # 示例10个细胞进行分析 malignant_hn5_ids = sample_info %\u0026gt;% filter(tumor == \u0026#34;HN5\u0026#34;) %\u0026gt;% filter(`Lymph node` == 0) %\u0026gt;% filter(`classified as cancer cell` == 1) %\u0026gt;% pull(cell) %\u0026gt;% head(10) # 计算每个细胞对于所有候选配体的受调控活性 ligand_activities = predict_single_cell_ligand_activities( cell_ids = malignant_hn5_ids, expression_scaled = expression_scaled, ligand_target_matrix = ligand_target_matrix, potential_ligands = potential_ligands) # 131 dim(ligand_activities) # [1] 1310 5 head(ligand_activities) # # A tibble: 6 × 5 # setting test_ligand auroc aupr pearson # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 HNSCC5_p3_HNSCC5_P3_E03 HGF 0.538 0.0310 0.0233 # 2 HNSCC5_p3_HNSCC5_P3_E03 TNFSF10 0.529 0.0292 0.0144 # 3 HNSCC5_p3_HNSCC5_P3_E03 TGFB2 0.551 0.0391 0.0343 ## 对配体活性标准化 normalized_ligand_activities = normalize_single_cell_ligand_activities(ligand_activities) dim(normalized_ligand_activities) # [1] 10 132 step6：计算细胞配体活性与目标基因表达活性的相关性 1 2 3 4 5 6 7 8 cell_scores_tbl = tibble( cell = malignant_hn5_ids, score = expression_scaled[malignant_hn5_ids,\u0026#34;TGFBI\u0026#34;]) ## 配体TNC活性与TGFB1配体表达的相关性 inner_join(cell_scores_tbl,normalized_ligand_activities) %\u0026gt;% ggplot(aes(score,TNC)) + geom_point() + geom_smooth(method = \u0026#34;lm\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/029%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--nichenet%E7%BB%86%E8%83%9E%E9%80%9A%E8%AE%AF%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e原始论文：https://www.nature.com/articles/s41592-019-0667-5\u003c/li\u003e\n\u003cli\u003e官方手册：https://github.com/saeyslab/nichenetr\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# install.packages(\u0026#34;devtools\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edevtools::install_github(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;saeyslab/nichenetr\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"0原理简介\"\u003e0、原理简介\u003c/h2\u003e\n\u003cp\u003e（1）NicheNet是2020年于Nature method提出的单细胞数据细胞通讯分析工具。相比于cellphoneDB等工具，NicheNet进一步考虑了受体被激活后的信号传导与下游靶基因的差异表达情况。\u003c/p\u003e","title":"单细胞分析工具--NicheNet细胞通讯分析"},{"content":" cellDancer是美国休斯顿卫理公会研究所的助理教授Guangyu Wang团队开发的RNA速率分析新工具，于2023年4月发表于nature biotechnology。该工具基于深度学习框架预测细胞特异的速率参数(α, β and γ)，相较于之前的scvelo等RNA速率分析工具可有效预测 transcriptional boost, multi-lineage forward, multi-lineage backward等复杂情况下的单细胞数据发育预测分析。\nPaper：https://www.nature.com/articles/s41587-023-01728-5 Github：https://github.com/GuangyuWangLab2021/cellDancer Tutorial：https://guangyuwanglab2021.github.io/cellDancer_website 文章概述 （1）模型算法简介\n首先根据velocity算法计算出每个细胞的每个基因的unspliced与spliced丰度； 然后将其作为DNN神经网络的输入层，模型输出是3个速率参数； 再根据预测的参数计算该基因未来下一状态的unspliced与spliced丰度； 将计算的unspliced与spliced丰度与该基因所在细胞的邻居unspliced与spliced丰度相似度作为损失函数指标； 在不断优化迭代过程中，得到每个细胞中每个基因的最佳速率参数； 基于上述得到的速率参数，进行后续的下游分析，例如细胞速率推测，伪时间分析等。 （2）复杂情况数据\u0026ndash;transcription boost\nTranscriptional boost refers to a boost in the expression induced by a change in the transcription rate.即基因在发育过程出现异常的激活 Barile鉴定了89个在红系细胞分化过程中出现transcription boost现象的基因。 这些基因会导致传统工具(scVelo)导致错误的预测，而cellDancer而进行有效的处理 （3）复杂情况数据\u0026ndash;multi-lineage异质性\n小鼠海马体有5个发育分支谱系，分别是 dentate gyrus granule neurons pyramidal neurons in subiculum and CA1 pyramidal neurons in CA2/3/4 oligodendrocyte precursors (OPCs) astrocyte 由于在不同分支中，基因可能有不同的表达模式，称为branching gene branching gene在不同分支中具有multiple dynamics；与之相对的则只有mono-kinetic 如下图所示 cellDancer不仅能够正确预测细胞发育轨迹，也能正确鉴定出branching genes （4）衍生用法的介绍\n小鼠胰腺可发育成4种细胞类型，简称为alpha-, beta-, delta-，epsilon-cells cellDancer在进一步预测发育轨迹的基础上，可使用每个细胞的每个基因的3个速率参数作为鉴定细胞类型的方式之一 此外cellDancer的分析结果也可无缝衔接到dynamo分析框架，进行多样的后续下游分析。 此外文章进一步结合scEU-seq数据等角度验证cellDancer分析结果的可靠性、鲁棒性等，在此就不记录了，具体看阅读原文。\n软件用法 作者提供了一个全面的教程资源以及示例数据可供学习；\n​\thttps://guangyuwanglab2021.github.io/cellDancer_website/\n在此以其中一个示例数据学习其主要的使用方法。\n根据教程，搭建conda环境，并下载示例数据（Case 1）\n1 2 3 4 conda create -n cellDancer python==3.7.6 conda activate cellDancer pip install celldancer # jupyter lab 环境下分析 1 2 3 4 5 6 7 8 9 10 import os import sys import glob import pandas as pd import math import matplotlib.pyplot as plt import celldancer as cd import celldancer.cdplt as cdplt from celldancer.cdplt import colormap os.mkdir(\u0026#34;./tmp\u0026#34;) （1）读取上游velocyto/Seurat分析结果\n(1) 每个细胞的每个基因的 unsplice与splice比例 (2) 细胞的分群与UMAP降维结果 1 2 3 4 5 6 7 8 9 cell_type_u_s_path=\u0026#39;GastrulationErythroid_cell_type_u_s.csv\u0026#39; cell_type_u_s=pd.read_csv(cell_type_u_s_path) cell_type_u_s.head() # gene_name\tunsplice\tsplice\tcellID\tclusters\tembedding1\tembedding2 # 0\tSox17\t0.0\t0.043971\tcell_363\tBlood progenitors 2\t3.460521\t15.574629 # 1\tSox17\t0.0\t0.000000\tcell_382\tBlood progenitors 2\t2.490433\t14.971734 # 2\tSox17\t0.0\t0.018161\tcell_385\tBlood progenitors 2\t2.351203\t15.267069 # 3\tSox17\t0.0\t0.000000\tcell_393\tBlood progenitors 2\t5.899098\t14.388825 # 4\tSox17\t0.0\t0.000000\tcell_398\tBlood progenitors 2\t4.823139\t15.374831 （2）每个细胞的每个基因速率分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 以其中的4个基因为例 gene_list=[\u0026#39;Smarca2\u0026#39;, \u0026#39;Rbms2\u0026#39;, \u0026#39;Myo1b\u0026#39;, \u0026#39;Hba-x\u0026#39;] loss_df, cellDancer_df=cd.velocity(cell_type_u_s,\\ gene_list=gene_list,\\ permutation_ratio=0.125,\\ n_jobs=-1, save_path = \u0026#34;./tmp\u0026#34;) cellDancer_df.to_csv(\u0026#34;cellDancer_estimation.csv\u0026#34;,index=False) # 可视化 ncols=2 height=math.ceil(len(gene_list)/2)*4 fig = plt.figure(figsize=(10,height)) for i in range(len(gene_list)): ax = fig.add_subplot(math.ceil(len(gene_list)/ncols), ncols, i+1) cdplt.scatter_gene( ax=ax, x=\u0026#39;splice\u0026#39;, y=\u0026#39;unsplice\u0026#39;, cellDancer_df=cellDancer_df, custom_xlim=None, custom_ylim=None, colors=colormap.colormap_erythroid, alpha=0.5, s = 5, velocity=True, gene=gene_list[i]) ax.set_title(gene_list[i]) ax.axis(\u0026#39;off\u0026#39;) plt.show() （3）根据上述所有基因的结果进行细胞速率分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 cellDancer_df=cd.compute_cell_velocity(cellDancer_df=cellDancer_df, projection_neighbor_choice=\u0026#39;gene\u0026#39;, expression_scale=\u0026#39;power10\u0026#39;, projection_neighbor_size=10, speed_up=(100,100)) # cellDancer_df=cd.compute_cell_velocity(cellDancer_df=cellDancer_df, # speed_up=(100,100)) # ## 使用默认参数影响不大 # 可视化 fig, ax = plt.subplots(figsize=(10,10)) cdplt.scatter_cell(ax, cellDancer_df, colors=colormap.colormap_erythroid, alpha=0.5, s=10, velocity=True, legend=\u0026#39;on\u0026#39;, min_mass=15, arrow_grid=(20,20), custom_xlim=[-6,13], custom_ylim=[2,16], ) ax.axis(\u0026#39;off\u0026#39;) plt.show() （4）伪时间分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 %%capture # set parameters import random # set parameters dt = 0.05 t_total = {dt:int(10/dt)} n_repeats = 10 # estimate pseudotime cellDancer_df = cd.pseudo_time(cellDancer_df=cellDancer_df, grid=(30,30), dt=dt, t_total=t_total[dt], n_repeats=n_repeats, speed_up=(100,100), n_paths = 3, plot_long_trajs=True, psrng_seeds_diffusion=[i for i in range(n_repeats)], n_jobs=8) # 可视化 fig, ax = plt.subplots(figsize=(6,6)) im=cdplt.scatter_cell(ax,cellDancer_df, colors=\u0026#39;pseudotime\u0026#39;, alpha=0.5, velocity=False, custom_xlim=(-5,11), custom_ylim=(4,18)) ax.axis(\u0026#39;off\u0026#39;) plt.show() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## 随着伪时间的变化， spliced RNA的变化水平 gene_list=[\u0026#39;Smarca2\u0026#39;, \u0026#39;Rbms2\u0026#39;, \u0026#39;Myo1b\u0026#39;, \u0026#39;Hba-x\u0026#39;] ncols=2 height=math.ceil(len(gene_list)/ncols)*4 fig = plt.figure(figsize=(10,height)) for i in range(len(gene_list)): ax = fig.add_subplot(math.ceil(len(gene_list)/ncols), ncols, i+1) cdplt.scatter_gene( ax=ax, x=\u0026#39;pseudotime\u0026#39;, y=\u0026#39;splice\u0026#39;, cellDancer_df=cellDancer_df, custom_xlim=None, custom_ylim=None, colors=colormap.colormap_erythroid, alpha=0.5, s = 5, velocity=False, gene=gene_list[i]) ax.set_title(gene_list[i]) ax.axis(\u0026#39;off\u0026#39;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ## 展示每个细胞的的每个基因的速率参数和unspliced/spliced变化 gene_samples=[\u0026#39;Smarca2\u0026#39;, \u0026#39;Rbms2\u0026#39;, \u0026#39;Myo1b\u0026#39;, \u0026#39;Hba-x\u0026#39;] for gene in gene_samples: fig, ax = plt.subplots(ncols=5, figsize=(12,3)) cdplt.scatter_cell(ax[0],cellDancer_df, colors=\u0026#39;alpha\u0026#39;, gene=gene, velocity=False) cdplt.scatter_cell(ax[1],cellDancer_df, colors=\u0026#39;beta\u0026#39;, gene=gene, velocity=False) cdplt.scatter_cell(ax[2],cellDancer_df, colors=\u0026#39;gamma\u0026#39;, gene=gene, velocity=False) cdplt.scatter_cell(ax[3],cellDancer_df, colors=\u0026#39;splice\u0026#39;, gene=gene, velocity=False) cdplt.scatter_cell(ax[4],cellDancer_df, colors=\u0026#39;unsplice\u0026#39;, gene=gene, velocity=False) ax[0].axis(\u0026#39;off\u0026#39;) ax[1].axis(\u0026#39;off\u0026#39;) ax[2].axis(\u0026#39;off\u0026#39;) ax[3].axis(\u0026#39;off\u0026#39;) ax[4].axis(\u0026#39;off\u0026#39;) ax[0].set_title(\u0026#39;alpha-\u0026#39;+gene) ax[1].set_title(\u0026#39;beta-\u0026#39;+gene) ax[2].set_title(\u0026#39;gamma-\u0026#39;+gene) ax[3].set_title(\u0026#39;spliced-\u0026#39;+gene) ax[4].set_title(\u0026#39;unspliced-\u0026#39;+gene) plt.tight_layout() plt.show() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/036%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--celldancer%E7%BB%86%E8%83%9E%E9%80%9F%E7%8E%87%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003ecellDancer是美国休斯顿卫理公会研究所的助理教授Guangyu Wang团队开发的RNA速率分析新工具，于2023年4月发表于nature biotechnology。该工具基于深度学习框架预测细胞特异的速率参数(α, β and γ)，相较于之前的scvelo等RNA速率分析工具可有效预测 transcriptional boost, multi-lineage forward, multi-lineage backward等复杂情况下的单细胞数据发育预测分析。\u003c/p\u003e","title":"单细胞分析工具--celldancer细胞速率分析"},{"content":" https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\npandas的dataframe自带一些绘图语法用以简单的表格数据可视化，适合于数据的初步探索、分析\n1 import pandas as pd 1、barplot柱状图 1 2 3 4 5 6 7 8 df = pd.DataFrame({\u0026#39;lab\u0026#39;:[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;], \u0026#39;val\u0026#39;:[10, 30, 20]}) # lab\tval # 0\tA\t10 # 1\tB\t30 # 2\tC\t20 ax = df.plot.bar(x=\u0026#39;lab\u0026#39;, y=\u0026#39;val\u0026#39;, rot=0, color=\u0026#34;green\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 speed = [0.1, 17.5, 40, 48] lifespan = [2, 8, 70, 1.5] index = [\u0026#39;snail\u0026#39;, \u0026#39;pig\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;rabbit\u0026#39;] # 类别名为index df = pd.DataFrame({\u0026#39;speed\u0026#39;: speed, \u0026#39;lifespan\u0026#39;: lifespan}, index=index) #\tspeed\tlifespan #snail\t0.1\t2.0 #pig\t17.5\t8.0 #elephant 40.0\t70.0 #rabbit\t48.0\t1.5 ax = df.plot.bar(rot=0) #所有列(如下图) ax = df.plot.bar(rot=0,stacked=True) ax = df[\u0026#34;speed\u0026#34;].plot.bar(rot=45) #指定列 ax = df.plot.bar( rot=0, subplots=True, layout=(1,2), color={\u0026#34;speed\u0026#34;: \u0026#34;red\u0026#34;, \u0026#34;lifespan\u0026#34;: \u0026#34;green\u0026#34;} ) pandas.DataFrame.plot.barh()支持绘制横向的柱状图（Dataframe数据内容需要是横向的）\n2、lineplot线图 （类似上面的barplot）\n1 2 3 4 5 6 7 df = pd.DataFrame({\u0026#39;lab\u0026#39;:[\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;], \u0026#39;val\u0026#39;:[10, 30, 20]}) # lab\tval # 0\tA\t10 # 1\tB\t30 # 2\tC\t20 ax = df.plot.line(x=\u0026#39;lab\u0026#39;, y=\u0026#39;val\u0026#39;, rot=0, color=\u0026#34;green\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 speed = [0.1, 17.5, 40, 48] lifespan = [2, 8, 70, 1.5] index = [\u0026#39;snail\u0026#39;, \u0026#39;pig\u0026#39;, \u0026#39;elephant\u0026#39;, \u0026#39;rabbit\u0026#39;] # 类别名为index df = pd.DataFrame({\u0026#39;speed\u0026#39;: speed, \u0026#39;lifespan\u0026#39;: lifespan}, index=index) #\tspeed\tlifespan #snail\t0.1\t2.0 #pig\t17.5\t8.0 #elephant 40.0\t70.0 #rabbit\t48.0\t1.5 ax = df.plot.line(rot=0) #所有列 3、boxplot箱图 1 2 3 4 5 6 7 8 9 # 宽表格(列名表示分组) data = np.random.randn(25, 4) df = pd.DataFrame(data, columns=list(\u0026#39;ABCD\u0026#39;)) ax = df.plot.box() # 长表格(一列表示分组) age_list = [8, 10, 12, 14, 72, 74, 76, 78, 20, 25, 30, 35, 60, 85] df = pd.DataFrame({\u0026#34;gender\u0026#34;: list(\u0026#34;MMMMMMMMFFFFFF\u0026#34;), \u0026#34;age\u0026#34;: age_list}) ax = df.plot.box(column=\u0026#34;age\u0026#34;, by=\u0026#34;gender\u0026#34;) 4、scatter点图 1 2 3 4 5 df = pd.DataFrame([[5.1, 3.5, 0], [4.9, 3.0, 0], [7.0, 3.2, 1], [6.4, 3.2, 1], [5.9, 3.0, 2]], columns=[\u0026#39;length\u0026#39;, \u0026#39;width\u0026#39;, \u0026#39;species\u0026#39;]) ax = df.plot.scatter(x=\u0026#39;length\u0026#39;, y=\u0026#39;width\u0026#39;) ax = df.plot.scatter(x=\u0026#39;length\u0026#39;, y=\u0026#39;width\u0026#39;, c=\u0026#34;species\u0026#34;, colormap=\u0026#39;viridis\u0026#39;) 5、density密度图 1 2 3 4 5 df = pd.DataFrame([[5.1, 3.5, 0], [4.9, 3.0, 0], [7.0, 3.2, 1], [6.4, 3.2, 1], [5.9, 3.0, 2]], columns=[\u0026#39;length\u0026#39;, \u0026#39;width\u0026#39;, \u0026#39;species\u0026#39;]) ax = df[\u0026#34;length\u0026#34;].plot.kde() ax = df.plot.kde() ","permalink":"https://lishensuo.github.io/en/posts/program/030python-%E5%8F%AF%E8%A7%86%E5%8C%96-pandas%E7%BB%98%E5%9B%BE/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\"\u003ehttps://pandas.pydata.org/docs/reference/api/pandas.DataFrame.plot.html\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003epandas的dataframe自带一些绘图语法用以简单的表格数据可视化，适合于数据的初步探索、分析\u003c/p\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1barplot柱状图\"\u003e1、barplot柱状图\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf = pd.DataFrame({\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;lab\u0026#39;\u003c/span\u003e:[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;A\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;B\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e], \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;val\u0026#39;\u003c/span\u003e:[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e]})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \tlab\tval\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0\tA\t10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1\tB\t30\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2\tC\t20\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eax = df.plot.bar(x=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;lab\u0026#39;\u003c/span\u003e, y=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;val\u0026#39;\u003c/span\u003e, rot=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, color=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;green\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220730145626960.png\" alt=\"image-20220730145626960\" style=\"zoom: 67%;\" /\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003espeed = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e17.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e40\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e48\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elifespan = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e70\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1.5\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eindex = [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;snail\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;pig\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;elephant\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;rabbit\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 类别名为index\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf = pd.DataFrame({\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;speed\u0026#39;\u003c/span\u003e: speed,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;lifespan\u0026#39;\u003c/span\u003e: lifespan}, index=index)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#\t\t  speed\tlifespan\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#snail\t  0.1\t2.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#pig\t  17.5\t8.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#elephant 40.0\t70.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#rabbit\t  48.0\t1.5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eax = df.plot.bar(rot=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)              \u003cspan style=\"color:#007f7f\"\u003e#所有列(如下图)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eax = df.plot.bar(rot=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,stacked=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eax = df[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;speed\u0026#34;\u003c/span\u003e].plot.bar(rot=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e45\u003c/span\u003e)    \u003cspan style=\"color:#007f7f\"\u003e#指定列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eax = df.plot.bar(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    rot=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, subplots=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e, layout=(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    color={\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;speed\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;red\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;lifespan\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;green\u0026#34;\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220730153508146.png\" alt=\"image-20220730153508146\" style=\"zoom: 80%;\" /\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003epandas.DataFrame.plot.barh()\u003c/code\u003e支持绘制横向的柱状图（Dataframe数据内容需要是横向的）\u003c/p\u003e","title":"Python-可视化-pandas绘图"},{"content":" 官方教程链接：https://seaborn.pydata.org/tutorial.html 1 2 3 4 import seaborn as sns import matplotlib.pyplot as plt import pandas as pd 1. theme主题设置 示例展示效果见链接 context: 用于调整整体字体和标注的大小\n\u0026ldquo;paper\u0026rdquo;, \u0026ldquo;notebook\u0026rdquo;,\u0026ldquo;talk\u0026rdquo;, \u0026ldquo;poster\u0026rdquo; style: 用于调整背景和网格线\n\u0026ldquo;whitegrid\u0026rdquo;, \u0026ldquo;darkgrid\u0026rdquo;, \u0026ldquo;white\u0026rdquo;, \u0026ldquo;dark\u0026rdquo;, \u0026ldquo;ticks\u0026rdquo; 1 2 # 默认设置 (全局声明，对后面所有绘图有效) sns.set_theme(context=\u0026#39;notebook\u0026#39;, style=\u0026#39;darkgrid\u0026#39;) 2. 散点图示例 示例数据 1 2 3 4 5 # Demo data: 企鹅数据集 # df = sns.load_dataset(\u0026#34;penguins\u0026#34;) df = pd.read_csv(\u0026#34;./seaborn-data-master/penguins.csv\u0026#34;) df.head() 绘图全流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 plt.figure(figsize=(6, 6)) # 默认是[6.4, 4.8] # axis-level sns.scatterplot(data=df, x=\u0026#34;bill_length_mm\u0026#34;, y=\u0026#34;bill_depth_mm\u0026#34;, hue=\u0026#34;species\u0026#34;, style=\u0026#34;species\u0026#34;, palette=\u0026#34;dark\u0026#34;) # 标题 plt.title(\u0026#34;Penguin measurements\u0026#34;, fontsize=16) plt.xlabel(\u0026#34;Bill length (mm)\u0026#34;) plt.ylabel(\u0026#34;Bill depth (mm)\u0026#34;) plt.xticks(fontsize=6) plt.yticks(fontsize=12) # 图例 plt.legend(fontsize=12, title=\u0026#34;Species\u0026#34;, title_fontsize=14) # 添加参考线 y = 20 plt.axhline(y=20, color=\u0026#39;r\u0026#39;, linestyle=\u0026#39;--\u0026#39;, linewidth=2, label=\u0026#34;Reference Line (y=20)\u0026#34;) # 添加参考线 y = y = 2x + 5 plt.axline((50, 20), slope=2, color=\u0026#34;#2ECC71\u0026#34;, linestyle=\u0026#34;--\u0026#34;, linewidth=2, label=\u0026#34;y = 2x + 5\u0026#34;) # # 保存图片 # plt.savefig(\u0026#34;scatterplot.pdf\u0026#34;) # 展示 plt.show() 3. 箱图示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # # 可以提前修改分类列的因子顺序 # species_order = [\u0026#34;Gentoo\u0026#34;, \u0026#34;Chinstrap\u0026#34;, \u0026#34;Adelie\u0026#34;] # df[\u0026#34;species\u0026#34;] = pd.Categorical(df[\u0026#34;species\u0026#34;], categories=species_order, ordered=True) sns.boxplot(data=df, x=\u0026#34;species\u0026#34;, y=\u0026#34;bill_length_mm\u0026#34;, hue=\u0026#34;sex\u0026#34;, order=[\u0026#34;Gentoo\u0026#34;, \u0026#34;Chinstrap\u0026#34;, \u0026#34;Adelie\u0026#34;], width=0.5, # 默认 0.8 showfliers=True, # 显示离群点 # flierprops = dict(marker=\u0026#39;o\u0026#39;, markerfacecolor=\u0026#39;red\u0026#39;, markersize=3), #离群点显示效果 palette=\u0026#34;Paired\u0026#34;) plt.xticks(rotation=45) # plt.legend().remove() # 删除legend plt.show() 4. 柱状图/线图(误差棒) 1 2 3 4 5 6 7 8 9 10 11 12 13 fig, axes = plt.subplots(1, 2, figsize=(14, 6)) # figsize 设置整个图形的大小 sns.barplot(data=df, x=\u0026#34;species\u0026#34;, y=\u0026#34;bill_length_mm\u0026#34;, errorbar=\u0026#34;sd\u0026#34;, ax=axes[0]) # 将ax传递给sns.barplot axes[0].set_title(\u0026#34;Bar Plot with Standard Deviation\u0026#34;) sns.lineplot(data=df, x=\u0026#34;species\u0026#34;, y=\u0026#34;bill_length_mm\u0026#34;, errorbar=\u0026#34;pi\u0026#34;, ax=axes[1]) # 将ax传递给sns.lineplot axes[1].set_title(\u0026#34;Line Plot with Prediction Interval\u0026#34;) # 自动调整布局 plt.tight_layout() # 显示图形 plt.show() Seaborn支持四种类型的误差棒，分别是\u0026quot;sd\u0026quot;, \u0026ldquo;se\u0026rdquo;, \u0026ldquo;pi\u0026rdquo;, \u0026ldquo;ci\u0026rdquo; （默认为ci） 具体区别参见教程。\n5. axis-level vs figure-level sns.relplot等figure-level的绘图函数是广义的，sns.scatterplot等axis-level的绘图函数是Specific。可以通过kind参数，设置具体的几何绘图类型 二者从可视化角度的区别在与legend的位置 1 2 3 4 5 # 如下图所示，最大区别是legend的位置 sns.relplot(data=df, kind=\u0026#34;scatter\u0026#34;, x=\u0026#34;bill_length_mm\u0026#34;, y=\u0026#34;bill_depth_mm\u0026#34;, hue=\u0026#34;species\u0026#34;, style=\u0026#34;species\u0026#34;) plt.show() 此外，可以通过col/row参数方便的设置分面（axis-level funcs不支持） 1 2 3 4 sns.relplot(data=df, kind=\u0026#34;scatter\u0026#34;, x=\u0026#34;bill_length_mm\u0026#34;, y=\u0026#34;bill_depth_mm\u0026#34;, hue=\u0026#34;species\u0026#34;, style=\u0026#34;species\u0026#34;, col=\u0026#34;species\u0026#34;) plt.show() 关于分面，可以通过sns.FacetGrid()绘制axis-level的分面绘图\n6. 色板 palette参数: 用于调整颜色系。下面的示例展示效果见教程。\nseaborn系列 \u0026ldquo;deep\u0026rdquo;, \u0026ldquo;muted\u0026rdquo;, \u0026ldquo;pastel\u0026rdquo;, \u0026ldquo;bright\u0026rdquo;, \u0026ldquo;dark\u0026rdquo;, \u0026ldquo;colorblind\u0026rdquo; matplotlib系列 \u0026ldquo;Set1\u0026rdquo;，\u0026ldquo;Set2\u0026rdquo;, \u0026ldquo;Set3\u0026rdquo;, \u0026ldquo;Paired\u0026rdquo;, \u0026ldquo;Accent\u0026rdquo;, \u0026ldquo;Dark2\u0026rdquo;, \u0026ldquo;Pastel1\u0026rdquo;, \u0026ldquo;Pastel2\u0026rdquo; \u0026hellip; 直接自定义：palette = [\u0026quot;#E74C3C\u0026quot;, \u0026ldquo;#3498DB\u0026rdquo;, \u0026ldquo;#2ECC71\u0026rdquo;] ","permalink":"https://lishensuo.github.io/en/posts/program/031python-%E5%8F%AF%E8%A7%86%E5%8C%96-seabornsns%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e官方教程链接\u003c/strong\u003e：https://seaborn.pydata.org/tutorial.html\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e seaborn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e sns\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e matplotlib.pyplot \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e plt\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1-theme主题设置\"\u003e1. theme主题设置\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e示例展示效果见链接\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003econtext\u003c/strong\u003e: 用于调整整体字体和标注的大小\u003c/p\u003e","title":"Python-可视化-seaborn(sns)绘图基础"},{"content":" scCODE( single-cell consensus optimization of differentially expressed gene detection)是由复旦大学附属金山医院邹欣等人开发的R包工具，于2022年12月发表于Briefing in Bioinformatics；该工具对多种差异基因分析策略进行了集成、整合，用于鉴定鲁棒性的单细胞差异基因。用法比较简单，简单记录如下。\nPaper：https://academic.oup.com/bib/article-abstract/23/5/bbac180/6590434?redirectedFrom=fulltext Github：https://github.com/XZouProjects/scCODE 1、安装R包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 necessary1 \u0026lt;- c(\u0026#39;doParallel\u0026#39;, \u0026#39;samr\u0026#39;,\u0026#39;doSNOW\u0026#39;,\u0026#39;pls\u0026#39;) installed \u0026lt;- necessary1 %in% installed.packages()[, \u0026#39;Package\u0026#39;] if (length(necessary1[!installed]) \u0026gt;=1){ install.packages(necessary1[!installed]) } necessary2\u0026lt;-c(\u0026#39;DESeq2\u0026#39;, \u0026#39;DEsingle\u0026#39;, \u0026#39;edgeR\u0026#39;, \u0026#39;limma\u0026#39;, \u0026#39;MAST\u0026#39;, \u0026#39;S4Vectors\u0026#39;, \u0026#39;scDD\u0026#39;, \u0026#39;scmap\u0026#39;, \u0026#39;SingleCellExperiment\u0026#39;, \u0026#39;SummarizedExperiment\u0026#39;) installed \u0026lt;- necessary2 %in% installed.packages()[, \u0026#39;Package\u0026#39;] if (length(necessary2[!installed]) \u0026gt;=1){ if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) library(BiocManager) BiocManager::install(necessary2[!installed]) } install.packages(\u0026#34;BPSC_0.99.2.tar.gz\u0026#34;, repos = NULL, type=\u0026#34;source\u0026#34;) install.packages(\u0026#34;OGFSC_0.2.3.tar.gz\u0026#34;, repos = NULL, type=\u0026#34;source\u0026#34;) install.packages(\u0026#34;scCODE_1.2.0.0.tar.gz\u0026#34;, repos = NULL, type=\u0026#34;source\u0026#34;) 2、差异基因分析 （1）准备两组单细胞样本的count表达矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 library(scCODE) data1\u0026lt;-data1_sccode data1[1:4,1:4] # [,1] [,2] [,3] [,4] # Gnai3 12336.737462 0 0 5399.62 # Cdc45 0.000000 0 0 0.00 # Narf 0.000000 0 0 0.00 # Scmh1 8.639172 0 0 0.00 dim(data1) # [1] 13045 139 data2\u0026lt;-data2_sccode dim(data2) # [1] 13045 323 （2）差异分析 默认light模式下，使用5种策略进行分析；再统计每种策略的判断结果。\n如果一个基因的5种结果均判断为显著差异基因，则相对更可靠。\n在linux端使用时，出现类似OpenBLAS blas_thread_init: pthread_create failed for thread 60 of 128: Resource temporarily unavailable报错，经查在shell命令行设置如下参数可正常使用。\n1 2 3 export OPENBLAS_NUM_THREADS=2 export GOTO_NUM_THREADS=2 export OMP_NUM_THREADS=2 1 2 3 4 5 6 results\u0026lt;-scCODE(data1,data2,light = TRUE,top_ranked=5) deg = results$DE_results table(deg$Detected_times) # 1 2 3 4 5 # 360 1287 132 496 917 head(deg) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/037%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--sccode%E7%BB%BC%E5%90%88%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003escCODE\u003c/strong\u003e( single-cell consensus optimization of differentially expressed gene detection)是由复旦大学附属金山医院邹欣等人开发的R包工具，于2022年12月发表于Briefing in Bioinformatics；该工具对多种差异基因分析策略进行了集成、整合，用于鉴定鲁棒性的单细胞差异基因。用法比较简单，简单记录如下。\u003c/p\u003e","title":"单细胞分析工具--sccode综合差异分析"},{"content":" ShinyCell包是由杜克-新加坡国立大学医学院的John F. Ouyang团队开发的单细胞分析工具包，实现基于shiny网页交互式展示单细胞数据；于2021年3月发表于Bioinformatics杂志。如文章中介绍，ShinyCell相比同类工具具有多个优势，例如直观的side-by-side的降维可视化方式，hdf5格式保存表达矩阵从而读取快速，支持pdf/png保存图片，支持多种常见单细胞数据类型等。参考其教程文档，学习记录如下。\nPaper | ShinyCell: simple and sharable visualization of single-cell gene expression data DOI | https://doi.org/10.1093/bioinformatics/btab209 Github | https://github.com/SGDDNB/ShinyCell 1. 安装R包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # (1) 安装ShinyCell所需的依赖包 reqPkg = c(\u0026#34;data.table\u0026#34;, \u0026#34;Matrix\u0026#34;, \u0026#34;hdf5r\u0026#34;, \u0026#34;reticulate\u0026#34;, \u0026#34;ggplot2\u0026#34;, \u0026#34;gridExtra\u0026#34;, \u0026#34;glue\u0026#34;, \u0026#34;readr\u0026#34;, \u0026#34;RColorBrewer\u0026#34;, \u0026#34;R.utils\u0026#34;, \u0026#34;Seurat\u0026#34;) newPkg = reqPkg[!(reqPkg %in% installed.packages()[,\u0026#34;Package\u0026#34;])] if(length(newPkg)){install.packages(newPkg)} # (2) 安装运行shiny所需的R包 reqPkg = c(\u0026#34;shiny\u0026#34;, \u0026#34;shinyhelper\u0026#34;, \u0026#34;data.table\u0026#34;, \u0026#34;Matrix\u0026#34;, \u0026#34;DT\u0026#34;, \u0026#34;hdf5r\u0026#34;, \u0026#34;reticulate\u0026#34;, \u0026#34;ggplot2\u0026#34;, \u0026#34;gridExtra\u0026#34;, \u0026#34;magrittr\u0026#34;, \u0026#34;ggdendro\u0026#34;) newPkg = reqPkg[!(reqPkg %in% installed.packages()[,\u0026#34;Package\u0026#34;])] if(length(newPkg)){install.packages(newPkg)} # (3) 最后安装ShinyCell包 # github直接安装 devtools::install_github(\u0026#34;SGDDNB/ShinyCell\u0026#34;) # 源文件本地安装 devtools::install_local(\u0026#34;ShinyCell-master.zip\u0026#34;) ShinyCell支持多种单细胞数据类型，包括Seurat， SCE(singlecellexperiment), h5ad, loom；并均提供了相应的示例文件； 如其文档所强调，ShinyCell是一个可视化工具，而不是分析工具；所以提供的单细胞数据需要已经完成基础的上游分析； 下面主要以Seurat类型为例进行学习 1 2 3 library(Seurat) library(ShinyCell) library(shiny) 2. 基础用法 2.1 示例数据\n1 2 3 # getExampleData() # ~200MB # http://files.ddnetbio.com/hrpiFiles/readySeu_rset.rds seu = readRDS(\u0026#34;readySeu_rset.rds\u0026#34;) 单细胞数据里需包括（1）标准化表达矩阵；（2）细胞meta信息；（3）降维信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ### （1）标准化表达矩阵 dim(seu) # [1] 12590 9852 Assays(seu) # [1] \u0026#34;RNA\u0026#34; seu@assays$RNA@data[1:4,1:4] #注意是ENSEMBL基因ID # 4 x 4 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # FM_AAACCTGAGAAACGCC-1 FM_AAACCTGAGTGGAGTC-1 FM_AAACCTGCATAGAAAC-1 FM_AAACCTGTCATTCACT-1 # ENSG00000000003 . . 0.8413237 . # ENSG00000000419 . . . . # ENSG00000000457 . . . . # ENSG00000000460 . . . . ### （2）细胞meta信息 head(t(seu@meta.data[1,]),10) # FM_AAACCTGAGAAACGCC-1 # orig.ident \u0026#34;FM\u0026#34; # RNA_snn_res.0.5 \u0026#34;5\u0026#34; # library \u0026#34;FM\u0026#34; # nUMI \u0026#34;13798\u0026#34; # nGene \u0026#34;3522\u0026#34; # pctMT \u0026#34;1.232063\u0026#34; # pctHK \u0026#34;20.77113\u0026#34; # score_S \u0026#34;-0.2176265\u0026#34; # score_G2M \u0026#34;-0.3646008\u0026#34; # phase \u0026#34;G1\u0026#34; ### （3）降维信息 names(seu@reductions) # [1] \u0026#34;pca\u0026#34; \u0026#34;tsne\u0026#34; \u0026#34;umap\u0026#34; \u0026#34;diffmap\u0026#34; \u0026#34;fdl\u0026#34; head(Embeddings(seu, reduction = \u0026#34;umap\u0026#34;)) # UMAP_1 UMAP_2 # FM_AAACCTGAGAAACGCC-1 -7.728941 -3.2370806 # FM_AAACCTGAGTGGAGTC-1 -7.048894 2.8379904 # FM_AAACCTGCATAGAAAC-1 -7.768705 1.6628623 # FM_AAACCTGTCATTCACT-1 -6.059119 3.3121483 # FM_AAACCTGTCTCTGAGA-1 -8.030442 1.5388506 # FM_AAACGGGCAGGCGATA-1 -9.831629 -0.5126803 2.2 生成shiny网页\n（1）生成meta配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 scConf = createConfig(seu) head(scConf) # 每行对应一项meta的title、level name、颜色方案等信息 t(scConf[1,]) # [,1] # ID \u0026#34;orig.ident\u0026#34; # UI \u0026#34;orig.ident\u0026#34; # fID \u0026#34;FM|NR|PR|RR\u0026#34; # fUI \u0026#34;FM|NR|PR|RR\u0026#34; # fCL \u0026#34;#A6CEE3|#B89B74|#ED8F47|#B15928\u0026#34; # fRow \u0026#34;1\u0026#34; # default \u0026#34;1\u0026#34; # grp \u0026#34;TRUE\u0026#34; ID, fID 对应原始数据；UI, fUI, fCL 分布表示在shiny中展示的meta title，level name，colors\nfROW表示 legend的行数，default 表示是否为默认展示的两种cell info，grp表示是否为分组类型\n（2）生成shiny配置文件\n1 2 3 4 5 6 7 8 9 ?makeShinyApp makeShinyApp(seu, scConf, gene.mapping = TRUE, # default FALSE, only when ENSEMBL gene id gex.assay = \u0026#34;RNA\u0026#34;, gex.slot = \u0026#34;data\u0026#34;, shiny.title = \u0026#34;scRNA-seq shiny app\u0026#34;, shiny.dir = \u0026#34;shinyApp/\u0026#34;) # 查看结果 list.files(\u0026#34;shinyApp\u0026#34;) # [1] \u0026#34;sc1conf.rds\u0026#34; \u0026#34;sc1def.rds\u0026#34; \u0026#34;sc1gene.rds\u0026#34; \u0026#34;sc1gexpr.h5\u0026#34; \u0026#34;sc1meta.rds\u0026#34; \u0026#34;server.R\u0026#34; \u0026#34;ui.R\u0026#34; 除了其中的gene.mapping参数（需要在单细胞数据的基因名为ENSEMBL格式时设置为TRUE），其余均为默认参数； 此外还有其它参数，包括默认展示的gene，降维类型；shiny.footnotes参数还支持设置网页的脚注用以交代数据集来源。 （3）最后运行shiny网页即可\n1 2 # 在本地浏览器的3344端口打开 runApp(\u0026#34;shinyApp/\u0026#34;, launch.browser = T, port = 3344) 3. 模块介绍 （1）完成上述步骤后即可在本地生成一个shiny网页，下面结合作者分享的示例http://shinycell1.ddnetbio.com/介绍其内容；\n在每个模块中，均有3个Toggle选项支持筛选细胞，调整部分绘图参数等。\n（2）如上图所示，ShinyCell主要支持7个可视化模块；若从绘图类型来说共是6种图\n模块 图形 含义 e.g. 1 CellInfo vs GeneExpr 降维图 对比可视化细胞的分群信息与表达信息 A+B 2 CellInfo vs CellInfo 降维图 对比可视化细胞的两种不同分群信息 A+A 3 GeneExpr vs GeneExpr 降维图 对比可视化细胞的两种不同表达信息 B+B 4 Gene coexpression 降维图 可视化细胞的两种不同表达信息 C 5 Violinplot / Boxplot 小提琴图/箱图 可视化特定分群下，细胞的表达分布 D 6 Bubbleplot / Heatmap 点图/热图 可视化特定分群下，细胞的多个表达分布 F 7 Proportion plot 柱状图 可视化特定分群下，细胞的另一种分群的分布 E 4. 进阶用法 4.1 meta config调整 如上介绍，生成shiny网页的第一步是根据单细胞数据的meta信息生成相应的config文件，用以设置模块可视化的细节。\n默认情况下会使用全部的meta信息，如需调整一方面可直接修改原来的单细胞数据；另一方面也可以使用ShinyCell包进行部分修改，如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 seu \u0026lt;- readRDS(\u0026#34;readySeu_rset.rds\u0026#34;) seu@meta.data = seu@meta.data[,1:6] scConf = createConfig(seu) # 展示当前的meta config legend showLegend(scConf) # (1)删除若干条细胞注释信息 scConf = delMeta(scConf, c(\u0026#34;orig.ident\u0026#34;)) # (2)修改在shiny的细胞注释名title name(fID) scConf = modMetaName(scConf, meta.to.mod = c(\u0026#34;nUMI\u0026#34;, \u0026#34;nGene\u0026#34;), new.name = c(\u0026#34;No. UMIs\u0026#34;, \u0026#34;No. detected genes\u0026#34;)) # (3)修改在shiny的细胞注释名level name(fUI) scConf = modLabels(scConf, meta.to.mod = \u0026#34;library\u0026#34;, new.labels = c(\u0026#34;fm\u0026#34;, \u0026#34;pr\u0026#34;, \u0026#34;nr\u0026#34;, \u0026#34;rr\u0026#34;)) # (4)修改在shiny的细胞注释可视化颜色(fCL) scConf = modColours(scConf, meta.to.mod = \u0026#34;library\u0026#34;, new.colours= RColorBrewer::brewer.pal(n = 4, name = \u0026#34;Set1\u0026#34;)) showLegend(scConf) # showOrder(scConf) # scConf = reorderMeta(scConf, rev(scConf$ID)) # showOrder(scConf) 如需修改特定meta的level factor顺序，似乎只能在原始单细胞数据的meta中进行修改。\n4.2 多个数据集 ShinyCell支持在同一个网页内独立展示多个的数据集，可参考示例网页http://shinycell2.ddnetbio.com\n简单生成方法如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## 数据集1 seu \u0026lt;- readRDS(\u0026#34;readySeu_rset.rds\u0026#34;) scConf1 = createConfig(seu) makeShinyFiles(seu, scConf1, gene.mapping = TRUE, shiny.prefix = \u0026#34;sc1\u0026#34;, # 前缀不同 shiny.dir = \u0026#34;shinyAppMulti/\u0026#34;) ## 数据集2 scConf2 = delMeta(scConf1, c(\u0026#34;orig.ident\u0026#34;)) makeShinyFiles(seu, scConf2, gene.mapping = TRUE, shiny.prefix = \u0026#34;sc2\u0026#34;, # 前缀不同 gex.assay = \u0026#34;RNA\u0026#34;, gex.slot = \u0026#34;data\u0026#34;, shiny.dir = \u0026#34;shinyAppMulti/\u0026#34;) ## 生成shiny配置文件 makeShinyCodesMulti( shiny.title = \u0026#34;Multi-dataset Tutorial\u0026#34;, shiny.prefix = c(\u0026#34;sc1\u0026#34;, \u0026#34;sc2\u0026#34;), shiny.headers = c(\u0026#34;Dataset1\u0026#34;, \u0026#34;Dataset2\u0026#34;), shiny.footnotes = \u0026#34;\u0026#34;, shiny.dir = \u0026#34;shinyAppMulti/\u0026#34;) ## 运行网页 runApp(\u0026#34;shinyAppMulti/\u0026#34;, launch.browser = T, port = 3344) 4.3 linux平台 对于大型单细胞数据集，需要在服务器linux平台分析时，大体与上述方式类似，简述流程如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # (1) 前期需在linux的R语言环境下安装相关R包，并准备相关数据 # (2) 生成shiny网页文件 seu \u0026lt;- readRDS(\u0026#34;readySeu_rset.rds\u0026#34;) scConf = createConfig(seu) makeShinyApp(seu, scConf, gene.mapping = TRUE, shiny.title = \u0026#34;ShinyCell Quick Start\u0026#34;) # (3) linux端运行网页，注意需要设置launch.browser参数为FALSE runApp(\u0026#34;shinyApp/\u0026#34;, launch.browser = F, port = 3344) # (4) 本地window端链接：同时win键+R，输入cmd打开命令窗口，根据下述命令进行链接 ssh -L localhost:3344:localhost:3344 username@192.168.212.xxx -p 22 # (5) 最后本地浏览器打开 http://127.0.0.1:3344/ 即可 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/040%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--shinycell%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%B1%95%E7%A4%BA%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE/","summary":"\u003cblockquote\u003e\n\u003cp\u003eShinyCell包是由杜克-新加坡国立大学医学院的John F. Ouyang团队开发的单细胞分析工具包，实现基于shiny网页交互式展示单细胞数据；于2021年3月发表于Bioinformatics杂志。如文章中介绍，ShinyCell相比同类工具具有多个优势，例如直观的side-by-side的降维可视化方式，hdf5格式保存表达矩阵从而读取快速，支持pdf/png保存图片，支持多种常见单细胞数据类型等。参考其教程文档，学习记录如下。\u003c/p\u003e","title":"单细胞分析工具--ShinyCell交互式展示单细胞数据"},{"content":" Seurat V5版本有一段时间了，由于时间原因未来得及了解。现根据其官方文档简单整理其用法，与V4比较类似的地方就不多叙述了。此外，V5的亮点之一还在于单细胞多组学的整合分析，此次就不做记录了。（PS：中秋快乐~）\n主要参考Seurat官方文档：\nhttps://satijalab.org/seurat/ https://satijalab.org/seurat/articles/install_v5 https://satijalab.org/seurat/articles/essential_commands https://satijalab.org/seurat/articles/seurat5_essential_commands 0. 安装 首先是安装R语言环境（linux环境），使用conda命令 1 2 3 4 5 6 conda create -n r_env -y conda activate r_env conda install -c r r-base=4.2.2 conda install conda-forge::r-seurat conda install r::r-tidyverse 其次，安装其它推荐的工具包 1 2 3 4 5 6 7 8 9 10 11 12 # rcurl使用conda安装 setRepositories(ind = 1:3, addURLs = c(\u0026#39;https://satijalab.r-universe.dev\u0026#39;, \u0026#39;https://bnprks.r-universe.dev/\u0026#39;)) install.packages(c(\u0026#34;presto\u0026#34;, \u0026#34;glmGamPoi\u0026#34;)) # conda install -c anaconda hdf5 install.packages(c(\u0026#34;BPCells\u0026#34;)) # BiocManager::install(\u0026#34;Rsamtools\u0026#34;) install.packages(\u0026#39;Signac\u0026#39;) remotes::install_github(\u0026#34;satijalab/seurat-data\u0026#34;, quiet = TRUE) #提供示例数据集 # remotes::install_github(\u0026#34;satijalab/azimuth\u0026#34;, quiet = TRUE) #自动注细胞类型的R包，先不安装了 remotes::install_github(\u0026#34;satijalab/seurat-wrappers\u0026#34;, quiet = TRUE) 分析前，加载相关初始包 1 2 3 4 library(Seurat) library(dplyr) library(patchwork) library(ggplot2) 示例分析数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library(SeuratData) # AvailableData() # InstallData(\u0026#34;pbmc3k\u0026#34;) # InstallData(\u0026#34;ifnb\u0026#34;) library(pbmc3k.SeuratData) data(\u0026#39;pbmc3k\u0026#39;) pbmc3k = UpdateSeuratObject(pbmc3k) pbmc3k pbmc = pbmc3k library(ifnb.SeuratData) data(\u0026#39;ifnb\u0026#39;) ifnb = UpdateSeuratObject(ifnb) ifnb 1. Layer结构 Seurat V4/3使用的还是v3版本的Seurat Object； Seurat V5提出了新的v5版本的Seurat Object： 主要区别之一是在Assays层级结构下，明确定义了Layer结构 每个Seurat可以包含多个Assays，每个Assay可以包含多个Layers 1.1 创建v3/5对象 读取表达矩阵\nhttps://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\n1 2 3 4 5 6 7 pbmc.counts \u0026lt;- Read10X(data.dir = \u0026#34;filtered_gene_bc_matrices/hg19/\u0026#34;) class(pbmc.counts) # [1] \u0026#34;dgCMatrix\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;Matrix\u0026#34; dim(pbmc.counts) # [1] 32738 2700 直接创建Seurat Object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## v3 options(Seurat.object.assay.version = \u0026#34;v3\u0026#34;) pbmc \u0026lt;- CreateSeuratObject(counts = pbmc.counts) class(pbmc[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;Assay\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;SeuratObject\u0026#34; ## v5 options(Seurat.object.assay.version = \u0026#34;v5\u0026#34;) pbmc \u0026lt;- CreateSeuratObject(counts = pbmc.counts) class(pbmc[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;Assay5\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;SeuratObject\u0026#34; 先创建Assay Object，再创建Seurat Object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # create a v3 assay assay.v3 \u0026lt;- CreateAssayObject(counts = pbmc.counts) class(assay.v3) # create a v5 assay assay.v5 \u0026lt;- CreateAssay5Object(counts = pbmc.counts) class(assay.v5) # # create an assay using only normalized data # assay.v5 \u0026lt;- CreateAssay5Object(data = log1p(pbmc.counts)) # create a Seurat object based on this assay pbmc3k_slim \u0026lt;- CreateSeuratObject(assay.v5) pbmc3k_slim # 加入一个新的Assay（v3） pbmc3k_slim[[\u0026#39;RNA3\u0026#39;]] = as(object = pbmc3k_slim[[\u0026#34;RNA\u0026#34;]], Class = \u0026#34;Assay5\u0026#34;) 1.2 Layers相关操作 查看 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 obj \u0026lt;- CreateSeuratObject(counts = pbmc.counts) obj # An object of class Seurat # 32738 features across 2700 samples within 1 assay # Active assay: RNA (32738 features, 0 variable features) # 1 layer present: counts DefaultAssay(obj) # [1] \u0026#34;RNA\u0026#34; DefaultLayer(obj[[\u0026#39;RNA\u0026#39;]]) # [1] \u0026#34;counts\u0026#34; Layers(obj[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;counts\u0026#34; obj \u0026lt;- NormalizeData(obj, verbose = FALSE) Layers(obj[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;counts\u0026#34; \u0026#34;data\u0026#34; 拆分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pbmc3k$batch \u0026lt;- sample(c(\u0026#34;batchA\u0026#34;, \u0026#34;batchB\u0026#34;, \u0026#34;batchC\u0026#34;), ncol(pbmc3k), replace = TRUE) # Split layers by batch pbmc3k[[\u0026#34;RNA\u0026#34;]] \u0026lt;- split(pbmc3k[[\u0026#34;RNA\u0026#34;]], f = pbmc3k$batch) Layers(pbmc3k[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;data.batchC\u0026#34; \u0026#34;data.batchA\u0026#34; \u0026#34;data.batchB\u0026#34; \u0026#34;counts.batchC\u0026#34; # [5] \u0026#34;counts.batchA\u0026#34; \u0026#34;counts.batchB\u0026#34; # Rejoin layers pbmc3k[[\u0026#34;RNA\u0026#34;]] \u0026lt;- JoinLayers(pbmc3k[[\u0026#34;RNA\u0026#34;]]) Layers(pbmc3k[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;data\u0026#34; \u0026#34;counts\u0026#34; # create a Seurat object initialized with multiple layers batchA_counts \u0026lt;- pbmc.counts[, 1:200] batchB_counts \u0026lt;- pbmc.counts[, 201:400] batchC_counts \u0026lt;- pbmc.counts[, 401:600] count_list \u0026lt;- list(batchA_counts, batchB_counts, batchC_counts) names(count_list) \u0026lt;- c(\u0026#34;batchA\u0026#34;, \u0026#34;batchB\u0026#34;, \u0026#34;batchC\u0026#34;) obj \u0026lt;- CreateSeuratObject(counts = count_list) Layers(obj[[\u0026#34;RNA\u0026#34;]]) # [1] \u0026#34;counts.batchA\u0026#34; \u0026#34;counts.batchB\u0026#34; \u0026#34;counts.batchC\u0026#34; 2. 常用操作 2.1 标准步骤 逐步处理 1 2 3 4 5 6 7 8 pbmc \u0026lt;- NormalizeData(object = pbmc) pbmc \u0026lt;- FindVariableFeatures(object = pbmc) pbmc \u0026lt;- ScaleData(object = pbmc) pbmc \u0026lt;- RunPCA(object = pbmc) pbmc \u0026lt;- FindNeighbors(object = pbmc, dims = 1:30) pbmc \u0026lt;- FindClusters(object = pbmc) pbmc \u0026lt;- RunUMAP(object = pbmc, dims = 1:30) DimPlot(object = pbmc, reduction = \u0026#34;umap\u0026#34;) SCT简化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # https://github.com/satijalab/seurat/issues/8183 # https://blog.csdn.net/weixin_46128755/article/details/136395843 # matrixStats版本问题会导致SCTransform运行出错，这里选择安装1.1.0版本 pbmc \u0026lt;- SCTransform(object = pbmc) pbmc \u0026lt;- RunPCA(object = pbmc) pbmc \u0026lt;- FindNeighbors(object = pbmc, dims = 1:30) pbmc \u0026lt;- FindClusters(object = pbmc) pbmc \u0026lt;- RunUMAP(object = pbmc, dims = 1:30) DimPlot(object = pbmc, reduction = \u0026#34;umap\u0026#34;) # 或者 pbmc \u0026lt;- SCTransform(pbmc) %\u0026gt;% RunPCA() %\u0026gt;% FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters() %\u0026gt;% RunUMAP(dims = 1:30) 2.2 查看结构 细胞/基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # cell names colnames(pbmc) |\u0026gt; head() Cells(pbmc) |\u0026gt; head() # feature names Features(pbmc) |\u0026gt; head() rownames(pbmc) |\u0026gt; head() # 高变基因 # Variable feature names VariableFeatures(pbmc) |\u0026gt; str() VariableFeatures(pbmc[[\u0026#34;SCT\u0026#34;]]) |\u0026gt; str() VariableFeatures(pbmc[[\u0026#34;RNA\u0026#34;]]) |\u0026gt; str() # VariableFeatures(pbmc, assay = \u0026#39;SCT\u0026#39;) var.gene.names = VariableFeatures(pbmc)[1:1000] VariableFeatures(pbmc[[\u0026#34;RNA\u0026#34;]]) = var.gene.names meta.data 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 colnames(pbmc@meta.data) # [1] \u0026#34;orig.ident\u0026#34; \u0026#34;nCount_RNA\u0026#34; \u0026#34;nFeature_RNA\u0026#34; # [4] \u0026#34;seurat_annotations\u0026#34; \u0026#34;nCount_SCT\u0026#34; \u0026#34;nFeature_SCT\u0026#34; # [7] \u0026#34;SCT_snn_res.0.8\u0026#34; \u0026#34;seurat_clusters\u0026#34; Idents(object = pbmc) \u0026lt;- \u0026#34;seurat_annotations\u0026#34; # View cell identities, get summary table table(Idents(pbmc)) # Naive CD4 T Memory CD4 T CD14+ Mono B CD8 T FCGR3A+ Mono # 697 483 480 344 271 162 # NK DC Platelet # 155 32 14 Idents(pbmc) \u0026lt;- \u0026#34;CD4 T cells\u0026#34; table(Idents(pbmc)) # 逆操作 pbmc[[\u0026#34;old.ident\u0026#34;]] \u0026lt;- Idents(object = pbmc) colnames(pbmc@meta.data) # Rename identity classes pbmc \u0026lt;- RenameIdents(object = pbmc, `CD4 T cells` = \u0026#34;T Helper cells\u0026#34;) Idents(object = pbmc) |\u0026gt; table() 矩阵信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## Retrieve data in an expression matrix RNA counts matrix pbmc[[\u0026#34;RNA\u0026#34;]]$counts |\u0026gt; dim() # [1] 13714 2700 pbmc[[\u0026#34;SCT\u0026#34;]]$counts |\u0026gt; dim() # [1] 12572 2700 LayerData(pbmc, assay = \u0026#34;RNA\u0026#34;, layer = \u0026#34;counts\u0026#34;) |\u0026gt; dim() # [1] 13714 2700 # GetAssayData from Seurat v4 is still supported GetAssayData(object = pbmc, assay = \u0026#34;RNA\u0026#34;, slot = \u0026#34;counts\u0026#34;) |\u0026gt; dim() # Set expression data assume new.data is a new expression matrix pbmc[[\u0026#34;RNA\u0026#34;]]$counts \u0026lt;- new.data ## 降维信息 pbmc@reductions |\u0026gt; names() # [1] \u0026#34;pca\u0026#34; \u0026#34;umap\u0026#34; pbmc[[\u0026#39;pca\u0026#39;]]@cell.embeddings |\u0026gt; head() Embeddings(pbmc, reduction = \u0026#34;pca\u0026#34;) |\u0026gt; head() pbmc[[\u0026#39;pca\u0026#39;]]@feature.loadings |\u0026gt; dim() Loadings(pbmc, reduction = \u0026#34;pca\u0026#34;) |\u0026gt; dim() 2.3 增删操作 提取特定feature 1 2 3 4 5 6 7 FetchData(object = pbmc, vars = c(\u0026#34;PC_1\u0026#34;, \u0026#34;nFeature_RNA\u0026#34;, \u0026#34;MS4A1\u0026#34;), layer = \u0026#34;counts\u0026#34;) |\u0026gt; head(3) # PC_1 nFeature_RNA MS4A1 # AAACATACAACCAC 10.165883 779 0 # AAACATTGAGCTAC 5.812925 1352 4 # AAACATTGATCAGC 8.566106 1129 0 筛选cells 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Idents(object = pbmc) \u0026lt;- \u0026#34;seurat_annotations\u0026#34; subset(x = pbmc, idents = \u0026#34;B\u0026#34;) |\u0026gt; dim() subset(x = pbmc, idents = \u0026#34;B\u0026#34;, invert = TRUE) |\u0026gt; dim() # Subset on the expression level of a gene/feature subset(x = pbmc, subset = MS4A1 \u0026gt; 0.5) |\u0026gt; dim() # Subset on a combination of criteria subset(x = pbmc, subset = MS4A1 \u0026gt; 0.5 \u0026amp; PC_1 \u0026gt; 5) |\u0026gt; dim() subset(x = pbmc, subset = MS4A1 \u0026gt; 0.5, idents = \u0026#34;B\u0026#34;) |\u0026gt; dim() # Subset on a value in the object meta data subset(x = pbmc, subset = groups == \u0026#34;g1\u0026#34;) |\u0026gt; dim() # Downsample the number of cells per identity class subset(x = pbmc, downsample = 100) |\u0026gt; dim() 拆分与合并 在1.2小结，了解到可以按Layer拆分，但仍属于同一个Object 下面的命令可以拆分独立的多个Object 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## 拆分 ifnb_list \u0026lt;- SplitObject(ifnb, split.by = \u0026#34;stim\u0026#34;) # [1] \u0026#34;list\u0026#34; ifnb_list$CTRL ifnb_list$STIM ## 合并 merged_obj \u0026lt;- merge(x = ifnb_list$CTRL, y = ifnb_list$STIM) merged_obj # An object of class Seurat # 14053 features across 13999 samples within 1 assay # Active assay: RNA (14053 features, 0 variable features) # 4 layers present: data.1, data.2, counts.1, counts.2 merged_obj[[\u0026#34;RNA\u0026#34;]] \u0026lt;- JoinLayers(merged_obj[[\u0026#34;RNA\u0026#34;]]) merged_obj # An object of class Seurat # 14053 features across 13999 samples within 1 assay # Active assay: RNA (14053 features, 0 variable features) # 2 layers present: data, counts ##### Merge objects (with integration)：去批次效应 merged_obj \u0026lt;- merge(x = ifnb_list$CTRL, y = ifnb_list$STIM) merged_obj \u0026lt;- NormalizeData(merged_obj) merged_obj \u0026lt;- FindVariableFeatures(merged_obj) merged_obj \u0026lt;- ScaleData(merged_obj) merged_obj \u0026lt;- RunPCA(merged_obj) #去批次整合（上面的标准流都是对于每个Layer独立操作的） merged_obj \u0026lt;- IntegrateLayers(object = merged_obj, method = RPCAIntegration, orig.reduction = \u0026#34;pca\u0026#34;, new.reduction = \u0026#34;integrated.rpca\u0026#34;, verbose = FALSE) merged_obj # now that integration is complete, rejoin layers merged_obj[[\u0026#34;RNA\u0026#34;]] \u0026lt;- JoinLayers(merged_obj[[\u0026#34;RNA\u0026#34;]]) Seurat V5版本共支持5种去批次效应的方法：CCAIntegration, RPCAIntegration, HarmonyIntegration, FastMNNIntegration, scVIIntegration，可参考：https://satijalab.org/seurat/articles/seurat5_integration\nPseudobulk计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bulk \u0026lt;- AggregateExpression(ifnb, group.by = \u0026#34;seurat_annotations\u0026#34;, return.seurat = TRUE) Cells(bulk) # [1] \u0026#34;CD14 Mono\u0026#34; \u0026#34;CD4 Naive T\u0026#34; \u0026#34;CD4 Memory T\u0026#34; \u0026#34;CD16 Mono\u0026#34; \u0026#34;B\u0026#34; # [6] \u0026#34;CD8 T\u0026#34; \u0026#34;T activated\u0026#34; \u0026#34;NK\u0026#34; \u0026#34;DC\u0026#34; \u0026#34;B Activated\u0026#34; # [11] \u0026#34;Mk\u0026#34; \u0026#34;pDC\u0026#34; \u0026#34;Eryth\u0026#34; dim(bulk) # [1] 14053 13 bulk \u0026lt;- AggregateExpression(ifnb, group.by = \u0026#34;seurat_annotations\u0026#34;, return.seurat = FALSE) class(bulk$RNA) # [1] \u0026#34;dgCMatrix\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;Matrix\u0026#34; # pseudobulk cells by stimulation condition AND cell type bulk \u0026lt;- AggregateExpression(ifnb, group.by = c(\u0026#34;stim\u0026#34;, \u0026#34;seurat_annotations\u0026#34;), return.seurat = TRUE) Cells(bulk) 基于Pseudobulk结果，可采用DESeq2方法进行差异基因检验。可参考：https://satijalab.org/seurat/articles/de_vignette\n2.4 可视化 主要绘图命令记录如下，基本与V4类似。示例可视化效果可参考 https://satijalab.org/seurat/articles/visualization_vignette https://lishensuo.github.io/posts/bioinfo/006%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--seurat4%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 DimPlot(object = pbmc, reduction = \u0026#34;pca\u0026#34;) # Dimensional reduction plot, with cells colored by a quantitative feature Defaults to UMAP if available FeaturePlot(object = pbmc, features = \u0026#34;MS4A1\u0026#34;) # Scatter plot across single cells FeatureScatter(object = pbmc, feature1 = \u0026#34;MS4A1\u0026#34;, feature2 = \u0026#34;PC_1\u0026#34;) FeatureScatter(object = pbmc, feature1 = \u0026#34;MS4A1\u0026#34;, feature2 = \u0026#34;CD3D\u0026#34;) # Scatter plot across individual features, repleaces CellPlot CellScatter(object = pbmc, cell1 = \u0026#34;AGTCTACTAGGGTG\u0026#34;, cell2 = \u0026#34;CACAGATGGTTTCT\u0026#34;) VariableFeaturePlot(object = pbmc) # Violin and Ridge plots VlnPlot(object = pbmc, features = c(\u0026#34;LYZ\u0026#34;, \u0026#34;CCL5\u0026#34;, \u0026#34;IL32\u0026#34;)) RidgePlot(object = pbmc, feature = c(\u0026#34;LYZ\u0026#34;, \u0026#34;CCL5\u0026#34;, \u0026#34;IL32\u0026#34;)) # Heatmaps (visualize scale.data slot) DimHeatmap(object = pbmc, reduction = \u0026#34;pca\u0026#34;, cells = 200) # standard workflow var.gene.names = VariableFeatures(pbmc)[1:50] pbmc \u0026lt;- ScaleData(pbmc, features = var.gene.names) # https://github.com/satijalab/seurat/issues/2722 DoHeatmap(object = pbmc, label = F) # heatmap with maximum of 10 cells per group DoHeatmap(pbmc, var.gene.names, cells = colnames(subset(pbmc, downsample = 10)), label = F) 绘制Dotplot时，注意分组变量不能包含NA值 1 2 3 4 5 6 7 8 9 10 11 12 table(is.na(pbmc$seurat_annotations)) # FALSE TRUE # 2638 62 Idents(pbmc) \u0026lt;- as.character(Idents(pbmc)) pbmc$seurat_annotations_2 = pbmc$seurat_annotations pbmc$seurat_annotations_2 = as.character(pbmc$seurat_annotations) pbmc$seurat_annotations_2[is.na(pbmc$seurat_annotations_2)] = \u0026#39;Other\u0026#39; Idents(pbmc) = pbmc$seurat_annotations_2 VlnPlot(object = pbmc, features = \u0026#34;MS4A1\u0026#34;, split.by = \u0026#34;groups\u0026#34;) DotPlot(object = pbmc, features = c(\u0026#34;LYZ\u0026#34;, \u0026#34;CCL5\u0026#34;, \u0026#34;IL32\u0026#34;), split.by = \u0026#34;groups\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/041%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--seurat5%E5%9F%BA%E7%A1%80%E7%94%A8%E6%B3%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003eSeurat V5版本有一段时间了，由于时间原因未来得及了解。现根据其官方文档简单整理其用法，与V4比较类似的地方就不多叙述了。此外，V5的亮点之一还在于单细胞多组学的整合分析，此次就不做记录了。（PS：中秋快乐~）\u003c/p\u003e","title":"单细胞分析工具--Seurat5基础用法"},{"content":" 网站：https://cellxgene.cziscience.com/\nAPI：https://chanzuckerberg.github.io/cellxgene-census/\nSchema：https://github.com/chanzuckerberg/single-cell-curation/blob/main/schema/3.0.0/schema.md\nCELLxGENE 是一套工具，可帮助科学家查找、下载、探索、分析、注释和发布单细胞数据集。它包含几个功能强大的工具，具有各种功能，可帮助您处理单细胞数据。\nChan Zuckerberg Initiative（CZI）是由马克·扎克伯格（Mark Zuckerberg）和妻子普莉希拉·陈（Priscilla Chan）于2015年创立的慈善组织。其使命是通过支持科学、教育和社区发展来推动人类潜能和促进平等。\n其核心是整合了大量的单细胞转录组数据集于一体，具有如下特点\n物种来源主要是Homo sapiens, Mus musculus; 样本主要来自大多数组织的正常细胞(Normal, 即non-disease); 数据类型是未标准化的原始Counts表达数据; 在目前最新的版本(20240701)中，细胞总量已分别达到74M(human), 41M(mouse) Note that the Census RNA data includes duplicate cells present across multiple datasets. Duplicate cells can be filtered in or out using the cell metadata variable is_primary_data which is described in the Census schema.\nCELLxGENE基于这些数据资源主要提供两类功能，Download (下载) \u0026amp; Explore (分析)。下面将主要学习下数据获取的方式。\n方式1（如上图）：从网站的Datasets页面，根据提供的多种filter筛选目标数据集，然后点击下载按钮；提供了h5ad与rds两种格式，可分别用于Python的scanpy(v0.8)分析以及R的Seurat分析(v5)\n方式2：使用网站提供的API接口进行定制化下载，如下主要记录对于Python端的简单学习。\n简单来说，可以将census视为CELLxGENE将所有细胞数据进行的整合。我们可以基于特定的cell或者gene metadata条件(Slice)，筛选目标的单细胞数据。\n1 2 # pip install -U cellxgene-census import cellxgene_census 查看所有的cell metadata类型（2023-05-15版本） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 census = cellxgene_census.open_soma(census_version=\u0026#34;2023-05-15\u0026#34;) keys = list(census[\u0026#34;census_data\u0026#34;][\u0026#34;homo_sapiens\u0026#34;].obs.keys()) keys # [\u0026#39;soma_joinid\u0026#39;, # \u0026#39;dataset_id\u0026#39;, # \u0026#39;assay\u0026#39;, # \u0026#39;assay_ontology_term_id\u0026#39;, # \u0026#39;cell_type\u0026#39;, # \u0026#39;cell_type_ontology_term_id\u0026#39;, # \u0026#39;development_stage\u0026#39;, # \u0026#39;development_stage_ontology_term_id\u0026#39;, # \u0026#39;disease\u0026#39;, # \u0026#39;disease_ontology_term_id\u0026#39;, # \u0026#39;donor_id\u0026#39;, # \u0026#39;is_primary_data\u0026#39;, # \u0026#39;self_reported_ethnicity\u0026#39;, # \u0026#39;self_reported_ethnicity_ontology_term_id\u0026#39;, # \u0026#39;sex\u0026#39;, # \u0026#39;sex_ontology_term_id\u0026#39;, # \u0026#39;suspension_type\u0026#39;, # \u0026#39;tissue\u0026#39;, # \u0026#39;tissue_ontology_term_id\u0026#39;, # \u0026#39;tissue_general\u0026#39;, # \u0026#39;tissue_general_ontology_term_id\u0026#39;] 获取该版本所有细胞的metadata（建议使用特定条件筛选，这里仅为了下面探索全部的类别信息） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 with cellxgene_census.open_soma(census_version=\u0026#34;2023-05-15\u0026#34;) as census: # Reads SOMADataFrame as a slice cell_metadata = census[\u0026#34;census_data\u0026#34;][\u0026#34;homo_sapiens\u0026#34;].obs.read( # value_filter = \u0026#34;sex == \u0026#39;female\u0026#39; and cell_type in [\u0026#39;microglial cell\u0026#39;, \u0026#39;neuron\u0026#39;]\u0026#34;, # column_names = [\u0026#34;assay\u0026#34;, \u0026#34;cell_type\u0026#34;, \u0026#34;tissue\u0026#34;, \u0026#34;tissue_general\u0026#34;, \u0026#34;suspension_type\u0026#34;, \u0026#34;disease\u0026#34;] # value_filter = \u0026#34;tissue_general == \u0026#39;prostate gland\u0026#39;\u0026#34; ) # Concatenates results to pyarrow.Table cell_metadata = cell_metadata.concat() # Converts to pandas.DataFrame cell_metadata = cell_metadata.to_pandas() # 1m31.6s cell_metadata.shape # (53794728, 21) cell_metadata[\u0026#39;dataset_id\u0026#39;][:200000].drop_duplicates() # 0 9d8e5dca-03a3-457d-b7fb-844c75735c83 # 72335 a6388a6f-6076-401b-9b30-7d4306a20035 # 103124 842c6f5d-4a94-4eef-8510-8c792d1124bc # Name: dataset_id, dtype: object cell_metadata[\u0026#39;donor_id\u0026#39;][:10000].drop_duplicates() # 0 donor-GOLD # 869 donor-BOAT # 4369 donor-KEYS # 8675 donor-PINK # Name: donor_id, dtype: object # 统计其它metadata的类别分布情况 from pathlib import Path filtered_keys = [item for item in keys if item not in [\u0026#39;soma_joinid\u0026#39;,\u0026#39;dataset_id\u0026#39;,\u0026#39;donor_id\u0026#39;]] for item in filtered_keys: # cell_metadata[item].value_counts() file_name = f\u0026#39;stat_{item}.txt\u0026#39; file_path = Path(\u0026#39;census_20230515\u0026#39;) / file_name print(file_path) cell_metadata[item].value_counts().to_csv(file_path, sep = \u0026#39;\\t\u0026#39;) ## e.g. stat_sex.txt # sex\tcount # male\t28197731 # female\t22513226 # unknown\t3083771 详见：https://github.com/lishensuo/utils/tree/main/CELLxGene/census_20230515\n获取目前最新版本(20240701)所有细胞的metadata 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 census = cellxgene_census.open_soma(census_version=\u0026#34;2024-07-01\u0026#34;) # The \u0026#34;stable\u0026#34; release is currently 2024-07-01. # Specify \u0026#39;census_version=\u0026#34;2024-07-01\u0026#34;\u0026#39; in future calls to open_soma() to ensure data consistency. keys_latest = list(census[\u0026#34;census_data\u0026#34;][\u0026#34;homo_sapiens\u0026#34;].obs.keys()) list(set(keys_latest) - set(keys)) # [\u0026#39;raw_mean_nnz\u0026#39;, # \u0026#39;observation_joinid\u0026#39;, # \u0026#39;raw_variance_nnz\u0026#39;, # \u0026#39;raw_sum\u0026#39;, # \u0026#39;tissue_type\u0026#39;, # \u0026#39;n_measured_vars\u0026#39;, # \u0026#39;nnz\u0026#39;] #类似 质控相关的指标 with cellxgene_census.open_soma() as census: cell_metadata_latest = census[\u0026#34;census_data\u0026#34;][\u0026#34;homo_sapiens\u0026#34;].obs.read() cell_metadata_latest = cell_metadata_latest.concat() cell_metadata_latest = cell_metadata_latest.to_pandas() #2m30s cell_metadata_latest.shape # (74322510, 28) filtered_keys = [item for item in keys if item not in [\u0026#39;soma_joinid\u0026#39;,\u0026#39;dataset_id\u0026#39;,\u0026#39;donor_id\u0026#39;]] for item in filtered_keys: # cell_metadata[item].value_counts() file_name = f\u0026#39;stat_{item}.txt\u0026#39; file_path = Path(\u0026#39;census_20240701\u0026#39;) / file_name print(file_path) cell_metadata_latest[item].value_counts().to_csv(file_path, sep = \u0026#39;\\t\u0026#39;) 详见：https://github.com/lishensuo/utils/tree/main/CELLxGene/census_20240701\n下面简单探索前列腺细胞(Prostate gland cells)的metadata 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 with cellxgene_census.open_soma(census_version=\u0026#34;2024-07-01\u0026#34;) as census: # Reads SOMADataFrame as a slice cell_metadata = census[\u0026#34;census_data\u0026#34;][\u0026#34;homo_sapiens\u0026#34;].obs.read( # value_filter = \u0026#34;sex == \u0026#39;female\u0026#39; and cell_type in [\u0026#39;microglial cell\u0026#39;, \u0026#39;neuron\u0026#39;]\u0026#34;, # column_names = [\u0026#34;assay\u0026#34;, \u0026#34;cell_type\u0026#34;, \u0026#34;tissue\u0026#34;, \u0026#34;tissue_general\u0026#34;, \u0026#34;suspension_type\u0026#34;, \u0026#34;disease\u0026#34;] value_filter = \u0026#34;tissue_general == \u0026#39;prostate gland\u0026#39;\u0026#34; ) # Concatenates results to pyarrow.Table cell_metadata = cell_metadata.concat() # Converts to pandas.DataFrame cell_metadata = cell_metadata.to_pandas() cell_metadata.shape # (348664, 28) cell_metadata[\u0026#39;disease\u0026#39;].value_counts()[lambda x: x \u0026gt; 0] # disease # normal 227680 # benign prostatic hyperplasia 120984 # Name: count, dtype: int64 cell_metadata[\u0026#39;cell_type\u0026#39;].value_counts()[lambda x: x \u0026gt; 0].head(10) # cell_type # basal cell of prostate epithelium 138418 # luminal cell of prostate epithelium 29128 # epithelial cell of urethra 23634 # epithelial cell 20552 # secretory cell 16662 # prostate gland microvascular endothelial cell 14230 # smooth muscle cell of prostate 8702 # fibroblast of connective tissue of nonglandular part of prostate 7654 # basal epithelial cell of prostatic duct 7295 # CD1c-positive myeloid dendritic cell 7210 # Name: count, dtype: int64 单细胞数据下载，以上面前列腺组织的fibroblast (669 cells)为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 with cellxgene_census.open_soma(census_version=\u0026#34;2024-07-01\u0026#34;) as census: adata = cellxgene_census.get_anndata( census = census, organism = \u0026#34;Homo sapiens\u0026#34;, var_value_filter = \u0026#34;feature_id in [\u0026#39;ENSG00000161798\u0026#39;, \u0026#39;ENSG00000188229\u0026#39;]\u0026#34;, obs_value_filter = \u0026#34;sex == \u0026#39;female\u0026#39; and cell_type in [\u0026#39;microglial cell\u0026#39;, \u0026#39;neuron\u0026#39;]\u0026#34;, column_names = {\u0026#34;obs\u0026#34;: [\u0026#34;assay\u0026#34;, \u0026#34;cell_type\u0026#34;, \u0026#34;tissue\u0026#34;, \u0026#34;tissue_general\u0026#34;, \u0026#34;suspension_type\u0026#34;, \u0026#34;disease\u0026#34;]}, ) print(adata) # 2m58s adata # AnnData object with n_obs × n_vars = 669 × 60530 # obs: \u0026#39;soma_joinid\u0026#39;, \u0026#39;dataset_id\u0026#39;, \u0026#39;assay\u0026#39;, \u0026#39;assay_ontology_term_id\u0026#39;, \u0026#39;cell_type\u0026#39;, \u0026#39;cell_type_ontology_term_id\u0026#39;, \u0026#39;development_stage\u0026#39;, \u0026#39;development_stage_ontology_term_id\u0026#39;, \u0026#39;disease\u0026#39;, \u0026#39;disease_ontology_term_id\u0026#39;, \u0026#39;donor_id\u0026#39;, # \u0026#39;is_primary_data\u0026#39;, \u0026#39;observation_joinid\u0026#39;, \u0026#39;self_reported_ethnicity\u0026#39;, \u0026#39;self_reported_ethnicity_ontology_term_id\u0026#39;, \u0026#39;sex\u0026#39;, \u0026#39;sex_ontology_term_id\u0026#39;, \u0026#39;suspension_type\u0026#39;, \u0026#39;tissue\u0026#39;, \u0026#39;tissue_ontology_term_id\u0026#39;, # \u0026#39;tissue_type\u0026#39;, \u0026#39;tissue_general\u0026#39;, \u0026#39;tissue_general_ontology_term_id\u0026#39;, \u0026#39;raw_sum\u0026#39;, \u0026#39;nnz\u0026#39;, \u0026#39;raw_mean_nnz\u0026#39;, \u0026#39;raw_variance_nnz\u0026#39;, \u0026#39;n_measured_vars\u0026#39; # var: \u0026#39;soma_joinid\u0026#39;, \u0026#39;feature_id\u0026#39;, \u0026#39;feature_name\u0026#39;, \u0026#39;feature_length\u0026#39;, \u0026#39;nnz\u0026#39;, \u0026#39;n_measured_obs\u0026#39; adata.var.head() # soma_joinid feature_id feature_name feature_length nnz n_measured_obs # 0 ENSG00000000003 TSPAN6 4530 4530448 73855064 # 1 ENSG00000000005 TNMD 1476 236059 61201828 # 2 ENSG00000000419 DPM1 9276 17576462 74159149 # 3 ENSG00000000457 SCYL3 6883 9117322 73988868 # 4 ENSG00000000460 C1orf112 5970 6287794 73636201 adata.layers[\u0026#39;counts\u0026#39;] = adata.X.copy() adata.layers[\u0026#39;counts\u0026#39;] # \u0026lt;Compressed Sparse Row sparse matrix of dtype \u0026#39;float32\u0026#39; # with 1591668 stored elements and shape (669, 60530)\u0026gt; adata.write_h5ad(\u0026#34;cellxgene_prostate.h5ad\u0026#34;) 另外的下载方式（scGPT采用） 首先查询目标细胞的soma_joinid数据 然后直接根据上述ID，获取对应细胞的表达数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 with cellxgene_census.open_soma(census_version=\u0026#34;2024-07-01\u0026#34;) as census: cell_metadata = census[\u0026#34;census_data\u0026#34;][\u0026#34;homo_sapiens\u0026#34;].obs.read( value_filter = \u0026#34;tissue_general == \u0026#39;prostate gland\u0026#39; and cell_type == \u0026#39;fibroblast\u0026#39;\u0026#34; ) cell_metadata = cell_metadata.concat() cell_metadata = cell_metadata.to_pandas() adata2 = cellxgene_census.get_anndata( census = census, organism = \u0026#34;Homo sapiens\u0026#34;, # obs_value_filter = \u0026#34;tissue_general == \u0026#39;prostate gland\u0026#39; and cell_type == \u0026#39;fibroblast\u0026#39;\u0026#34; obs_coords = list(cell_metadata[\u0026#39;soma_joinid\u0026#39;]) ) # 2m52s API的下载速度目前体验下来，比较不稳定，有时非常慢。在时间允许的情况下，可以编写脚本，在后台慢慢下载。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/042%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--cellxgene%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"\u003cblockquote\u003e\n\u003cp\u003e网站：https://cellxgene.cziscience.com/\u003c/p\u003e\n\u003cp\u003eAPI：https://chanzuckerberg.github.io/cellxgene-census/\u003c/p\u003e","title":"单细胞分析工具--CELLxGENE数据库"},{"content":"scVI (single-cell variational inference)是2018年发表的一项单细胞分析工具。它主要基于VAE变分自编码器的思想，计算去除批次效应后的细胞低维空间表示。而后于2022年被整合到单细胞组学分析工具包scvi-tool中。\nDeep generative modeling for single-cell transcriptomics, https://www.nature.com/articles/s41592-018-0229-2 A Python library for probabilistic analysis of single-cell omics data, https://www.nature.com/articles/s41587-021-01206-w Github： https://github.com/scverse/scvi-tools 上图为18年发表文章的Figure，简单理解如下\n观测/输入数据\nXn,1: Cell N的Gene 1的观测表达值\nSn：Cell N的批次标签\n潜变量：\nZn：Cell N的低维表示空间，即我们最关心的结果。\nln：Cell N的library size，可以理解为UMI counts\n变分后验(Variational posterior)表示对观测数据 (X,S) 所假设的潜在变量 (Z, l) 的真实后验分布的近似（编码器）。在VAE中，通常将其建模为高斯分布，其参数（均值和方差）由神经网络输出。然后生成模型部分（解码器）负责从潜在空间中生成新的数据样本X，应与真实数据相似。\n上述过程的可优化损失主要来自两方面：（1）重构损失，即解码器的输出与输入X的差异；（2）通过KL散度计算变分后验分布p(z|x)与先验分布p(z)的差异，主要确保潜在空间的分布结构合理。\n详细解释参考：https://docs.scvi-tools.org/en/stable/user_guide/models/scvi.html\n1. 安装 https://docs.scvi-tools.org/en/stable/tutorials/notebooks/quick_start/api_overview.html https://docs.scvi-tools.org/en/stable/tutorials/notebooks/scrna/harmonization.html#integration-with-scanvi 1 2 3 4 5 6 7 8 9 conda create -n scvi python=3.10 -y conda activate scvi # conda install scvi-tools -c conda-forge pip install -U scvi-tools -i https://pypi.tuna.tsinghua.edu.cn/simple pip install -U scanpy -i https://pypi.tuna.tsinghua.edu.cn/simple # 在具体分析过程中，还遇到部分缺少依赖包的报错，根据提示安装即可 # 例如：scib-metrics leidenalg pymde scib_metrics 2. 初始设置 1 2 3 4 5 6 7 8 9 10 scvi.settings.seed = 0 print(\u0026#34;Last run with scvi-tools version:\u0026#34;, scvi.__version__) # 1.2.0 sc.set_figure_params(figsize=(6, 6), frameon=False) sns.set_theme() torch.set_float32_matmul_precision(\u0026#34;high\u0026#34;) save_dir = \u0026#34;./data/\u0026#34; %config InlineBackend.print_figure_kwargs={\u0026#34;facecolor\u0026#34;: \u0026#34;w\u0026#34;} %config InlineBackend.figure_format=\u0026#34;retina\u0026#34; 3. 读取数据及预处理 1 2 3 4 5 6 7 8 9 10 # adata = scvi.data.heart_cell_atlas_subsampled(save_path=save_dir.name) adata = sc.read(os.path.join(save_dir, \u0026#34;hca_subsampled_20k.h5ad\u0026#34;)) remove = [\u0026#34;doublets\u0026#34;, \u0026#34;NotAssigned\u0026#34;] keep = [c not in remove for c in adata.obs.cell_type.values] adata = adata[keep, :].copy() adata # AnnData object with n_obs × n_vars = 18641 × 26662 # obs: \u0026#39;NRP\u0026#39;, \u0026#39;age_group\u0026#39;, \u0026#39;cell_source\u0026#39;, \u0026#39;cell_type\u0026#39;, \u0026#39;donor\u0026#39;, \u0026#39;gender\u0026#39;, \u0026#39;n_counts\u0026#39;, \u0026#39;n_genes\u0026#39;, \u0026#39;percent_mito\u0026#39;, \u0026#39;percent_ribo\u0026#39;, \u0026#39;region\u0026#39;, \u0026#39;sample\u0026#39;, \u0026#39;scrublet_score\u0026#39;, \u0026#39;source\u0026#39;, \u0026#39;type\u0026#39;, \u0026#39;version\u0026#39;, \u0026#39;cell_states\u0026#39;, \u0026#39;Used\u0026#39; # var: \u0026#39;gene_ids-Harvard-Nuclei\u0026#39;, \u0026#39;feature_types-Harvard-Nuclei\u0026#39;, \u0026#39;gene_ids-Sanger-Nuclei\u0026#39;, \u0026#39;feature_types-Sanger-Nuclei\u0026#39;, \u0026#39;gene_ids-Sanger-Cells\u0026#39;, \u0026#39;feature_types-Sanger-Cells\u0026#39;, \u0026#39;gene_ids-Sanger-CD45\u0026#39;, \u0026#39;feature_types-Sanger-CD45\u0026#39;, \u0026#39;n_counts\u0026#39; # uns: \u0026#39;cell_type_colors\u0026#39; 质控/标准化/相关备份 1 2 3 4 5 6 7 sc.pp.filter_genes(adata, min_counts=3) adata.layers[\u0026#34;counts\u0026#34;] = adata.X.copy() # 保存备份整个对象的状态.X 矩阵的副本 sc.pp.normalize_total(adata, target_sum=1e4) sc.pp.log1p(adata) adata.raw = adata #保存备份整个对象的状态 鉴定高变基因 1 2 3 4 5 6 7 8 sc.pp.highly_variable_genes( adata, n_top_genes=1200, subset=True, layer=\u0026#34;counts\u0026#34;, flavor=\u0026#34;seurat_v3\u0026#34;, batch_key=\u0026#34;cell_source\u0026#34;, ) 3. 计算潜变量 实例化模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 scvi.model.SCVI.setup_anndata( adata, layer=\u0026#34;counts\u0026#34;, categorical_covariate_keys=[\u0026#34;cell_source\u0026#34;, \u0026#34;donor\u0026#34;], continuous_covariate_keys=[\u0026#34;percent_mito\u0026#34;, \u0026#34;percent_ribo\u0026#34;], ) model = scvi.model.SCVI(adata) #可在此调整n_latent等参数 model # SCVI model with the following parameters: # n_hidden: 128, n_latent: 10, n_layers: 1, dropout_rate: 0.1, dispersion: gene, gene_likelihood: zinb, # latent_distribution: normal. # Training status: Not Trained # Model\u0026#39;s adata is minified?: False VAE属于自监督学习算法，scVI基于Pytorch实现的神经网络架构，支持GPU加速 1 2 3 4 5 6 model.train() # model_dir = os.path.join(save_dir, \u0026#34;scvi_model\u0026#34;) # model.save(model_dir, overwrite=True) # model = scvi.model.SCVI.load(model_dir, adata=adata) 计算潜变量结果 1 2 3 4 5 6 SCVI_LATENT_KEY = \u0026#34;X_scVI\u0026#34; latent = model.get_latent_representation() adata.obsm[SCVI_LATENT_KEY] = latent latent.shape # (18641, 10) 计算 normalized (decoded) gene expression. 1 2 3 4 adata_subset = adata[adata.obs.cell_type == \u0026#34;Fibroblast\u0026#34;] latent_subset = model.get_latent_representation(adata_subset) # (2446, 10) denoised = model.get_normalized_expression(adata_subset, library_size=1e4, ) # reconstructed output denoised.iloc[:5, :5] 4. 可视化 1 2 3 4 5 6 7 8 9 10 11 12 13 SCVI_NORMALIZED_KEY = \u0026#34;scvi_normalized\u0026#34; adata.layers[SCVI_NORMALIZED_KEY] = model.get_normalized_expression(library_size=10e4) sc.pp.neighbors(adata, use_rep=SCVI_LATENT_KEY) sc.tl.umap(adata, min_dist=0.3) sc.pl.umap( adata, color=[\u0026#34;donor\u0026#34;, \u0026#34;cell_source\u0026#34;], ncols=2, frameon=False, ) 1 2 3 # neighbors were already computed using scVI SCVI_CLUSTERS_KEY = \u0026#34;leiden_scVI\u0026#34; sc.tl.leiden(adata, key_added=SCVI_CLUSTERS_KEY, resolution=0.5) 5. 鉴定差异基因 1 2 3 4 5 6 7 8 9 10 11 # one vs one de_df = model.differential_expression( groupby=\u0026#34;cell_type\u0026#34;, group1=\u0026#34;Endothelial\u0026#34;, group2=\u0026#34;Fibroblast\u0026#34; ) de_df.head() # one vs rest de_df = model.differential_expression( groupby=\u0026#34;cell_type\u0026#34;, ) de_df.head() 6. SCANVI去批次 Now, we assume that all of our data is annotated. This can lead to a more accurate integration result when using scANVI 如果已经有注释好的细胞类型，使用scANVI去批次会更有效。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 adata.obs.cell_type.unique().tolist() # [\u0026#39;Myeloid\u0026#39;, # \u0026#39;Ventricular_Cardiomyocyte\u0026#39;, # \u0026#39;Fibroblast\u0026#39;, # \u0026#39;Endothelial\u0026#39;, # \u0026#39;Adipocytes\u0026#39;, # \u0026#39;Pericytes\u0026#39;, # \u0026#39;Atrial_Cardiomyocyte\u0026#39;, # \u0026#39;Smooth_muscle_cells\u0026#39;, # \u0026#39;Neuronal\u0026#39;, # \u0026#39;Lymphoid\u0026#39;, # \u0026#39;Mesothelial\u0026#39;] scanvi_model = scvi.model.SCANVI.from_scvi_model( model, adata=adata, labels_key=\u0026#34;cell_type\u0026#34;, unlabeled_category=\u0026#34;Unknown\u0026#34;, ) scanvi_model.train() SCANVI_LATENT_KEY = \u0026#34;X_scANVI\u0026#34; adata.obsm[SCANVI_LATENT_KEY] = scanvi_model.get_latent_representation(adata) adata.obsm[SCANVI_LATENT_KEY].shape # (18641, 10) 1 2 # 传统PCA sc.tl.pca(adata) 使用scib_metrics评估三种降维的效果 https://scib-metrics.readthedocs.io/en/stable/notebooks/lung_example.html 1 2 3 4 5 6 7 8 9 10 11 12 from scib_metrics.benchmark import Benchmarker bm = Benchmarker( adata, batch_key=\u0026#34;cell_source\u0026#34;, label_key=\u0026#34;cell_type\u0026#34;, embedding_obsm_keys=[\u0026#34;X_pca\u0026#34;, SCVI_LATENT_KEY, SCANVI_LATENT_KEY], n_jobs=-1, ) bm.benchmark() bm.plot_results_table(min_max_scale=False) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/043%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--scvi%E5%8E%BB%E9%99%A4%E6%89%B9%E6%AC%A1%E6%95%88%E5%BA%94/","summary":"\u003cp\u003escVI (single-cell variational inference)是2018年发表的一项单细胞分析工具。它主要基于VAE变分自编码器的思想，计算去除批次效应后的细胞低维空间表示。而后于2022年被整合到单细胞组学分析工具包scvi-tool中。\u003c/p\u003e","title":"单细胞分析工具--scVI去除批次效应"},{"content":" scCODA(single-cell compositional data analysis)是由德国环境健康研究中心计算生物学研究所M Büttner等人基于python开发的单细胞数据分析工具，于2021年11月发表于Nature Communication；主要用于分析不同分组样本的细胞组成的差异。参考官方文档记录用法如下。\nPaper：https://www.nature.com/articles/s41467-021-27150-6 Github：https://github.com/theislab/scCODA Tutorial：https://sccoda.readthedocs.io/en/latest/index.html 1、安装环境 1 2 3 4 5 conda create -n sccoda python=3.9 conda activate sccoda conda install rpy2 pip install sccoda # conda install -c conda-forge notebook 2、分析流程 （1）加载函数 1 2 3 4 5 6 7 8 9 10 11 12 13 import importlib import warnings warnings.filterwarnings(\u0026#34;ignore\u0026#34;) import pandas as pd import pickle as pkl import matplotlib.pyplot as plt from sccoda.util import comp_ana as mod from sccoda.util import cell_composition_data as dat from sccoda.util import data_visualization as viz import sccoda.datasets as scd （2）读取数据 pandas.Dataframe：第一列为样本名，其余每列各代表一种细胞类型，值表示细胞数量 使用scanny包转换为Anndata结构格式，obs表示样本信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## 导入示例数据 cell_counts = scd.haber() print(cell_counts) # Mouse Endocrine Enterocyte Enterocyte.Progenitor Goblet Stem TA TA.Early Tuft # 0 Control_1 36 59 136 36 239 125 191 18 # 1 Control_2 5 46 23 20 50 11 40 5 # 2 Control_3 45 98 188 124 250 155 365 33 data_all = dat.from_pandas(cell_counts, covariate_columns=[\u0026#34;Mouse\u0026#34;]) data_all.obs data_all.X ## 提取分组信息 data_all.obs[\u0026#34;Condition\u0026#34;] = data_all.obs[\u0026#34;Mouse\u0026#34;].str.replace(r\u0026#34;_[0-9]\u0026#34;, \u0026#34;\u0026#34;, regex=True) # Mouse Condition # 0 Control_1 Control # 1 Control_2 Control # 2 Control_3 Control data_salm = data_all[data_all.obs[\u0026#34;Condition\u0026#34;].isin([\u0026#34;Control\u0026#34;, \u0026#34;Salm\u0026#34;])] （3）组成差异分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 设置先验信息 model_salm = mod.CompositionalAnalysis(data_salm, formula=\u0026#34;Condition\u0026#34;, #指定参考组 reference_cell_type=\u0026#34;Goblet\u0026#34;) #指定一种细胞类型作为已知组间比例不变的标准，如不确定设置为 \u0026#34;automatic\u0026#34; ## Markov-chain Monte Carlo (MCMC) inferrence sim_results = model_salm.sample_hmc() # time consuming # 备选方案：sample_hmc_da(), sample_nuts() ## 分析结果 # sim_results.set_fdr(est_fdr=0.4) sim_results.summary() sim_results.credible_effects() sim_results.effect_df 如上重点关注effect的Final Parameter列\n若为0表示，该细胞类型比例在组间差异不大，可设置est_fdr设置判断的阈值标准 大于0，则表示相对于参考组，细胞比例提高；反之，则相反。 3、可视化 此外scCODA也提供了一些可视化细胞比例的绘图函数，简单示例如下。\n箱图 1 viz.boxplots(data_salm, feature_name=\u0026#34;Condition\u0026#34;) 柱状图 1 viz.stacked_barplot(data_salm, feature_name=\u0026#34;Condition\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/038%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--sccoda%E7%BB%86%E8%83%9E%E7%BB%84%E6%88%90%E6%AF%94%E8%BE%83/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003escCODA\u003c/strong\u003e(single-cell compositional data analysis)是由德国环境健康研究中心计算生物学研究所M Büttner等人基于python开发的单细胞数据分析工具，于2021年11月发表于Nature Communication；主要用于分析不同分组样本的细胞组成的差异。参考官方文档记录用法如下。\u003c/p\u003e","title":"单细胞分析工具--sccoda细胞组成比较"},{"content":" COSG(COSine similarity-based marker Gene identification)是由来自哈佛医学院和Broad研究所博后Ming Dai等人开发，旨在从余弦相似度的角度鉴定cluster的marker gene，于2021年12月被Briefings in Bioinformatics接收。目前已将此方法分别包装为R包与Python包，分别对应Seurat与Scanny分析流程。\nPaper：https://doi.org/10.1093/bib/bbab579 Github：https://github.com/genecell/COSG， https://github.com/genecell/COSGR 1、分析思路 （1）准备好数据， 即标准化后的单细胞表达矩阵，并完成细胞聚类分析(scATAC， ST同理)；\n（2）对cluster K模拟一个ideal marker gene(仅在k表达，其余cluster不表达)；\n（3）计算所有真实基因分别与该基因的余弦相似度，并进一步计算出COSG score；\n（4）COSG score取值范围为0~1。值越大，表示为cluster specific marker gene；\n（5）同理依次计算出其余cluster的marker gene。\n2、性能比较 文章主要与常用的Wilcoxon-test等分析方式在多种数据集上进行比较，概括如下：\n（1）在模拟的单细胞数据集中，COSG方法可以最大程度发现每个clutser的marker gene；\n（2）在大规模单细胞数据中， COSG在保持精度的同时分析速度很快；\n（3）COSG在scATAC以及空间转录组数据上也同样具有较优的表现\n3、代码实操 1 2 3 4 5 6 7 8 9 10 11 12 13 14 remotes::install_github(repo = \u0026#39;genecell/COSGR\u0026#39;) library(COSG) library(Seurat) ## 输入数据 data(\u0026#39;pbmc_small\u0026#39;,package=\u0026#39;COSG\u0026#39;) dim(pbmc_small@assays$RNA@data) #标准化矩阵 # [1] 230 80 table(Idents(pbmc_small)) #聚类分群结果 # 0 1 2 # 36 25 19 R包的分析函数即为cosg()，默认参数如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 marker_cosg \u0026lt;- cosg( pbmc_small, groups=\u0026#39;all\u0026#39;, #考虑全部分组 assay=\u0026#39;RNA\u0026#39;, slot=\u0026#39;data\u0026#39;, mu=1, #惩罚项参数，值越大 remove_lowly_expressed=TRUE, #是否过滤低表达基因 expressed_pct=0.1, #设置低表达的阈值 n_genes_user=100 #每个cluster定义Top-N个marker gene ) head(marker_cosg$names,3) # 0 1 2 # 1 CD7 S100A8 MS4A1 # 2 CCL5 TYMP CD79A # 3 GNLY S100A9 TCL1A head(marker_cosg$scores,3) # 0 1 2 # 1 0.6391917 0.8954042 0.6922908 # 2 0.6391267 0.8312083 0.5832425 # 3 0.6328148 0.8120045 0.5757478 简单可视化一下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 top_list\u0026lt;-c() for (group in colnames(marker_cosg$names)){ top_i\u0026lt;-marker_cosg$names[group][1:5,1] top_list\u0026lt;-c(top_list,top_i) } DotPlot(pbmc_small, assay = \u0026#39;RNA\u0026#39;, # scale=TRUE, features = unique(top_list)) + RotatedAxis() pbmc_small \u0026lt;- ScaleData(pbmc_small, features = top_list) DoHeatmap(pbmc_small, assay = \u0026#39;RNA\u0026#39;, features = top_list) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/039%E5%8D%95%E7%BB%86%E8%83%9E%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7--cosg%E9%89%B4%E5%AE%9Amarker%E5%9F%BA%E5%9B%A0/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eCOSG\u003c/strong\u003e(COSine similarity-based marker Gene identification)是由来自哈佛医学院和Broad研究所博后Ming Dai等人开发，旨在从余弦相似度的角度鉴定cluster的marker gene，于2021年12月被Briefings in Bioinformatics接收。目前已将此方法分别包装为R包与Python包，分别对应Seurat与Scanny分析流程。\u003c/p\u003e","title":"单细胞分析工具--COSG鉴定marker基因"},{"content":"在对转录组数据分析时，分组比较的差异分析前提时获得测序表达矩阵。\n根据测序技术分为两种，对应的分析R包如下所示。\nRNAseq的原始count表达矩阵 DESeq2 edgeR limma 芯片array标准化后的表达矩阵 limma 1、示例count表达矩阵 如下使用TCGAbiolinks包下载共9个癌症样本、35个正常样本的表达矩阵；其中涉及到8对配对样本（tumor与normal来自同一病人）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 library(TCGAbiolinks) library(SummarizedExperiment) library(tidyverse) query \u0026lt;- GDCquery(project = \u0026#34;TCGA-CHOL\u0026#34;, legacy = FALSE, data.category = \u0026#34;Transcriptome Profiling\u0026#34;, data.type = \u0026#34;Gene Expression Quantification\u0026#34;) GDCdownload(query, files.per.chunk = 10) data = GDCprepare(query, save = F) rownames(data) = rowData(data)$gene_name data = data[rowData(data)$gene_type==\u0026#34;protein_coding\u0026#34;,] count = assay(data, \u0026#34;unstranded\u0026#34;) count = count[!duplicated(rownames(count)),] dim(count) # [1] 19938 44 count[1:4,1:4] # TCGA-W5-AA2X-01A-11R-A41I-07 TCGA-W5-AA2X-11A-11R-A41I-07 # TSPAN6 3310 2322 # TNMD 0 0 # DPM1 1881 716 # SCYL3 966 315 # TCGA-W5-AA33-01A-11R-A41I-07 TCGA-ZH-A8Y2-01A-11R-A41I-07 # TSPAN6 11312 6768 # TNMD 1 0 # DPM1 968 1273 # SCYL3 1296 774 meta = colData(data)[,c(\u0026#34;barcode\u0026#34;,\u0026#34;sample\u0026#34;, \u0026#34;patient\u0026#34;,\u0026#34;shortLetterCode\u0026#34;)] %\u0026gt;% as.data.frame() meta$Group = meta$shortLetterCode # NT: Solid Tissue Normal; TP: Primary Tumor head(meta[,\u0026#34;Group\u0026#34;,drop=F]) # Group # TCGA-W5-AA2X-01A-11R-A41I-07 TP # TCGA-W5-AA2X-11A-11R-A41I-07 NT # TCGA-W5-AA33-01A-11R-A41I-07 TP # TCGA-ZH-A8Y2-01A-11R-A41I-07 TP # TCGA-ZH-A8Y6-01A-11R-A41I-07 TP # TCGA-W5-AA2Z-01A-11R-A41I-07 TP table(meta$Group) # NT TP # 9 35 identical(colnames(count), rownames(meta)) # [1] TRUE ## 8对配对样本 meta_pair = meta[TCGAquery_MatchedCoupledSampleTypes(meta$barcode, c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;)), ] # TCGA-W5-AA2I TCGA-W5-AA2Q TCGA-W5-AA2U TCGA-W5-AA2X TCGA-W5-AA30 TCGA-W5-AA31 TCGA-W5-AA34 TCGA-ZU-A8S4 # 2 2 2 2 2 2 2 2 count_pair = count[, meta_pair$barcode] identical(meta_pair$barcode, colnames(count_pair)) #[1] TRUE 2、DESeq2 常规分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 library(DESeq2) # 分组因子化：对照组在前，实验组在后 meta$Group = factor(meta$Group, levels = c(\u0026#34;NT\u0026#34;, \u0026#34;TP\u0026#34;)) dds = DESeqDataSetFromMatrix(countData = count, colData = meta, design= ~ Group) # keep \u0026lt;- rowSums(counts(dds)) \u0026gt;= 10 # dds \u0026lt;- dds[keep,] dds = DESeq(dds) resultsNames(dds) # lists the coefficients # [1] \u0026#34;Intercept\u0026#34; \u0026#34;Group_TP_vs_NT\u0026#34; res = results(dds, name=\u0026#34;Group_TP_vs_NT\u0026#34;) deg = as.data.frame(res) deg = deg[order(deg$padj), ] head(deg) # baseMean log2FoldChange lfcSE stat pvalue padj # MSMO1 7585.3612 -3.748488 0.2109579 -17.76889 1.231028e-70 1.105094e-66 # RMDN2 396.7567 -2.929035 0.1648278 -17.77027 1.201019e-70 1.105094e-66 # GCDH 2272.9263 -3.302603 0.1863973 -17.71809 3.040673e-70 1.819742e-66 # TCAIM 1239.0505 -2.235421 0.1303740 -17.14621 6.708695e-66 3.011198e-62 # KCNN2 360.4449 -5.504765 0.3234836 -17.01714 6.129148e-65 2.200854e-61 # USH2A 550.8569 -6.469569 0.3914803 -16.52591 2.388048e-61 6.125002e-58 count_log = log2(counts(dds, normalized=TRUE) + 1) gene_exp = count_log[\u0026#34;MSMO1\u0026#34;, ,drop=F] %\u0026gt;% t() %\u0026gt;% as.data.frame() %\u0026gt;% dplyr::mutate(Group=meta$Group) ggplot(gene_exp, aes(x=Group, y=MSMO1)) + geom_boxplot() 配对分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 library(DESeq2) dim(count_pair) # [1] 19938 16 head(meta_pair[,c(\u0026#34;Group\u0026#34;,\u0026#34;patient\u0026#34;)]) # Group patient # TCGA-W5-AA2X-11A-11R-A41I-07 NT TCGA-W5-AA2X # TCGA-W5-AA2Q-11A-11R-A41I-07 NT TCGA-W5-AA2Q # TCGA-W5-AA30-11A-11R-A41I-07 NT TCGA-W5-AA30 # TCGA-ZU-A8S4-11A-11R-A41I-07 NT TCGA-ZU-A8S4 # TCGA-W5-AA31-11A-11R-A41I-07 NT TCGA-W5-AA31 # TCGA-W5-AA2I-11A-11R-A41I-07 NT TCGA-W5-AA2I dds2 = DESeqDataSetFromMatrix(countData = count_pair, colData = meta_pair, design= ~ Group + patient) dds2 = DESeq(dds2) resultsNames(dds2) # lists the coefficients # [1] \u0026#34;Intercept\u0026#34; \u0026#34;Group_TP_vs_NT\u0026#34; # [3] \u0026#34;patient_TCGA.W5.AA2Q_vs_TCGA.W5.AA2I\u0026#34; \u0026#34;patient_TCGA.W5.AA2U_vs_TCGA.W5.AA2I\u0026#34; # [5] \u0026#34;patient_TCGA.W5.AA2X_vs_TCGA.W5.AA2I\u0026#34; \u0026#34;patient_TCGA.W5.AA30_vs_TCGA.W5.AA2I\u0026#34; # [7] \u0026#34;patient_TCGA.W5.AA31_vs_TCGA.W5.AA2I\u0026#34; \u0026#34;patient_TCGA.W5.AA34_vs_TCGA.W5.AA2I\u0026#34; # [9] \u0026#34;patient_TCGA.ZU.A8S4_vs_TCGA.W5.AA2I\u0026#34; res2 = results(dds2, name=\u0026#34;Group_TP_vs_NT\u0026#34;) deg2 = as.data.frame(res2) deg2 = deg2[order(deg2$padj), ] head(deg2) # baseMean log2FoldChange lfcSE stat pvalue padj # PCK2 22699.219 -5.653594 0.1854230 -30.49025 3.508987e-204 6.059670e-200 # GRHPR 17379.340 -3.574706 0.1551980 -23.03319 2.168223e-117 1.872152e-113 # KDM8 1614.762 -4.555835 0.1989067 -22.90438 4.201674e-116 2.418624e-112 # CTH 2367.082 -5.254396 0.2324677 -22.60270 4.077093e-113 1.760183e-109 # ADI1 18162.701 -3.714171 0.1659464 -22.38174 5.927946e-111 2.047394e-107 # PBLD 8315.518 -5.683135 0.2594054 -21.90831 2.164593e-106 6.230059e-103 library(\u0026#34;BiocParallel\u0026#34;) # Parallelizing DESeq, results, and lfcShrink # not supported on Windows register(MulticoreParam(4)) dds = DESeq(dds, parallel = TRUE) 3、edgeR 常规分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 library(edgeR) ##(1) DGEList对象 # 分组因子字符串：对照组在前；实验组在后 Group = factor(meta$Group, levels = c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;)) table(Group) # Group # NT TP # 9 35 dge.list = DGEList(counts=count, group=Group) dge.list$counts[1:4,1:4] dge.list$samples %\u0026gt;% head() # group lib.size norm.factors # TCGA-W5-AA2X-01A-11R-A41I-07 TP 41184464 1 # TCGA-W5-AA2X-11A-11R-A41I-07 NT 36468189 1 # TCGA-W5-AA33-01A-11R-A41I-07 TP 43378374 1 ##(2) 计算文库因子 dge.list = calcNormFactors(dge.list) # Default method = \u0026#39;TMM\u0026#39; dge.list$samples %\u0026gt;% head() # group lib.size norm.factors # TCGA-W5-AA2X-01A-11R-A41I-07 TP 41184464 1.2238691 # TCGA-W5-AA2X-11A-11R-A41I-07 NT 36468189 0.6258154 # TCGA-W5-AA33-01A-11R-A41I-07 TP 43378374 1.3504490 ##(3) 根据分组设计，进行差异分析 design = model.matrix(~ Group) #### 如有其它协变量因素，放在主要变量之前即可，如下示例 # design = model.matrix(~ Gender + Age + Group) head(design) # (Intercept) GroupTP # 1 1 1 # 2 1 0 # 3 1 1 dge.list = estimateDisp(dge.list, design) fit = glmFit(dge.list, design) # Defaults to the last coefficient. fit = glmLRT(fit) deg = topTags(fit, n = Inf) deg = as.data.frame(deg) head(deg) # logFC logCPM LR PValue FDR # MSMO1 -3.636116 7.467688 371.8917 7.249780e-83 1.445461e-78 # GCDH -3.189232 5.737307 359.9146 2.938892e-80 2.929781e-76 # KCNN2 -5.382560 3.055588 344.2997 7.387479e-77 4.909718e-73 # RCL1 -3.799208 5.786302 338.9246 1.094155e-75 5.453816e-72 # SC5D -3.852832 6.657183 338.3414 1.465859e-75 5.845260e-72 # USH2A -6.352713 3.665099 329.5388 1.211265e-73 4.025034e-70 count_log = log2(cpm(dge.list) + 1) # TMM normalized count_log[1:4,1:4] gene_exp = count_log[\u0026#34;MSMO1\u0026#34;, ,drop=F] %\u0026gt;% t() %\u0026gt;% as.data.frame() %\u0026gt;% dplyr::mutate(Group=meta$Group) ggplot(gene_exp, aes(x=Group, y=MSMO1)) + geom_boxplot() 配对分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 library(edgeR) Group = factor(meta_pair$Group, levels = c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;)) # 对照组在前；实验组在后 Patient = meta_pair$patient dge.list = DGEList(counts=count_pair, group=Group) dge.list = calcNormFactors(dge.list) # Default method = \u0026#39;TMM\u0026#39; design = model.matrix(~ Patient + Group) head(design) # (Intercept) PatientTCGA-W5-AA2Q PatientTCGA-W5-AA2U PatientTCGA-W5-AA2X PatientTCGA-W5-AA30 # 1 1 0 0 1 0 # 2 1 1 0 0 0 # 3 1 0 0 0 1 # 4 1 0 0 0 0 # 5 1 0 0 0 0 # 6 1 0 0 0 0 # PatientTCGA-W5-AA31 PatientTCGA-W5-AA34 PatientTCGA-ZU-A8S4 GroupTP # 1 0 0 0 0 # 2 0 0 0 0 # 3 0 0 0 0 # 4 0 0 1 0 # 5 1 0 0 0 # 6 0 0 0 0 dge.list = estimateDisp(dge.list, design) fit = glmQLFit(dge.list, design, robust = TRUE) fit = glmQLFTest(fit) # By default, the test is for the last coefficient in the design matrix, deg = topTags(fit, n = Inf) deg = as.data.frame(deg) head(deg) # logFC logCPM F PValue FDR # CTH -5.168010 5.735511 451.8950 1.891581e-10 2.184341e-06 # KDM8 -4.469608 5.191592 439.9909 2.191134e-10 2.184341e-06 # PCK2 -5.566911 8.997974 385.1885 4.551845e-10 2.240078e-06 # IQGAP3 5.382710 4.043167 378.8504 4.985585e-10 2.240078e-06 # EPB41L4B -3.747267 6.347686 360.6129 6.533619e-10 2.240078e-06 # GCH1 -3.670607 5.705010 358.5600 6.741130e-10 2.240078e-06 4、limma RNAseq差异分析 （1）常规分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 Group = factor(meta$Group, levels = c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;)) table(Group) # Group # NT TP # 9 35 design = model.matrix(~ Group) head(design) # (Intercept) GroupTP # 1 1 1 # 2 1 0 # 3 1 1 # 4 1 1 # 5 1 1 # 6 1 1 v = voom(count,design,normalize=\u0026#34;quantile\u0026#34;) fit = lmFit(v,design) fit = eBayes(fit) colnames(coef(fit)) #[1] \u0026#34;(Intercept)\u0026#34; \u0026#34;GroupTP\u0026#34; tT = topTable(fit, adjust=\u0026#34;fdr\u0026#34;, sort.by=\u0026#34;p\u0026#34;, number=Inf) head(tT) # logFC AveExpr t P.Value adj.P.Val B # RMDN2 -2.900127 2.5323698 -28.67963 1.336773e-29 2.665258e-25 56.90314 # USH2A -6.535628 0.3847154 -23.73211 2.788056e-26 2.005247e-22 49.38508 # KCNN2 -5.460617 0.6268550 -23.68516 3.017223e-26 2.005247e-22 49.31589 # ESR1 -5.701844 1.4121136 -21.54736 1.278570e-24 6.373031e-21 45.80920 # AC132217.2 -5.094348 -5.1967122 -20.17979 1.659743e-23 6.430672e-20 42.06491 # SOX5 -4.944365 0.7859657 -20.10020 1.935201e-23 6.430672e-20 43.12095 （2）配对分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 Group = factor(meta_pair$Group, levels = c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;)) table(Group) # Group # NT TP # 8 8 Patient = factor(meta_pair$patient) table(Patient) Patient # TCGA-W5-AA2I TCGA-W5-AA2Q TCGA-W5-AA2U TCGA-W5-AA2X TCGA-W5-AA30 TCGA-W5-AA31 TCGA-W5-AA34 TCGA-ZU-A8S4 # 2 2 2 2 2 2 2 2 design = model.matrix(~ Patient + Group) head(design) # (Intercept) PatientTCGA-W5-AA2Q PatientTCGA-W5-AA2U PatientTCGA-W5-AA2X PatientTCGA-W5-AA30 # 1 1 0 0 1 0 # 2 1 1 0 0 0 # 3 1 0 0 0 1 # 4 1 0 0 0 0 # 5 1 0 0 0 0 # 6 1 0 0 0 0 # PatientTCGA-W5-AA31 PatientTCGA-W5-AA34 PatientTCGA-ZU-A8S4 GroupTP # 1 0 0 0 0 # 2 0 0 0 0 # 3 0 0 0 0 # 4 0 0 1 0 # 5 1 0 0 0 # 6 0 0 0 0 v = voom(count_pair, design, normalize=\u0026#34;quantile\u0026#34;) fit = lmFit(v,design) fit = eBayes(fit) colnames(coef(fit)) # [1] \u0026#34;(Intercept)\u0026#34; \u0026#34;PatientTCGA-W5-AA2Q\u0026#34; \u0026#34;PatientTCGA-W5-AA2U\u0026#34; \u0026#34;PatientTCGA-W5-AA2X\u0026#34; # [5] \u0026#34;PatientTCGA-W5-AA30\u0026#34; \u0026#34;PatientTCGA-W5-AA31\u0026#34; \u0026#34;PatientTCGA-W5-AA34\u0026#34; \u0026#34;PatientTCGA-ZU-A8S4\u0026#34; # [9] \u0026#34;GroupTP\u0026#34; tT = topTable(fit, coef = \u0026#34;GroupTP\u0026#34;, adjust=\u0026#34;fdr\u0026#34;, sort.by=\u0026#34;p\u0026#34;, number=Inf) head(tT) # logFC AveExpr t P.Value adj.P.Val B # BTD -2.500130 5.412028 -37.40476 5.067356e-10 8.241491e-06 13.61382 # MCM3 2.535346 5.765008 35.09944 8.267119e-10 8.241491e-06 13.22475 # ABCC10 1.768879 3.760942 31.34388 1.973016e-09 9.926863e-06 12.32708 # FGGY -2.559748 4.447616 -29.91541 2.822782e-09 9.926863e-06 12.07469 # ZCCHC2 -1.924153 4.452133 -29.51382 3.131304e-09 9.926863e-06 12.01657 # ACOT1 -4.146553 1.943388 -28.79614 3.782277e-09 9.926863e-06 11.27019 芯片数据差异分析 （1）GEO芯片数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 library(GEOquery) Sys.setenv(\u0026#34;VROOM_CONNECTION_SIZE\u0026#34; = 131072 * 10) gse = getGEO(\u0026#39;GSE109169\u0026#39;, getGPL = F) gse = gse[[1]] exp_dat = exprs(gse) %\u0026gt;% as.data.frame() dim(exp_dat) # [1] 19076 50 exp_dat[1:4,1:4] # GSM2934481 GSM2934482 GSM2934483 GSM2934484 # 2315554 7.31 7.27 7.63 7.38 # 2315633 7.24 7.52 7.42 7.37 # 2315674 7.36 7.42 7.61 7.31 # 2315739 7.24 7.56 7.76 7.46 meta = pData(gse) %\u0026gt;% dplyr::select(title, dplyr::ends_with(\u0026#34;ch1\u0026#34;)) colnames(meta)=gsub(\u0026#34;[:_]ch1\u0026#34;, \u0026#34;\u0026#34;, colnames(meta)) meta$Group = ifelse(meta$source_name==\u0026#34;breast cancer tissue\u0026#34;, \u0026#34;tumor\u0026#34;, \u0026#34;normal\u0026#34;) # normal tumor # 25 25 meta$Patient = stringr::str_split(meta$title, \u0026#34;-\u0026#34;, simplify=T)[,1] table(meta$Patient) # 2102 2110 2146 2181 2190 2280 2297 2353 2365 2397 2451 2454 2706 2780 2910 2917 2943 2972 2985 3156 3159 # 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 # 3197 3232 3297 3355 # 2 2 2 2 head(meta[,c(\u0026#34;Group\u0026#34;,\u0026#34;Patient\u0026#34;)]) # Group Patient # GSM2934481 normal 2102 # GSM2934482 tumor 2102 # GSM2934483 normal 2110 # GSM2934484 tumor 2110 # GSM2934485 normal 2146 # GSM2934486 tumor 2146 identical(rownames(meta), colnames(exp_dat)) # [1] TRUE （2）常规分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Group = factor(meta$Group, levels = c(\u0026#34;normal\u0026#34;,\u0026#34;tumor\u0026#34;)) table(Group) # Group # normal tumor # 25 25 design=model.matrix(~ Group) head(design) # (Intercept) Grouptumor # 1 1 0 # 2 1 1 # 3 1 0 # 4 1 1 # 5 1 0 # 6 1 1 fit = lmFit(exp_dat, design) fit = eBayes(fit) colnames(coef(fit)) # [1] \u0026#34;(Intercept)\u0026#34; \u0026#34;Grouptumor\u0026#34; tT = topTable(fit, adjust=\u0026#34;fdr\u0026#34;, sort.by=\u0026#34;p\u0026#34;, number=Inf) head(tT) # logFC AveExpr t P.Value adj.P.Val B # 4004044 -2.6860 6.8706 -21.16464 6.424093e-27 1.225460e-22 50.47849 # 4000538 -4.1400 6.6420 -19.36848 3.622286e-25 3.454937e-21 46.66686 # 2591421 -2.2128 7.1468 -16.18728 9.688784e-22 6.160775e-18 39.10226 # 3830189 -1.8416 8.0504 -16.03976 1.433530e-21 6.836502e-18 38.72368 # 3519309 -2.1232 7.7964 -15.30913 1.034876e-20 3.948259e-17 36.80964 # 3745525 -1.0784 6.1008 -15.21411 1.344319e-20 4.274038e-17 36.55587 （3）配对分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 Group = factor(meta$Group, levels = c(\u0026#34;normal\u0026#34;,\u0026#34;tumor\u0026#34;)) table(Group) # Group # normal tumor # 25 25 Patient = factor(meta$Patient) table(Patient) # Patient # 2102 2110 2146 2181 2190 2280 2297 2353 2365 2397 2451 2454 2706 2780 2910 2917 2943 2972 2985 3156 3159 # 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 # 3197 3232 3297 3355 # 2 2 2 2 design=model.matrix(~ Patient + Group) head(design) # Groupnormal Grouptumor # 1 1 0 # 2 0 1 # 3 1 0 fit = lmFit(exp_dat, design) fit \u0026lt;- eBayes(fit) colnames(coef(fit)) # [1] \u0026#34;(Intercept)\u0026#34; \u0026#34;Patient2110\u0026#34; \u0026#34;Patient2146\u0026#34; \u0026#34;Patient2181\u0026#34; \u0026#34;Patient2190\u0026#34; \u0026#34;Patient2280\u0026#34; \u0026#34;Patient2297\u0026#34; # [8] \u0026#34;Patient2353\u0026#34; \u0026#34;Patient2365\u0026#34; \u0026#34;Patient2397\u0026#34; \u0026#34;Patient2451\u0026#34; \u0026#34;Patient2454\u0026#34; \u0026#34;Patient2706\u0026#34; \u0026#34;Patient2780\u0026#34; # [15] \u0026#34;Patient2910\u0026#34; \u0026#34;Patient2917\u0026#34; \u0026#34;Patient2943\u0026#34; \u0026#34;Patient2972\u0026#34; \u0026#34;Patient2985\u0026#34; \u0026#34;Patient3156\u0026#34; \u0026#34;Patient3159\u0026#34; # [22] \u0026#34;Patient3197\u0026#34; \u0026#34;Patient3232\u0026#34; \u0026#34;Patient3297\u0026#34; \u0026#34;Patient3355\u0026#34; \u0026#34;Grouptumor\u0026#34; tT \u0026lt;- topTable(fit, coef = \u0026#34;Grouptumor\u0026#34;, adjust=\u0026#34;fdr\u0026#34;, sort.by=\u0026#34;p\u0026#34;, number=Inf) head(tT) # logFC AveExpr t P.Value adj.P.Val B # 4004044 -2.6860 6.8706 -23.34059 1.764542e-19 3.366041e-15 33.97414 # 4000538 -4.1400 6.6420 -21.21050 2.072006e-18 1.976279e-14 31.71755 # 3830189 -1.8416 8.0504 -19.34286 2.168752e-17 1.379037e-13 29.52627 # 2701109 -2.4704 7.0796 -17.61105 2.298621e-16 1.096212e-12 27.28943 # 3062082 -2.9824 9.0236 -17.27304 3.728465e-16 1.422484e-12 26.82740 # 2591421 -2.2128 7.1468 -17.03824 5.241945e-16 1.564468e-12 26.50125 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/045%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90r%E5%8C%85-deseq2+edger+limma/","summary":"\u003cp\u003e在对转录组数据分析时，分组比较的差异分析前提时获得测序表达矩阵。\u003c/p\u003e\n\u003cp\u003e根据测序技术分为两种，对应的分析R包如下所示。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRNAseq的原始count表达矩阵\n\u003cul\u003e\n\u003cli\u003eDESeq2\u003c/li\u003e\n\u003cli\u003eedgeR\u003c/li\u003e\n\u003cli\u003elimma\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e芯片array标准化后的表达矩阵\n\u003cul\u003e\n\u003cli\u003elimma\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1示例count表达矩阵\"\u003e1、示例count表达矩阵\u003c/h1\u003e\n\u003cp\u003e如下使用TCGAbiolinks包下载共9个癌症样本、35个正常样本的表达矩阵；其中涉及到8对配对样本（tumor与normal来自同一病人）\u003c/p\u003e","title":"差异分析R包-DESeq2+edgeR+limma"},{"content":"TCGAbiolinks包是一站式分析TCGA数据的R包工具，它集成了TCGA数据下载、分析、可视化的全部流程。此次系列笔记主要跟着 TCGAbiolinks帮助文档重新学习下TCGA数据挖掘流程。\n官方文档：https://bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/index.html\n文献：TCGAbiolinks: an R/Bioconductor package for integrative analysis of TCGA data https://pubmed.ncbi.nlm.nih.gov/26704973/\n安装包\n1 2 3 4 5 6 7 if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) #From github BiocManager::install(\u0026#34;BioinformaticsFMRP/TCGAbiolinksGUI.data\u0026#34;) BiocManager::install(\u0026#34;BioinformaticsFMRP/TCGAbiolinks\u0026#34;) #From Bioconductor BiocManager::install(\u0026#34;TCGAbiolinks\u0026#34;) 一、查找TCGA数据 主要通过GDCquery()函数查找数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library(TCGAbiolinks) GDCquery( project, data.category, data.type, workflow.type, legacy = FALSE, access, platform, file.type, barcode, data.format, experimental.strategy, sample.type ) 1 选择肿瘤类型 project参数：指定一个或多个感兴趣的TCGA项目名 如下代码所示，供包括33种TCGA癌症类型。癌症简称对应全称及中文名见文末。 1 2 3 4 5 6 7 8 9 projects = TCGAbiolinks:::getGDCprojects()$project_id TCGAs = grep(\u0026#34;TCGA\u0026#34;, projects, value = T) sort(TCGAs) # [1] \u0026#34;TCGA-ACC\u0026#34; \u0026#34;TCGA-BLCA\u0026#34; \u0026#34;TCGA-BRCA\u0026#34; \u0026#34;TCGA-CESC\u0026#34; \u0026#34;TCGA-CHOL\u0026#34; \u0026#34;TCGA-COAD\u0026#34; # [7] \u0026#34;TCGA-DLBC\u0026#34; \u0026#34;TCGA-ESCA\u0026#34; \u0026#34;TCGA-GBM\u0026#34; \u0026#34;TCGA-HNSC\u0026#34; \u0026#34;TCGA-KICH\u0026#34; \u0026#34;TCGA-KIRC\u0026#34; # [13] \u0026#34;TCGA-KIRP\u0026#34; \u0026#34;TCGA-LAML\u0026#34; \u0026#34;TCGA-LGG\u0026#34; \u0026#34;TCGA-LIHC\u0026#34; \u0026#34;TCGA-LUAD\u0026#34; \u0026#34;TCGA-LUSC\u0026#34; # [19] \u0026#34;TCGA-MESO\u0026#34; \u0026#34;TCGA-OV\u0026#34; \u0026#34;TCGA-PAAD\u0026#34; \u0026#34;TCGA-PCPG\u0026#34; \u0026#34;TCGA-PRAD\u0026#34; \u0026#34;TCGA-READ\u0026#34; # [25] \u0026#34;TCGA-SARC\u0026#34; \u0026#34;TCGA-SKCM\u0026#34; \u0026#34;TCGA-STAD\u0026#34; \u0026#34;TCGA-TGCT\u0026#34; \u0026#34;TCGA-THCA\u0026#34; \u0026#34;TCGA-THYM\u0026#34; # [31] \u0026#34;TCGA-UCEC\u0026#34; \u0026#34;TCGA-UCS\u0026#34; \u0026#34;TCGA-UVM\u0026#34; 2 hg19/hg38 主要根据参考基因组的不同，包含两套数据：GDC Legacy Archive【主要GRCh37 (hg19)】，GDC harmonized database【GRCh38 (hg38)】 通过设置参数legacy ，默认为FALSE(hg38)；TRUE则表示使用hg19参考基因组的测序数据。 3 下载数据类型 基于上述的参数，我们可以设置如下参数，交代我们的目标数据类型\ndata.category = 指定下载什么类型的数据：如转录组数据、临床数据\u0026hellip;. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ##(1) GDC harmonized database【GRCh38 (hg38)】 TCGAbiolinks:::getProjectSummary(\u0026#34;TCGA-BRCA\u0026#34;, legacy = FALSE)$data_categories$data_category # [1] \u0026#34;Structural Variation\u0026#34; \u0026#34;Simple Nucleotide Variation\u0026#34; # [3] \u0026#34;Copy Number Variation\u0026#34; \u0026#34;Transcriptome Profiling\u0026#34; # [5] \u0026#34;DNA Methylation\u0026#34; \u0026#34;Sequencing Reads\u0026#34; # [7] \u0026#34;Biospecimen\u0026#34; \u0026#34;Clinical\u0026#34; # [9] \u0026#34;Proteome Profiling\u0026#34; ##(2) GDC Legacy Archive【主要GRCh37 (hg19)】 TCGAbiolinks:::getProjectSummary(\u0026#34;TCGA-BRCA\u0026#34;, legacy = TRUE)$data_categories$data_category # [1] \u0026#34;Protein expression\u0026#34; \u0026#34;Copy number variation\u0026#34; # [3] \u0026#34;Biospecimen\u0026#34; \u0026#34;Simple nucleotide variation\u0026#34; # [5] \u0026#34;Gene expression\u0026#34; \u0026#34;Raw microarray data\u0026#34; # [7] \u0026#34;DNA methylation\u0026#34; \u0026#34;Clinical\u0026#34; # [9] \u0026#34;Raw sequencing data\u0026#34; data.type = 更加细节的数据类型选择，例如harmonized的Transcriptome Profiling有 Gene Expression Quantification, Isoform Expression Quantification, miRNA Expression Quantification, Splice Junction Quantification4种数据。而我们一般需要的是Gene Expression Quantification。 workflow.type = 同一个测序数据可能有不同的pipeline处理流程，如果有不同的处理流程，需要选择。据最新的TCGA版本，仅提供STAR - Counts。 platform = 测序平台（optional） file.type = 具体的数据文件（optional, for legacy） 如果不知道目标数据的上述信息，可以参考下面的概述 具体参考文末第二点。\n4 样本标签Barcode 完整的barcode：形如 TCGA-G4-6317-02A-11D-2064-05，这个标签包含了从病人来源到测序过程、分析的所有信息，如下图所示比较重要的是Participant、Sample 、Portion三个部分，分别交代了病人编号、样本类型、测序类型 病人的id：形如 TCGA-G4-6317 样本来源的id：形如 TCGA-G4-6317-02 其中比较重要的是交代样本类型的Sample的两位数信息，是后面进行差异分析的分组依据。具体对应的含义如下。例如01表示病人的原位瘤组织；11表示来自病人的正常组织\u0026hellip;. 基于上述理解，我们也可以设置sample.type = 参数指定下载感兴趣的样本类型数据，例如sample.type = \u0026quot;Primary Tumor\u0026quot;\n对于给定的TCGA barcode，可以利用TCGAquery_SampleTypes()提取出目标分组的样本；TCGAquery_MatchedCoupledSampleTypes()函数可以提取来自同一病人的配对样本数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 query \u0026lt;- GDCquery(project = c(\u0026#34;TCGA-BRCA\u0026#34;), legacy = FALSE, data.category = \u0026#34;Transcriptome Profiling\u0026#34;, data.type = \u0026#34;Gene Expression Quantification\u0026#34;, workflow.type = \u0026#34;HTSeq - Counts\u0026#34;) dim(getResults(query)) #[1] 1222 29 query_info = getResults(query) TP = TCGAquery_SampleTypes(query_info$sample.submitter_id,\u0026#34;TP\u0026#34;) NT = TCGAquery_SampleTypes(query_info$sample.submitter_id,\u0026#34;NT\u0026#34;) query \u0026lt;- GDCquery(project = c(\u0026#34;TCGA-BRCA\u0026#34;), legacy = FALSE, data.category = \u0026#34;Transcriptome Profiling\u0026#34;, data.type = \u0026#34;Gene Expression Quantification\u0026#34;, workflow.type = \u0026#34;HTSeq - Counts\u0026#34;, barcode = c(TP, NT)) dim(getResults(query)) #[1] 1215 29 Pair_sample = TCGAquery_MatchedCoupledSampleTypes(query_info$sample.submitter_id,c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;)) query \u0026lt;- GDCquery(project = c(\u0026#34;TCGA-BRCA\u0026#34;), legacy = FALSE, data.category = \u0026#34;Transcriptome Profiling\u0026#34;, data.type = \u0026#34;Gene Expression Quantification\u0026#34;, workflow.type = \u0026#34;HTSeq - Counts\u0026#34;, barcode = Pair_sample) dim(getResults(query)) #[1] 229 29 如上是查询TCGA目标数据的几种常见标准，还有几个参数没有介绍，可参看函数帮助文档。可根据自己的目的灵活设置上述参数。\n二、从数据下载到差异分析 以胆管癌为例，演示从数据下载到差异分析的全流程。\n1 Legacy(hg19) 1.1 下载数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library(TCGAbiolinks) ##(1) 获取下载目标文件 query \u0026lt;- GDCquery(project = \u0026#34;TCGA-CHOL\u0026#34;, legacy = TRUE, data.category = \u0026#34;Gene expression\u0026#34;, data.type = \u0026#34;Gene expression quantification\u0026#34;, platform = \u0026#34;Illumina HiSeq\u0026#34;, file.type = \u0026#34;results\u0026#34;) ##(2) 下载数据到本地 # files.per.chunk = 10 表示分批下载，每批下载10个病人的数据，可避免中途报错，而前功尽弃。 GDCdownload(query, files.per.chunk = 10) ##(3) 加载数据至当前环境 data \u0026lt;- GDCprepare(query, save = T, save.filename = \u0026#34;CHOL_RNAseq_hg19.rda\u0026#34;) 1.2 探索数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 library(SummarizedExperiment) dim(assay(data)) #[1] 19947 45 ##(1) 查看表达矩阵 assayNames(data) # [1] \u0026#34;raw_count\u0026#34; \u0026#34;scaled_estimate\u0026#34; assay(data, \u0026#34;raw_count\u0026#34;)[1:3,1:3] # TCGA-W5-AA2I-11A-11R-A41I-07 TCGA-W5-AA2U-11A-11R-A41I-07 TCGA-W5-AA2I-01A-32R-A41I-07 # A1BG|1 80062.65 79948.1 2519.20 # A2M|2 79697.45 126813.9 4107.88 # NAT1|9 364.00 397.0 126.00 ##(2) 样本(临床)信息 dim(colData(data)) #[1] 45 201 colData(data)[1:4,1:4] ##(3) 基因信息 rowData(data)[1:6,1:5] # DataFrame with 6 rows and 3 columns # gene_id entrezgene ensembl_gene_id # \u0026lt;character\u0026gt; \u0026lt;integer\u0026gt; \u0026lt;character\u0026gt; # A1BG A1BG 1 ENSG00000121410 # A2M A2M 2 ENSG00000175899 # NAT1 NAT1 9 ENSG00000171428 rowRanges(data) 1.3 整理数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ##(1)更改表达矩阵行名/基因名格式 rownames(data) = stringr::str_split(rownames(data), \u0026#34;[|]\u0026#34;, simplify = T)[,1] data = data[!duplicated(rownames(data)),] dim(data) # [1] 19938 45 assay(data, \u0026#34;raw_count\u0026#34;)[1:3,1:3] # TCGA-W5-AA2I-11A-11R-A41I-07 TCGA-W5-AA2U-11A-11R-A41I-07 TCGA-W5-AA2I-01A-32R-A41I-07 # A1BG 80062.65 79948.1 2519.20 # A2M 79697.45 126813.9 4107.88 # NAT1 364.00 397.0 126.00 ##(2) 分析样本间相关性，鉴定离群点样本 CorOutliers \u0026lt;- TCGAanalyze_Preprocessing(data, cor.cut = 0, filename=\u0026#34;CHOL45_hg19_cor.png\u0026#34;) ##(3) 标准化 dataNorm \u0026lt;- TCGAanalyze_Normalization(tabDF = data, geneInfo = geneInfo) #没有log处理 dim(dataNorm) # [1] 17618 45 class(dataNorm) # [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34; dataNorm[1:3,1:3] # TCGA-W5-AA2I-11A-11R-A41I-07 TCGA-W5-AA2U-11A-11R-A41I-07 TCGA-W5-AA2I-01A-32R-A41I-07 # A1BG 80063 79948 2519 # A2M 79697 126814 4108 # NAT1 364 397 126 ##(4) 过滤低表达基因 dataFilt \u0026lt;- TCGAanalyze_Filtering(tabDF = dataNorm, method = \u0026#34;quantile\u0026#34;, qnt.cut = 0.05) dim(dataFilt) exp_data = dataFilt 1.4 差异分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ##(1) 确定分组样本 samplesNT \u0026lt;- TCGAquery_SampleTypes(barcode = colnames(exp_data), typesample = c(\u0026#34;NT\u0026#34;)) samplesTP \u0026lt;- TCGAquery_SampleTypes(barcode = colnames(exp_data), typesample = c(\u0026#34;TP\u0026#34;)) ##(2) 差异分析 dataDEGs \u0026lt;- TCGAanalyze_DEA(mat1 = exp_data[,samplesNT], mat2 = exp_data[,samplesTP], Cond1type = \u0026#34;Normal\u0026#34;, Cond2type = \u0026#34;Tumor\u0026#34;, pipeline = \u0026#34;edgeR\u0026#34;, method = \u0026#34;glmLRT\u0026#34;) ##(3) 整理结果 DEGs \u0026lt;- TCGAanalyze_LevelTab(dataDEGs,\u0026#34;Tumor\u0026#34;,\u0026#34;Normal\u0026#34;, exp_data[,samplesTP],exp_data[,samplesNT]) DEGs = DEGs[order(DEGs$FDR),] DEGs$Direct = ifelse(DEGs$logFC\u0026gt;0, \u0026#34;Up\u0026#34;, \u0026#34;Down\u0026#34;) head(DEGs) # mRNA logFC FDR Delta Tumor Normal Direct # USH2A USH2A -5.261122 1.805847e-46 -150.9650 28.69444 1207.88889 Down # KCNN2 KCNN2 -4.344681 1.045519e-36 -188.2695 43.33333 893.77778 Down # LCAT LCAT -3.683368 2.344098e-31 -1875.2437 509.11111 6640.22222 Down # IQCE IQCE 4.229960 6.301169e-30 12462.2846 2946.19444 153.33333 Up # DCXR DCXR -4.070648 9.023484e-30 -7408.0132 1819.86111 32284.22222 Down # PRSS16 PRSS16 6.947385 3.517876e-28 9163.9866 1319.05556 10.22222 Up DEGs = DEGs[order(DEGs$FDR),] DEGs$Direct = ifelse(DEGs$logFC\u0026gt;0, \u0026#34;Up\u0026#34;, \u0026#34;Down\u0026#34;) table(DEGs$FDR\u0026lt;0.01,DEGs$Direct) DEGs_sig = subset(DEGs, FDR\u0026lt;0.01) table(DEGs_sig$Direct, abs(DEGs_sig$logFC)\u0026gt;1) 2 Harmonized(hg38) 2.1 下载数据 1 2 3 4 5 6 7 8 9 10 11 12 13 library(TCGAbiolinks) ##(1) 获取下载目标文件 query \u0026lt;- GDCquery(project = \u0026#34;TCGA-CHOL\u0026#34;, legacy = FALSE, data.category = \u0026#34;Transcriptome Profiling\u0026#34;, data.type = \u0026#34;Gene Expression Quantification\u0026#34;) ##(2) 下载数据到本地 # files.per.chunk = 10 表示分批下载，每批下载10个病人的数据，可避免中途报错，而前功尽弃。 GDCdownload(query, files.per.chunk = 10) ##(3) 加载数据至当前环境 data \u0026lt;- GDCprepare(query, save = T, save.filename = \u0026#34;CHOL_RNAseq_hg38.rda\u0026#34;) 2.2 探索数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 library(SummarizedExperiment) dim(assay(data)) #[1] 60660 44 ##(1) 查看表达矩阵 assayNames(data) #[1] \u0026#34;unstranded\u0026#34; \u0026#34;stranded_first\u0026#34; \u0026#34;stranded_second\u0026#34; \u0026#34;tpm_unstrand\u0026#34; #[5] \u0026#34;fpkm_unstrand\u0026#34; \u0026#34;fpkm_uq_unstrand\u0026#34; assay(data, \u0026#34;unstranded\u0026#34;)[1:3,1:3] # TCGA-W5-AA2X-01A-11R-A41I-07 TCGA-W5-AA2X-11A-11R-A41I-07 TCGA-W5-AA33-01A-11R-A41I-07 # ENSG00000000003.15 3310 2322 11312 # ENSG00000000005.6 0 0 1 # ENSG00000000419.13 1881 716 968 ##(2) 样本(临床)信息 dim(colData(data)) #[1] 44 201 colData(data)[1:4,1:4] ##(3) 基因信息 t(rowData(data)[1,]) # TransposedDataFrame with 10 rows and 1 column # ENSG00000000003.15 # source \u0026lt;factor\u0026gt; HAVANA # type \u0026lt;factor\u0026gt; gene # score \u0026lt;numeric\u0026gt; NA # phase \u0026lt;integer\u0026gt; NA # gene_id \u0026lt;character\u0026gt; ENSG00000000003.15 # gene_type \u0026lt;character\u0026gt; protein_coding # gene_name \u0026lt;character\u0026gt; TSPAN6 # level \u0026lt;character\u0026gt; 2 # hgnc_id \u0026lt;character\u0026gt; HGNC:11858 # havana_gene \u0026lt;character\u0026gt; OTTHUMG00000022002.2 table(rowData(data)$gene_type) %\u0026gt;% sort(decreasing = T) %\u0026gt;% head() # protein_coding lncRNA processed_pseudogene unprocessed_pseudogene misc_RNA snRNA # 19962 16901 10167 2614 2212 1901 rowRanges(data) 2.3 整理数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ##(1)更改表达矩阵行名/基因名格式，筛选基因 rownames(data) = rowData(data)$gene_name data = data[!duplicated(rownames(data)),] data = data[rowData(data)$gene_type==\u0026#34;protein_coding\u0026#34;,] dim(data) # [1] 19934 44 assay(data, \u0026#34;unstranded\u0026#34;)[1:3,1:3] # TCGA-W5-AA2X-01A-11R-A41I-07 TCGA-W5-AA2X-11A-11R-A41I-07 TCGA-W5-AA33-01A-11R-A41I-07 # TSPAN6 3310 2322 11312 # TNMD 0 0 1 # DPM1 1881 716 968 ##(2) 分析样本间相关性，鉴定离群点样本 CorOutliers \u0026lt;- TCGAanalyze_Preprocessing(data, cor.cut = 0, filename=\u0026#34;CHOL45_hg38_cor.png\u0026#34;) ##(3) 标准化 dataNorm \u0026lt;- TCGAanalyze_Normalization(tabDF = data, geneInfo = geneInfo) #没有log处理 dim(dataNorm) # [1] 15196 44 class(dataNorm) # [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34; dataNorm[1:3,1:3] # TCGA-W5-AA2X-01A-11R-A41I-07 TCGA-W5-AA2X-11A-11R-A41I-07 TCGA-W5-AA33-01A-11R-A41I-07 # TSPAN6 3310 2322 11312 # DPM1 1881 716 968 # SCYL3 966 315 1296 ##(4) 过滤低表达基因 # dataFilt \u0026lt;- TCGAanalyze_Filtering(tabDF = dataNorm, # method = \u0026#34;quantile\u0026#34;, # qnt.cut = 0.05) # dim(dataFilt) exp_data = dataNorm 2.4 差异分析 (1) edgeR 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ##(1) 确定分组样本 samplesNT \u0026lt;- TCGAquery_SampleTypes(barcode = colnames(exp_data), typesample = c(\u0026#34;NT\u0026#34;)) samplesTP \u0026lt;- TCGAquery_SampleTypes(barcode = colnames(exp_data), typesample = c(\u0026#34;TP\u0026#34;)) ##(2) 差异分析 dataDEGs \u0026lt;- TCGAanalyze_DEA(mat1 = exp_data[,samplesNT], mat2 = exp_data[,samplesTP], Cond1type = \u0026#34;Normal\u0026#34;, Cond2type = \u0026#34;Tumor\u0026#34;, pipeline = \u0026#34;edgeR\u0026#34;, method = \u0026#34;glmLRT\u0026#34;) ##(3) 整理结果 DEGs \u0026lt;- TCGAanalyze_LevelTab(dataDEGs,\u0026#34;Tumor\u0026#34;,\u0026#34;Normal\u0026#34;, exp_data[,samplesTP],exp_data[,samplesNT]) DEGs = DEGs[order(DEGs$FDR),] DEGs$Direct = ifelse(DEGs$logFC\u0026gt;0, \u0026#34;Up\u0026#34;, \u0026#34;Down\u0026#34;) head(DEGs) # mRNA logFC FDR Delta Tumor Normal Direct # USH2A USH2A -5.261122 1.805847e-46 -150.9650 28.69444 1207.88889 Down # KCNN2 KCNN2 -4.344681 1.045519e-36 -188.2695 43.33333 893.77778 Down # LCAT LCAT -3.683368 2.344098e-31 -1875.2437 509.11111 6640.22222 Down # IQCE IQCE 4.229960 6.301169e-30 12462.2846 2946.19444 153.33333 Up # DCXR DCXR -4.070648 9.023484e-30 -7408.0132 1819.86111 32284.22222 Down # PRSS16 PRSS16 6.947385 3.517876e-28 9163.9866 1319.05556 10.22222 Up DEGs = DEGs[order(DEGs$FDR),] DEGs$Direct = ifelse(DEGs$logFC\u0026gt;0, \u0026#34;Up\u0026#34;, \u0026#34;Down\u0026#34;) table(DEGs$FDR\u0026lt;0.01,DEGs$Direct) DEGs_sig = subset(DEGs, FDR\u0026lt;0.01) table(DEGs_sig$Direct, abs(DEGs_sig$logFC)\u0026gt;1) (2) Deseq2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ##(1)Deseq2差异分析 library(TCGAbiolinks) library(DESeq2) library(tidyverse) data$sample_type = factor(data$sample_type, levels = c(\u0026#34;Solid Tissue Normal\u0026#34;,\u0026#34;Primary Tumor\u0026#34;)) ddsSE \u0026lt;- DESeqDataSet(data, design = ~ sample_type) keep \u0026lt;- rowSums(counts(ddsSE)) \u0026gt;= 10 ddsSE \u0026lt;- ddsSE[keep,] ddsSE \u0026lt;- DESeq(ddsSE) resultsNames(ddsSE) res \u0026lt;- results(ddsSE, name = \u0026#34;sample_type_Primary.Tumor_vs_Solid.Tissue.Normal\u0026#34;) dea \u0026lt;- as.data.frame(res) %\u0026gt;% arrange(padj) head(dea) # baseMean log2FoldChange lfcSE stat pvalue padj # MSMO1 7585.3117 -3.748458 0.2108963 -17.77394 1.125105e-70 1.012094e-66 # RMDN2 396.7564 -2.929007 0.1648043 -17.77264 1.151350e-70 1.012094e-66 # GCDH 2272.8992 -3.302565 0.1863391 -17.72342 2.765888e-70 1.620903e-66 # TCAIM 1239.0498 -2.235399 0.1303361 -17.15104 6.174288e-66 2.713754e-62 # KCNN2 360.4370 -5.504733 0.3234314 -17.01979 5.858475e-65 2.059957e-61 # RCL1 2371.8288 -3.917907 0.2368974 -16.53842 1.940540e-61 5.686107e-58 ##(2)配对差异分析 data_pair = data[,data$barcode %in% TCGAquery_MatchedCoupledSampleTypes(data$barcode, c(\u0026#34;NT\u0026#34;,\u0026#34;TP\u0026#34;))] dim(data_pair) data_pair$pair = substr(data_pair$barcode, 1, 12) table(data_pair$pair) # TCGA-W5-AA2I TCGA-W5-AA2Q TCGA-W5-AA2U TCGA-W5-AA2X TCGA-W5-AA30 TCGA-W5-AA31 TCGA-W5-AA34 TCGA-ZU-A8S4 # 2 2 2 2 2 2 2 2 data_pair$sample_type = factor(data_pair$sample_type, levels = c(\u0026#34;Solid Tissue Normal\u0026#34;,\u0026#34;Primary Tumor\u0026#34;)) ddsSE \u0026lt;- DESeqDataSet(data_pair, design = ~ sample_type + pair) keep \u0026lt;- rowSums(counts(ddsSE)) \u0026gt;= 10 ddsSE \u0026lt;- ddsSE[keep,] ddsSE \u0026lt;- DESeq(ddsSE) resultsNames(ddsSE) res \u0026lt;- results(ddsSE, name = \u0026#34;sample_type_Primary.Tumor_vs_Solid.Tissue.Normal\u0026#34;) dea_p \u0026lt;- as.data.frame(res) %\u0026gt;% arrange(padj) head(dea_p) # baseMean log2FoldChange lfcSE stat pvalue padj # PCK2 22698.702 -5.653596 0.1854224 -30.49037 3.496861e-204 5.903052e-200 # GRHPR 17379.001 -3.574709 0.1552370 -23.02743 2.476640e-117 2.090408e-113 # KDM8 1614.739 -4.555841 0.1989383 -22.90077 4.564515e-116 2.568453e-112 # CTH 2367.036 -5.254399 0.2324287 -22.60650 3.740448e-113 1.578563e-109 # ADI1 18162.322 -3.714172 0.1659180 -22.38559 5.438272e-111 1.836069e-107 # PBLD 8315.323 -5.683141 0.2593493 -21.91308 1.949637e-106 5.485303e-103 四、关于病人的临床数据与肿瘤分型 1、获取病人的临床数据 如上在GDCprepare()过程中，会自动注释病人样本的临床信息。 我们也可以预先单独下载每个病人的临床数据，以供参考。 方法一：GDCquery() pipeline 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 query \u0026lt;- GDCquery(project = \u0026#34;TCGA-ACC\u0026#34;, data.category = \u0026#34;Clinical\u0026#34;, data.type = \u0026#34;Clinical Supplement\u0026#34;, data.format = \u0026#34;BCR Biotab\u0026#34;) GDCdownload(query, files.per.chunk = 20) clinical.BCRtab.all \u0026lt;- GDCprepare(query) grep(\u0026#34;clinical_\u0026#34;, names(clinical.BCRtab.all), value = T) # [1] \u0026#34;clinical_drug_brca\u0026#34; \u0026#34;clinical_omf_v4.0_brca\u0026#34; # [3] \u0026#34;clinical_follow_up_v4.0_brca\u0026#34; \u0026#34;clinical_follow_up_v1.5_brca\u0026#34; # [5] \u0026#34;clinical_follow_up_v4.0_nte_brca\u0026#34; \u0026#34;clinical_patient_brca\u0026#34; # [7] \u0026#34;clinical_radiation_brca\u0026#34; \u0026#34;clinical_nte_brca\u0026#34; # [9] \u0026#34;clinical_follow_up_v2.1_brca\u0026#34; clinical_patient_brca = as.data.frame(clinical.BCRtab.all$clinical_patient_brca) clinical_patient_brca[1:4,1:4] # bcr_patient_uuid bcr_patient_barcode form_completion_date prospective_collection # 1 bcr_patient_uuid bcr_patient_barcode form_completion_date tissue_prospective_collection_indicator # 2 CDE_ID: CDE_ID:2003301 CDE_ID: CDE_ID:3088492 # 3 6E7D5EC6-A469-467C-B748-237353C23416 TCGA-3C-AAAU 2014-1-13 NO # 4 55262FCB-1B01-4480-B322-36570430C917 TCGA-3C-AALI 2014-7-28 NO 方法二：GDCquery_clinic() 根据官方介绍，这个函数下载的是indexed clinical: a refined clinical data that is created using the XML files(方法一). 这种方法下载速度较快，建议优先使用。如果没有想要的信息，再使用方法一。 1 2 3 4 5 6 7 8 clinical \u0026lt;- GDCquery_clinic(project = \u0026#34;TCGA-BRCA\u0026#34;, type = \u0026#34;clinical\u0026#34;) clinical \u0026lt;- GDCquery_clinic(project = \u0026#34;TCGA-BRCA\u0026#34;, type = \u0026#34;clinical\u0026#34;) clinical[1:4,1:4] # submitter_id synchronous_malignancy ajcc_pathologic_stage tumor_stage # 1 TCGA-E2-A14U No Stage I stage i # 2 TCGA-E9-A1RC No Stage IIIC stage iiic # 3 TCGA-D8-A1J9 No Stage IA stage ia # 4 TCGA-E2-A14P No Stage IIIC stage iiic 2、获取病人的肿瘤分型 PanCancerAtlas_subtypes() The columns “Subtype_Selected” was selected as most prominent subtype classification (from the other columns) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 subtypes \u0026lt;- PanCancerAtlas_subtypes() dim(subtypes) #[1] 7734 10 table(subtypes$cancer.type) # ACC AML BLCA BRCA COAD ESCA GBM HNSC KICH KIRC KIRP LGG LIHC LUAD LUSC OVCA PCPG # 91 187 129 1218 341 169 606 279 66 442 161 516 196 230 178 489 178 # PRAD READ SKCM STAD THCA UCEC UCS # 333 118 333 383 496 538 57 head(as.data.frame(subtypes)) # pan.samplesID cancer.type Subtype_mRNA Subtype_DNAmeth Subtype_protein Subtype_miRNA Subtype_CNA Subtype_Integrative Subtype_other Subtype_Selected # 1 TCGA-OR-A5J1 ACC steroid-phenotype-high+proliferation CIMP-high NA miRNA_1 Quiet COC3 C1A ACC.CIMP-high # 2 TCGA-OR-A5J2 ACC steroid-phenotype-high+proliferation CIMP-low 1 miRNA_1 Noisy COC3 C1A ACC.CIMP-low # 3 TCGA-OR-A5J3 ACC steroid-phenotype-high CIMP-intermediate 3 miRNA_6 Chromosomal COC2 C1A ACC.CIMP-intermediate # 4 TCGA-OR-A5J4 ACC \u0026lt;NA\u0026gt; CIMP-high NA miRNA_6 Chromosomal \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; ACC.CIMP-high # 5 TCGA-OR-A5J5 ACC steroid-phenotype-high CIMP-intermediate NA miRNA_2 Chromosomal COC2 C1A ACC.CIMP-intermediate # 6 TCGA-OR-A5J6 ACC steroid-phenotype-low CIMP-low 2 miRNA_1 Noisy COC1 C1B ACC.CIMP-low TCGAquery_subtype() These subtypes will be automatically added in the summarizedExperiment object through GDCprepare. But you can also use the TCGAquery_subtype function to retrieve this information. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 brca.subtype \u0026lt;- TCGAquery_subtype(tumor = \u0026#34;brca\u0026#34;) t(brca.subtype[1,]) # [,1] # patient \u0026#34;TCGA-3C-AAAU\u0026#34; # Tumor.Type \u0026#34;BRCA\u0026#34; # Included_in_previous_marker_papers \u0026#34;NO\u0026#34; # vital_status \u0026#34;Alive\u0026#34; # days_to_birth \u0026#34;-20211\u0026#34; # days_to_death \u0026#34;NA\u0026#34; # days_to_last_followup \u0026#34;4047\u0026#34; # age_at_initial_pathologic_diagnosis \u0026#34;55\u0026#34; # pathologic_stage \u0026#34;NA\u0026#34; # Tumor_Grade \u0026#34;NA\u0026#34; # BRCA_Pathology \u0026#34;NA\u0026#34; # BRCA_Subtype_PAM50 \u0026#34;LumA\u0026#34; # MSI_status \u0026#34;NA\u0026#34; # HPV_Status \u0026#34;NA\u0026#34; # tobacco_smoking_history \u0026#34;NA\u0026#34; # CNV Clusters \u0026#34;C6\u0026#34; # Mutation Clusters \u0026#34;C7\u0026#34; # DNA.Methylation Clusters \u0026#34;C1\u0026#34; # mRNA Clusters \u0026#34;C1\u0026#34; # miRNA Clusters \u0026#34;C3\u0026#34; # lncRNA Clusters \u0026#34;NA\u0026#34; # Protein Clusters \u0026#34;NA\u0026#34; # PARADIGM Clusters \u0026#34;C5\u0026#34; # Pan-Gyn Clusters \u0026#34;NA\u0026#34; GDCquery_Maf()函数可以支持下载突变数据，这里就暂时不学习了。之后有机会再了解一下。\n补充 1 、TCGA简称对应全称以及中文名 Study Abbreviation Study Name 中文名 ACC Adrenocortical carcinoma 肾上腺皮质癌 BLCA Bladder Urothelial Carcinoma 膀胱尿路上皮癌 BRCA Breast invasive carcinoma 浸润性乳腺癌 CESC Cervical squamous cell carcinoma and endocervical adenocarcinoma 宫颈鳞状细胞癌和宫颈内腺癌 CHOL Cholangiocarcinoma 胆管癌 COAD Colon adenocarcinoma 结肠腺癌 DLBC Lymphoid Neoplasm Diffuse Large B-cell Lymphoma 淋巴样肿瘤弥漫大b细胞淋巴瘤 ESCA Esophageal carcinoma 食管癌癌 GBM Glioblastoma multiforme 多形性成胶质细胞瘤 HNSC Head and Neck squamous cell carcinoma 头颈部鳞状细胞癌 KICH Kidney Chromophobe 肾嫌色细胞癌 KIRC Kidney renal clear cell carcinoma 肾透明细胞癌 KIRP Kidney renal papillary cell carcinoma 肾乳头状细胞癌 LAML Acute Myeloid Leukemia 急性髓系白血病 LGG Brain Lower Grade Glioma 脑低级别胶质瘤 LIHC Liver hepatocellular carcinoma 肝脏肝细胞癌 LUAD Lung adenocarcinoma 肺腺癌 LUSC Lung squamous cell carcinoma 肺鳞癌 MESO Mesothelioma 间皮瘤 OV Ovarian serous cystadenocarcinoma 卵巢浆液性囊腺癌 PAAD Pancreatic adenocarcinoma 胰腺腺癌 PCPG Pheochromocytoma and Paraganglioma 嗜铬细胞瘤和副神经节瘤 PRAD Prostate adenocarcinoma 前列腺腺癌 READ Rectum adenocarcinoma 直肠腺癌 SARC Sarcoma 肉瘤 SKCM Skin Cutaneous Melanoma 皮肤皮肤黑色素瘤 STAD Stomach adenocarcinoma 胃腺癌 TGCT Testicular Germ Cell Tumors 睾丸生殖细胞肿瘤 THCA Thyroid carcinoma 甲状腺癌 THYM Thymoma 胸腺瘤 UCEC Uterine Corpus Endometrial Carcinoma 子宫内膜癌 UCS Uterine Carcinosarcoma 子宫癌肉瘤 UVM Uveal Melanoma 葡萄膜黑色素瘤 2 、GDC所有数据类型 2.1 GDC harmonized database Data.category Data.type Workflow.Type Platform Transcriptome Profiling Gene Expression Quantification HTSeq - Counts Transcriptome Profiling Gene Expression Quantification HTSeq - FPKM Transcriptome Profiling Gene Expression Quantification HTSeq - FPKM-UQ Transcriptome Profiling Gene Expression Quantification STAR - Counts Transcriptome Profiling Isoform Expression Quantification - Transcriptome Profiling miRNA Expression Quantification - Transcriptome Profiling Splice Junction Quantification Copy number variation Copy Number Segment Copy number variation Masked Copy Number Segment Copy number variation Gene Level Copy Number Scores Simple Nucleotide Variation Masked Somatic Mutation MuSE Variant Aggregation and Masking Simple Nucleotide Variation Masked Somatic Mutation MuTect2 Variant Aggregation and Masking Simple Nucleotide Variation Masked Somatic Mutation SomaticSniper Variant Aggregation and Masking Simple Nucleotide Variation Masked Somatic Mutation VarScan2 Variant Aggregation and Masking Raw Sequencing Data - Biospecimen Slide Image Biospecimen Biospecimen Supplement Clinical - DNA Methylation Methylation Beta Value Illumina Human Methylation 450 DNA Methylation Methylation Beta Value Illumina Human Methylation 27 2.2 GDC Legacy Archive Data.category Data.type Platform file.type Copy number variation - Affymetrix SNP Array 6.0 nocnv_hg18.seg Copy number variation - Affymetrix SNP Array 6.0 hg18.seg Copy number variation - Affymetrix SNP Array 6.0 nocnv_hg19.seg Copy number variation - Affymetrix SNP Array 6.0 hg19.seg Copy number variation - Illumina HiSeq - Simple nucleotide variation Simple somatic mutation Raw sequencing data Biospecimen Clinical Protein expression MDA RPPA Core - Gene expression Gene expression quantification Illumina HiSeq normalized_results Gene expression Gene expression quantification Illumina HiSeq results Gene expression Gene expression quantification HT_HG-U133A - Gene expression Gene expression quantification AgilentG4502A_07_2 - Gene expression Gene expression quantification AgilentG4502A_07_1 - Gene expression Gene expression quantification HuEx-1_0-st-v2 FIRMA.txt Gene expression Gene expression quantification gene.txt Gene expression Isoform expression quantification - - Gene expression miRNA gene quantification - hg19.mirna Gene expression miRNA gene quantification hg19.mirbase20 Gene expression miRNA gene quantification mirna Gene expression Exon junction quantification - - Gene expression Exon quantification - - Gene expression miRNA isoform quantification - hg19.isoform Gene expression miRNA isoform quantification - isoform DNA methylation Illumina Human Methylation 450 Not used DNA methylation Illumina Human Methylation 27 Not used DNA methylation Illumina DNA Methylation OMA003 CPI Not used DNA methylation Illumina DNA Methylation OMA002 CPI Not used DNA methylation Illumina Hi Seq DNA methylation Bisulfite sequence alignment DNA methylation Methylation percentage DNA methylation Aligned reads Raw microarray data Raw intensities Illumina Human Methylation 450 idat Raw Microarray Data Raw intensities Illumina Human Methylation 27 idat Structural Rearrangement Other ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/046tcgabiolinks%E5%8C%85-tcga%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90/","summary":"\u003cp\u003e\u003ccode\u003eTCGAbiolinks\u003c/code\u003e包是一站式分析TCGA数据的R包工具，它集成了TCGA数据下载、分析、可视化的全部流程。此次系列笔记主要跟着 TCGAbiolinks帮助文档重新学习下TCGA数据挖掘流程。\u003c/p\u003e","title":"TCGAbiolinks包-TCGA数据下载与差异分析"},{"content":"1、计算公式 sample 1 sample 2 \u0026hellip;\u0026hellip;.. sample k Gene 1 10 12 30 Gene 2 20 25 60 \u0026hellip;\u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; \u0026hellip; Gene n 0 0 \u0026hellip; 1 对于(n*k)表达矩阵中k个样本的n个基因的count表达数据。\n在任意样本（列）中，基因i的长度为l，count表达值为q；则基因i的FPKM与TPM标准化方式计算如下\n$$ \\begin{align} \u0026amp; FPKM_i = \\frac{\\frac{q_i}{l_i/10^3}}{\\sum_{j=1}^nq_j/10^6} = \\frac{\\frac{q_i}{l_i}}{{\\sum_{j=1}^nq_j}}*10^9 \\tag{1} \\ \\ \u0026amp; TPM_i = \\frac{\\frac{q_i}{l_i/10^3}}{\\sum_{j=1}^n(\\frac{q_j}{l_j/10^3})/10^6} = \\frac{\\frac{q_i}{l_i}}{\\sum_{j=1}^n(\\frac{q_j}{l_j})} * 10^6 \\tag{2}\n\\end{align} $$\nFPKM : fragments per kilobase of exon per million mapped fragments. TPM：transcript per million, and the sum of all TPM values is the same in all samples. 2、基因长度 2.1 gtf注释外显子之和 参考https://www.biostars.org/p/456800/，计算基因的所有外显子长度之和作为基因长度。 基因以及对应外显子坐标信息来自基因组注释文件gtf，下载方式参考之前Refgenie笔记。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 library(GenomicFeatures) #如下选取的是hg19版本的注释基因组文件 txdb \u0026lt;- makeTxDbFromGFF(\u0026#34;gencode.v32lift37.annotation.gtf\u0026#34;,format=\u0026#34;gtf\u0026#34;) exons_per_gene \u0026lt;- exonsBy(txdb,by=\u0026#34;gene\u0026#34;) gene_len_from_exon \u0026lt;- as.data.frame(sum(width(reduce(exons_per_gene)))) colnames(gene_len_from_exon)[1] = \u0026#34;length\u0026#34; gene_len_from_exon$ENSEMBL = str_split(rownames(gene_len_from_exon),\u0026#34;[.]\u0026#34;, simplify = T)[,1] head(gene_len_from_exon) # length ENSEMBL # ENSG00000000003.15_3 4536 ENSG00000000003 # ENSG00000000005.6_3 1476 ENSG00000000005 # ENSG00000000419.12_4 1207 ENSG00000000419 ##接下来将基因ENSEMBL名转为Symbol格式 gene_ids\u0026lt;-AnnotationDbi::select(org.Hs.eg.db, keys=gene_len_from_exon$ENSEMBL, columns=\u0026#34;SYMBOL\u0026#34;, #目标格式 keytype=\u0026#34;ENSEMBL\u0026#34;) #目前的格式 gene_ids = gene_ids %\u0026gt;% dplyr::distinct(ENSEMBL, .keep_all = T) %\u0026gt;% na.omit() gene_len = dplyr::left_join(gene_len_from_exon, gene_ids) %\u0026gt;% dplyr::distinct(ENSEMBL, .keep_all = T) %\u0026gt;% dplyr::distinct(SYMBOL, .keep_all = T) dim(gene_len) # [1] 34102 3 head(gene_len) # length ENSEMBL SYMBOL # 1 4536 ENSG00000000003 TSPAN6 # 2 1476 ENSG00000000005 TNMD # 3 1207 ENSG00000000419 DPM1 2.2 TCGAbiolinks包内置的基因长度信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ##(1) hg19 geneInfo_hg19 = TCGAbiolinks::geneInfo %\u0026gt;% na.omit() %\u0026gt;% as.data.frame() head(geneInfo_hg19) ##(1) hg38 geneInfo_hg38 = TCGAbiolinks::geneInfoHT %\u0026gt;% tibble::rownames_to_column(\u0026#34;ENSEMBL\u0026#34;) library(org.Hs.eg.db) gene_ids = AnnotationDbi::select(org.Hs.eg.db, keys=geneInfo_hg38$ENSEMBL, columns=c(\u0026#34;SYMBOL\u0026#34;), #目标格式 keytype=\u0026#34;ENSEMBL\u0026#34;) #目前的格式 gene_ids = gene_ids %\u0026gt;% distinct(ENSEMBL, .keep_all = T) %\u0026gt;% distinct(SYMBOL, .keep_all = T) %\u0026gt;% na.omit() head(gene_ids) geneInfo_hg38 = dplyr::inner_join(geneInfo_hg38, gene_ids) %\u0026gt;% tibble::column_to_rownames(\u0026#34;SYMBOL\u0026#34;) head(geneInfo_hg38) 3、定义函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ##(1) counts_to_tpm counts_to_tpm \u0026lt;- function(counts, geneLength) { # Process one column at a time. tpm \u0026lt;- do.call(cbind, lapply(1:ncol(counts), function(i) { # log的减法相当于除法：每一列（单个样本的count）/对应基因的长度 rate = log(counts[,i]) - log(geneLength) #上一步更新后的新的细胞文库大小 denom = log(sum(exp(rate))) #按照细胞文库标准化 exp(rate - denom + log(1e6)) })) colnames(tpm) \u0026lt;- colnames(counts) rownames(tpm) \u0026lt;- rownames(counts) return(tpm) } ##(2) counts_to_fpkm counts_to_fpkm \u0026lt;- function(counts, geneLength) { fpkm \u0026lt;- do.call(cbind, lapply(1:ncol(counts), function(i) { N \u0026lt;- sum(counts[,i]) exp(log(counts[,i]) - log(geneLength) - log(N) + log(1e9)) })) colnames(fpkm) \u0026lt;- colnames(counts) rownames(fpkm) \u0026lt;- rownames(counts) return(fpkm) } ##(3) fpkm_to_Tpm fpkm_to_tpm \u0026lt;- function(fpkm) { exp(log(fpkm) - log(colsum(fpkm)) + log(1e6)) } 4、示例分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ##(1)基因表达矩阵 exp_count = fread(\u0026#34;GEO/GSE81861_CRC_NM_all_cells_COUNT.csv.gz\u0026#34;,data.table = F) %\u0026gt;% dplyr::mutate(gene=str_split(V1,\u0026#34;_\u0026#34;,simplify = T)[,2]) %\u0026gt;% dplyr::distinct(gene, .keep_all = T) %\u0026gt;% tibble::column_to_rownames(\u0026#34;gene\u0026#34;) %\u0026gt;% dplyr::select(!V1) %\u0026gt;% dplyr::filter(rownames(.) %in% gene_len$SYMBOL) dim(exp_count) # [1] 26258 266 exp_count[1:4,1:4] # RHC3934__Bcell__.7DEA7B RHC3944__Bcell__.7DEA7B RHC3962__Tcell__.C6E879 RHC4003__Bcell__.7DEA7B # TSPAN6 0 0 0 0 # TNMD 0 0 0 0 # DPM1 0 0 0 0 # SCYL3 0 0 0 1 ##(2)基因长度 gene_len_sub = gene_len[match(rownames(exp_count),gene_len$SYMBOL), ] gene_len_sub = data.frame(length=gene_len_sub$length, row.names = gene_len_sub$SYMBOL) head(gene_len_sub) # length # TSPAN6 4536 # TNMD 1476 # DPM1 1207 identical(rownames(exp_count), rownames(gene_len_sub)) #[1] TRUE ##(3) count 2 TPM exp_tpm = counts_to_tpm(exp_count, gene_len_sub) ##(4) count 2 FPKM exp_fpkm = counts_to_fpkm(exp_count, gene_len_sub) ##(5) fpkm 2 tpm exp_tpm2 = as.data.frame(apply(exp_fpkm, 2, fpkm_to_tpm)) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/047%E8%A1%A8%E8%BE%BE%E7%9F%A9%E9%98%B5tpmfpkm%E6%A0%87%E5%87%86%E5%8C%96/","summary":"\u003ch1 id=\"1计算公式\"\u003e1、计算公式\u003c/h1\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth style=\"text-align: center\"\u003e\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003esample 1\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003esample 2\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003e\u0026hellip;\u0026hellip;..\u003c/th\u003e\n          \u003cth style=\"text-align: center\"\u003esample k\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eGene 1\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e10\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e12\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e30\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eGene 2\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e20\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e25\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e60\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u0026hellip;\u0026hellip;\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u0026hellip;\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u0026hellip;\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u0026hellip;\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u0026hellip;\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd style=\"text-align: center\"\u003eGene n\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e0\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e0\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e\u0026hellip;\u003c/td\u003e\n          \u003ctd style=\"text-align: center\"\u003e1\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e对于(n*k)表达矩阵中k个样本的n个基因的count表达数据。\u003c/p\u003e\n\u003cp\u003e在任意样本（列）中，基因i的长度为\u003ccode\u003el\u003c/code\u003e，count表达值为\u003ccode\u003eq\u003c/code\u003e；则基因i的FPKM与TPM标准化方式计算如下\u003c/p\u003e","title":"表达矩阵TPM,FPKM标准化"},{"content":" 挖掘GEO数据时，主要一方面是下载GEO的测序数据（包括基因芯片array与RNAseq两类）的表达矩阵。同时会涉及到一些细节问题，例如array芯片ID转换、样本meta信息等。\n1、下载GEO数据 主要使用GEOquery包下载\n1.1 array芯片数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #BiocManager::install(\u0026#34;GEOquery\u0026#34;) library(GEOquery) gse = getGEO(\u0026#39;GSE70213\u0026#39;, getGPL = F) if(length(gse)==1) gse = gse[[1]] # [1] \u0026#34;ExpressionSet\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;Biobase\u0026#34; ##(1) 表达矩阵 exp_dat = exprs(gse) %\u0026gt;% as.data.frame() # GSM1720833 GSM1720834 GSM1720835 GSM1720836 # 10338001 2041.40800 2200.86100 2323.7600 3216.26300 # 10338002 63.78059 65.08438 58.3082 75.86145 # 10338003 635.39040 687.39360 756.0040 1181.92900 # 10338004 251.56680 316.99730 320.5132 592.80600 ##(2) 样本信息 meta = pData(gse) %\u0026gt;% dplyr::select(title, dplyr::ends_with(\u0026#34;ch1\u0026#34;)) colnames(meta)=gsub(\u0026#34;[:_]ch1\u0026#34;, \u0026#34;\u0026#34;, colnames(meta)) head(meta[,1:3]) # title source_name organism # GSM1720833 quad-control-1 quadriceps muscle Mus musculus # GSM1720834 quad-control-2 quadriceps muscle Mus musculus # GSM1720835 quad-control-3 quadriceps muscle Mus musculus # GSM1720836 quad-control-4 quadriceps muscle Mus musculus # GSM1720837 quad-control-5 quadriceps muscle Mus musculus # GSM1720838 quad-control-6 quadriceps muscle Mus musculus ##(3)下载Supplementary file gse@experimentData@other$supplementary_file # [1] \u0026#34;ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE70nnn/GSE70213/suppl/GSE70213_RAW.tar\u0026#34; 获得表达矩阵的候选方法：在GEO网页Download family中手动下载，然后导入到R中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ##(1) SOFT formatted family file(s) geo_soft = getGEO(filename = \u0026#34;GSE70213_family.soft\u0026#34;) geo_soft@header #类似上面的gse@experimentData geo_soft@gsms #每个样本的信息、表达数据 geo_soft@gpls #GPL注释信息 #生成表达矩阵 probesets \u0026lt;- Table(GPLList(geo_soft)[[1]])$ID exp_dat2 \u0026lt;- do.call(\u0026#39;cbind\u0026#39;, lapply(geo_soft@gsms,function(x){ tab \u0026lt;- Table(x) mymatch \u0026lt;- match(probesets,tab$ID_REF) return(tab$VALUE[mymatch]) })) rownames(exp_dat2)=probesets exp_dat2[1:4,1:4] ##(2) Series Matrix File(s) series_mt = read.table(\u0026#34;GSE70213_series_matrix.txt.gz\u0026#34;, comment.char = \u0026#34;!\u0026#34;) #或者查看一下注释的行数 series_mt = data.table::fread(\u0026#34;GSE70213_series_matrix.txt.gz\u0026#34;,skip = 65,data.table = F) ##(3) cel格式转换，芯片原始数据一般放在Supplementary file中 library(oligo) CELs = read.celfiles(list.files(\u0026#34;GSE70213_RAW/\u0026#34;, full.names = T)) expreset = rma(CELs, normalize=F) exp_dat3 = exprs(expreset) exp_dat3[1:4,1:4] colnames(exp_dat3) = stringr::str_split(colnames(exp_dat3), \u0026#34;_\u0026#34;, simplify = T)[,1] 1.3 RNAseq测序数据 1 2 3 4 5 6 7 8 9 10 11 12 13 ##(1) 样本信息 gse = getGEO(\u0026#39;GSE87809\u0026#39;, getGPL = F) if(length(gse)==1) gse = gse[[1]] meta = pData(gse) %\u0026gt;% dplyr::select(title, dplyr::ends_with(\u0026#34;ch1\u0026#34;)) colnames(meta)=gsub(\u0026#34;[:_]ch1\u0026#34;, \u0026#34;\u0026#34;, colnames(meta)) head(meta[,1:3]) ##(2) 表达矩阵：因为是RNAseq数据，需要在Series Matrix File(s)或者附件材料里下载。方法同上。 gse@experimentData@other$supplementary_file # [1] \u0026#34;ftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE87nnn/GSE87809/suppl/GSE87809_endometriosis_RNA_seq_FPKM.txt.gz\u0026#34; 2、注释芯片ID 如下一般得到的表达矩阵的基因名还是芯片ID，需要进一步转为基因名。\n首先需要下载GPL注释信息，然后整理好对应芯片ID与基因名的关系。根据芯片ID的复杂，可分为若干种情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 gse = getGEO(\u0026#39;GSE70213\u0026#39;, getGPL = F) if(length(gse)==1) gse = gse[[1]] # [1] \u0026#34;ExpressionSet\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;Biobase\u0026#34; ##表达矩阵 exp_dat = exprs(gse) %\u0026gt;% as.data.frame() # GSM1720833 GSM1720834 GSM1720835 GSM1720836 # 10338001 2041.40800 2200.86100 2323.7600 3216.26300 # 10338002 63.78059 65.08438 58.3082 75.86145 # 10338003 635.39040 687.39360 756.0040 1181.92900 # 10338004 251.56680 316.99730 320.5132 592.80600 ##获取GPL平台 gse@annotation # [1] \u0026#34;GPL6246\u0026#34; ##下载GPL注释信息 GPL=getGEO(\u0026#34;GPL6246\u0026#34;) GPL@dataTable@table[1:4,] dim(GPL@dataTable@table) # [1] 35557 12 查看下载得到的GPL注释信息，可分为如下几种情况\n2.1 直接注释有Symbol基因名 以GPL96为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 GPL=getGEO(\u0026#34;GPL96\u0026#34;) anno=GPL@dataTable@table colnames(anno) #一般probe ID都在第一列 probe2symbol=anno[,c(1,grep(\u0026#34;symbol\u0026#34;,colnames(anno),ignore.case = T))] head(probe2symbol) # ID Gene Symbol #1 1007_s_at DDR1 /// MIR4640 #2 1053_at RFC2 #3 117_at HSPA6 #4 121_at PAX8 #5 1255_g_at GUCA1A #6 1294_at MIR5193 /// UBA7 colnames(probe2symbol)=c(\u0026#34;ID\u0026#34;,\u0026#34;Symbol\u0026#34;) 进一步修饰整理 1 2 3 4 5 6 7 8 9 10 #去掉未匹配到的情况 probe2symbol=probe2symbol[!(probe2symbol[,2] %in% c(\u0026#34;\u0026#34;,NA,\u0026#34;---\u0026#34;)),] #针对一个探针匹配到多种gene的情况 tmp=unlist(lapply(1:nrow(probe2symbol),function(i){ gene=trimws(unlist(strsplit(probe2symbol[,2][i],\u0026#34;//*\u0026#34;))) names(gene)=rep(probe2symbol[,1][i],length(gene)) return(gene) })) probe2symbol=data.frame(ID=names(tmp),Symbol=tmp) 2.2 注释有其它格式基因名 这种情况需要知道不同格式基因名转换的方法，以下举了两个例子。\n（1）提供的是ENTREZ_GENE_ID 格式\n例如平台GPL17889 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 library(org.Hs.eg.db) keytypes(org.Hs.eg.db) GPL=getGEO(\u0026#34;GPL17889\u0026#34;) anno=GPL@dataTable@table anno[,2]=as.character(anno[,2]) #因为ENTREZID是纯数字组成，需要转为字符型 gene_bridge\u0026lt;-AnnotationDbi::select(org.Hs.eg.db, keys=anno[,2], columns=c(\u0026#34;SYMBOL\u0026#34;), #目标格式 keytype=\u0026#34;ENTREZID\u0026#34;) #当前格式 probe2symbol=dplyr::left_join(anno, gene_bridge, by=c(\u0026#34;ORF\u0026#34;=\u0026#34;ENTREZID\u0026#34;)) head(probe2symbol) # ID ORF SYMBOL # 1 1_at 1 A1BG # 2 10_at 10 NAT2 # 3 100_at 100 ADA # 4 1000_at 1000 CDH2 # 5 10000_at 10000 AKT3 # 6 100009613_at 100009613 LINC02584 probe2symbol=probe2symbol[,-2] colnames(probe2symbol)=c(\u0026#34;ID\u0026#34;,\u0026#34;Symbol\u0026#34;) （2）提供的是NCBI Accession Number格式\n例如平台GPL16686，类似NR_046018、NM_152486、AA972198、BX101169格式 同样利用org.Hs.eg.db包转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 GPL=getGEO(\u0026#34;GPL16686\u0026#34;) anno=GPL@dataTable@table probe2symbol=anno[,c(1,6)] probe2symbol=probe2symbol[probe2symbol[,2]!=\u0026#34;\u0026#34;,] gene_bridge=AnnotationDbi::select(org.Hs.eg.db, keys=probe2symbol[,2], columns=c(\u0026#34;SYMBOL\u0026#34;), #目标格式 keytype=\u0026#34;ACCNUM\u0026#34;) #当前格式 probe2symbol=dplyr::left_join(probe2symbol,gene_bridge,by=c(\u0026#34;GB_ACC\u0026#34;=\u0026#34;ACCNUM\u0026#34;)) # ID GB_ACC SYMBOL # 1 16657436 NR_046018 DDX11L1 # 2 16657450 NR_024368 LINC01000 # 3 16657450 NR_024368 LINC01000 # 4 16657450 NR_024368 LINC01000 # 5 16657476 NR_029406 RPL23AP87 # 6 16657476 NR_029406 RPL23AP87 probe2symbol=probe2symbol[,-2] colnames(probe2symbol)=c(\u0026#34;ID\u0026#34;,\u0026#34;Symbol\u0026#34;) probe2symbol=probe2symbol[!(probe2symbol[,2] %in% c(\u0026#34;\u0026#34;,NA,\u0026#34;---\u0026#34;)),] 2.3 gene_assignment的特殊注释 例如GPL6244，如下图解释(可以看到也可以是用GB_list进行基因ID转换) 可以看到当一个探针匹配到多个基因时，是用///分隔；用//分隔同一基因的不同角度注释，其中Symbol ID一般位于第二条信息。需要用一些R语言技巧提取出来。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 GPL=getGEO(\u0026#34;GPL6244\u0026#34;) anno=GPL@dataTable@table anno=anno[anno[,\u0026#34;gene_assignment\u0026#34;]!=\u0026#34;---\u0026#34;,] tmp=unlist(lapply(1:nrow(anno),function(i){ tmp1=strsplit(anno[,\u0026#34;gene_assignment\u0026#34;][i],\u0026#34;///\u0026#34;) #1个探针对多个基因的拆分 tmp2=unique(trimws(stringr::str_split(unlist(tmp1),\u0026#34;//\u0026#34;,simplify = T)[,2])) #提取第二个symbol ID names(tmp2)=rep(anno[,1][i],length(tmp2)) return(tmp2) })) probe2symbol=data.frame(ID=names(tmp),Symbol=tmp) # ID Symbol # 1 7896738 OR4G2P # 2 7896738 OR4G11P # 3 7896738 OR4G1P # 4 7896740 OR4F4 # 5 7896740 OR4F17 # 6 7896740 OR4F5 2.4 AnnoProbe包 AnnoProbe是生信技能树曾老师团队写的一个包，整理有常见芯片平台与基因名的对应关系。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #devtools::install_github(\u0026#34;jmzeng1314/AnnoProbe\u0026#34;) library(AnnoProbe) AnnoProbe::getGPLList() %\u0026gt;% dim() # [1] 185 2 AnnoProbe::idmap(gpl = \u0026#34;GPL570\u0026#34;) %\u0026gt;% head() # trying URL \u0026#39;http://49.235.27.111/GEOmirror/GPL/GPL570_bioc.rda\u0026#39; # Content type \u0026#39;application/octet-stream\u0026#39; length 264292 bytes (258 KB) # downloaded 258 KB # # file downloaded in C:/Users/xiaoxin/Desktop/GEOquery # probe_id symbol # 193731 1053_at RFC2 # 193732 117_at HSPA6 # 193733 121_at PAX8 # 193734 1255_g_at GUCA1A # 193735 1316_at THRA # 193736 1320_at PTPN21 Plus：GEO搜索方式 1 2 3 4 5 6 7 8 9 10 11 # https://www.ncbi.nlm.nih.gov/gds \u0026#34;blood\u0026#34;[All Fields] AND \u0026#34;Homo Sapiens\u0026#34;[porgn] AND (\u0026#34;Alzheimer\u0026#34;[All Fields]) AND (\u0026#34;gds\u0026#34;[Filter] OR \u0026#34;gse\u0026#34;[Filter] OR \u0026#34;gsm\u0026#34;[Filter]) AND (\u0026#34;Expression profiling by array\u0026#34;[Filter] OR \u0026#34;Expression profiling by high throughput sequencing\u0026#34;[Filter]) # \u0026#34;Homo Sapiens\u0026#34;[porgn] AND # \u0026#34;blood\u0026#34;[All Fields] AND ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/048%E4%BB%8Egeo%E4%B8%8B%E8%BD%BD%E8%8A%AF%E7%89%87%E6%88%96rnaseq%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AE/","summary":"\u003cblockquote\u003e\n\u003cp\u003e挖掘GEO数据时，主要一方面是下载GEO的测序数据（包括基因芯片array与RNAseq两类）的表达矩阵。同时会涉及到一些细节问题，例如array芯片ID转换、样本meta信息等。\u003c/p\u003e","title":"从GEO下载芯片或RNAseq测序数据"},{"content":"1、准备conda环境与软件 1 2 3 4 5 6 7 8 # 准备download环境 conda create -n download conda activate download # 安装软件 conda install -c hcc aspera-cli conda install -c bioconda sra-tools conda install -c conda-forge pigz 以SRR13911909为例 2、aspera下载 https://www.ebi.ac.uk/ena/browser/view/SRR13911909 2.1 下载链接 1 2 3 4 5 # era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR139/009/SRR13911909/SRR13911909_1.fastq.gz # era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR139/009/SRR13911909/SRR13911909_2.fastq.gz # 观察上述链接规律后，可以自动生成下载链接 era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/00${id:0-1}/${id}/${id}_1.fastq.gz era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/00${id:0-1}/${id}/${id}_2.fastq.gz 2.2 aspera下载 1 2 3 4 5 6 7 8 9 10 11 12 13 id=SRR13911909 ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/download/etc/asperaweb_id_dsa.openssh \\ era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/00${id:0-1}/${id}/${id}_1.fastq.gz . ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/download/etc/asperaweb_id_dsa.openssh \\ era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/00${id:0-1}/${id}/${id}_2.fastq.gz . #最后一个点表示下载文件的储存路径 #如果是其它环境，将download替换为对应环境名即可 #如果是base环境： ~/miniconda3/etc/asperaweb_id_dsa.openssh 使用aspera可以达到百兆的速度，建议首先尝试。但最近试了几次，容易报错，不稳定(报错内容如下)；有时候可以。\n1 2 # ascp: failed to authenticate, exiting. # Session Stop (Error: failed to authenticate) 如上图所示，虽然ebi网站也提供了fastq.gz的ftp链接。但经过尝试后，不建议使用。因为下载不稳定，容易中断(网速极慢)。尽管wget支持断点续传，但是会出现部分序列丢失情况，导致后续步骤报错。当aspera方法暂时不能使用时，建议使用下面介绍的prefetch方法。\n2.3 prefetch下载 先下载.sra文件 1 2 3 4 5 id=SRR13911909 # -p 显示进程 # -X 允许下载的文件内存上限 # -O 下载文件的储存路径 prefetch -p -X 35G ${id} -O . 再拆分为fastq.gz文件 1 2 3 4 5 6 7 8 9 10 fasterq-dump --split-files ${id} -p -O ./ # pigz多线程压缩 ls *fastq | while read id do pigz -v $id done # 删除sra文件 rm -rf ${id} ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/049%E4%B8%8B%E8%BD%BD%E6%B5%8B%E5%BA%8F%E6%95%B0%E6%8D%AEsrr%E4%B8%8Efastq.gz%E6%96%B9%E5%BC%8F/","summary":"\u003ch1 id=\"1准备conda环境与软件\"\u003e1、准备conda环境与软件\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 准备download环境\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econda create -n download \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econda activate download\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 安装软件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econda install -c hcc aspera-cli\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econda install -c bioconda sra-tools\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econda install -c conda-forge pigz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e以SRR13911909为例\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"2aspera下载\"\u003e2、aspera下载\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.ebi.ac.uk/ena/browser/view/SRR13911909\"\u003ehttps://www.ebi.ac.uk/ena/browser/view/SRR13911909\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"21-下载链接\"\u003e2.1 下载链接\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR139/009/SRR13911909/SRR13911909_1.fastq.gz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR139/009/SRR13911909/SRR13911909_2.fastq.gz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 观察上述链接规律后，可以自动生成下载链接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eera-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0:6\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/00\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0-1\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e_1.fastq.gz\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eera-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0:6\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/00\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0-1\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e_2.fastq.gz \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"22-aspera下载\"\u003e2.2 aspera下载\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eid=SRR13911909\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eascp -QT -l 300m -P33001  \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u003c/span\u003e-i ~/miniconda3/envs/download/etc/asperaweb_id_dsa.openssh   \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u003c/span\u003eera-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0:6\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/00\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0-1\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e_1.fastq.gz  .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eascp -QT -l 300m -P33001  \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u003c/span\u003e-i ~/miniconda3/envs/download/etc/asperaweb_id_dsa.openssh   \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u003c/span\u003eera-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0:6\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/00\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid:0-1\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e/\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003eid\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e_2.fastq.gz  .\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#最后一个点表示下载文件的储存路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#如果是其它环境，将download替换为对应环境名即可\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#如果是base环境： ~/miniconda3/etc/asperaweb_id_dsa.openssh\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e使用aspera可以达到百兆的速度，建议首先尝试。但最近试了几次，容易报错，不稳定(报错内容如下)；有时候可以。\u003c/p\u003e","title":"下载测序数据SRR与fastq.gz方式"},{"content":"shell Ctrl + a : 将光标移到本行的开始处\nCtrl + e : 将光标移到本行的末尾处\nBacksapce : 删除前一个字符\nCtrl + d : 删除后一个字符\nCtrl + k : 从光标开始剪切至行的末尾\nCtrl + y : 从行的开头剪切光标处\nCtrl + u : 粘贴之前剪切的内容\nCtrl + r : 搜索历史命令，仅支持关键字搜索。若存在多个匹配结果，可再次Ctrl + r可返回其它匹配结果的历史命令。使用方向键→可将当前显示的命令移到命令行处。\n","permalink":"https://lishensuo.github.io/en/posts/program/050%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%B3%BB%E5%88%97/","summary":"\u003ch2 id=\"shell\"\u003eshell\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eCtrl + a\u003c/code\u003e : 将光标移到本行的开始处\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCtrl + e\u003c/code\u003e : 将光标移到本行的末尾处\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eBacksapce\u003c/code\u003e : 删除前一个字符\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCtrl + d\u003c/code\u003e : 删除后一个字符\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCtrl + k\u003c/code\u003e : 从光标开始剪切至行的末尾\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eCtrl + y\u003c/code\u003e : 从行的开头剪切光标处\u003c/p\u003e","title":"050快捷键"},{"content":"refgenie：参考基因组（阿拉丁）商店 http://refgenie.databio.org/ Here we provide a web interface and a RESTful API to access genome assets for popular reference genome assemblies.\n该平台由位于弗吉尼亚大学公共卫生基因组学中心的计算生物学和生物信息学研究小组(Sheffield lab of computational biology)建立。上次修改/更新是2021年11月。\nrefgenie提供了人、鼠等常见物种的参考基因组以及注释文件等信息(fasta、gtf\u0026hellip;)以及常用fastq比对工具的（star、hisat2\u0026hellip;）索引文件。(如下图所示)\nrefgenie不仅提供了网站点击下载方式，也可以通过linux命令行的方式，下载并且管理我们的参考数据，在下载以及使用中大大提高了效率。以下简单总结下，基于命令行的下载、管理refgenie参考数据的用法。 1、安装 1 2 3 pip install --user refgenie #or conda install refgenie 2、准备 1 2 3 4 5 6 7 8 9 mkdir ~/refgenie refgenie init -c ~/refgenie/genome_config.yaml #之后下载的数据基本都要使用 -c参数 用于指定genome_config.yaml文件路径 #列出所有的genome/asset refgenie listr -c ~/refgenie/genome_config.yaml #列出指定物种类型的所有数据类型(如下代码块所示) refgenie listr -g hg38 -c ~/refgenie/genome_config.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 Remote refgenie assets Server URL: http://refgenomes.databio.org ┏━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━┓ ┃ genome ┃ asset (seek_keys) ┃ tags ┃ ┡━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━┩ │ hg38 │ fasta (fasta, fai, chrom_sizes, dir) │ default │ │ hg38 │ gencode_gtf (gencode_gtf, dir) │ default │ │ hg38 │ refgene_anno (refgene_anno, refgene_tss, refgene_exon, refgene_intron, │ default │ │ │ refgene_pre_mRNA, dir) │ │ │ hg38 │ dbsnp (dbsnp, tabix, dir) │ default │ │ hg38 │ ensembl_gtf (ensembl_gtf, ensembl_tss, ensembl_gene_body, dir) │ default │ │ hg38 │ ensembl_rb (ensembl_rb, dir) │ default │ │ hg38 │ suffixerator_index (esa, dir) │ default │ │ hg38 │ bwa_index (bwa_index, dir) │ default │ │ hg38 │ bowtie2_index (bowtie2_index, dir) │ default │ │ hg38 │ dbnsfp (dbnsfp, tabix, dir) │ default │ │ hg38 │ star_index (star_index, dir) │ default │ │ hg38 │ fasta_txome (fasta_txome, fai, chrom_sizes, dir) │ default │ │ hg38 │ hisat2_index (hisat2_index, dir) │ default │ │ hg38 │ cellranger_reference (cellranger_reference, dir) │ default │ │ hg38 │ bismark_bt2_index (bismark_bt2_index, dir) │ default │ │ hg38 │ salmon_partial_sa_index (salmon_partial_sa_index, dir) │ default │ │ hg38 │ tgMap (tgMap, dir) │ default │ │ hg38 │ salmon_sa_index (salmon_sa_index, dir) │ default │ └────────┴─────────────────────────────────────────────────────────────────────────┴───────── 3、pull下载指定的genome/asset 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #下载hg38版本的fasta文件 refgenie pull hg38/fasta -c ~/refgenie/genome_config.yaml #下载hg38版本的gtf文件 refgenie pull hg38/gencode_gtf -c ~/refgenie/genome_config.yaml #下载hg38版本的salmon软件的索引文件 refgenie pull hg38_cdna/salmon_index -c ~/refgenie/genome_config.yaml #列出本地已经下载的参考数据 refgenie list -c ~/refgenie/genome_config.yaml refgenie list -g hg38 -c ~/refgenie/genome_config.yaml #返回已经下载的genome/asset的路径，这在批量化的脚本文件中十分有用 echo $(refgenie seek hg38/fasta -c ~/refgenie/genome_config.yaml) # /home/ssli/refgenie/alias/hg38/fasta/default/hg38.fa head $(refgenie seek hg38/fasta -c ~/refgenie/genome_config.yaml) # \u0026gt;chr1 AC:CM000663.2 gi:568336023 LN:248956422 rl:Chromosome M5:6aef897c3d6ff0c78aff06ac189178dd AS:GRCh38 # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN # NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN refgenie还可以建立比对索引文件等功能，详见帮助文档：http://refgenie.databio.org/en/latest/\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/050refgenie%E4%B8%8B%E8%BD%BD%E5%8F%82%E8%80%83%E5%9F%BA%E5%9B%A0%E7%BB%84/","summary":"\u003ch1 id=\"refgenie参考基因组阿拉丁商店\"\u003erefgenie：参考基因组（阿拉丁）商店\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"http://refgenie.databio.org/\"\u003ehttp://refgenie.databio.org/\u003c/a\u003e\n\u003cem\u003eHere we provide a web interface and a RESTful API to access genome assets for popular reference genome assemblies.\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://upload-images.jianshu.io/upload_images/20354525-4a88fd7f5b351d03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e该平台由位于弗吉尼亚大学公共卫生基因组学中心的计算生物学和生物信息学研究小组(Sheffield lab of computational biology)建立。上次修改/更新是2021年11月。\u003c/p\u003e","title":"Refgenie下载参考基因组"},{"content":" 1 2 3 4 5 if (!require(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;STRINGdb\u0026#34;) library(STRINGdb) 1、定义要使用的STRING版本、物种，以及PPI阈值分数 1 2 3 4 string_db \u0026lt;- STRINGdb$new(version=\u0026#34;11\u0026#34;, species=9606, score_threshold=200, input_directory=\u0026#34;\u0026#34;) 2、示例基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data(diff_exp_example1) genes = diff_exp_example1[1:50,] head(genes) # pvalue logFC gene # 1 0.0001018 3.333461 VSTM2L # 2 0.0001392 3.822383 TBC1D2 # 3 0.0001720 3.306056 LENG9 # 4 0.0001739 3.024605 TMEM27 # 5 0.0001990 3.854414 LOC100506014 # 6 0.0002393 3.082052 TSPAN1 ###基因名匹配protein ID #第一个参数是data.frame; 第二个参数是基因所在列的列名 genes_mapped \u0026lt;- string_db$map(genes, \u0026#34;gene\u0026#34; ) #Warning: we couldn\u0026#39;t map to STRING 30% of your identifiers head(genes_mapped) # gene pvalue logFC STRING_id # 1 VSTM2L 0.0001018 3.333461 9606.ENSP00000362560 # 2 TBC1D2 0.0001392 3.822383 9606.ENSP00000481721 # 3 LENG9 0.0001720 3.306056 9606.ENSP00000479355 # 4 TMEM27 0.0001739 3.024605 9606.ENSP00000369699 # 40 LOC100506014 0.0001990 3.854414 \u0026lt;NA\u0026gt; # 5 TSPAN1 0.0002393 3.082052 9606.ENSP00000361072 #string_db$plot_network(genes_mapped$STRING_id) 3、下载这些基因间的互作关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ppi = string_db$get_interactions(genes_mapped$STRING_id) %\u0026gt;% distinct() ppi = ppi %\u0026gt;% dplyr::left_join(genes_mapped[,c(1,4)], by=c(\u0026#39;from\u0026#39;=\u0026#39;STRING_id\u0026#39;)) %\u0026gt;% #列标序号根据具体情况而定 dplyr::rename(Gene1=gene) %\u0026gt;% ##列名根据具体情况而定 dplyr::left_join(genes_mapped[,c(1,4)], by=c(\u0026#39;to\u0026#39;=\u0026#39;STRING_id\u0026#39;)) %\u0026gt;% dplyr::rename(Gene2=gene) %\u0026gt;% dplyr::select(Gene1, Gene2, combined_score) head(ppi) # Gene1 Gene2 combined_score # 1 C3 TYROBP 240 # 2 ABCA12 GRHL3 308 # 3 FAM189A1 TM4SF20 400 # 4 ABCA12 NIPAL4 824 # 5 GRHL3 NIPAL4 275 # 6 GRHL3 IGDCC4 238 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/051stringdb%E5%8C%85%E4%B8%8B%E8%BD%BD%E8%9B%8B%E7%99%BDppi%E6%95%B0%E6%8D%AE/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (!require(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BiocManager\u0026#34;\u003c/span\u003e, quietly = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    install.packages(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BiocManager\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBiocManager::install(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;STRINGdb\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(STRINGdb)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1定义要使用的string版本物种以及ppi阈值分数\"\u003e1、定义要使用的STRING版本、物种，以及PPI阈值分数\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estring_db \u0026lt;- STRINGdb$new(version=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;11\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          species=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9606\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          score_threshold=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          input_directory=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2示例基因\"\u003e2、示例基因\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(diff_exp_example1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes = diff_exp_example1[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e50\u003c/span\u003e,]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(genes)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      pvalue    logFC         gene\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 0.0001018 3.333461       VSTM2L\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 0.0001392 3.822383       TBC1D2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 0.0001720 3.306056        LENG9\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4 0.0001739 3.024605       TMEM27\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5 0.0001990 3.854414 LOC100506014\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 0.0002393 3.082052       TSPAN1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###基因名匹配protein ID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#第一个参数是data.frame; 第二个参数是基因所在列的列名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes_mapped \u0026lt;- string_db$map(genes, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;gene\u0026#34;\u003c/span\u003e )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#Warning:  we couldn\u0026#39;t map to STRING 30% of your identifiers\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(genes_mapped)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#            gene    pvalue    logFC            STRING_id\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1        VSTM2L 0.0001018 3.333461 9606.ENSP00000362560\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2        TBC1D2 0.0001392 3.822383 9606.ENSP00000481721\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3         LENG9 0.0001720 3.306056 9606.ENSP00000479355\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4        TMEM27 0.0001739 3.024605 9606.ENSP00000369699\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 40 LOC100506014 0.0001990 3.854414                 \u0026lt;NA\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5        TSPAN1 0.0002393 3.082052 9606.ENSP00000361072\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#string_db$plot_network(genes_mapped$STRING_id)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"3下载这些基因间的互作关系\"\u003e3、下载这些基因间的互作关系\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eppi = string_db$get_interactions(genes_mapped$STRING_id) %\u0026gt;% distinct()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eppi = ppi %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::left_join(genes_mapped[,c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)], by=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;from\u0026#39;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;STRING_id\u0026#39;\u003c/span\u003e)) %\u0026gt;% \u003cspan style=\"color:#007f7f\"\u003e#列标序号根据具体情况而定\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::rename(Gene1=gene) %\u0026gt;% \u003cspan style=\"color:#007f7f\"\u003e##列名根据具体情况而定\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::left_join(genes_mapped[,c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)], by=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;to\u0026#39;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;STRING_id\u0026#39;\u003c/span\u003e)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::rename(Gene2=gene) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(Gene1, Gene2, combined_score)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(ppi)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      Gene1   Gene2 combined_score\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1       C3  TYROBP            240\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2   ABCA12   GRHL3            308\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 FAM189A1 TM4SF20            400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4   ABCA12  NIPAL4            824\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5    GRHL3  NIPAL4            275\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6    GRHL3  IGDCC4            238\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"STRINGdb包下载蛋白PPI数据"},{"content":"1、GO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 GO_data \u0026lt;- clusterProfiler:::get_GO_data(\u0026#34;org.Hs.eg.db\u0026#34;, \u0026#34;ALL\u0026#34;, \u0026#34;SYMBOL\u0026#34;) names(GO_data) # [1] \u0026#34;PATHID2NAME\u0026#34; \u0026#34;EXTID2PATHID\u0026#34; \u0026#34;GO2ONT\u0026#34; \u0026#34;PATHID2EXTID\u0026#34; ###（1）GO term的组成基因 class(GO_data$PATHID2EXTID) #[1] \u0026#34;list\u0026#34; GO_data$PATHID2EXTID[1] # $`GO:0000002` # [1] \u0026#34;PARP1\u0026#34; \u0026#34;SLC25A4\u0026#34; \u0026#34;DNA2\u0026#34; \u0026#34;TYMP\u0026#34; \u0026#34;LIG3\u0026#34; \u0026#34;MEF2A\u0026#34; # [7] \u0026#34;MPV17\u0026#34; \u0026#34;OPA1\u0026#34; \u0026#34;TOP3A\u0026#34; \u0026#34;TP53\u0026#34; \u0026#34;LONP1\u0026#34; \u0026#34;AKT3\u0026#34; # [13] \u0026#34;PPARGC1A\u0026#34; \u0026#34;POLG2\u0026#34; \u0026#34;SLC25A36\u0026#34; \u0026#34;PIF1\u0026#34; \u0026#34;SESN2\u0026#34; \u0026#34;SLC25A33\u0026#34; # [19] \u0026#34;MGME1\u0026#34; \u0026#34;PRIMPOL\u0026#34; \u0026#34;STOX1\u0026#34; ###（2）基因所涉及的通路 class(GO_data$EXTID2PATHID) #[1] \u0026#34;list\u0026#34; GO_data$EXTID2PATHID[1] # $A1BG # [1] \u0026#34;GO:0001775\u0026#34; \u0026#34;GO:0002252\u0026#34; \u0026#34;GO:0002263\u0026#34; \u0026#34;GO:0002274\u0026#34; \u0026#34;GO:0002275\u0026#34; \u0026#34;GO:0002283\u0026#34; \u0026#34;GO:0002366\u0026#34; # [8] \u0026#34;GO:0002376\u0026#34; \u0026#34;GO:0002443\u0026#34; \u0026#34;GO:0002444\u0026#34; \u0026#34;GO:0002446\u0026#34; \u0026#34;GO:0002576\u0026#34; \u0026#34;GO:0003674\u0026#34; \u0026#34;GO:0005575\u0026#34; # ... ###（3）GO term的名字 class(GO_data$PATHID2NAME) #[1] \u0026#34;character\u0026#34; GO_data$PATHID2NAME[1] # GO:0000001 # \u0026#34;mitochondrion inheritance\u0026#34; ###（4）GO term的类别 class(GO_data$GO2ONT) #[1] \u0026#34;character\u0026#34; GO_data$GO2ONT[1] # GO:0000002 # \u0026#34;BP\u0026#34; table(GO_data$GO2ONT) # BP CC MF # 16013 1981 4755 library(tidyverse) go_name = reshape2::melt(GO_data$PATHID2NAME) %\u0026gt;% rownames_to_column(\u0026#34;ID\u0026#34;) %\u0026gt;% dplyr::rename(\u0026#34;Name\u0026#34;=\u0026#34;value\u0026#34;) go_type = reshape2::melt(GO_data$GO2ONT) %\u0026gt;% rownames_to_column(\u0026#34;ID\u0026#34;) %\u0026gt;% dplyr::rename(\u0026#34;Type\u0026#34;=\u0026#34;value\u0026#34;) go_info = inner_join(go_name, go_type) %\u0026gt;% dplyr::mutate(GSEA=toupper(gsub(\u0026#34; \u0026#34;,\u0026#34;_\u0026#34;,paste0(\u0026#34;GO\u0026#34;,Type,\u0026#34; \u0026#34;,Name)))) dim(go_info) head(go_info) table(rownames(brca_enrich_kegg) %in% go_info$GSEA) # ID Name Type # 1 GO:0000002 mitochondrial genome maintenance BP # 2 GO:0000003 reproduction BP # 3 GO:0000009 alpha-1,6-mannosyltransferase activity MF # 4 GO:0000010 trans-hexaprenyltranstransferase activity MF # 5 GO:0000012 single strand break repair BP # 6 GO:0000014 single-stranded DNA endodeoxyribonuclease activity MF # GSEA # 1 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE # 2 GOBP_REPRODUCTION # 3 GOMF_ALPHA-1,6-MANNOSYLTRANSFERASE_ACTIVITY # 4 GOMF_TRANS-HEXAPRENYLTRANSTRANSFERASE_ACTIVITY # 5 GOBP_SINGLE_STRAND_BREAK_REPAIR # 6 GOMF_SINGLE-STRANDED_DNA_ENDODEOXYRIBONUCLEASE_ACTIVITY 此外 GO.db包也提供了除组成基因以外的GO注释信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 library(GO.db) keytypes(GO.db) # [1] \u0026#34;DEFINITION\u0026#34; \u0026#34;GOID\u0026#34; \u0026#34;ONTOLOGY\u0026#34; \u0026#34;TERM\u0026#34; goids = keys(GO.db, keytype = \u0026#34;GOID\u0026#34;)[1:3] # [1] \u0026#34;GO:0000001\u0026#34; \u0026#34;GO:0000002\u0026#34; \u0026#34;GO:0000003\u0026#34; goids_anno = AnnotationDbi::select(GO.db, keys = goids, columns = c(\u0026#34;TERM\u0026#34;,\u0026#34;ONTOLOGY\u0026#34;,\u0026#34;DEFINITION\u0026#34;), #其中DEFINITION为term的详细描述 keytype=\u0026#34;GOID\u0026#34;) #所有的BP term的GO id goBP = select(GO.db, keys = \u0026#34;BP\u0026#34;, columns = c(\u0026#34;GOID\u0026#34;), keytype=\u0026#34;ONTOLOGY\u0026#34;) 2、KEGG 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 hsa_kegg \u0026lt;- clusterProfiler::download_KEGG(\u0026#34;hsa\u0026#34;) names(hsa_kegg) # [1] \u0026#34;KEGGPATHID2EXTID\u0026#34; \u0026#34;KEGGPATHID2NAME\u0026#34; ### KEGG id与name head(z) # from to # 1 hsa00010 Glycolysis / Gluconeogenesis # 2 hsa00020 Citrate cycle (TCA cycle) # 3 hsa00030 Pentose phosphate pathway ### KEGG id的组成基因 head(hsa_kegg$KEGGPATHID2EXTID) # from to # 1 hsa00010 10327 # 2 hsa00010 124 # 3 hsa00010 125 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/052%E4%BD%BF%E7%94%A8clusterprofiler%E4%B8%8B%E8%BD%BDgokegg%E9%80%9A%E8%B7%AF%E5%9F%BA%E5%9B%A0/","summary":"\u003ch1 id=\"1go\"\u003e1、GO\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e47\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e48\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e49\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e50\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e51\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e52\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e53\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e54\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e55\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e56\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e57\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e58\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e59\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e60\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e61\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e62\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e63\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e64\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e65\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e66\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGO_data \u0026lt;- clusterProfiler:::get_GO_data(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;org.Hs.eg.db\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ALL\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SYMBOL\u0026#34;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames(GO_data)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;PATHID2NAME\u0026#34;  \u0026#34;EXTID2PATHID\u0026#34; \u0026#34;GO2ONT\u0026#34;       \u0026#34;PATHID2EXTID\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###（1）GO term的组成基因\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(GO_data$PATHID2EXTID)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#[1] \u0026#34;list\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGO_data$PATHID2EXTID[1]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $`GO:0000002`\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;PARP1\u0026#34;    \u0026#34;SLC25A4\u0026#34;  \u0026#34;DNA2\u0026#34;     \u0026#34;TYMP\u0026#34;     \u0026#34;LIG3\u0026#34;     \u0026#34;MEF2A\u0026#34;   \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [7] \u0026#34;MPV17\u0026#34;    \u0026#34;OPA1\u0026#34;     \u0026#34;TOP3A\u0026#34;    \u0026#34;TP53\u0026#34;     \u0026#34;LONP1\u0026#34;    \u0026#34;AKT3\u0026#34;    \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [13] \u0026#34;PPARGC1A\u0026#34; \u0026#34;POLG2\u0026#34;    \u0026#34;SLC25A36\u0026#34; \u0026#34;PIF1\u0026#34;     \u0026#34;SESN2\u0026#34;    \u0026#34;SLC25A33\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [19] \u0026#34;MGME1\u0026#34;    \u0026#34;PRIMPOL\u0026#34;  \u0026#34;STOX1\u0026#34;  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###（2）基因所涉及的通路\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(GO_data$EXTID2PATHID)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#[1] \u0026#34;list\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGO_data$EXTID2PATHID[1]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $A1BG\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;GO:0001775\u0026#34; \u0026#34;GO:0002252\u0026#34; \u0026#34;GO:0002263\u0026#34; \u0026#34;GO:0002274\u0026#34; \u0026#34;GO:0002275\u0026#34; \u0026#34;GO:0002283\u0026#34; \u0026#34;GO:0002366\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [8] \u0026#34;GO:0002376\u0026#34; \u0026#34;GO:0002443\u0026#34; \u0026#34;GO:0002444\u0026#34; \u0026#34;GO:0002446\u0026#34; \u0026#34;GO:0002576\u0026#34; \u0026#34;GO:0003674\u0026#34; \u0026#34;GO:0005575\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###（3）GO term的名字\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(GO_data$PATHID2NAME)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#[1] \u0026#34;character\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGO_data$PATHID2NAME[1]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GO:0000001 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026#34;mitochondrion inheritance\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###（4）GO term的类别\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(GO_data$GO2ONT)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#[1] \u0026#34;character\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGO_data$GO2ONT[1]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GO:0000002 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026#34;BP\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etable(GO_data$GO2ONT)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# BP    CC    MF \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 16013  1981  4755 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ego_name = reshape2::melt(GO_data$PATHID2NAME) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\trownames_to_column(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ID\u0026#34;\u003c/span\u003e) %\u0026gt;%\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdplyr::rename(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;value\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ego_type = reshape2::melt(GO_data$GO2ONT) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\trownames_to_column(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ID\u0026#34;\u003c/span\u003e) %\u0026gt;%\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdplyr::rename(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Type\u0026#34;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;value\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ego_info = inner_join(go_name, go_type) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdplyr::mutate(GSEA=toupper(gsub(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;_\u0026#34;\u003c/span\u003e,paste0(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GO\u0026#34;\u003c/span\u003e,Type,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e,Name))))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(go_info)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(go_info)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etable(rownames(brca_enrich_kegg) %in% go_info$GSEA)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          \u003cspan style=\"color:#007f7f\"\u003e# ID                                               Name Type\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 GO:0000002                   mitochondrial genome maintenance   BP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 GO:0000003                                       reproduction   BP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 GO:0000009             alpha-1,6-mannosyltransferase activity   MF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4 GO:0000010          trans-hexaprenyltranstransferase activity   MF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5 GO:0000012                         single strand break repair   BP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 GO:0000014 single-stranded DNA endodeoxyribonuclease activity   MF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                                     \u003cspan style=\"color:#007f7f\"\u003e# GSEA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1                   GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2                                       GOBP_REPRODUCTION\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3             GOMF_ALPHA-1,6-MANNOSYLTRANSFERASE_ACTIVITY\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4          GOMF_TRANS-HEXAPRENYLTRANSTRANSFERASE_ACTIVITY\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5                         GOBP_SINGLE_STRAND_BREAK_REPAIR\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 GOMF_SINGLE-STRANDED_DNA_ENDODEOXYRIBONUCLEASE_ACTIVITY\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e此外 \u003ccode\u003eGO.db\u003c/code\u003e包也提供了除组成基因以外的GO注释信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(GO.db)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekeytypes(GO.db)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;DEFINITION\u0026#34; \u0026#34;GOID\u0026#34;       \u0026#34;ONTOLOGY\u0026#34;   \u0026#34;TERM\u0026#34; \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egoids = keys(GO.db, keytype = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GOID\u0026#34;\u003c/span\u003e)[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;GO:0000001\u0026#34; \u0026#34;GO:0000002\u0026#34; \u0026#34;GO:0000003\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egoids_anno = AnnotationDbi::select(GO.db,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       keys = goids,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       columns = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;TERM\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ONTOLOGY\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;DEFINITION\u0026#34;\u003c/span\u003e), \u003cspan style=\"color:#007f7f\"\u003e#其中DEFINITION为term的详细描述\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       keytype=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GOID\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#所有的BP term的GO id\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egoBP = select(GO.db,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              keys = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BP\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              columns = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GOID\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              keytype=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ONTOLOGY\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2kegg\"\u003e2、KEGG\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehsa_kegg \u0026lt;- clusterProfiler::download_KEGG(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hsa\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames(hsa_kegg)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;KEGGPATHID2EXTID\u0026#34; \u0026#34;KEGGPATHID2NAME\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### KEGG id与name\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(z)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#       from                                       to\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 hsa00010             Glycolysis / Gluconeogenesis\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 hsa00020                Citrate cycle (TCA cycle)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 hsa00030                Pentose phosphate pathway\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### KEGG id的组成基因\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(hsa_kegg$KEGGPATHID2EXTID)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#       from    to\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 hsa00010 10327\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 hsa00010   124\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 hsa00010   125\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"使用clusterProfiler下载GO\u0026KEGG通路基因"},{"content":"\r一、基因组大小 （1）人类基因组主要由细胞核的23对染色体组成(核基因组)，还包括线粒体中的小DNA分子(线粒体基因组)。\n（2）单倍体基因组大概有30亿个碱基对组成，具体到每个染色体的碱基对长度与基因数量如下所示(参照UCSC的hg38)。\n（3）在这30亿个碱基中，仅有1.5%的区域是2~3w个可编码蛋白质的基因。\n平均基因长度有10Kbp左右，但是不同基因的长度区别很大 其余98.5%的区域为非编码区，包括各种调控基因表达的DNA原件，同时也可以转录为non-coding RNA，发挥潜在作用。 二、基因组fasta文件 人类基因组序列信息通常以染色体为单位保存为fasta文件中。\n（1）参考基因组一般保存为纯文本格式，即直接记录“A”、“T”、“C”、“G”这样的 ASCII 码字符。而1个 ASCII 字符，大小是 1B，所以，如果按纯文本保存 30亿个字母(单链)，就是30亿字母 = 3,000,000,000 B = 3 GB。\n（2）理论上应该只有25条序列信息(Chr1:22,X,Y,ChrM)。但是在实际下载的文件中，序列数量远远不止这些。如下以UCSC里的hg38版本为例，有455条序列信息。\n除了上述25条序列外，其它序列主要是scaffolds，可大致分为ChrUn, Random, Alt三类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 wget http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz gunzip hg38.fa.gz #提取染色体id grep \u0026#34;^\u0026gt;\u0026#34; hg38.fa \u0026gt; chr.id wc -l chr.id #455 chr.id head chr.id # \u0026gt;chr1 # \u0026gt;chr10 # \u0026gt;chr11 # \u0026gt;chr11_KI270721v1_random # \u0026gt;chr12 # \u0026gt;chr13 # \u0026gt;chr14 # \u0026gt;chr14_GL000009v2_random # \u0026gt;chr14_GL000225v1_random # \u0026gt;chr14_KI270722v1_random 人类基因组主要通过二代测序技术获得，将测得的短Read片段拼接、组装成基因组的染色体序列，需要经历contigs与scaffolds两个过程\n（1）contigs是依靠read间的重叠拼接的序列(a few kbp long)，特点是不含有N碱基；\n（2）scaffolds则主要依靠read pairs关系进一步拼接contigs，特点是会产生N碱基(a few hundred kbp)；\n（3）最终再由scaffolds拼接成染色体序列。\n2.1 Unlocalized scaffolds(*****random) 知道这些scaffolds在哪条染色体上，但不知道其在染色体的具体位置及方向\nformat: chr{chromosome number orname}_{sequence_accession}v{sequence_version}_random\n1 2 3 4 5 6 7 8 9 10 grep \u0026#34;random\u0026#34; chr.id \u0026gt; chr.random wc -l chr.random #42 chr.random head chr.random # \u0026gt;chr11_KI270721v1_random # \u0026gt;chr14_GL000009v2_random # \u0026gt;chr14_GL000225v1_random # \u0026gt;chr14_KI270722v1_random # \u0026gt;chr14_GL000194v1_random # \u0026gt;chr14_KI270723v1_random 2.2 Unplaced scaffolds(chrUn******) 不知道这条scaffolds的所属染色体信息 format: chrUn_{sequence_accession}v{sequence_version} 1 2 3 4 5 6 7 8 9 10 grep \u0026#34;chrUn\u0026#34; chr.id \u0026gt; chr.chrUn wc -l chr.chrUn #127 chr.chrUn head chr.chrUn # \u0026gt;chrUn_KI270302v1 # \u0026gt;chrUn_KI270304v1 # \u0026gt;chrUn_KI270303v1 # \u0026gt;chrUn_KI270305v1 # \u0026gt;chrUn_KI270322v1 # \u0026gt;chrUn_KI270320v1 2.3 Alternate loci scaffolds(*****alt) 简单理解：参考基因组存在的主要依据是人类99.9%的序列是一致的。但是会存在一些序列在不同人群中不一致。例如49%人群该基因组特定位置为序列A，而49%人群则为序列B，都是正常的。但拿其中一种作为参考基因组都可能不太合适，因此标记出Alternate loci scaffolds。 format: chr{chromosome number or name}_{sequence_accession}v{sequence_version}_alt Alternate loci scaffolds为hg38版本基因组新添类型Sequence，此前hg19版本还没有。 1 2 3 4 5 6 7 8 9 10 grep \u0026#34;alt\u0026#34; chr.id \u0026gt; chr.alt wc -l chr.alt #261 chr.alt head chr.alt # \u0026gt;chr1_KI270762v1_alt # \u0026gt;chr1_KI270766v1_alt # \u0026gt;chr1_KI270760v1_alt # \u0026gt;chr1_KI270765v1_alt # \u0026gt;chr1_GL383518v1_alt # \u0026gt;chr1_GL383519v1_alt 注意：以上具体的chromosome name均为ucsc的hg版本，与GRCh38略有差异，但基本也是这几种类型sequence。\n三、基因结构 1、编码区与非编码区 基因 DNA可分为编码区和非编码区：编码区可转录为 mRNA 并最终翻译成蛋白质；非编码区上具有基因表达的调控元件。\n（1）编码区：在转录的过程，从DNA编码区的5\u0026rsquo;端开始转录生成preRNA，然后进一步加工修饰剪切得到成熟mRNA，进行后续的翻译。\n外显子：在preRNA 经过剪切或修饰后、被保留的DNA部分。 起始密码子(Start Codon)：是mRNA上开始合成蛋白质的密码子，也是第一个被核糖体翻译的mRNA密码子。通常为AUG。 终止密码子(Stop Codon)：代表核糖体翻译的终止。通常为UAG、UAA、UGA。 UTR(untranslated region)：属于外显子部分。即外显子也包含非编码区域。 位于5\u0026rsquo;端的UTR称为5\u0026rsquo;UTR，如下图橙色标注，从mRNA起点的甲基化鸟嘌呤核苷酸帽延伸至AUG起始密码子。 与5\u0026rsquo;UTR上游的第一个碱基相对应DNA链上的碱基称为TSS(Transcription start sites) 位于3\u0026rsquo;端的UTR称为3\u0026rsquo;UTR，为mRNA的结束部分，如下图红色标注，从编码区末端的终止密码子延伸至多聚A尾巴（Poly-A）。 与3\u0026rsquo;UTR下游的最后一个碱基相对应DNA链上的碱基称为TTS(Transcription termination sites) CDS(Coding sequence)：包括mRNA中从5\u0026rsquo;UTR后的起始密码子开始到3\u0026rsquo;UTR前的终止密码子的实际编码蛋白序列 ORF(Open reading frame)：从一个起始密码子开始到一个终止密码子结束的一段序列 注意与CDS定义上的区别。CDS一定是ORF，ORF不一定是CDS Transcript转录本：一条基因通过可变剪切机制可转录形成的一种或多种可供编码蛋白质的成熟的mRNA。 在最终成熟mRNA的上下游两端修饰有特殊的结构，分别是5\u0026rsquo; cap帽子与 3\u0026rsquo; Poly-A尾巴。 Poly-A尾是mRNA\u0026rsquo;区别于其它non-coding RNA的主要标志 （2）非编码区：位于DNA序列上下游的non-coding区域含有调控基因表达原件\n启动子Promoter：DNA分子上能与RNA聚合酶结合并形成转录起始复合体的区域，位于TSS位点上游的100~1000碱基序列。 真核生物启动子通常会包括一个TATA盒，比较接近TSS区域(50个碱基对以内) 终止子Terminator：给RNA聚合酶提供转录终止信号的DNA序列 增强子Enhancer：可以蛋白质结合的小段DNA，从而加强所调控基因的转录作用。可以位于靶基因的上游/下游，距离也可以很远。 2、基因组注释文件gtf 第一列：染色体ID 第三列：region类型 第四列：region的起始位点坐标（染色体的第一个碱基序号为1） 第五列：region的终止位点坐标 第七列：正负链信息（+forward/-reverse） 正链：表示实际mRNA序列与坐标对应DNA序列相同，除了（U/T变换） 负链：表示实际mRNA序列与坐标对应DNA序列的互补链相同，除了（U/T变换），也需要从5\u0026rsquo;到3\u0026rsquo;端读取。 第八列：对于实际编码区coding region，表示在这个CDS区域开始编码新密码子的起始index{0,1,2} 第九列：region的属性键值对。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # wget https://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/genes/hg38.refGene.gtf.gz gtf = data.table::fread(\u0026#34;hg38.refGene.gtf.gz\u0026#34;) head(gtf,3) # V1 V2 V3 V4 V5 V6 V7 V8 # 1: chr1 refGene transcript 11874 14409 . + . # 2: chr1 refGene exon 11874 12227 . + . # 3: chr1 refGene exon 12613 12721 . + . # V9 # 1: gene_id \u0026#34;DDX11L1\u0026#34;; transcript_id \u0026#34;NR_046018\u0026#34;; gene_name \u0026#34;DDX11L1\u0026#34;; # 2: gene_id \u0026#34;DDX11L1\u0026#34;; transcript_id \u0026#34;NR_046018\u0026#34;; exon_number \u0026#34;1\u0026#34;; exon_id \u0026#34;NR_046018.1\u0026#34;; gene_name \u0026#34;DDX11L1\u0026#34;; # 3: gene_id \u0026#34;DDX11L1\u0026#34;; transcript_id \u0026#34;NR_046018\u0026#34;; exon_number \u0026#34;2\u0026#34;; exon_id \u0026#34;NR_046018.2\u0026#34;; gene_name \u0026#34;DDX11L1\u0026#34;; table(gtf$V3) # 3UTR 5UTR CDS exon start_codon stop_codon transcript # 67901 121178 655401 836541 64026 64026 84787 ## 一般来说，每个exon region都对应一个CDS region，除了假基因Pseudogenes。 不同平台机构给出的gtf注释文件略有差异，但每列含义基本相同。发现NCBI提供的gff3文件注释信息最全，包括非编码RNA，蛋白质编码RNA、假基因等\n1 2 3 4 5 6 7 8 9 library(AnnoProbe) IDs \u0026lt;- c(\u0026#34;DDX11L1\u0026#34;, \u0026#34;MIR6859-1\u0026#34;, \u0026#34;OR4G4P\u0026#34;, \u0026#34;OR4F5\u0026#34;) ID_type = \u0026#34;SYMBOL\u0026#34; annoGene(IDs, ID_type) # SYMBOL biotypes ENSEMBL chr start end # 1 DDX11L1 transcribed_unprocessed_pseudogene ENSG00000223972 chr1 11869 14409 # 3 MIR6859-1 miRNA ENSG00000278267 chr1 17369 17436 # 7 OR4G4P unprocessed_pseudogene ENSG00000268020 chr1 52473 53312 # 9 OR4F5 protein_coding ENSG00000186092 chr1 65419 71585 四、下载参考基因组 目前常用的基因组版本为GRCh38/37，hg38/19，前者可通过NCBI/Ensembl下载，后者可通过UCSC网站下载。\n如下图所示GRCh38可认为等同于hg38；GRCh37可认为等同于hg19。\n以下载GRCh38/hg38为例，如下\n4.1 NCBI https://www.ncbi.nlm.nih.gov/projects/genome/guide/human/ 1 wget -c ftp://ftp.ncbi.nlm.nih.gov/refseq/H_sapiens/annotation/GRCh38_latest/refseq_identifiers/GRCh38_latest_genomic.fna.gz 4.2 ensembl ensembl的release-103版本可以认为等于GRCh38 https://asia.ensembl.org/Homo_sapiens/Info/Index http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/dna/ https://www.ensembl.org/info/data/ftp/index.html 还包含有cDNA转录本序列 1 wget -c http://ftp.ensembl.org/pub/release-103/fasta/homo_sapiens/dna/Homo_sapiens.GRCh38.dna.toplevel.fa.gz 4.3 UCSC http://hgdownload.soe.ucsc.edu/downloads.html http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/ 1 wget -c http://hgdownload.soe.ucsc.edu/goldenPath/hg38/bigZips/hg38.fa.gz 也可以使用之前学习的Refgenie工具下载上述提到的gtf注释文件\n五、TxDb与GRanges对象查询gtf TxDb系列包是将物种基因组的gtf注释信息封装为TxDb对象，以供使用者方便的查询。\n1 2 3 4 5 6 7 8 9 10 11 12 13 #BiocManager::install(\u0026#34;TxDb.Hsapiens.UCSC.hg38.knownGene\u0026#34;) library(TxDb.Hsapiens.UCSC.hg38.knownGene) txdb \u0026lt;- TxDb.Hsapiens.UCSC.hg38.knownGene class(txdb) # [1] \u0026#34;TxDb\u0026#34; # attr(,\u0026#34;package\u0026#34;) # [1] \u0026#34;GenomicFeatures\u0026#34; seqlevels(txdb) \u0026lt;- paste0(\u0026#34;chr\u0026#34;,c(1:22,\u0026#34;X\u0026#34;,\u0026#34;Y\u0026#34;,\u0026#34;M\u0026#34;)) seqlevels(txdb) # [1] \u0026#34;chr1\u0026#34; \u0026#34;chr2\u0026#34; \u0026#34;chr3\u0026#34; \u0026#34;chr4\u0026#34; \u0026#34;chr5\u0026#34; \u0026#34;chr6\u0026#34; \u0026#34;chr7\u0026#34; \u0026#34;chr8\u0026#34; \u0026#34;chr9\u0026#34; \u0026#34;chr10\u0026#34; \u0026#34;chr11\u0026#34; # [12] \u0026#34;chr12\u0026#34; \u0026#34;chr13\u0026#34; \u0026#34;chr14\u0026#34; \u0026#34;chr15\u0026#34; \u0026#34;chr16\u0026#34; \u0026#34;chr17\u0026#34; \u0026#34;chr18\u0026#34; \u0026#34;chr19\u0026#34; \u0026#34;chr20\u0026#34; \u0026#34;chr21\u0026#34; \u0026#34;chr22\u0026#34; # [23] \u0026#34;chrX\u0026#34; \u0026#34;chrY\u0026#34; \u0026#34;chrM\u0026#34; #seqlevels(txdb) \u0026lt;- seqlevels0(txdb) txdb对象支持4种region fearture，共计22种的属性注释。\n具体使用时可提供keytypes() 所支持的7种信息之一，查询所匹配的其它（22种内）注释信息。\n其中GENEID为Entrez基因ID格式，TXID为Ensemble转录本ID格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 columns(txdb) # Gene : \u0026#34;GENEID\u0026#34; # CDS : \u0026#34;CDSCHROM\u0026#34; \u0026#34;CDSEND\u0026#34; \u0026#34;CDSID\u0026#34; \u0026#34;CDSNAME\u0026#34; \u0026#34;CDSPHASE\u0026#34; \u0026#34;CDSSTART\u0026#34; \u0026#34;CDSSTRAND\u0026#34; # EXON : \u0026#34;EXONCHROM\u0026#34; \u0026#34;EXONEND\u0026#34; \u0026#34;EXONID\u0026#34; \u0026#34;EXONNAME\u0026#34; \u0026#34;EXONRANK\u0026#34; \u0026#34;EXONSTART\u0026#34; \u0026#34;EXONSTRAND\u0026#34; # TX : \u0026#34;TXCHROM\u0026#34; \u0026#34;TXEND\u0026#34; \u0026#34;TXID\u0026#34; \u0026#34;TXNAME\u0026#34; \u0026#34;TXSTART\u0026#34; \u0026#34;TXSTRAND\u0026#34; keytypes(txdb) # [1] \u0026#34;GENEID\u0026#34; \u0026#34;CDSID\u0026#34; \u0026#34;CDSNAME\u0026#34; \u0026#34;EXONID\u0026#34; \u0026#34;EXONNAME\u0026#34; \u0026#34;TXID\u0026#34; \u0026#34;TXNAME\u0026#34; keys = \u0026#34;348\u0026#34; #APOE AnnotationDbi::select(txdb, keys = keys, keytype=\u0026#34;GENEID\u0026#34;, columns=columns(txdb)) AnnotationDbi::select(txdb, keys = keys, keytype=\u0026#34;GENEID\u0026#34;, columns=c(\u0026#34;TXID\u0026#34;,\u0026#34;TXSTART\u0026#34;,\u0026#34;TXEND\u0026#34;)) # \u0026#39;select()\u0026#39; returned 1:many mapping between keys and columns # GENEID TXID TXSTART TXEND # 1 348 201573 44905791 44908944 # 2 348 201574 44905796 44907326 # 3 348 201575 44905796 44909393 # 4 348 201576 44905812 44909025 # 5 348 201577 44906360 44908954 GenomicFeatures包提供了genes(),transcripts(), exons(), cds(), promoters()函数用于提取特定feature region为GRange对象。\n其中可通过filter=list()参数进行筛选符合注释信息的region，可包括\n\u0026ldquo;gene_id\u0026rdquo;, \u0026ldquo;tx_id\u0026rdquo;, \u0026ldquo;tx_name\u0026rdquo;, \u0026ldquo;tx_chrom\u0026rdquo;, \u0026ldquo;tx_strand\u0026rdquo;, \u0026ldquo;exon_id\u0026rdquo;, \u0026ldquo;exon_name\u0026rdquo;, \u0026ldquo;exon_chrom\u0026rdquo;, \u0026ldquo;exon_strand\u0026rdquo;, \u0026ldquo;exon_rank\u0026rdquo;. \u0026ldquo;cds_id\u0026rdquo;, \u0026ldquo;cds_name\u0026rdquo;, \u0026ldquo;cds_chrom\u0026rdquo;, \u0026ldquo;cds_strand\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 GR = transcripts(txdb, filter=list(gene_id=\u0026#34;348\u0026#34;)) GR$tx_id # GRanges object with 5 ranges and 2 metadata columns: # seqnames ranges strand | tx_id tx_name # \u0026lt;Rle\u0026gt; \u0026lt;IRanges\u0026gt; \u0026lt;Rle\u0026gt; | \u0026lt;integer\u0026gt; \u0026lt;character\u0026gt; # [1] chr19 44905791-44908944 + | 201573 ENST00000446996.5 # [2] chr19 44905796-44907326 + | 201574 ENST00000485628.2 # [3] chr19 44905796-44909393 + | 201575 ENST00000252486.9 # [4] chr19 44905812-44909025 + | 201576 ENST00000434152.5 # [5] chr19 44906360-44908954 + | 201577 ENST00000425718.1 # ------- # seqinfo: 25 sequences (1 circular) from hg38 genome ##相关操作 ranges(GR) width(GR) start(GR) end(GR) mcols(GR) GR$tx_id GR[strand(GR) == \u0026#34;+\u0026#34;] GR[1:4] GRange对象结合BSgenome系列包获取指定feature region的序列信息\n1 2 3 4 library(BSgenome.Hsapiens.UCSC.hg38) BSgenome = BSgenome.Hsapiens.UCSC.hg38 GR.seq \u0026lt;- getSeq(BSgenome,GR) GR.seq_df = as.data.frame(GR.seq) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/053%E4%BA%BA%E7%B1%BB%E5%9F%BA%E5%9B%A0%E7%BB%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%8E%E4%B8%8B%E8%BD%BD%E6%9F%A5%E8%AF%A2/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://www.edinformatics.com/math_science/human_chromosomes2.jpg\" alt=\"How many genes are in the human genome?\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"一基因组大小\"\u003e一、基因组大小\u003c/h1\u003e\n\u003cp\u003e（1）人类基因组主要由细胞核的23对染色体组成(核基因组)，还包括线粒体中的小DNA分子(线粒体基因组)。\u003c/p\u003e\n\u003cp\u003e（2）单倍体基因组大概有30亿个碱基对组成，具体到每个染色体的碱基对长度与基因数量如下所示(参照UCSC的hg38)。\u003c/p\u003e","title":"人类基因组基础知识与下载查询"},{"content":"1、不同基因ID转换 1.1 org.Hs.eg.db包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 library(dplyr) library(org.Hs.eg.db) keytypes(org.Hs.eg.db) # [1] \u0026#34;ACCNUM\u0026#34; \u0026#34;ALIAS\u0026#34; \u0026#34;ENSEMBL\u0026#34; \u0026#34;ENSEMBLPROT\u0026#34; \u0026#34;ENSEMBLTRANS\u0026#34; \u0026#34;ENTREZID\u0026#34; # [7] \u0026#34;ENZYME\u0026#34; \u0026#34;EVIDENCE\u0026#34; \u0026#34;EVIDENCEALL\u0026#34; \u0026#34;GENENAME\u0026#34; \u0026#34;GENETYPE\u0026#34; \u0026#34;GO\u0026#34; # [13] \u0026#34;GOALL\u0026#34; \u0026#34;IPI\u0026#34; \u0026#34;MAP\u0026#34; \u0026#34;OMIM\u0026#34; \u0026#34;ONTOLOGY\u0026#34; \u0026#34;ONTOLOGYALL\u0026#34; # [19] \u0026#34;PATH\u0026#34; \u0026#34;PFAM\u0026#34; \u0026#34;PMID\u0026#34; \u0026#34;PROSITE\u0026#34; \u0026#34;REFSEQ\u0026#34; \u0026#34;SYMBOL\u0026#34; # [25] \u0026#34;UCSCKG\u0026#34; \u0026#34;UNIPROT\u0026#34; gene_symbol=c(\u0026#34;RHO\u0026#34;,\u0026#34;CALM1\u0026#34;,\u0026#34;MEG3\u0026#34;,\u0026#34;GNGT1\u0026#34;,\u0026#34;SAG\u0026#34;,\u0026#34;RPGRIP1\u0026#34;,\u0026#34;TRPM1\u0026#34;,\u0026#34;PCP2\u0026#34;,\u0026#34;PCP4\u0026#34;,\u0026#34;AP1B1\u0026#34;) gene_ids\u0026lt;-AnnotationDbi::select(org.Hs.eg.db, keys=as.character(gene_symbol), columns=c(\u0026#34;ENSEMBL\u0026#34;,\u0026#34;ENTREZID\u0026#34;), #目标格式 keytype=\u0026#34;SYMBOL\u0026#34;) #目前的格式 gene_ids ##去重 gene_ids %\u0026gt;% dplyr::distinct(ENTREZID, .keep_all = T) # SYMBOL ENSEMBL ENTREZID # 1 RHO ENSG00000163914 6010 # 2 CALM1 ENSG00000198668 801 # 3 MEG3 ENSG00000214548 55384 # 4 GNGT1 ENSG00000127928 2792 # 5 SAG ENSG00000130561 6295 # 6 RPGRIP1 ENSG00000092200 57096 # 7 TRPM1 ENSG00000134160 4308 # 8 PCP2 ENSG00000174788 126006 # 9 PCP4 ENSG00000183036 5121 # 10 AP1B1 ENSG00000100280 162 1.2 biomaRt包 1 2 3 4 5 6 7 8 9 10 11 12 library(\u0026#34;biomaRt\u0026#34;) ensembl = useMart(\u0026#34;ensembl\u0026#34;,dataset=\u0026#34;hsapiens_gene_ensembl\u0026#34;) attributes = listAttributes(ensembl) attributes[1:5,] # library(httr) # httr::set_config(config(ssl_verifypeer = 0L)) gene_symbol=c(\u0026#34;RHO\u0026#34;,\u0026#34;CALM1\u0026#34;,\u0026#34;MEG3\u0026#34;,\u0026#34;GNGT1\u0026#34;,\u0026#34;SAG\u0026#34;,\u0026#34;RPGRIP1\u0026#34;,\u0026#34;TRPM1\u0026#34;,\u0026#34;PCP2\u0026#34;,\u0026#34;PCP4\u0026#34;,\u0026#34;AP1B1\u0026#34;) gene_ids2 \u0026lt;- getBM(filters= \u0026#34;hgnc_symbol\u0026#34;, attributes= c(\u0026#34;hgnc_symbol\u0026#34;,\u0026#34;ensembl_gene_id\u0026#34;,\u0026#34;entrezgene_id\u0026#34;), values = gene_symbol, mart= ensembl) gene_ids2 2、鼠源基因转为人类基因ID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 musGenes \u0026lt;- c(\u0026#34;Hmmr\u0026#34;, \u0026#34;Tlx3\u0026#34;, \u0026#34;Cpeb4\u0026#34;) ## 方式1：直接大小写转换 toupper(musGenes) # [1] \u0026#34;HMMR\u0026#34; \u0026#34;TLX3\u0026#34; \u0026#34;CPEB4\u0026#34; ## 方式2：通过biomaRt包（不稳定） require(\u0026#34;biomaRt\u0026#34;) # library(httr) # httr::set_config(config(ssl_verifypeer = 0L)) human = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;hsapiens_gene_ensembl\u0026#34;,host = \u0026#34;dec2021.archive.ensembl.org\u0026#34;) mouse = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;mmusculus_gene_ensembl\u0026#34;,host = \u0026#34;dec2021.archive.ensembl.org\u0026#34;) genes = getLDS(attributes = c(\u0026#34;mgi_symbol\u0026#34;), filters = \u0026#34;mgi_symbol\u0026#34;, values = musGenes, mart = mouse, attributesL = c(\u0026#34;hgnc_symbol\u0026#34;), martL = human, uniqueRows=T) ## 方式3：MGI 数据库 # https://support.bioconductor.org/p/129636/ library(dplyr) mouse_human_genes = read.csv(\u0026#34;http://www.informatics.jax.org/downloads/reports/HOM_MouseHumanSequence.rpt\u0026#34;,sep=\u0026#34;\\t\u0026#34;) convert_mouse_to_human \u0026lt;- function(gene_list){ output = c() for(gene in gene_list){ class_key = (mouse_human_genes %\u0026gt;% filter(Symbol == gene \u0026amp; Common.Organism.Name==\u0026#34;mouse, laboratory\u0026#34;))[[\u0026#39;DB.Class.Key\u0026#39;]] if(!identical(class_key, integer(0)) ){ human_genes = (mouse_human_genes %\u0026gt;% filter(DB.Class.Key == class_key \u0026amp; Common.Organism.Name==\u0026#34;human\u0026#34;))[,\u0026#34;Symbol\u0026#34;] for(human_gene in human_genes){ output = append(output,human_gene) } } } return (output) } convert_mouse_to_human(musGenes) # 1] \u0026#34;HMMR\u0026#34; \u0026#34;TLX3\u0026#34; \u0026#34;CPEB4\u0026#34; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # # https://github.com/lishensuo/utils # # library(\u0026#34;biomaRt\u0026#34;) # # library(httr) # # httr::set_config(config(ssl_verifypeer = 0L)) # human = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;hsapiens_gene_ensembl\u0026#34;,host = \u0026#34;dec2021.archive.ensembl.org\u0026#34;) # mouse = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;mmusculus_gene_ensembl\u0026#34;,host = \u0026#34;dec2021.archive.ensembl.org\u0026#34;) # # # https://www.gencodegenes.org/mouse/ # dat = data.table::fread(\u0026#34;gencode.vM33.basic.annotation.gtf.gz\u0026#34;) # dat = subset(dat, V3 == \u0026#34;gene\u0026#34;) # dat_sub = dat[,\u0026#34;V9\u0026#34;] %\u0026gt;% # separate(V9, into = c(\u0026#34;gene_id\u0026#34;,\u0026#34;gene_type\u0026#34;,\u0026#34;gene_name\u0026#34;,\u0026#34;mgi_id\u0026#34;,\u0026#34;havana_gene\u0026#34;), sep = \u0026#34;; \u0026#34;) # dat_sub$gene_name2 = gsub(\u0026#39;gencode.vM33.basic.annotation.gtf.gz \u0026#34;\u0026#39;,\u0026#39;\u0026#39;,dat_sub$gene_name) # dat_sub$gene_name2 = gsub(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\u0026#39;,dat_sub$gene_name2) # # genes = getLDS(attributes = c(\u0026#34;mgi_symbol\u0026#34;), filters = \u0026#34;mgi_symbol\u0026#34;, # values = dat_sub$gene_name2, # mart = mouse, # attributesL = c(\u0026#34;hgnc_symbol\u0026#34;), # martL = human, uniqueRows=T) # write.csv(genes, file = \u0026#34;mgi2hgnc_biomart.csv\u0026#34;, row.names = F, quote = F) # head(genes) 3、蛋白质与基因ID转换 https://www.uniprot.org/uploadlists/ 4、化合物ID转换 4.1 网页转换 https://pubchem.ncbi.nlm.nih.gov/idexchange/idexchange.cgi\n4.2 python工具转换 （1）https://pubchempy.readthedocs.io/en/v1.0.4/index.html\n1 pip install pubchempy （2）简单用法如下\n1 import pubchempy as pcp ①可直接根据化合物CID，构建出pubchempy.Compound对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 c = pcp.Compound.from_cid(5090) type(c) # pubchempy.Compound ##举例3个属性值 c.molecular_formula # \u0026#39;C17H14O4S\u0026#39; c.canonical_smiles # \u0026#39;CS(=O)(=O)C1=CC=C(C=C1)C2=C(C(=O)OC2)C3=CC=CC=C3\u0026#39; c.synonyms[:3] # [\u0026#39;rofecoxib\u0026#39;, \u0026#39;162011-90-7\u0026#39;, \u0026#39;Vioxx\u0026#39;] ## 转换成表格，显示全部属性 c_df = pcp.compounds_to_frame(c) c_df.columns # Index([\u0026#39;atom_stereo_count\u0026#39;, \u0026#39;atoms\u0026#39;, \u0026#39;bond_stereo_count\u0026#39;, \u0026#39;bonds\u0026#39;, # \u0026#39;cactvs_fingerprint\u0026#39;, \u0026#39;canonical_smiles\u0026#39;, \u0026#39;charge\u0026#39;, \u0026#39;complexity\u0026#39;, # \u0026#39;conformer_id_3d\u0026#39;, \u0026#39;conformer_rmsd_3d\u0026#39;, \u0026#39;coordinate_type\u0026#39;, # \u0026#39;covalent_unit_count\u0026#39;, \u0026#39;defined_atom_stereo_count\u0026#39;, # \u0026#39;defined_bond_stereo_count\u0026#39;, \u0026#39;effective_rotor_count_3d\u0026#39;, \u0026#39;elements\u0026#39;, # \u0026#39;exact_mass\u0026#39;, \u0026#39;feature_selfoverlap_3d\u0026#39;, \u0026#39;fingerprint\u0026#39;, # \u0026#39;h_bond_acceptor_count\u0026#39;, \u0026#39;h_bond_donor_count\u0026#39;, \u0026#39;heavy_atom_count\u0026#39;, # \u0026#39;inchi\u0026#39;, \u0026#39;inchikey\u0026#39;, \u0026#39;isomeric_smiles\u0026#39;, \u0026#39;isotope_atom_count\u0026#39;, # \u0026#39;iupac_name\u0026#39;, \u0026#39;mmff94_energy_3d\u0026#39;, \u0026#39;mmff94_partial_charges_3d\u0026#39;, # \u0026#39;molecular_formula\u0026#39;, \u0026#39;molecular_weight\u0026#39;, \u0026#39;monoisotopic_mass\u0026#39;, # \u0026#39;multipoles_3d\u0026#39;, \u0026#39;pharmacophore_features_3d\u0026#39;, \u0026#39;record\u0026#39;, # \u0026#39;rotatable_bond_count\u0026#39;, \u0026#39;shape_fingerprint_3d\u0026#39;, \u0026#39;shape_selfoverlap_3d\u0026#39;, # \u0026#39;tpsa\u0026#39;, \u0026#39;undefined_atom_stereo_count\u0026#39;, \u0026#39;undefined_bond_stereo_count\u0026#39;, # \u0026#39;volume_3d\u0026#39;, \u0026#39;xlogp\u0026#39;], # dtype=\u0026#39;object\u0026#39;) ②根据小分子属性值，搜索符合条件的小分子对象\n仅支持6种属性：[\u0026ldquo;name\u0026rdquo;,\u0026ldquo;smiles\u0026rdquo;,\u0026ldquo;sdf\u0026rdquo;,\u0026ldquo;inchi\u0026rdquo;,\u0026ldquo;inchikey\u0026rdquo;,\u0026ldquo;formula\u0026rdquo;]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 第一个参数--属性值，第二个参数--属性类型 ## 返回结果是包含若干个小分子对象的list results = pcp.get_compounds(\u0026#39;Glucose\u0026#39;, \u0026#39;name\u0026#39;) results = pcp.get_compounds(\u0026#39;C1=CC2=C(C3=C(C=CC=N3)C=C2)N=C1\u0026#39;, \u0026#39;smiles\u0026#39;) multi_results = pcp.get_compounds(\u0026#39;C6H12O6\u0026#39;, \u0026#39;formula\u0026#39;) results = multi_results[:3] for cp in results: print(cp.isomeric_smiles) # C1[C@H]([C@H]([C@@H](C(O1)(CO)O)O)O)O # C([C@H]([C@H]([C@@H]([C@H](C=O)O)O)O)O)O # C(C(C(C(C(C=O)O)O)O)O)O cs = pcp.get_compounds(\u0026#39;C20H41Br\u0026#39;, \u0026#39;formula\u0026#39;) cs[:3] # [Compound(20271), Compound(23148745), Compound(10808570)] cs_df = pcp.compounds_to_frame(cs, properties=[\u0026#39;isomeric_smiles\u0026#39;, \u0026#39;xlogp\u0026#39;, \u0026#39;rotatable_bond_count\u0026#39;]) cs_df.shape # (43, 3) 补充：MyGene MyGene.info 是一个为生物信息学提供高效、统一、RESTful API 的基因注释服务平台，支持快速查询基因的ID转换、结构、功能、通路、蛋白、疾病、药物靶点等多种注释信息；数据来源整合了多个主流数据库（如 NCBI, Ensembl, UniProt, GO, KEGG, ChEMBL 等）。\nhttps://docs.mygene.info/en/latest/index.html https://github.com/biothings/mygene.info https://pypi.org/project/mygene/ 使用方式也非常简单，可以直接通过API接口，也提供了封装好的Python、R包进行调用。下面简单记录其Python包的用法，方便以后使用。\n1 2 3 4 5 # pip install mygene import mygene mg = mygene.MyGeneInfo() 方式1：根据指定的entrezgene/ensembl id查询\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 res = mg.getgene(1017, fields=\u0026#39;all\u0026#39;) res.keys() # dict_keys([\u0026#39;AllianceGenome\u0026#39;, \u0026#39;HGNC\u0026#39;, \u0026#39;MIM\u0026#39;, \u0026#39;_id\u0026#39;, \u0026#39;_version\u0026#39;, \u0026#39;accession\u0026#39;, \u0026#39;agr\u0026#39;, # \u0026#39;alias\u0026#39;, \u0026#39;chembl\u0026#39;, \u0026#39;ec\u0026#39;, \u0026#39;ensembl\u0026#39;, \u0026#39;entrezgene\u0026#39;, \u0026#39;exac\u0026#39;, \u0026#39;exons\u0026#39;, \u0026#39;exons_hg19\u0026#39;, # \u0026#39;generif\u0026#39;, \u0026#39;genomic_pos\u0026#39;, \u0026#39;genomic_pos_hg19\u0026#39;, \u0026#39;go\u0026#39;, \u0026#39;homologene\u0026#39;, \u0026#39;interpro\u0026#39;, \u0026#39;ipi\u0026#39;, # \u0026#39;map_location\u0026#39;, \u0026#39;name\u0026#39;, \u0026#39;other_names\u0026#39;, \u0026#39;pantherdb\u0026#39;, \u0026#39;pathway\u0026#39;, \u0026#39;pdb\u0026#39;, \u0026#39;pfam\u0026#39;, \u0026#39;pharmgkb\u0026#39;, # \u0026#39;pharos\u0026#39;, \u0026#39;pir\u0026#39;, \u0026#39;prosite\u0026#39;, \u0026#39;reagent\u0026#39;, \u0026#39;refseq\u0026#39;, \u0026#39;reporter\u0026#39;, \u0026#39;summary\u0026#39;, \u0026#39;symbol\u0026#39;, \u0026#39;taxid\u0026#39;, # \u0026#39;type_of_gene\u0026#39;, \u0026#39;umls\u0026#39;, \u0026#39;unigene\u0026#39;, \u0026#39;unii\u0026#39;, \u0026#39;uniprot\u0026#39;, \u0026#39;wikipedia\u0026#39;]) ## 笔记最后列出了每个key/field的含义说明 # 使用fields参数限定返回的注释条目 mg.getgene(1017, fields=\u0026#39;name,symbol,refseq\u0026#39;) mg.getgene(1017, fields=[\u0026#39;name\u0026#39;, \u0026#39;symbol\u0026#39;, \u0026#39;refseq.rna\u0026#39;]) # 同时查询多个基因 mg.getgenes([1017,1018,\u0026#39;ENSG00000148795\u0026#39;], fields=\u0026#39;name,symbol,entrezgene,taxid,type_of_gene\u0026#39;) mg.getgenes([1017,1018,\u0026#39;ENSG00000148795\u0026#39;], fields=\u0026#39;name,symbol,entrezgene,taxid,ensembl\u0026#39;, as_dataframe=True) 方式2：根据关键字匹配搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 mg.query(\u0026#39;cdk2\u0026#39;) # 默认返回最匹配的10个结果，且返回条目进包括entrezgene/name/symbol/taxid # 针对特定条目进行搜索，且筛选物种 mg.query(\u0026#39;symbol:cdk2\u0026#39;, species=\u0026#39;human\u0026#39;, fields=\u0026#39;name,symbol,entrezgene,taxid,ensembl\u0026#39;) # 批量搜索，scopes参数设置针对某一条目进行搜索 mg.querymany([1017, 695], scopes=\u0026#39;entrezgene\u0026#39;, species=\u0026#39;human\u0026#39;) mg.querymany([\u0026#34;TP53\u0026#34;, \u0026#34;EGFR\u0026#34;, \u0026#39;NA_TEST\u0026#39;], scopes=\u0026#39;symbol\u0026#39;, species=\u0026#39;human\u0026#39;, as_dataframe=True) # 当fetch_all=True，生成一个可迭代对象 kinases = mg.query(\u0026#39;name:kinase\u0026#39;, species=\u0026#39;human\u0026#39;, fetch_all=True) for gene in kinases: print(gene[\u0026#39;_id\u0026#39;], gene[\u0026#39;symbol\u0026#39;]) 基本信息 字段名 含义 _id / entrezgene 主键，通常等于 Entrez Gene ID，如 1017 _version 数据版本号 symbol 基因符号，例如 CDK2 name 基因全名，例如 \u0026ldquo;cyclin-dependent kinase 2\u0026rdquo; taxid NCBI 物种 ID，9606 表示人类 type_of_gene 基因类型，如 protein-coding、ncRNA、pseudo 等 summary 基因功能简要描述 alias 其他名称或别名（例如缩写、旧称） other_names 附加名称（全称、别称等） 序列信息 字段名 含义 accession 基因相关的 GenBank/RefSeq accession 列表 refseq RefSeq 序列 ID（mRNA、protein、genomic 等） genomic_pos 基因在最新人类基因组版本（如 hg38）上的位置 genomic_pos_hg19 在旧版本（hg19）上的位置信息 exons 外显子位置（hg38） exons_hg19 外显子位置（hg19） 生物通路与功能注释\n字段名 含义 go Gene Ontology 注释，包括 BP（生物过程）、MF（分子功能）、CC（细胞成分） pathway 涉及的信号通路信息（来自 Reactome、WikiPathways、KEGG 等） pantherdb Panther 通路数据库注释 pharmgkb 药物-基因相互作用信息 pharos 药物开发相关注释（Drug Target 分类） 蛋白结构和功能域\n字段名 含义 uniprot UniProt 蛋白数据库的 ID 和注释 interpro InterPro 蛋白家族或功能域 pfam Pfam 蛋白结构域 prosite Prosite 模式/结构域数据库 pdb 相关蛋白质的三维结构（来自 Protein Data Bank） ec 酶编号（Enzyme Commission Number），如 kinase 常有 ipi International Protein Index（已弃用） pir PIR 蛋白数据库 ID 同源与进化 字段名 含义 homologene NCBI HomoloGene 同源基因信息 ([tax_id, entrezgene_id]) ensembl Ensembl 基因数据库的 ID 和注释 MIM OMIM（人类遗传疾病数据库）相关信息 unigene NCBI UniGene 聚类（旧） umls Unified Medical Language System 编号（跨数据库映射） exac ExAC 等人群变异数据汇总（Exome Aggregation Consortium） HGNC HGNC（人类基因命名委员会）ID 和详细命名信息 实验与试剂相关\n字段名 含义 reporter 基因在不同表达芯片平台上的探针 ID（如 Affymetrix） reagent BioGPS 等平台上的实验试剂资源 agr Alliance of Genome Resources ID（联合资源数据库） AllianceGenome Alliance Genome 注释（也可能重复 agr） 药物相关\n字段名 含义 chembl ChEMBL 中的药物靶点信息 unii FDA UNII（药物成分唯一标识符） 网络资源 字段名 含义 wikipedia Wikipedia 页面链接（如果有） map_location 染色体图谱位置，如 12q13.2（12号染色体长臂） generif GeneRIFs：简短文献注释，来自 PubMed 摘要（Gene Reference Into Function） ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/054%E5%9F%BA%E5%9B%A0-%E8%9B%8B%E7%99%BD-%E5%8C%96%E5%90%88%E7%89%A9id%E8%BD%AC%E6%8D%A2/","summary":"\u003ch1 id=\"1不同基因id转换\"\u003e1、不同基因ID转换\u003c/h1\u003e\n\u003ch2 id=\"11-orghsegdb包\"\u003e1.1 org.Hs.eg.db包\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(dplyr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(org.Hs.eg.db)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekeytypes(org.Hs.eg.db) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  [1] \u0026#34;ACCNUM\u0026#34;       \u0026#34;ALIAS\u0026#34;        \u0026#34;ENSEMBL\u0026#34;      \u0026#34;ENSEMBLPROT\u0026#34;  \u0026#34;ENSEMBLTRANS\u0026#34; \u0026#34;ENTREZID\u0026#34;    \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  [7] \u0026#34;ENZYME\u0026#34;       \u0026#34;EVIDENCE\u0026#34;     \u0026#34;EVIDENCEALL\u0026#34;  \u0026#34;GENENAME\u0026#34;     \u0026#34;GENETYPE\u0026#34;     \u0026#34;GO\u0026#34;          \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [13] \u0026#34;GOALL\u0026#34;        \u0026#34;IPI\u0026#34;          \u0026#34;MAP\u0026#34;          \u0026#34;OMIM\u0026#34;         \u0026#34;ONTOLOGY\u0026#34;     \u0026#34;ONTOLOGYALL\u0026#34; \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [19] \u0026#34;PATH\u0026#34;         \u0026#34;PFAM\u0026#34;         \u0026#34;PMID\u0026#34;         \u0026#34;PROSITE\u0026#34;      \u0026#34;REFSEQ\u0026#34;       \u0026#34;SYMBOL\u0026#34;      \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [25] \u0026#34;UCSCKG\u0026#34;       \u0026#34;UNIPROT\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_symbol=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RHO\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;CALM1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;MEG3\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GNGT1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SAG\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RPGRIP1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;TRPM1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;PCP2\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;PCP4\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;AP1B1\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_ids\u0026lt;-AnnotationDbi::select(org.Hs.eg.db, keys=as.character(gene_symbol), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                columns=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ENSEMBL\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ENTREZID\u0026#34;\u003c/span\u003e), \u003cspan style=\"color:#007f7f\"\u003e#目标格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                keytype=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SYMBOL\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#目前的格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_ids\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##去重\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_ids %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::distinct(ENTREZID, .keep_all = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eT\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     SYMBOL         ENSEMBL ENTREZID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1      RHO ENSG00000163914     6010\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2    CALM1 ENSG00000198668      801\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3     MEG3 ENSG00000214548    55384\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4    GNGT1 ENSG00000127928     2792\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5      SAG ENSG00000130561     6295\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6  RPGRIP1 ENSG00000092200    57096\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 7    TRPM1 ENSG00000134160     4308\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 8     PCP2 ENSG00000174788   126006\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 9     PCP4 ENSG00000183036     5121\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 10   AP1B1 ENSG00000100280      162\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"12-biomart包\"\u003e1.2 biomaRt包\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;biomaRt\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eensembl = useMart(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ensembl\u0026#34;\u003c/span\u003e,dataset=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hsapiens_gene_ensembl\u0026#34;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eattributes = listAttributes(ensembl)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eattributes[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# library(httr)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# httr::set_config(config(ssl_verifypeer = 0L))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_symbol=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RHO\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;CALM1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;MEG3\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GNGT1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SAG\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RPGRIP1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;TRPM1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;PCP2\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;PCP4\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;AP1B1\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_ids2 \u0026lt;- getBM(filters= \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hgnc_symbol\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    attributes= c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hgnc_symbol\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ensembl_gene_id\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;entrezgene_id\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    values = gene_symbol, mart= ensembl)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_ids2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2鼠源基因转为人类基因id\"\u003e2、鼠源基因转为人类基因ID\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emusGenes \u0026lt;- c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Hmmr\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Tlx3\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Cpeb4\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 方式1：直接大小写转换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etoupper(musGenes)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;HMMR\u0026#34;  \u0026#34;TLX3\u0026#34;  \u0026#34;CPEB4\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 方式2：通过biomaRt包（不稳定）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erequire(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;biomaRt\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# library(httr)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# httr::set_config(config(ssl_verifypeer = 0L))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehuman = useMart(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ensembl\u0026#34;\u003c/span\u003e, dataset = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hsapiens_gene_ensembl\u0026#34;\u003c/span\u003e,host = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dec2021.archive.ensembl.org\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emouse = useMart(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ensembl\u0026#34;\u003c/span\u003e, dataset = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mmusculus_gene_ensembl\u0026#34;\u003c/span\u003e,host = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dec2021.archive.ensembl.org\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes = getLDS(attributes = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mgi_symbol\u0026#34;\u003c/span\u003e), filters = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mgi_symbol\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               values = musGenes, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               mart = mouse, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               attributesL = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hgnc_symbol\u0026#34;\u003c/span\u003e), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               martL = human, uniqueRows=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eT\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 方式3：MGI 数据库\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# https://support.bioconductor.org/p/129636/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(dplyr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emouse_human_genes = read.csv(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;http://www.informatics.jax.org/downloads/reports/HOM_MouseHumanSequence.rpt\u0026#34;\u003c/span\u003e,sep=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\\t\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econvert_mouse_to_human \u0026lt;- \u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(gene_list){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  output = c()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e(gene \u003cspan style=\"color:#fff;font-weight:bold\"\u003ein\u003c/span\u003e gene_list){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    class_key = (mouse_human_genes %\u0026gt;% filter(Symbol == gene \u0026amp; Common.Organism.Name==\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mouse, laboratory\u0026#34;\u003c/span\u003e))[[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;DB.Class.Key\u0026#39;\u003c/span\u003e]]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e(!identical(class_key, integer(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)) ){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      human_genes = (mouse_human_genes %\u0026gt;% filter(DB.Class.Key == class_key \u0026amp; Common.Organism.Name==\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;human\u0026#34;\u003c/span\u003e))[,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Symbol\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e(human_gene \u003cspan style=\"color:#fff;font-weight:bold\"\u003ein\u003c/span\u003e human_genes){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        output = append(output,human_gene)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e (output)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econvert_mouse_to_human(musGenes)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1] \u0026#34;HMMR\u0026#34;  \u0026#34;TLX3\u0026#34;  \u0026#34;CPEB4\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # https://github.com/lishensuo/utils\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# library(\u0026#34;biomaRt\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # library(httr)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # httr::set_config(config(ssl_verifypeer = 0L))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# human = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;hsapiens_gene_ensembl\u0026#34;,host = \u0026#34;dec2021.archive.ensembl.org\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# mouse = useMart(\u0026#34;ensembl\u0026#34;, dataset = \u0026#34;mmusculus_gene_ensembl\u0026#34;,host = \u0026#34;dec2021.archive.ensembl.org\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # https://www.gencodegenes.org/mouse/\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dat = data.table::fread(\u0026#34;gencode.vM33.basic.annotation.gtf.gz\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dat = subset(dat, V3 == \u0026#34;gene\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dat_sub = dat[,\u0026#34;V9\u0026#34;] %\u0026gt;% \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   separate(V9, into = c(\u0026#34;gene_id\u0026#34;,\u0026#34;gene_type\u0026#34;,\u0026#34;gene_name\u0026#34;,\u0026#34;mgi_id\u0026#34;,\u0026#34;havana_gene\u0026#34;), sep = \u0026#34;; \u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dat_sub$gene_name2 = gsub(\u0026#39;gencode.vM33.basic.annotation.gtf.gz \u0026#34;\u0026#39;,\u0026#39;\u0026#39;,dat_sub$gene_name)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dat_sub$gene_name2 = gsub(\u0026#39;\u0026#34;\u0026#39;,\u0026#39;\u0026#39;,dat_sub$gene_name2)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# genes = getLDS(attributes = c(\u0026#34;mgi_symbol\u0026#34;), filters = \u0026#34;mgi_symbol\u0026#34;, \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                values = dat_sub$gene_name2, \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                mart = mouse, \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                attributesL = c(\u0026#34;hgnc_symbol\u0026#34;), \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                martL = human, uniqueRows=T)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# write.csv(genes, file = \u0026#34;mgi2hgnc_biomart.csv\u0026#34;, row.names = F, quote = F)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# head(genes)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3蛋白质与基因id转换\"\u003e3、蛋白质与基因ID转换\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.uniprot.org/uploadlists/\"\u003ehttps://www.uniprot.org/uploadlists/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220528214617188.png\" alt=\"image-20220528214617188\"  /\u003e\r\n\u003c/p\u003e","title":"基因-蛋白-化合物ID转换"},{"content":"以前通路富集分析直接使用clusterprofiler包，阅读文献发现GSEA分析及可视化较多使用Broad团队研发的工具，现简要学习其(window版本)使用方法。\n软件及示例数据下载：https://www.gsea-msigdb.org/gsea/index.jsp\n初始论文：https://www.pnas.org/content/102/43/15545 2005\n官方手册：https://www.gsea-msigdb.org/gsea/doc/GSEAUserGuideFrame.html\n视频教程：https://www.youtube.com/watch?v=KY6SS4vRchY (推荐)\n1、数据准备 GSEA分析需要两大类数据：两组样本的表达矩阵，通路基因集\n对于array芯片表达矩阵，一般已进行标准化处理；对于RNA-seq的count表达矩阵，可使用DESeq2包进行样本间标准化处理。\n为方便后续分析，需将基因ID转为symbol格式\n如下以airway包的RNAseq原始count表达矩阵为例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # BiocManager::install(\u0026#34;airway\u0026#34;) library(tidyverse) library(airway) data(airway) exp=assay(airway) class(exp) # [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34; dim(exp) # [1] 64102 8 exp[1:4,1:4] ## ID转换 library(org.Hs.eg.db) gene_ids = AnnotationDbi::select(org.Hs.eg.db, keys=rownames(exp), columns=c(\u0026#34;SYMBOL\u0026#34;), keytype=\u0026#34;ENSEMBL\u0026#34;) gene_ids = gene_ids %\u0026gt;% dplyr::distinct(ENSEMBL, .keep_all = T) %\u0026gt;% dplyr::distinct(SYMBOL, .keep_all = T) %\u0026gt;% na.omit() exp = exp[match(gene_ids$ENSEMBL, rownames(exp)),] exp[1:4,1:4] rownames(exp) = gene_ids$SYMBOL exp[1:4,1:4] ## 分组信息 meta = colData(airway)[,3,drop=F] %\u0026gt;% as.data.frame() %\u0026gt;% dplyr::arrange(dex) colnames(meta) = \u0026#34;Group\u0026#34; exp = exp[, rownames(meta)] identical(colnames(exp), rownames(meta)) （1）表达矩阵导出为gct格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 library(DESeq2) dds \u0026lt;- DESeqDataSetFromMatrix(countData = exp, colData = meta, design=~Group) dds \u0026lt;- DESeq(dds) norm_counts \u0026lt;- counts(dds, normalized = T) %\u0026gt;% as.data.frame() %\u0026gt;% tibble::rownames_to_column(\u0026#34;NAME\u0026#34;) %\u0026gt;% dplyr::mutate(description=NAME, .before=2) norm_counts[1:4,1:4] # NAME description SRR1039509 SRR1039513 # 1 TSPAN6 TSPAN6 500.2045 610.3226 # 2 TNMD TNMD 0.0000 0.0000 # 3 DPM1 DPM1 575.0119 545.9994 # 4 SCYL3 SCYL3 235.5874 245.3257 fid \u0026lt;- \u0026#34;norm_counts.gct\u0026#34; writeLines(c(\u0026#34;#1.2\u0026#34;, paste(nrow(norm_counts), ncol(norm_counts) - 2, collapse=\u0026#34;\\t\u0026#34;)), fid, sep=\u0026#34;\\n\u0026#34;) write.table(norm_counts, fid, sep = \u0026#34;\\t\u0026#34;, quote = F, row.names = F, append = TRUE) （2）分组信息导出为cls格式 1 2 3 4 5 fid \u0026lt;- \u0026#34;norm_counts.cls\u0026#34; writeLines(c(paste(nrow(meta), length(unique(meta$Group)), 1), paste(\u0026#34;#\u0026#34;, unique(meta$Group)[1], unique(meta$Group)[2]), paste(as.character(meta$Group), collapse = \u0026#34; \u0026#34;)), fid, sep=\u0026#34;\\n\u0026#34;) （3）通路集gmt格式 GSEA软件提供了msigdb的8类通路基因集(symbol ID的gmt格式)，可直接使用 如需提供自定义的基因集，也需要储存为gmt格式 1 2 3 4 5 6 7 8 9 10 11 12 13 pw_gene = clusterProfiler::read.gmt(\u0026#34;h.all.v7.5.1.symbols.gmt\u0026#34;) pw_gene.list = split(pw_gene$gene, pw_gene$term) lapply(seq(pw_gene.list), function(i){ # i = 1 pw_name = names(pw_gene.list)[i] pw_gene = pw_gene.list[[i]] pw_sle = paste(pw_name,pw_name, paste(pw_gene, collapse = \u0026#34; \u0026#34;), collapse = \u0026#34; \u0026#34;) return(pw_sle) }) %\u0026gt;% unlist %\u0026gt;% writeLines(., \u0026#34;test.gmt\u0026#34;, sep=\u0026#34;\\n\u0026#34;) 2、分析步骤 （1）加载数据 gct表达矩阵 cls表型分组信息 gmt通路基因集(optional) （2）GSEA分析 Expression dataset 选择对应的gct表达矩阵 Gene sets database 选择工具自提供的msigdb通路集(Hallmark) Phenotype labels 选择组间比较方式 Collapse/Remap to gene symbols 由于已设置gene ID，选择 No_Collapse Permutation type 在样本量较少的情况下选择 gene_set Analysis name 设置本次GSEA分析的任务名 其余参数一般保持默认即可 最后执行分析Run按钮，等待左侧状态变为Success，点击查看结果。 3、分析结果 点击完成状态按钮，进入分析结果报告，可查看每组的相对GSEA富集通路详情与可视化； 红色箭头标注的文件地址是本次分析结果所有文件的储存路径，方便查看。 所有通路的显著富集结果 指定通路的可视化 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/055gsea%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/","summary":"\u003cp\u003e以前通路富集分析直接使用clusterprofiler包，阅读文献发现GSEA分析及可视化较多使用Broad团队研发的工具，现简要学习其(window版本)使用方法。\u003c/p\u003e","title":"GSEA富集分析工具"},{"content":"1、背景知识 （1）两种富集分析 基于超几何检验的ORA(over representation analysis)富集分析 ① 假设对转录组分组测序的10000个基因表达数据进行差异分析；\n② 按照规定cutoff阈值(logFC/Pvalue)筛选得到100个差异表达基因；\n③ 对于特定通路，包含500个基因；其中有30个属于差异基因\n④ 差异基因是否富集到该通路，即表示30/70与470/9430相比，是否具有显著意义。\n1 2 3 4 # 如上公式：N=10000，M=500，n=100，k=30 d \u0026lt;- data.frame(non_DEG=c(470, 9430), DEG=c(30, 70)) row.names(d) \u0026lt;- c(\u0026#34;In set\u0026#34;, \u0026#34;not in category\u0026#34;) fisher.test(d, alternative = \u0026#34;less\u0026#34;) 如上计算结果，p值越小(\u0026lt;0.05)，说明得到的差异基因是显著富集到这个通路基因集上的。然后就可以这个基因集的生物学意义讲述后续的故事了。\n基于置换检验的GSEA(gene set enrichment analysis)富集分析 ① 假设对转录组分组测序的10000个基因表达数据进行差异分析，一般按照差异倍数从高到低进行排序；\n② 假设对于包含500个基因的特定通路，遍历上述10000个基因的排序列表；\n③ 在遍历过程中，如基因属于通路集则加分(hit)，不属于则减分；加减分的权重与差异倍数先关。\n④ ES(enrichment score)表示遍历过程中产生的绝对值最大值。ES大于0，表明通路集富集到排序列表的顶部；反之则富集到排序列表的底部。\n⑤ 随机选择500个基因若干次，计算ES背景分布，从而计算相应的P值。\n（2）通路基因集 常见的通路基因集包括GO、KEGG、Reactome等。MsigDB数据库则综合收集了多种通路基因集。4\nGO\nGene Ontology 基因本体论 http://www.geneontology.org/ GO 分别定义了三种类型的基因集：①细胞组成（cellular component，CC）；②生物过程（biological process，BP）；③分子功能（Molecular Function，MF）。详见http://geneontology.org/docs/ontology-documentation/ 举个例子来说：基因A(其蛋白产物是cytochrome c(细胞色素c)），该基因的具有氧化还原活性（molecular function）；参与氧化磷酸化生物学过程(molecular function)；而发挥作用的位置位于细胞线粒体基质(cellular component) KEGG\nKyoto Encyclopedia of Genes and Genomes 京都基因与基因组百科全书 https://www.genome.jp/kegg/ KEGG是系统分析基因功能，联系基因组信息和功能信息，以探索分子相互作用和反应网络的知识库（人工绘制）,其中包含有大量的通路（PATHWAY）图，涉及metabolism, genetic and environmental information processing, cellular processes, organismal systems, human diseases, and drug development七大类。 Reactome https://reactome.org/\nWikiPathway https://www.wikipathways.org/\nMsigdb\nMolecular Signatures Database 分子特征数据库 https://www.gsea-msigdb.org/gsea/msigdb/index.jsp 截止目前该数据库收集有32284个基因集，可分为9大类 \u0026mdash; H: hallmark gene sets，C1: positional gene sets，C2: curated gene sets，C3: regulatory target gene sets，C4: computational gene sets，C5: ontology gene sets，C6: oncogenic signature gene sets，C7: immunologic signature gene sets，C8: cell type signature gene sets 此外还有其它类型通路基因集，例如疾病基因集DO，就不一一列举了。\n（3）clusterProfiler包 R包clusterProfiler由南方医科大学余光创团队开发，是一个常用的富集分析工具包，目前已更新到4.x系列版本。该包包含了富集分析相关的方方面面函数功能，从上游分析到下游可视化等一应俱全。后续笔记主要参考官方教程学习该包的基础用法。\nDOI: 10.1016/j.xinn.2021.100141 Tutorial：https://yulab-smu.top/biomedical-knowledge-mining-book/index.html 2、富集分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 加载包 library(tidyverse) library(clusterProfiler) library(org.Hs.eg.db) ## 示例基因数据 # (1) 降序差异基因列表用于GSEA分析 data(geneList, package=\u0026#34;DOSE\u0026#34;) str(geneList) # Named num [1:12495] 4.57 4.51 4.42 4.14 3.88 ... # - attr(*, \u0026#34;names\u0026#34;)= chr [1:12495] \u0026#34;4312\u0026#34; \u0026#34;8318\u0026#34; \u0026#34;10874\u0026#34; \u0026#34;55143\u0026#34; ... gene_list = geneList # (2) 显著差异基因集用于ORA分析 gene_deg = names(geneList)[abs(geneList) \u0026gt; 2] head(gene_deg) # [1] \u0026#34;4312\u0026#34; \u0026#34;8318\u0026#34; \u0026#34;10874\u0026#34; \u0026#34;55143\u0026#34; \u0026#34;55388\u0026#34; \u0026#34;991\u0026#34; 需要使用ENTREZID的基因ID。如果是其它格式，可使用clusterProfiler::bitr()函数或者之前笔记提到的方式进行转换。\n1 2 3 4 5 6 7 8 9 10 keytypes(org.Hs.eg.db) # [1] \u0026#34;ACCNUM\u0026#34; \u0026#34;ALIAS\u0026#34; \u0026#34;ENSEMBL\u0026#34; \u0026#34;ENSEMBLPROT\u0026#34; \u0026#34;ENSEMBLTRANS\u0026#34; # [6] \u0026#34;ENTREZID\u0026#34; \u0026#34;ENZYME\u0026#34; \u0026#34;EVIDENCE\u0026#34; \u0026#34;EVIDENCEALL\u0026#34; \u0026#34;GENENAME\u0026#34; # [11] \u0026#34;GENETYPE\u0026#34; \u0026#34;GO\u0026#34; \u0026#34;GOALL\u0026#34; \u0026#34;IPI\u0026#34; \u0026#34;MAP\u0026#34; # [16] \u0026#34;OMIM\u0026#34; \u0026#34;ONTOLOGY\u0026#34; \u0026#34;ONTOLOGYALL\u0026#34; \u0026#34;PATH\u0026#34; \u0026#34;PFAM\u0026#34; # [21] \u0026#34;PMID\u0026#34; \u0026#34;PROSITE\u0026#34; \u0026#34;REFSEQ\u0026#34; \u0026#34;SYMBOL\u0026#34; \u0026#34;UCSCKG\u0026#34; # [26] \u0026#34;UNIPROT\u0026#34; ids \u0026lt;- bitr(x, fromType=\u0026#34;SYMBOL\u0026#34;, toType=\u0026#34;ENTREZID\u0026#34;, OrgDb=\u0026#34;org.Hs.eg.db\u0026#34;) （1）GO ORA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ego \u0026lt;- enrichGO(gene = gene_deg, OrgDb = org.Hs.eg.db, ont = \u0026#34;CC\u0026#34;, # \u0026#34;BP\u0026#34;,\u0026#34;MF\u0026#34;,\u0026#34;ALL\u0026#34; pAdjustMethod = \u0026#34;BH\u0026#34;, pvalueCutoff = 0.01, qvalueCutoff = 0.05, readable = TRUE) t(ego@result[1,]) # GO:0005819 # ID \u0026#34;GO:0005819\u0026#34; # Description \u0026#34;spindle\u0026#34; # GeneRatio \u0026#34;26/201\u0026#34; # BgRatio \u0026#34;426/19869\u0026#34; # pvalue \u0026#34;2.149144e-13\u0026#34; # p.adjust \u0026#34;6.339976e-11\u0026#34; # qvalue \u0026#34;5.610398e-11\u0026#34; # geneID \u0026#34;CDCA8/CDC20/KIF23/CENPE/ASPM/DLGAP5/SKA1/NUSAP1/TPX2/TACC3/NEK2/CDK1/MAD2L1/KIF18A/BIRC5/KIF11/TRAT1/TTK/AURKB/PRC1/KIFC1/KIF18B/KIF20A/AURKA/CCNB1/KIF4A\u0026#34; # Count \u0026#34;26\u0026#34; ## *补充：如果输入基因集是SYMBOL格式，可以设置参数keyType = \u0026#34;SYMBOL\u0026#34;直接分析。但只有GO支持。 GO 去冗余 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ## (1) GOSemSim包可以计算GO term相似度 library(GOSemSim) hsGO \u0026lt;- godata(\u0026#39;org.Hs.eg.db\u0026#39;, ont=\u0026#34;MF\u0026#34;) goSim(\u0026#34;GO:0004022\u0026#34;, \u0026#34;GO:0005515\u0026#34;, semData=hsGO, measure=\u0026#34;Jiang\u0026#34;) go1 = c(\u0026#34;GO:0004022\u0026#34;,\u0026#34;GO:0004024\u0026#34;,\u0026#34;GO:0004174\u0026#34;) go2 = c(\u0026#34;GO:0009055\u0026#34;,\u0026#34;GO:0005515\u0026#34;) mgoSim(go1, go2, semData=hsGO, measure=\u0026#34;Wang\u0026#34;, combine=NULL) # pair mgoSim(go1, go2, semData=hsGO, measure=\u0026#34;Wang\u0026#34;, combine=\u0026#34;BMA\u0026#34;) # whole # 基因(set)相似度 GOSemSim::geneSim(\u0026#34;241\u0026#34;, \u0026#34;251\u0026#34;, semData=hsGO, measure=\u0026#34;Wang\u0026#34;, combine=\u0026#34;BMA\u0026#34;) mgeneSim(genes=c(\u0026#34;835\u0026#34;, \u0026#34;5261\u0026#34;,\u0026#34;241\u0026#34;, \u0026#34;994\u0026#34;), semData=hsGO, measure=\u0026#34;Wang\u0026#34;,verbose=FALSE) # pair-wise gs1 \u0026lt;- c(\u0026#34;835\u0026#34;, \u0026#34;5261\u0026#34;,\u0026#34;241\u0026#34;, \u0026#34;994\u0026#34;, \u0026#34;514\u0026#34;, \u0026#34;533\u0026#34;) gs2 \u0026lt;- c(\u0026#34;578\u0026#34;,\u0026#34;582\u0026#34;, \u0026#34;400\u0026#34;, \u0026#34;409\u0026#34;, \u0026#34;411\u0026#34;) clusterSim(gs1, gs2, semData=hsGO, measure=\u0026#34;Wang\u0026#34;, combine=\u0026#34;BMA\u0026#34;) mclusterSim(list(gs1, gs2, gs3), semData=hsGO, measure=\u0026#34;Wang\u0026#34;, combine=\u0026#34;BMA\u0026#34;) ## (2) 富集结果去冗余 dim(ego) # [1] 23 9 ego_sim \u0026lt;- clusterProfiler::simplify(ego, cutoff=0.7, measure = \u0026#34;Wang\u0026#34;, by=\u0026#34;p.adjust\u0026#34;, select_fun=min) dim(ego_sim) # [1] 8 9 # 同样也支持对GSEA结果的去冗余处理 GSEA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ## GSEA gseago \u0026lt;- gseGO(geneList = gene_list, OrgDb = org.Hs.eg.db, ont = \u0026#34;CC\u0026#34;, minGSSize = 100, maxGSSize = 500, pvalueCutoff = 0.05, verbose = FALSE) gseago = setReadable(gseago, OrgDb = org.Hs.eg.db) t(gseago@result[1,]) # GO:0000775 # ID \u0026#34;GO:0000775\u0026#34; # Description \u0026#34;chromosome, centromeric region\u0026#34; # setSize \u0026#34;188\u0026#34; # enrichmentScore \u0026#34;0.5970689\u0026#34; # NES \u0026#34;2.676869\u0026#34; # pvalue \u0026#34;1e-10\u0026#34; # p.adjust \u0026#34;1.62e-09\u0026#34; # qvalue \u0026#34;1.021053e-09\u0026#34; # rank \u0026#34;530\u0026#34; # leading_edge \u0026#34;tags=20%, list=4%, signal=19%\u0026#34; # core_enrichment \u0026#34;CDCA8/CENPE/NDC80/TOP2A/HJURP/SKA1/NEK2/CENPM/CENPN/ERCC6L/MAD2L1/KIF18A/CDT1/BIRC5/EZH2/TTK/NCAPG/AURKB/CCNB1/KIF2C/PLK1/BUB1B/ZWINT/CENPU/SPC25/SPAG5/DSCC1/CENPI/OIP5/HELLS/NCAPD2/CENPA/BUB1/CENPF/ZWILCH/CEBPB/H2BC11\u0026#34; （2）KEGG ORA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # R.utils::setOption(\u0026#34;clusterProfiler.download.method\u0026#34;,\u0026#34;auto\u0026#34;) ekg \u0026lt;- enrichKEGG(gene = gene_deg, organism = \u0026#39;hsa\u0026#39;, pvalueCutoff = 0.05) ekg \u0026lt;- setReadable(ekg, OrgDb = org.Hs.eg.db, keyType = \u0026#34;ENTREZID\u0026#34;) t(ekg@result[1,]) # hsa04110 # ID \u0026#34;hsa04110\u0026#34; # Description \u0026#34;Cell cycle\u0026#34; # GeneRatio \u0026#34;11/94\u0026#34; # BgRatio \u0026#34;127/8218\u0026#34; # pvalue \u0026#34;1.809545e-07\u0026#34; # p.adjust \u0026#34;3.781948e-05\u0026#34; # qvalue \u0026#34;3.695281e-05\u0026#34; # geneID \u0026#34;CDC45/CDC20/CCNB2/CCNA2/CDK1/MAD2L1/TTK/CHEK1/CCNB1/MCM5/PTTG1\u0026#34; # Count \u0026#34;11\u0026#34; browseKEGG(ekg, \u0026#39;hsa04110\u0026#39;) library(\u0026#34;pathview\u0026#34;) pathview(gene.data = gene_list, pathway.id = \u0026#34;hsa04110\u0026#34;, species = \u0026#34;hsa\u0026#34;, limit = list(gene=max(abs(geneList)), cpd=1)) 当出现报错类似于No gene can be mapped when using enrichKEGG，且检查输入基因无误后，一个可能的解决方案是自己构建本地KEGG数据库。参考https://github.com/YuLab-SMU/clusterProfiler/issues/561中undo6411解答。或者也可以直接从MsigDB数据库下载，再使用GSEA()函数。\nGSEA 1 2 3 4 5 6 7 gseakg \u0026lt;- gseKEGG(geneList = gene_list, organism = \u0026#39;hsa\u0026#39;, minGSSize = 120, pvalueCutoff = 0.05, verbose = FALSE) gseakg \u0026lt;- setReadable(gseakg, OrgDb = org.Hs.eg.db, keyType = \u0026#34;ENTREZID\u0026#34;) t(gseakg@result[1,]) 针对其它通路集的富集分析函数\n通路集 ORA函数 GSEA函数 WikiPathway enrichWP gseWP Reactome enrichPathway gsePathway DO(disease ontology) enrichDO gseDO NCG(Network of Cancer Gene) enrichNCG gseNCG DisGeNET(disease gene network) enrichDGN gseDGN Mesh(医学主题词) enrichMeSH gseMeSH （3）自定义基因集 clusterProfiler包提供的enricher()与GSEA()函数可实现对自定义基因集进行富集分析 主要通过TERM2GENE参数提供基因集数据框，一列名为term代表通路名；一列为gene代表组成基因 如下以MsigDB数据库为例，学习用法。该库的详细介绍参见笔记 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # install.packages(\u0026#34;msigdbr\u0026#34;) library(msigdbr) hm_df = msigdbr(species = \u0026#34;Homo sapiens\u0026#34;) %\u0026gt;% as.data.frame() head(hm_df) colnames(hm_df) # [1] \u0026#34;gs_cat\u0026#34; \u0026#34;gs_subcat\u0026#34; \u0026#34;gs_name\u0026#34; \u0026#34;gene_symbol\u0026#34; # [5] \u0026#34;entrez_gene\u0026#34; \u0026#34;ensembl_gene\u0026#34; \u0026#34;human_gene_symbol\u0026#34; \u0026#34;human_entrez_gene\u0026#34; # [9] \u0026#34;human_ensembl_gene\u0026#34; \u0026#34;gs_id\u0026#34; \u0026#34;gs_pmid\u0026#34; \u0026#34;gs_geoid\u0026#34; # [13] \u0026#34;gs_exact_source\u0026#34; \u0026#34;gs_url\u0026#34; \u0026#34;gs_description\u0026#34; unique(hm_df$gs_cat) # [1] \u0026#34;C3\u0026#34; \u0026#34;C2\u0026#34; \u0026#34;C8\u0026#34; \u0026#34;C6\u0026#34; \u0026#34;C7\u0026#34; \u0026#34;C4\u0026#34; \u0026#34;C1\u0026#34; \u0026#34;C5\u0026#34; \u0026#34;H\u0026#34; unique(hm_df$gs_subcat) # [1] \u0026#34;MIR:MIR_Legacy\u0026#34; \u0026#34;TFT:TFT_Legacy\u0026#34; \u0026#34;CGP\u0026#34; \u0026#34;TFT:GTRD\u0026#34; # [5] \u0026#34;\u0026#34; \u0026#34;VAX\u0026#34; \u0026#34;CP:BIOCARTA\u0026#34; \u0026#34;CGN\u0026#34; # [9] \u0026#34;GO:BP\u0026#34; \u0026#34;GO:CC\u0026#34; \u0026#34;IMMUNESIGDB\u0026#34; \u0026#34;GO:MF\u0026#34; # [13] \u0026#34;HPO\u0026#34; \u0026#34;CP:KEGG\u0026#34; \u0026#34;MIR:MIRDB\u0026#34; \u0026#34;CM\u0026#34; # [17] \u0026#34;CP\u0026#34; \u0026#34;CP:PID\u0026#34; \u0026#34;CP:REACTOME\u0026#34; \u0026#34;CP:WIKIPATHWAYS\u0026#34; hm_H = msigdbr(species = \u0026#34;Homo sapiens\u0026#34;, category = \u0026#34;H\u0026#34;, subcategory = NULL) %\u0026gt;% as.data.frame() %\u0026gt;% dplyr::select(gs_cat, gs_subcat, gs_name, gene_symbol) hm_H = hm_H %\u0026gt;% dplyr::select(gs_name, gene_symbol) %\u0026gt;% dplyr::rename(\u0026#34;term\u0026#34; = \u0026#34;gs_name\u0026#34;, \u0026#34;gene\u0026#34; = \u0026#34;gene_symbol\u0026#34;) head(hm_H) # term gene # 1 HALLMARK_ADIPOGENESIS ABCA1 # 2 HALLMARK_ADIPOGENESIS ABCB8 # 3 HALLMARK_ADIPOGENESIS ACAA2 # 4 HALLMARK_ADIPOGENESIS ACADL # 5 HALLMARK_ADIPOGENESIS ACADM # 6 HALLMARK_ADIPOGENESIS ACADS 富集分析 1 2 3 4 5 6 7 8 9 10 # 注意上述选择的是Symbol格式基因，输入基因也需要与之匹配 res_go \u0026lt;- enricher(gene_deg2, TERM2GENE = hm_H) dim(res_go) dim(res_go@result) res_go_df = res_go@result res_gsea \u0026lt;- GSEA(gene_list2, TERM2GENE = hm_H) dim(res_gsea) dim(res_gsea@result) res_gsea_df = res_gsea@result 3、可视化 以上面分析的ego与gseago为例 1 2 library(enrichplot) # 除第一个barplot函数，其余均基于ggplot绘图体系 （1）柱状图/点图 1 2 3 4 5 6 7 8 9 ## barplot (R基础函数) barplot(ego, showCategory=10) # 指定GO通路集 pw2show = c(\u0026#34;GO:0005819\u0026#34;,\u0026#34;GO:0072686\u0026#34;,\u0026#34;GO:0098687\u0026#34;,\u0026#34;GO:0000779\u0026#34;) barplot(ego, showCategory=ego@result$Description[which(rownames(ego@result) %in% pw2show)]) # 针对ont = \u0026#34;ALL\u0026#34;的情况 barplot(ego, split = \u0026#34;ONTOLOGY\u0026#34;) + facet_grid(ONTOLOGY~., scale = \u0026#34;free\u0026#34;) 1 2 3 4 5 dotplot(ego) ## 默认如下对应关系,可设置参数修改这些关系： # 颜色映射P值 # 大小映射交集基因数(差异基因与通路基因集) # 横轴表示比例(count/geneset) 1 2 edox \u0026lt;- pairwise_termsim(ego) treeplot(edox, cluster.params = list(method=\u0026#34;ward.D\u0026#34;, n = 4, label_words_n = 2)) （2）GSEA打分 单个通路GSEA 1 2 3 4 5 gseaplot(gseago, geneSetID = 1, title = gseago$Description[1]) # by = \u0026#34;preranked\u0026#34;只展示上半部分 # by = \u0026#34;runningScore\u0026#34;只展示下半部分 多条通路结果 1 2 3 gseaplot2(gseago, geneSetID = 1:3, pvalue_table = T) （3）通路与基因 热图 1 2 3 heatplot(ego, foldChange=gene_list, showCategory = 5) 网络图 1 2 3 4 5 6 library(patchwork) p1 = cnetplot(ego, foldChange=gene_list,showCategory = 3) p2 = cnetplot(ego, foldChange=gene_list,showCategory = 3, circular = T) p3 = cnetplot(ego, foldChange=gene_list,showCategory = 3, colorEdge = T, node_label=\u0026#34;gene\u0026#34;) p4 = cnetplot(ego, foldChange=gene_list,showCategory = 3, layout = \u0026#34;gem\u0026#34;) (p1 + p2) / (p3 + p4) （4）通路与通路 1 2 3 4 5 ego_pair \u0026lt;- enrichplot::pairwise_termsim(ego) emapplot(ego_pair, showCategory = 15, layout=\u0026#34;kk\u0026#34;, cex_category=1.5,min_edge = 0.8) gseago_pair \u0026lt;- enrichplot::pairwise_termsim(gseago) emapplot(gseago_pair, showCategory = 15, layout=\u0026#34;kk\u0026#34;, min_edge = 0.1, color = \u0026#34;NES\u0026#34;) 4、多基因集分析 clusterProfiler包的compareCluster()函数提供了针对多组实验设计得到的若干差异基因列表的同时富集分析(ORA)结果，及友好的可视化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## (1) 直接多基因集的富集通路比较 data(gcSample) str(gcSample[5:8]) #取后4个差异基因列表做演示 # List of 4 # $ X5: chr [1:929] \u0026#34;5982\u0026#34; \u0026#34;7318\u0026#34; \u0026#34;6352\u0026#34; \u0026#34;2101\u0026#34; ... # $ X6: chr [1:585] \u0026#34;5337\u0026#34; \u0026#34;9295\u0026#34; \u0026#34;4035\u0026#34; \u0026#34;811\u0026#34; ... # $ X7: chr [1:582] \u0026#34;2621\u0026#34; \u0026#34;2665\u0026#34; \u0026#34;5690\u0026#34; \u0026#34;3608\u0026#34; ... # $ X8: chr [1:237] \u0026#34;2665\u0026#34; \u0026#34;4735\u0026#34; \u0026#34;1327\u0026#34; \u0026#34;3192\u0026#34; ... ## 两个主要参数 # 多个差异基因列表 # 富集分析method (One of \u0026#34;groupGO\u0026#34;, \u0026#34;enrichGO\u0026#34;, \u0026#34;enrichKEGG\u0026#34;, \u0026#34;enrichDO\u0026#34; or \u0026#34;enrichPathway\u0026#34;) ck \u0026lt;- compareCluster(geneCluster = gcSample[5:8], fun = enrichKEGG) ck \u0026lt;- setReadable(ck, OrgDb = org.Hs.eg.db, keyType=\u0026#34;ENTREZID\u0026#34;) table(ck@compareClusterResult$Cluster) # X5 X6 X7 X8 # 10 1 15 19 dotplot(ck) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## (2) 假如分别用两种药物A、B进行干扰细胞系，经1h、3h后得到4组差异基因 group_A_1h=gcSample[[2]] group_A_3h=gcSample[[3]] group_B_1h=gcSample[[4]] group_B_3h=gcSample[[5]] design=c(rep(\u0026#34;A_1h\u0026#34;,length(group_A_1h)), rep(\u0026#34;A_3h\u0026#34;,length(group_A_3h)), rep(\u0026#34;B_1h\u0026#34;,length(group_B_1h)), rep(\u0026#34;B_3h\u0026#34;,length(group_B_3h))) mydf = data.frame(Drug = stringr::str_split(design,\u0026#34;_\u0026#34;,simplify = T)[,1], Time = stringr::str_split(design,\u0026#34;_\u0026#34;,simplify = T)[,2], DEG = c(group_A_1h,group_A_3h,group_B_1h,group_B_3h)) # Drug Time DEG # 1 A 1h 23450 # 2 A 1h 5160 # 3 A 1h 7126 formula_res \u0026lt;- compareCluster(DEG~Time+Drug, data=mydf, fun=\u0026#34;enrichKEGG\u0026#34;) table(formula_res@compareClusterResult$Cluster) # 1h.A 1h.B 3h.A 3h.B # 3 18 3 10 dotplot(formula_res) + dotplot(formula_res, x=\u0026#34;Time\u0026#34;) + facet_grid(~Drug) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/056clusterprofiler%E5%8C%85%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003ch2 id=\"1背景知识\"\u003e1、背景知识\u003c/h2\u003e\n\u003ch3 id=\"1两种富集分析\"\u003e（1）两种富集分析\u003c/h3\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-2db430f93bc01a2d.png\" alt=\"img\" style=\"zoom: 33%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e基于超几何检验的ORA(over representation analysis)富集分析\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e① 假设对转录组分组测序的\u003cstrong\u003e10000\u003c/strong\u003e个基因表达数据进行差异分析；\u003c/p\u003e\n\u003cp\u003e② 按照规定cutoff阈值(logFC/Pvalue)筛选得到\u003cstrong\u003e100\u003c/strong\u003e个差异表达基因；\u003c/p\u003e","title":"clusterProfiler包富集分析与可视化"},{"content":"0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 library(clusterProfiler) library(org.Hs.eg.db) data(geneList, package=\u0026#34;DOSE\u0026#34;) str(geneList) # Named num [1:12495] 4.57 4.51 4.42 4.14 3.88 ... # - attr(*, \u0026#34;names\u0026#34;)= chr [1:12495] \u0026#34;4312\u0026#34; \u0026#34;8318\u0026#34; \u0026#34;10874\u0026#34; \u0026#34;55143\u0026#34; ... gene_ids\u0026lt;-AnnotationDbi::select(org.Hs.eg.db, keys=as.character(names(gene_list)), columns=\u0026#34;SYMBOL\u0026#34;, #目标格式 keytype=\u0026#34;ENTREZID\u0026#34;) #目前的格式 # \u0026#39;select()\u0026#39; returned 1:1 mapping between keys and columns ## ORA分析 gene_deg = names(geneList)[abs(geneList) \u0026gt; 2] ego \u0026lt;- enrichGO(gene = gene_deg, OrgDb = org.Hs.eg.db, ont = \u0026#34;CC\u0026#34;, # \u0026#34;BP\u0026#34;,\u0026#34;MF\u0026#34;,\u0026#34;ALL\u0026#34; pAdjustMethod = \u0026#34;BH\u0026#34;, pvalueCutoff = 0.01, qvalueCutoff = 0.05, readable = TRUE) ## GSEA分析 gseago \u0026lt;- gseGO(geneList = geneList, OrgDb = org.Hs.eg.db, ont = \u0026#34;CC\u0026#34;, minGSSize = 100, maxGSSize = 500, pvalueCutoff = 0.05, verbose = FALSE) gseago = setReadable(gseago, OrgDb = org.Hs.eg.db) 1、ggplot2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ## ORA library(tidyverse) ego_df = ego@result %\u0026gt;% head(10) %\u0026gt;% dplyr::mutate(logp = -log10(p.adjust)) %\u0026gt;% dplyr::arrange(logp) %\u0026gt;% dplyr::mutate(Label=str_wrap(gsub(\u0026#34;_\u0026#34;,\u0026#34; \u0026#34;,Description), width = 50)) %\u0026gt;% dplyr::mutate(Label = factor(Label, levels=Label)) %\u0026gt;% tibble::remove_rownames() %\u0026gt;% dplyr::select(Label, logp) head(ego_df) # Label logp # 1 microtubule associated complex 5.419514 # 2 spindle midzone 5.681085 # 3 spindle microtubule 7.341138 ggplot(ego_df, aes(x=Label, y=logp)) + geom_bar(stat=\u0026#34;identity\u0026#34;, fill=\u0026#34;#1b9e77\u0026#34;) + xlab(\u0026#34;Pathway names\u0026#34;) + ylab(\u0026#34;-log10(P.adj)\u0026#34;) + scale_y_continuous(expand=c(0,0)) + coord_flip() + xlab(\u0026#34;GO Pathway\u0026#34;) + ylab(\u0026#34;Adjusted P value(-log10)\u0026#34;) + geom_text(aes(label = Label, y=0.2), hjust = 0, size=5) + theme_classic() + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), axis.title.y = element_text(size = 25), axis.title.x = element_text(size = 20), axis.text.x = element_text(size = 16)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## GSEA library(tidyverse) gseago_df = gseago@result %\u0026gt;% head(20) %\u0026gt;% dplyr::mutate(logp = -log10(p.adjust)) %\u0026gt;% dplyr::arrange(logp) %\u0026gt;% dplyr::mutate(Label=str_wrap(gsub(\u0026#34;_\u0026#34;,\u0026#34; \u0026#34;,Description), width = 50)) %\u0026gt;% dplyr::mutate(Label = factor(Label, levels=Label)) %\u0026gt;% tibble::remove_rownames() %\u0026gt;% dplyr::select(Label, logp, NES) head(gseago_df) # Label logp NES # 1 polymeric cytoskeletal fiber 3.755730 1.487284 # 2 chromosome, telomeric region 4.311816 1.907511 # 3 microtubule associated complex 4.432327 1.944046 ggplot(gseago_df, aes(NES, fct_reorder(Label, NES), fill=qvalue)) + geom_bar(stat=\u0026#39;identity\u0026#39;) + scale_fill_continuous(low=\u0026#39;red\u0026#39;, high=\u0026#39;blue\u0026#39;, guide=guide_colorbar(reverse=TRUE)) + theme_minimal() + ylab(NULL) 2、GOplot 官方教程：https://wencke.github.io/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # install.packages(\u0026#39;GOplot\u0026#39;) library(GOplot) # (1) 准备数据 ## 富集通路结果 res_enrich = ego@result %\u0026gt;% dplyr::select(ID, Description, geneID,p.adjust) %\u0026gt;% dplyr::mutate(Category = \u0026#34;GO\u0026#34;, .before=1) %\u0026gt;% dplyr::mutate(geneID = gsub(\u0026#34;/\u0026#34;,\u0026#34;, \u0026#34;, geneID)) %\u0026gt;% dplyr::rename(\u0026#34;Term\u0026#34;=\u0026#34;Description\u0026#34;, \u0026#34;Genes\u0026#34;=\u0026#34;geneID\u0026#34;, \u0026#34;adj_pval\u0026#34;=\u0026#34;p.adjust\u0026#34;) %\u0026gt;% dplyr::select(Category,ID,Term,Genes,adj_pval) %\u0026gt;% tibble::remove_rownames() t(res_enrich[1,]) # 1 # Category \u0026#34;GO\u0026#34; # ID \u0026#34;GO:0005819\u0026#34; # Term \u0026#34;spindle\u0026#34; # Genes \u0026#34;CDCA8, CDC20, KIF23, CENPE, ASPM, DLGAP5, SKA1, NUSAP1, TPX2, TACC3, NEK2, CDK1, MAD2L1, KIF18A, BIRC5, KIF11, TRAT1, TTK, AURKB, PRC1, KIFC1, KIF18B, KIF20A, AURKA, CCNB1, KIF4A\u0026#34; # adj_pval \u0026#34;6.339976e-11\u0026#34; ## 如上，ID为optional，Category为required ## (2) 基因差异倍数 res_logfc = data.frame(ID=gene_ids$SYMBOL, logFC=geneList) head(res_logfc) # ID logFC # 1 MMP1 4.572613 # 2 CDC45 4.514594 # 3 NMU 4.418218 ## 如无相关数据，可随便设置为0 ## (3) 构建绘图对象 circ \u0026lt;- circle_dat(res_enrich, res_logfc) head(circ) Circular visualization\n此种绘图方式，ID列为required\n1 2 GOCircle(circ, nsub = 10) # GOCircle(circ, nsub = 5) Chord visualization 1 2 3 4 5 6 7 8 ## 展示指定通路 pw_sle = ego@result$Description[1:4] ## 展示指定基因 gene_sle = res_logfc ## 构建绘图对象 gene_sle = res_logfc # chord \u0026lt;- chord_dat(data = circ, genes = gene_sle) # chord \u0026lt;- chord_dat(data = circ, process = pw_sle) 1 2 3 4 5 6 7 8 9 10 11 12 13 ## 含有差异倍数信息情况 GOChord(chord, limit = c(0, 0), # 第1个数：基因至少富集到0条通路 # 第2个数：基因至少富集到0条展示通路 space = 0.02, #基因矩形的间距 gene.order = \u0026#39;none\u0026#39;, process.label = 10, #legend字体大小 lfc.col = c(\u0026#34;red\u0026#34;,\u0026#34;gray\u0026#34;,\u0026#34;blue\u0026#34;), #映射差异倍数的颜色 ribbon.col=brewer.pal(length(pw_sle), \u0026#34;Set1\u0026#34;), #通路条带颜色 gene.space = 0.25, #基因名至圆的距离 gene.size = 3 # 基因名的大小 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 忽略差异倍数信息情况 GOChord(chord[,-1*ncol(chord)], nlfc = 0, limit = c(3, 3), # 第1个数：基因至少富集到3条通路 # 第2个数：基因至少富集到3条展示通路 space = 0.02, #基因矩形的间距 gene.order = \u0026#39;none\u0026#39;, process.label = 10, #legend字体大小 lfc.col = \u0026#34;red\u0026#34;, #映射差异倍数的颜色 ribbon.col=brewer.pal(length(pw_sle), \u0026#34;Set1\u0026#34;), #通路条带颜色 gene.space = 0.25, #基因名至圆的距离 gene.size = 3 # 基因名的大小 ) 3、aPEAR 参考：https://github.com/ievaKer/aPEAR， https://cran.r-project.org/web/packages/aPEAR/vignettes/aPEAR-vignette.html\n简介：该包可针对富集分析结果进行通路聚类，得到若干cluster，然后再进行网络图可视化。\n1 2 3 4 5 library(tidyverse) library(clusterProfiler) library(DOSE) library(org.Hs.eg.db) library(aPEAR) 该包的一个核心函数是enrichmentNetwork()，其需要的主要参数是表示富集分析的数据框。需要包含如下几列\nDescription：描述通路的含义；\npathwayGenes：通路的组成基因。\nit will be used to calculate the similarities between the pathways. It can be leading edge genes or the full gene list. The ID type (Ensembl, Gene symbol, etc.) does not matter but should be the same between all the pathways. The genes should be separated by “/”.\n通路富集程度的列，可以为P值；对于GSEA结果也可以是NES；\n通路基因数目的列。\n1 2 3 4 5 6 data(geneList) enrich \u0026lt;- gseGO(geneList, OrgDb = org.Hs.eg.db, ont = \u0026#39;CC\u0026#39;) enrich_df = enrich@result enrich_df2plot = enrich_df[,c(\u0026#34;Description\u0026#34;,\u0026#34;core_enrichment\u0026#34;,\u0026#34;NES\u0026#34;,\u0026#34;setSize\u0026#34;)] colnames(enrich_df2plot) = c(\u0026#34;Description\u0026#34;,\u0026#34;pathwayGenes\u0026#34;,\u0026#34;NES\u0026#34;,\u0026#34;Size\u0026#34;) 此外还有其它参数可以调整，包括聚类、颜色等\n计算通路相似度方法 simMethod = c(\u0026ldquo;jaccard\u0026rdquo;, \u0026ldquo;cosine\u0026rdquo;, \u0026ldquo;cor\u0026rdquo;) 聚类算法 clustMethod = c(\u0026ldquo;markov\u0026rdquo;, \u0026ldquo;hier\u0026rdquo;, \u0026ldquo;spectral\u0026rdquo;) 类别名 clustNameMethod = c(\u0026ldquo;pagerank\u0026rdquo;, \u0026ldquo;hits\u0026rdquo;, \u0026ldquo;none\u0026rdquo;) 筛选类-每类包含的最小通路数目 minClusterSize = 2 认为类别内/间，通路相似的阈值 innerCutoff/outerCutoff 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 set.seed(123) # 如果当前网络排版不理想，可以调整seed net.list= enrichmentNetwork(enrich_df2plot, simMethod = \u0026#34;jaccard\u0026#34;, clustMethod = \u0026#34;markov\u0026#34;, clustNameMethod = \u0026#34;pagerank\u0026#34;, minClusterSize = 5, innerCutoff = 0.1, outerCutoff = 0.5, drawEllipses = FALSE, fontSize = 3, repelLabels = FALSE, colorBy = \u0026#34;NES\u0026#34;, colorType = \u0026#34;nes\u0026#34;, # c(\u0026#34;nes\u0026#34;, \u0026#34;pval\u0026#34;) pCutoff = -10, # when colorType = \u0026#34;pval\u0026#34; nodeSize = \u0026#34;Size\u0026#34;, plotOnly = FALSE) net_cluster = net.list$clusters table(net_cluster$Cluster) # ciliary plasm condensed chromosome, centromeric region # 6 6 # external encapsulating structure mitotic spindle # 5 12 # postsynaptic specialization membrane vesicle lumen # 5 6 net.list$plot ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/057%E5%AF%8C%E9%9B%86%E9%80%9A%E8%B7%AF%E5%8F%AF%E8%A7%86%E5%8C%96%E6%96%B9%E5%BC%8F/","summary":"\u003ch2 id=\"0示例数据\"\u003e0、示例数据\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(clusterProfiler)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(org.Hs.eg.db)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(geneList, package=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;DOSE\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estr(geneList)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Named num [1:12495] 4.57 4.51 4.42 4.14 3.88 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# - attr(*, \u0026#34;names\u0026#34;)= chr [1:12495] \u0026#34;4312\u0026#34; \u0026#34;8318\u0026#34; \u0026#34;10874\u0026#34; \u0026#34;55143\u0026#34; ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_ids\u0026lt;-AnnotationDbi::select(org.Hs.eg.db, keys=as.character(names(gene_list)), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                columns=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SYMBOL\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#007f7f\"\u003e#目标格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                keytype=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ENTREZID\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#目前的格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026#39;select()\u0026#39; returned 1:1 mapping between keys and columns\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## ORA分析\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_deg = names(geneList)[abs(geneList) \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eego \u0026lt;- enrichGO(gene          = gene_deg,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                OrgDb         = org.Hs.eg.db,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                ont           = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;CC\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#007f7f\"\u003e# \u0026#34;BP\u0026#34;,\u0026#34;MF\u0026#34;,\u0026#34;ALL\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                pAdjustMethod = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BH\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                pvalueCutoff  = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                qvalueCutoff  = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.05\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                readable      = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## GSEA分析\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egseago \u0026lt;- gseGO(geneList     = geneList,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                OrgDb        = org.Hs.eg.db,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                ont          = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;CC\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                minGSSize    = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                maxGSSize    = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e500\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                pvalueCutoff = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.05\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                verbose      = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egseago = setReadable(gseago, OrgDb = org.Hs.eg.db)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1ggplot2\"\u003e1、ggplot2\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## ORA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eego_df = ego@result %\u0026gt;% head(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(logp = -log10(p.adjust)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::arrange(logp) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(Label=str_wrap(gsub(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;_\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e,Description), width = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e50\u003c/span\u003e)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(Label = factor(Label, levels=Label)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  tibble::remove_rownames() %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(Label, logp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(ego_df)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                                      Label     logp\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1           microtubule associated complex 5.419514\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2                          spindle midzone 5.681085\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3                      spindle microtubule 7.341138\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(ego_df, aes(x=Label, y=logp)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e, fill=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;#1b9e77\u0026#34;\u003c/span\u003e) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  xlab(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Pathway names\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ylab(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;-log10(P.adj)\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  scale_y_continuous(expand=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  coord_flip() + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  xlab(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GO Pathway\u0026#34;\u003c/span\u003e) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ylab(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Adjusted P value(-log10)\u0026#34;\u003c/span\u003e) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_text(aes(label = Label, y=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e), hjust = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  theme_classic() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  theme(axis.text.y = element_blank(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        axis.ticks.y = element_blank(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        axis.title.y = element_text(size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e25\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        axis.title.x = element_text(size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        axis.text.x = element_text(size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e16\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230114200216781.png\" alt=\"image-20230114200216781\" style=\"zoom: 33%;\" /\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## GSEA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egseago_df = gseago@result %\u0026gt;% head(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(logp = -log10(p.adjust)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::arrange(logp) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(Label=str_wrap(gsub(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;_\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34; \u0026#34;\u003c/span\u003e,Description), width = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e50\u003c/span\u003e)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(Label = factor(Label, levels=Label)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  tibble::remove_rownames() %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(Label, logp, NES)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(gseago_df)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                            Label     logp      NES\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1   polymeric cytoskeletal fiber 3.755730 1.487284\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2   chromosome, telomeric region 4.311816 1.907511\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 microtubule associated complex 4.432327 1.944046\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(gseago_df, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       aes(NES, fct_reorder(Label, NES), fill=qvalue)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;identity\u0026#39;\u003c/span\u003e) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  scale_fill_continuous(low=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;red\u0026#39;\u003c/span\u003e, high=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;blue\u0026#39;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                        guide=guide_colorbar(reverse=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  theme_minimal() + ylab(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNULL\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230114200540657.png\" alt=\"image-20230114200540657\" style=\"zoom:50%;\" /\u003e\r\n\u003ch2 id=\"2goplot\"\u003e2、GOplot\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e官方教程：https://wencke.github.io/\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# install.packages(\u0026#39;GOplot\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(GOplot)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) 准备数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 富集通路结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_enrich = ego@result %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(ID, Description, geneID,p.adjust) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(Category = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GO\u0026#34;\u003c/span\u003e, .before=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e) %\u0026gt;%  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(geneID = gsub(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;/\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;, \u0026#34;\u003c/span\u003e, geneID)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::rename(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Term\u0026#34;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Description\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Genes\u0026#34;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;geneID\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;adj_pval\u0026#34;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;p.adjust\u0026#34;\u003c/span\u003e) %\u0026gt;%\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(Category,ID,Term,Genes,adj_pval) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  tibble::remove_rownames()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003et(res_enrich[1,])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#           1                                                                                                                                                                                   \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Category \u0026#34;GO\u0026#34;                                                                                                                                                                                \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ID       \u0026#34;GO:0005819\u0026#34;                                                                                                                                                                        \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Term     \u0026#34;spindle\u0026#34;                                                                                                                                                                           \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Genes    \u0026#34;CDCA8, CDC20, KIF23, CENPE, ASPM, DLGAP5, SKA1, NUSAP1, TPX2, TACC3, NEK2, CDK1, MAD2L1, KIF18A, BIRC5, KIF11, TRAT1, TTK, AURKB, PRC1, KIFC1, KIF18B, KIF20A, AURKA, CCNB1, KIF4A\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# adj_pval \u0026#34;6.339976e-11\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 如上，ID为optional，Category为required\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) 基因差异倍数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_logfc = data.frame(ID=gene_ids$SYMBOL,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                       logFC=geneList)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(res_logfc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      ID    logFC\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  MMP1 4.572613\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 CDC45 4.514594\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3   NMU 4.418218\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 如无相关数据，可随便设置为0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (3) 构建绘图对象\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecirc \u0026lt;- circle_dat(res_enrich, res_logfc)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(circ)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eCircular visualization\u003c/p\u003e","title":"富集通路可视化方式"},{"content":"1、关于WGCNA原理 1.1 建立共表达网络 在基因共表达网络中，节点node代表基因，边edge代表两个基因间共表达关系。\n若一个基因同时与多个基因存在相关性，称为hub基因。 若一群基因存在高度互相相关，称为module。 基因共表达网络的展示形式一般为 n × n 邻接矩阵adjacency matrix(n个基因)\n（1）similarity matrix 在得到一个m × n 表达矩阵（m个样本，n个基因）后，第一步是计算两基因在多样本的表达水平相关性（例如spearman correlation，值一般在-1 ~ 1之间），从而得到表达相似度矩阵similarity matix，简记为S。根据是否考虑相关性的正负性，有两种处理方式。 $$ S=[s_{ij}], \\quad s_{ij} = |cor(i,j)| \\quad if \u0026lsquo;unsign\u0026rsquo; $$\n$$ S=[s_{ij}], \\quad s_{ij} = \\frac{1+cor(i,j)}{2} \\quad if \u0026lsquo;sign\u0026rsquo; $$\n不要把sign和directed弄混了。前者表示相关的正负性，后者表示方向性。使用WGCNA建立的都是undirected网络。\n（2）adjacency matrix 第二步是使用adjacency function将基因表达相似矩阵转为共表达邻接矩阵。根据adjacency function的特点分为hard与soft两种。\nHard adjacency function：设置一个阈值，若相关性高于阈值，则认为存在共表达关系，记为1；反之，则不存在，记为0。由此得到的结果成为 Unweighted Network。\n该网络中每个节点的连接度(connectivity)即为共表达的基因数。\n此方法的关键是确定一个合理阈值。对此最显著的弊端是假设定义0.8为阈值，为什么0.79就认为不存在共表达关系呢。\n1 2 3 4 5 6 $$ A=[a_{ij}], \u0026amp;\u0026amp; a_{ij}=signum(S_{ij}, \\tau) \\equiv \\begin{cases} 1 \u0026amp;\u0026amp; if \u0026amp; S_{ij}\\geq \\tau \\\\ 0 \u0026amp;\u0026amp; if \u0026amp; S_{ij}\u0026lt; \\tau \\end{cases} $$ Soft adjacency function：使用的前提是假设基因共表达网络为scale-free netork无尺度网络，其特征是少部分节点具有高连通性，大部分节点具有低连通性。在该网络中所有edge中，大部分接近于0，小部分接近于1，符合幂律分布，可使用幂函数(power function)拟合。由此得到的结果位于[0,1]之间，成为Weighted Network。\n该网络中每个节点的连接度(connectivity)即为所有邻居基因的共表达权重总和。\n此方法的关键是确定一个合理指数，使得符合幂律分布。由于更符合生物网络的本质，因此推荐使用这种方法。\n$$ A=[a_{ij}], \\quad a_{ij}=power(s_{ij},\\beta)\\equiv|s_{ij}|^{\\beta} $$\nScale-free network有两个特点\n（1）对节点error有一定容忍度，即破坏其中普通的低连通性节点，不会影响整体网络结构；\n（2）一旦是少数的hub node发生错误，则会造成严重后果。\n（3）topological overlap matrix 在WGCNA中，为了minimize effects of noise and spurious associations 将上一步得到adjacency matrix，转化为 topological overlap matrix (TOM)。这一转换主要是考虑到了其它基因对于两两基因间共表达关系的贡献。 $$ k_i=\\sum_{u}a_{iu} \\tag{1} $$\n$$ l_{ij}=\\sum_{u}a_{iu}a_{uj} \\tag{2} $$\n$$ \\Omega=[w_{ij}], \\quad w_{ij} = \\frac{l_{ij} + a_{ij}}{min{k_i,k_j} + 1 - a_{ij}} \\tag{3} $$\n对于式1，计算基因的连通性connectivity；对于式2，计算基因i与基因j分别与其余所有基因共表达指标乘积的和。\n举例来说基因i与基因j之间的共表达值为0.6，\n基因i与基因1~8的共表达值分别为0.1~0.8 → ki=3.6\n基因j与基因5~10的共表达值分别为0.1~0.6 → kj=1.8\n基因i与基因j存在3个共同令居，故 lij=(0.5*0.1)+(0.6*0.2)+(0.7*0.3)=0.38\n所以wij = (0.38 + 0.6)/(1.8+1-0.6) = 0.445\n由原来的0.6变为了0.445，降低的原因在于第三方基因与这对基因的相关性并不一致。\n1.2 鉴定模块及相关分析 鉴定模块Module：将基因共表达网络转化为 dissimilarity matrix（1-TOM），然后基于树状图的层次聚类进行动态剪切将基因划分为若干模块。 Module eigengene模块特征值：即使用一个特征值代表某样本对于某个模块的特征Trait情况。具体计算方法是使用主成分分析PCA，提取第一个主成分值，如下图所示。 Gene significance，GS：即比较样本基因表达与样本表型之间的相关性，有如下两种计算方式。一种是计算相关性绝对值，另一种是计算相关显著性。 总体原则是GS越接近1，表示基因与表型越相关。 $$ \\begin{align} \u0026amp; GS_i = |cor(x_i,T)| \\tag{1} \\ \u0026amp; GS_i = -log,p_i \\tag{2} \\ \\end{align} $$\nModule significance，MS：即模块内基因的平均GS $$ MS_{blue} = \\frac{\\sum_{i=1}^{n}GS_i}{n} $$\nModule Membership: 模块内基因表达与模块特征值的相关性，也称为eigengene-based connectivity，KME。 其绝对值越接近1，表明与该模块相关。 $$ MM^{blue}(i)=K_{cor,i}^{blue}=cor(x_i, E^{blue}) $$\nIntramodular connectivity模块内连通性：表示某基因与某个模块内基因的共表达权重关系总和。 参考资料： [1] A General Framework for Weighted Gene Co-Expression Network Analysis. doi:10.2202/1544-6115.1128\n[2] WGCNA: an R package for weighted correlation network analysis. doi:10.1186/1471-2105-9-559\n2、WGCNA实操 以下代码、数据主要参考官方教程\n1 2 # BiocManager::install(\u0026#34;WGCNA\u0026#34;) library(WGCNA) 2.1 整理输入数据 关于WGCNA的输入数据要求，官方文档已经做说明，大致如下几点：\n（1）至少20个样本以上，越多越好；\n（2）可以过滤点低表达或者低方差的基因，以减少干扰信息。但不太建议直接使用差异基因。\n（3）WGCNA最初用于芯片测序数据，也适用于RNA-seq数据。关于RNAseq标准化，由于不涉及到不同基因之间的比较，所有常规标准化方式都可以。\n整理表达矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 exp_dat = read.csv(\u0026#34;LiverFemale3600.csv\u0026#34;,row.names = 1) %\u0026gt;% .[,-c(1:7)] # [1] 3600 135 ##(1)转置为行名为样本，列名为基因的表达矩阵 exp_mt = as.data.frame(t(exp_dat)) exp_mt[1:4,1:4] # MMT00000044 MMT00000046 MMT00000051 MMT00000076 # F2_2 -1.81e-02 -0.0773 -0.0226 -0.00924 # F2_3 6.42e-02 -0.0297 0.0617 -0.14500 # F2_14 6.44e-05 0.1120 -0.1290 0.02870 # F2_15 -5.80e-02 -0.0589 0.0871 -0.04390 ##(2)判断数据质量--缺失值 gsg = goodSamplesGenes(exp_mt) gsg$allOK # [1] TRUE ##(3)判断数据质量--离群点样本 sampleTree = hclust(dist(exp_mt), method = \u0026#34;average\u0026#34;) sizeGrWindow(12,9) par(cex = 0.6); par(mar = c(0,4,2,0)) plot(sampleTree, main = \u0026#34;Sample clustering to detect outliers\u0026#34;, sub=\u0026#34;\u0026#34;, xlab=\u0026#34;\u0026#34;, cex.lab = 1.5, cex.axis = 1.5, cex.main = 2) abline(h = 15, col = \u0026#34;red\u0026#34;) #根据实际情况而定 ##如下图所示，存在一个显著离群点；剔除掉 clust = cutreeStatic(sampleTree, cutHeight = 15, minSize = 10) table(clust) # clust # 0 1 # 1 134 keepSamples = (clust==1) exp_mt_f = exp_mt[keepSamples, ] 整理样本表型数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 trait_dat = read.csv(\u0026#34;ClinicalTraits.csv\u0026#34;,row.names = 2) %\u0026gt;% .[,setdiff(11:37,c(15,30))] trait_dat_f = trait_dat[rownames(exp_mt_f),] # length_cm ab_fat other_fat total_fat # F2_2 10.5 3.81 2.78 6.59 # F2_3 10.8 1.70 2.05 3.75 # F2_14 10.0 1.29 1.67 2.96 # F2_15 10.3 3.62 3.34 6.96 identical(rownames(exp_mt_f), rownames(trait_dat_f)) #[1] TRUE ##汇总最终数据 exp_dat = exp_mt_f dim(exp_dat) # [1] 134 3600 exp_dat[1:4,1:4] trait_dat = trait_dat_f dim(trait_dat) # [1] 134 25 trait_dat[1:4,1:4] 如上最终得到了整理好的表达矩阵数据exp_dat以及对应样本的表型数据trait_dat\n2.2 选择合适的软阈值β 在1.1建立共表达网络，了解到WGCNA将similarity matrix转置为adjacency matrix的方法是进行幂律分布拟合。 这一步骤的关键是选取一个合适的指数参数β,使得adjacency matrix结果的权重值分布最大程度符合幂律分布。 可使用pickSoftThreshold筛选出最合适的值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #选定候选值 powers = c(c(1:10), seq(from = 12, to=20, by=2)) # [1] 1 2 3 4 5 6 7 8 9 10 12 14 16 18 20 sft = pickSoftThreshold(exp_dat, powerVector = powers, verbose = 5) ##结果可视化： sizeGrWindow(9, 5) par(mfrow = c(1,2)) cex1 = 0.9 ### （1）是否符合幂律分布； plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab=\u0026#34;Soft Threshold (power)\u0026#34;,ylab=\u0026#34;Scale Free Topology Model Fit,signed R^2\u0026#34;,type=\u0026#34;n\u0026#34;, main = paste(\u0026#34;Scale independence\u0026#34;)); text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers,cex=cex1,col=\u0026#34;red\u0026#34;) abline(h=0.90,col=\u0026#34;red\u0026#34;) ### （2）节点的平均连接度 plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab=\u0026#34;Soft Threshold (power)\u0026#34;,ylab=\u0026#34;Mean Connectivity\u0026#34;, type=\u0026#34;n\u0026#34;, main = paste(\u0026#34;Mean connectivity\u0026#34;)) text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col=\u0026#34;red\u0026#34;) par(mfrow = c(1,1)) 如下图所示，基本在6时，拟合幂律分布的结果是比较好的；同时节点的凭据连通性也趋于稳定了。之后会使用这个参数建立网络。\n2.3 建立网络，鉴定模块 方式一：逐步分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 ##(1) 根据选定的软阈值，得出邻接矩阵 adjacency = adjacency(exp_dat, power = 6) adjacency[1:4,1:4] # F2_2 F2_3 F2_14 F2_15 # F2_2 1.000000e+00 2.669773e-02 8.679043e-07 0.0285218325 # F2_3 2.669773e-02 1.000000e+00 1.491148e-06 0.1223727405 # F2_14 8.679043e-07 1.491148e-06 1.000000e+00 0.0007245466 # F2_15 2.852183e-02 1.223727e-01 7.245466e-04 1.0000000000 ##(2)转为TOM矩阵 TOM = TOMsimilarity(adjacency) TOM[1:4,1:4] # [,1] [,2] [,3] [,4] # [1,] 1.0000000000 0.0443291435 0.0006062579 0.033303820 # [2,] 0.0443291435 1.0000000000 0.0005190759 0.068058832 # [3,] 0.0006062579 0.0005190759 1.0000000000 0.002154665 # [4,] 0.0333038199 0.0680588319 0.0021546653 1.000000000 ##(3)进一步转为不相似性矩阵（距离矩阵） dissTOM = 1-TOM dissTOM[1:4,1:4] # [,1] [,2] [,3] [,4] # [1,] 0.0000000 0.9556709 0.9993937 0.9666962 # [2,] 0.9556709 0.0000000 0.9994809 0.9319412 # [3,] 0.9993937 0.9994809 0.0000000 0.9978453 # [4,] 0.9666962 0.9319412 0.9978453 0.0000000 ##(4) 层次聚类hierarchical clustering geneTree = hclust(as.dist(dissTOM), method = \u0026#34;average\u0026#34;) ##(5) 动态切割树，鉴定模块 dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM, deepSplit = 2, pamRespectsDendro = FALSE, minClusterSize = 30) # dynamicMods # 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 88 614 316 311 257 235 225 212 158 153 121 106 102 100 94 91 78 76 65 58 58 48 34 ##如上表示切割为22个基因模块，其中模块0表示 unassigned genes ##(6)将模块名映射为颜色名，并可视化 dynamicColors = labels2colors(dynamicMods) table(dynamicColors) #module0 会被映射到灰色 grey sizeGrWindow(8,6) plotDendroAndColors(geneTree, dynamicColors, \u0026#34;Dynamic Tree Cut\u0026#34;, dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = \u0026#34;Gene dendrogram and primary module colors\u0026#34;) 接下来需要判断有无非常相似的模块，进行合并操作 1 2 3 4 5 6 7 8 9 ##(7)根据模块的特征值，计算不同模块的相似性，进行层次聚类 MEList = moduleEigengenes(exp_dat, colors = dynamicColors) MEs = MEList$eigengenes MEDiss = 1-cor(MEs) METree = hclust(as.dist(MEDiss), method = \u0026#34;average\u0026#34;) sizeGrWindow(7, 6) plot(METree, main = \u0026#34;Clustering of module eigengenes\u0026#34;, xlab = \u0026#34;\u0026#34;, sub = \u0026#34;\u0026#34;) abline(h=0.25, col = \u0026#34;red\u0026#34;) #根据实际情况而定 1 2 3 4 5 6 7 8 9 10 11 12 ##(8)根据选择的阈值，合并模块 merge = mergeCloseModules(exp_dat, dynamicColors, cutHeight = 0.25) #新划分模块的颜色映射 mergedColors = merge$colors #新划分模块的特征值 mergedMEs = merge$newMEs #可视化合并前后的模块 sizeGrWindow(12, 9) plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c(\u0026#34;Dynamic Tree Cut\u0026#34;, \u0026#34;Merged dynamic\u0026#34;), dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05) 方式二：一步分析 WGCNA包提供了blockwiseModules()函数可将上述步骤打包在一起，一次执行建立网络、鉴定模块的分析。\n结合逐步分析，可以看到有一些关键参数可以调节：\npower：软阈值的选择 corType：计算相关性的方法；可选pearson(默认)，bicor。后者更能考虑离群点的影响。 networkType:计算邻接矩阵时，是否考虑正负相关性；默认为\u0026quot;unsigned\u0026quot;,可选\u0026quot;signed\u0026quot;, \u0026ldquo;signed hybrid\u0026rdquo; TOMType：计算TOM矩阵时，是否考虑正负相关性；默认为\u0026quot;signed\u0026quot;,可选\u0026quot;unsigned\u0026quot;。但是根据幂律转换的邻接矩阵(权重)的非负性，所以认为这里选择\u0026quot;signed\u0026quot;也没有太多的意义。 minModuleSize：模块的最少基因数 mergeCutHeight：合并模块的阈值 numericLabels：模块名是否为数字；若设置FALSE，表示映射为颜色名。 saveTOMs：是否保存TOM矩阵；如果设为TRUE，需要设置saveTOMFileBase参数，提供保存文件名；设置numericLabels参数，是否将模块名保存为颜色名 nThreads ：交代线程数，适用于Linux环境 verbose：0默认安静的执行，值越大表示给出的运行提示信息越多。 关于blocks相关参数：主要是考虑到输入基因数太大，电脑运行内存不足的情况。默认为\u0026quot;NULL\u0026quot;，即全部一次运行，不分多个blocks。\n1 2 3 4 5 6 7 8 9 10 11 net = blockwiseModules(exp_dat, power = 6, corType = \u0026#34;pearson\u0026#34;, networkType=\u0026#34;unsigned\u0026#34;, TOMType = \u0026#34;unsigned\u0026#34;, minModuleSize = 30, mergeCutHeight = 0.25, verbose = 3) names(net) # [1] \u0026#34;colors\u0026#34; \u0026#34;unmergedColors\u0026#34; \u0026#34;MEs\u0026#34; \u0026#34;goodSamples\u0026#34; \u0026#34;goodGenes\u0026#34; # [6] \u0026#34;dendrograms\u0026#34; \u0026#34;TOMFiles\u0026#34; \u0026#34;blockGenes\u0026#34; \u0026#34;blocks\u0026#34; \u0026#34;MEsOK\u0026#34; 解析结果list结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #(1) 最终得到的网络模块(合并之后) unique(net$colors) table(net$colors) # grey module是 unassigned gene ##合并之前的网络模块 unique(net$unmergedColors) table(net$unmergedColors) #(2) 134个样本对于18个模块的特征值 dim(net$MEs) net$MEs[1:4,1:4] net$MEsOK #(3)聚类树状图，color注释模块 plotDendroAndColors(dendro = net$dendrograms[[1]], colors = net$colors) 2.4 关联表型分析 以2.3 方式二得到结果继续分析\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # (1)计算模块特征值 # MEs = moduleEigengenes(exp_dat, net$colors)$eigengenes MEs = net$MEs MEs = orderMEs(MEs) # (2)计算18个module与25个表型的相关性以及对应的P值 moduleTraitCor = cor(MEs, trait_dat, use = \u0026#34;p\u0026#34;) moduleTraitCor[1:4,1:4] # length_cm ab_fat other_fat total_fat # MEmagenta 0.08015682 -0.004282784 -0.0311292 -0.01504395 # MEturquoise -0.14101586 -0.323615446 -0.0528274 -0.23393609 # MEred -0.15070061 -0.268348526 -0.1458333 -0.23102647 # MEyellow -0.13732537 -0.067163777 0.1958153 0.04806599 moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nrow(MEs)) moduleTraitPvalue[1:4,1:4] # length_cm ab_fat other_fat total_fat # MEmagenta 0.35722181 0.9608295943 0.72104901 0.863025117 # MEturquoise 0.10411666 0.0001366333 0.54437147 0.006518482 # MEred 0.08219621 0.0017187522 0.09269921 0.007237730 # MEyellow 0.11358818 0.4406688535 0.02336043 0.581283912 # (3)可视化相关性与P值 sizeGrWindow(10,6) # Will display correlations and their p-values textMatrix = paste(signif(moduleTraitCor, 2), \u0026#34;\\n(\u0026#34;, signif(moduleTraitPvalue, 1), \u0026#34;)\u0026#34;, sep = \u0026#34;\u0026#34;) dim(textMatrix) = dim(moduleTraitCor) par(mar = c(6, 8.5, 3, 3)) labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(trait_dat), yLabels = names(MEs), ySymbols = names(MEs), colorLabels = FALSE, colors = greenWhiteRed(50), textMatrix = textMatrix, setStdMargins = FALSE, cex.text = 0.5, zlim = c(-1,1), main = paste(\u0026#34;Module-trait relationships\u0026#34;)) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ##计算指定表型的相关分析 weight = trait_dat[,\u0026#34;X100xfat_weight\u0026#34;,drop=F] colnames(weight) = \u0026#34;weight\u0026#34; # (1) Gene significance，GS：即比较样本某个基因与对应表型的相关性 GS_weight = as.data.frame(cor(exp_dat, weight, use = \u0026#34;p\u0026#34;)) colnames(GS_weight) = \u0026#34;GS_weight\u0026#34; head(GS_weight) # GS_weight # MMT00000044 -0.06788487 # MMT00000046 -0.09806093 # MMT00000051 0.20311624 GS.p_weight = as.data.frame(corPvalueStudent(as.matrix(GS_weight), nrow(exp_dat))) # GS.p_weight # MMT00000044 0.43576664 # MMT00000046 0.25964873 # MMT00000051 0.01858241 # (2) Module Membership: 模块内基因表达与模块特征值的相关性 modNames = substring(names(MEs), 3) # 计算3600个基因与18个模块的相关性 MM = as.data.frame(cor(exp_dat, MEs, use = \u0026#34;p\u0026#34;)) colnames(MM) = paste(\u0026#34;MM\u0026#34;, modNames, sep=\u0026#34;\u0026#34;) MM[1:4,1:4] MMPvalue = as.data.frame(corPvalueStudent(as.matrix(MM), nrow(exp_dat))) MMPvalue = as.data.frame(corPvalueStudent(as.matrix(MM), nrow(exp_dat))); colnames(MMPvalue) = paste(\u0026#34;p.MM\u0026#34;, modNames, sep=\u0026#34;\u0026#34;); MMPvalue[1:4,1:4] # (3) 可视化blue模块基因特征 # identical(rownames(MM), names(net$colors)) # TRUE module = \u0026#34;blue\u0026#34; moduleGenes = names(net$colors)[net$colors==\u0026#34;blue\u0026#34;] sizeGrWindow(7, 7) par(mfrow = c(1,1)) verboseScatterplot(abs(MM[moduleGenes, \u0026#34;MMblue\u0026#34;]), abs(GS_weight[moduleGenes, 1]), xlab = paste(\u0026#34;Module Membership in\u0026#34;, module, \u0026#34;module\u0026#34;), ylab = \u0026#34;Gene significance for body weight\u0026#34;, main = paste(\u0026#34;Module membership vs. gene significance\\n\u0026#34;), cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module) 可视化blue模块内的基因特征。当基因与blue模块越相关时，该基因也与该表型Trait相关。\n2.5 挑选模块Hub基因 关于模块的Hub基因，WGCNA并没有明确的筛选方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ## (1) 模块内基因连接度 adjacency = adjacency(exp_dat, power = 6) # TOM = TOMsimilarity(adjacency) TOM[1:4,1:4] Alldegrees =intramodularConnectivity(adjacency, net$colors) head(Alldegrees) # kTotal kWithin kOut kDiff # MMT00000044 0.4092743 0.2862358 0.1230385 0.1631973 # MMT00000046 37.8927830 24.9652317 12.9275513 12.0376805 # MMT00000051 28.3866248 17.2076759 11.1789488 6.0287271 # MMT00000076 1.3015473 1.1992420 0.1023053 1.0969366 # MMT00000080 25.9713107 16.3954194 9.5758914 6.8195280 # MMT00000102 10.5051504 2.4713718 8.0337786 -5.5624067 #### kTotal:基因在整个网络中的连接度 #### kWithin: 基因在所属模块中的连接度，即Intramodular connectivity #### kOut: kTotal-kWithin #### kDiff: kIn-kOut #也可以绘制一个模块基因的Intramodular connectivity与Gene significance的散点图 ## (2) Module Membership: 即上一节计算的模块内基因表达与模块特征值的相关性。 ## (3) Gene significance，GS：即比较样本某个基因与对应表型的相关性 ## (4) 综合上述指标，自定义合适阈值，选取一定数量的模块Hub基因。 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/071wgcna%E5%9F%BA%E5%9B%A0%E5%8A%A0%E6%9D%83%E5%85%B1%E8%A1%A8%E8%BE%BE%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90/","summary":"\u003ch2 id=\"1关于wgcna原理\"\u003e1、关于WGCNA原理\u003c/h2\u003e\n\u003ch3 id=\"11-建立共表达网络\"\u003e1.1 建立共表达网络\u003c/h3\u003e\n\u003cp\u003e在基因共表达网络中，节点node代表基因，边edge代表两个基因间共表达关系。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e若一个基因同时与多个基因存在相关性，称为hub基因。\u003c/li\u003e\n\u003cli\u003e若一群基因存在高度互相相关，称为module。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e基因共表达网络的展示形式一般为 \u003ccode\u003en × n\u003c/code\u003e 邻接矩阵adjacency matrix(n个基因)\u003c/p\u003e","title":"WGCNA基因加权共表达网络分析"},{"content":"1、GSVA函数 1 2 3 4 5 6 7 # BiocManager::install(\u0026#34;GSVA\u0026#34;) library(GSVA) ?gsva gsva(expr = , #metrix格式表达矩阵(行--基因，列--样本) gset.idx.list = , #list格式基因集 method=c(\u0026#34;gsva\u0026#34;, \u0026#34;ssgsea\u0026#34;, \u0026#34;zscore\u0026#34;, \u0026#34;plage\u0026#34;), # defaul:gsva kcdf=c(\u0026#34;Gaussian\u0026#34;, \u0026#34;Poisson\u0026#34;, \u0026#34;none\u0026#34;)) # default:Gaussian 如上所示，gsva()函数有4个关键参数。\n前两个参数分别提供表达矩阵与基因集，其中基因名需要为相同的格式。 method参数设置方法，默认为gsva kcdf参数设置分布模拟类型，默认为Gaussian，适合于array数据以及log标准化(CPM/RPKM/TPM等)的RNA-seq数据。Poisson分布适合RNA-seq的原始count矩阵。 2、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ## (1) 表达矩阵 # BiocManager::install(\u0026#34;GSVAdata\u0026#34;) library(GSVAdata) data(commonPickrellHuang) ### array矩阵 array_mt = exprs(huangArrayRMAnoBatchCommon_eset) dim(array_mt) # [1] 11508 36 array_mt[1:4,1:4] # NA19099 NA18523 NA19144 NA19137 # 8567 8.370526 8.544890 8.270395 8.585984 # 23139 7.536228 7.232781 7.469420 7.801986 # 7580 6.325102 6.405961 6.510249 6.285510 # 55619 9.134495 9.049938 9.704679 9.285202 ### count矩阵 count_mt = exprs(pickrellCountsArgonneCQNcommon_eset) dim(count_mt) # [1] 11508 36 count_mt[1:4,1:4] # NA19099 NA18523 NA19144 NA19137 # 8567 326 209 318 343 # 23139 255 169 245 361 # 7580 72 69 124 76 # 55619 487 590 678 540 ## (2) 基因集 library(tidyverse) library(msigdbr) hm_H = msigdbr(species = \u0026#34;Homo sapiens\u0026#34;, category = \u0026#34;H\u0026#34;, subcategory = NULL) %\u0026gt;% as.data.frame() %\u0026gt;% dplyr::select(gs_cat, gs_subcat, gs_name, entrez_gene) hm_H.list = split(hm_H$entrez_gene, hm_H$gs_name) str(head(hm_H.list)) # List of 6 # $ HALLMARK_ADIPOGENESIS : int [1:210] 19 11194 10449 33 34 35 47 50 51 112 ... # $ HALLMARK_ALLOGRAFT_REJECTION: int [1:335] 16 6059 10006 43 92 207 322 567 567 586 ... # $ HALLMARK_ANDROGEN_RESPONSE : int [1:102] 10257 11057 2181 87 9510 11047 9590 207 220 56172 ... # $ HALLMARK_ANGIOGENESIS : int [1:36] 350 351 894 1281 1290 6372 2260 11167 3685 182 ... # $ HALLMARK_APICAL_JUNCTION : int [1:231] 58 60 70 71 72 87 88 89 81 81 ... # $ HALLMARK_APICAL_SURFACE : int [1:46] 102 79602 79602 84632 9465 351 50617 5205 2683 672 ... 3、GSVA分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ## (1) array + gsva res_gsva = gsva(array_mt, hm_H.list) class(res_gsva) # [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34; dim(res_gsva) # [1] 50 36 res_gsva[1:4,1:4] # NA19099 NA18523 NA19144 NA19137 # HALLMARK_ADIPOGENESIS -0.21147644 0.08157479 0.004672524 -0.1656925 # HALLMARK_ALLOGRAFT_REJECTION -0.32620137 -0.44105423 -0.452996166 -0.4288909 # HALLMARK_ANDROGEN_RESPONSE 0.02056377 0.09123573 -0.135386552 -0.2198959 # HALLMARK_ANGIOGENESIS -0.02435541 -0.18282244 0.281235763 0.5114103 ## (2) count + ssgsea res_gsva = gsva(count_mt, hm_H.list, method = \u0026#34;ssgsea\u0026#34;, kcdf = \u0026#34;Poisson\u0026#34;) class(res_gsva) # [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34; dim(res_gsva) # [1] 50 36 res_gsva[1:4,1:4] # NA19099 NA18523 NA19144 NA19137 # HALLMARK_ADIPOGENESIS 0.3288768 0.32899026 0.2893928 0.3297140 # HALLMARK_ALLOGRAFT_REJECTION 0.5018248 0.49183093 0.4672342 0.4531009 # HALLMARK_ANDROGEN_RESPONSE 0.3210905 0.28289473 0.2818011 0.2845855 # HALLMARK_ANGIOGENESIS 0.1794361 0.07705857 0.2076328 0.1276449 4、limma差异分析 以上面array + gsva的分析结果为例，随机模拟分组进行limma差异分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ## 模拟分组 meta = data.frame(sample=colnames(array_mt), group=rep(c(\u0026#34;G1\u0026#34;,\u0026#34;G2\u0026#34;), each=18)) head(meta) # sample group # 1 NA19099 G1 # 2 NA18523 G1 # 3 NA19144 G1 # 4 NA19137 G1 # 5 NA18861 G1 # 6 NA19116 G1 ## limma差异分析 library(limma) mod \u0026lt;- model.matrix(~ factor(meta$group)) colnames(mod) \u0026lt;- c(\u0026#34;G1\u0026#34;, \u0026#34;G2\u0026#34;) fit \u0026lt;- lmFit(res_gsva, mod) fit \u0026lt;- eBayes(fit) tt \u0026lt;- topTable(fit, coef=2, n=Inf) head(tt) # logFC AveExpr t P.Value adj.P.Val B # HALLMARK_COMPLEMENT 0.08684907 -0.10731154 2.495909 0.01676849 0.3324198 -3.059104 # HALLMARK_HEME_METABOLISM 0.07942485 -0.04250442 2.238926 0.03076698 0.3324198 -3.486635 # HALLMARK_IL2_STAT5_SIGNALING 0.07839683 -0.09276742 2.193525 0.03411795 0.3324198 -3.558694 # HALLMARK_MITOTIC_SPINDLE -0.10721385 -0.07656961 -2.057416 0.04617883 0.3324198 -3.768076 # HALLMARK_IL6_JAK_STAT3_SIGNALING 0.09342746 -0.20104143 2.026107 0.04943145 0.3324198 -3.814790 # HALLMARK_INFLAMMATORY_RESPONSE 0.10211588 -0.10571870 1.996939 0.05263925 0.3324198 -3.857810 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/058gsva%E5%8C%85%E5%8D%95%E6%A0%B7%E6%9C%AC%E5%AF%8C%E9%9B%86%E5%88%86%E6%9E%90/","summary":"\u003ch2 id=\"1gsva函数\"\u003e1、GSVA函数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# BiocManager::install(\u0026#34;GSVA\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(GSVA)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e?gsva\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egsva(expr = ,   \u003cspan style=\"color:#007f7f\"\u003e#metrix格式表达矩阵(行--基因，列--样本)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     gset.idx.list = , \u003cspan style=\"color:#007f7f\"\u003e#list格式基因集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     method=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;gsva\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ssgsea\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;zscore\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;plage\u0026#34;\u003c/span\u003e),  \u003cspan style=\"color:#007f7f\"\u003e# defaul:gsva\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     kcdf=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Gaussian\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Poisson\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e))  \u003cspan style=\"color:#007f7f\"\u003e# default:Gaussian\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e如上所示，\u003ccode\u003egsva()\u003c/code\u003e函数有4个关键参数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e前两个参数分别提供表达矩阵与基因集，其中基因名需要为相同的格式。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emethod\u003c/code\u003e参数设置方法，默认为\u003ccode\u003egsva\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ekcdf\u003c/code\u003e参数设置分布模拟类型，默认为\u003ccode\u003eGaussian\u003c/code\u003e，适合于array数据以及log标准化(CPM/RPKM/TPM等)的RNA-seq数据。\u003ccode\u003ePoisson\u003c/code\u003e分布适合RNA-seq的原始count矩阵。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"2示例数据\"\u003e2、示例数据\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e43\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) 表达矩阵\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# BiocManager::install(\u0026#34;GSVAdata\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(GSVAdata)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(commonPickrellHuang)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### array矩阵\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003earray_mt = exprs(huangArrayRMAnoBatchCommon_eset)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(array_mt)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 11508    36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003earray_mt[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        NA19099  NA18523  NA19144  NA19137\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 8567  8.370526 8.544890 8.270395 8.585984\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 23139 7.536228 7.232781 7.469420 7.801986\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 7580  6.325102 6.405961 6.510249 6.285510\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 55619 9.134495 9.049938 9.704679 9.285202\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### count矩阵\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecount_mt = exprs(pickrellCountsArgonneCQNcommon_eset)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(count_mt)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 11508    36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecount_mt[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#       NA19099 NA18523 NA19144 NA19137\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 8567      326     209     318     343\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 23139     255     169     245     361\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 7580       72      69     124      76\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 55619     487     590     678     540\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) 基因集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(msigdbr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehm_H = msigdbr(species = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Homo sapiens\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               category = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;H\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               subcategory = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNULL\u003c/span\u003e) %\u0026gt;% as.data.frame() %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(gs_cat, gs_subcat, gs_name, entrez_gene)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehm_H.list = split(hm_H$entrez_gene, hm_H$gs_name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estr(head(hm_H.list))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# List of 6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $ HALLMARK_ADIPOGENESIS       : int [1:210] 19 11194 10449 33 34 35 47 50 51 112 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $ HALLMARK_ALLOGRAFT_REJECTION: int [1:335] 16 6059 10006 43 92 207 322 567 567 586 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $ HALLMARK_ANDROGEN_RESPONSE  : int [1:102] 10257 11057 2181 87 9510 11047 9590 207 220 56172 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $ HALLMARK_ANGIOGENESIS       : int [1:36] 350 351 894 1281 1290 6372 2260 11167 3685 182 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $ HALLMARK_APICAL_JUNCTION    : int [1:231] 58 60 70 71 72 87 88 89 81 81 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $ HALLMARK_APICAL_SURFACE     : int [1:46] 102 79602 79602 84632 9465 351 50617 5205 2683 672 ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"3gsva分析\"\u003e3、GSVA分析\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) array + gsva\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_gsva = gsva(array_mt, hm_H.list)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(res_gsva)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(res_gsva)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 50 36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_gsva[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                                  NA19099     NA18523      NA19144    NA19137\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ADIPOGENESIS        -0.21147644  0.08157479  0.004672524 -0.1656925\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ALLOGRAFT_REJECTION -0.32620137 -0.44105423 -0.452996166 -0.4288909\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ANDROGEN_RESPONSE    0.02056377  0.09123573 -0.135386552 -0.2198959\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ANGIOGENESIS        -0.02435541 -0.18282244  0.281235763  0.5114103\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) count + ssgsea\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_gsva = gsva(count_mt, hm_H.list, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                method = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ssgsea\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                kcdf = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Poisson\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(res_gsva)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(res_gsva)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 50 36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_gsva[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                                NA19099    NA18523   NA19144   NA19137\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ADIPOGENESIS        0.3288768 0.32899026 0.2893928 0.3297140\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ALLOGRAFT_REJECTION 0.5018248 0.49183093 0.4672342 0.4531009\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ANDROGEN_RESPONSE   0.3210905 0.28289473 0.2818011 0.2845855\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_ANGIOGENESIS        0.1794361 0.07705857 0.2076328 0.1276449\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"4limma差异分析\"\u003e4、limma差异分析\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e以上面array + gsva的分析结果为例，随机模拟分组进行limma差异分析\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 模拟分组\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emeta = data.frame(sample=colnames(array_mt),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                  group=rep(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G1\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G2\u0026#34;\u003c/span\u003e), each=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e18\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(meta)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    sample group\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 NA19099    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 NA18523    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 NA19144    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4 NA19137    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5 NA18861    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 NA19116    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## limma差异分析\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(limma)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emod \u0026lt;- model.matrix(~ factor(meta$group))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecolnames(mod) \u0026lt;- c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G1\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G2\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efit \u0026lt;- lmFit(res_gsva, mod)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efit \u0026lt;- eBayes(fit)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ett \u0026lt;- topTable(fit, coef=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, n=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eInf\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(tt)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                                        logFC     AveExpr         t    P.Value adj.P.Val         B\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_COMPLEMENT               0.08684907 -0.10731154  2.495909 0.01676849 0.3324198 -3.059104\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_HEME_METABOLISM          0.07942485 -0.04250442  2.238926 0.03076698 0.3324198 -3.486635\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_IL2_STAT5_SIGNALING      0.07839683 -0.09276742  2.193525 0.03411795 0.3324198 -3.558694\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_MITOTIC_SPINDLE         -0.10721385 -0.07656961 -2.057416 0.04617883 0.3324198 -3.768076\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_IL6_JAK_STAT3_SIGNALING  0.09342746 -0.20104143  2.026107 0.04943145 0.3324198 -3.814790\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# HALLMARK_INFLAMMATORY_RESPONSE    0.10211588 -0.10571870  1.996939 0.05263925 0.3324198 -3.857810\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"GSVA包单样本富集分析"},{"content":"xCell xCell包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 devtools::install_github(\u0026#39;dviraran/xCell\u0026#39;) library(xCell) data(\u0026#34;xCell.data\u0026#34;) ##查看支持的64种细胞类型，同下图 colnames(xCell.data$spill$K) ##预测函数的关键参数解释 ?xCellAnalysis() # expr = 交代表达矩阵； ##如果是array，不需要额外标准化；如果是RNAseq，需要TPM/FPKM/TPM。 ##对于基因ID格式需要是symbol格式。 # rnaseq = TRUE 数据是否为RNAseq数据，如果是芯片数据设置为FALSE # cell.types.use = NULL 提供一个字符串，说明想要预测64种细胞中的哪些细胞类型 # parallel.sz = 4 调用的线程数，默认为4 NOTE：\n(1) 由于xCell支持64种细胞类型，分析前根据先验知识判断预期有哪些细胞类型再分析，会提高数据结果可靠度性。\n(2) xCell的结果适用于同一细胞类型在不同样本间的含量差异比较，不适用于同一样本的不同细胞类型组成分析。\n示例分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ##(1)加载包 library(xCell) data(\u0026#34;xCell.data\u0026#34;) ##(2)示例表达数据：xCell内嵌的array数据 sdy = readRDS(\u0026#39;sdy420.rds\u0026#39;) expr = sdy$expr dim(expr) #104个样本的12027个样本 # [1] 12027 104 expr[1:4,1:4] # SUB137169 SUB137172 SUB137208 SUB137209 # A1CF 6.3480 6.1807 5.9556 6.3678 # A2LD1 6.8177 8.6354 7.2744 6.8724 # A2M 6.7169 6.9159 7.3686 6.7054 # A2ML1 7.8906 9.8874 10.5970 9.0120 ##(3)选取预期的细胞类型用于预测 cell.types.use = intersect(colnames(xCell.data$spill$K), rownames(sdy$fcs)) cell.types.use # [1] \u0026#34;B-cells\u0026#34; \u0026#34;CD4+ naive T-cells\u0026#34; \u0026#34;CD4+ T-cells\u0026#34; # [4] \u0026#34;CD4+ Tcm\u0026#34; \u0026#34;CD4+ Tem\u0026#34; \u0026#34;CD8+ naive T-cells\u0026#34; # [7] \u0026#34;CD8+ T-cells\u0026#34; \u0026#34;CD8+ Tcm\u0026#34; \u0026#34;CD8+ Tem\u0026#34; # [10] \u0026#34;Memory B-cells\u0026#34; \u0026#34;Monocytes\u0026#34; \u0026#34;naive B-cells\u0026#34; # [13] \u0026#34;NK cells\u0026#34; \u0026#34;NKT\u0026#34; \u0026#34;Plasma cells\u0026#34; # [16] \u0026#34;pro B-cells\u0026#34; \u0026#34;Tgd cells\u0026#34; \u0026#34;Tregs\u0026#34; ##(4) xCellAnalysis分析 scores = xCellAnalysis(expr, rnaseq=F, cell.types.use = cell.types.use) #得到104样本的18种细胞类型的含量 dim(scores) # [1] 18 104 scores[1:4,1:4] # SUB137169 SUB137172 SUB137208 SUB137209 # B-cells 0.11282951 1.689912e-01 0.15363674 0.11287388 # CD4+ naive T-cells 0.06465254 0.000000e+00 0.09620357 0.07204639 # CD4+ T-cells 0.18315694 8.676322e-02 0.14341114 0.14930520 # CD4+ Tcm 0.06477823 4.463612e-18 0.02393895 0.01463585 CIBERSOFT CIBERSORT脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 source(\u0026#34;CIBERSORT.R\u0026#34;) # 使用CIBERSORT()函数预测免疫浸润细胞比例 # 其中涉及两个关键参数： ##（1） sig_matrix：参考细胞类型特征表达矩阵文件名，官方提供了LM22.txt LM22 = data.table::fread(\u0026#34;LM22.txt\u0026#34;) dim(LM22) # [1] 547 23 LM22[1:4,1:4] # Gene symbol B cells naive B cells memory Plasma cells # 1: ABCB4 555.71345 10.74423 7.225819 # 2: ABCB9 15.60354 22.09479 653.392328 # 3: ACAP1 215.30595 321.62102 38.616872 # 4: ACHE 15.11795 16.64885 22.123737 colnames(LM22) #所覆盖的22种免疫细胞 # [1] \u0026#34;Gene symbol\u0026#34; \u0026#34;B cells naive\u0026#34; \u0026#34;B cells memory\u0026#34; # [4] \u0026#34;Plasma cells\u0026#34; \u0026#34;T cells CD8\u0026#34; \u0026#34;T cells CD4 naive\u0026#34; # [7] \u0026#34;T cells CD4 memory resting\u0026#34; \u0026#34;T cells CD4 memory activated\u0026#34; \u0026#34;T cells follicular helper\u0026#34; # [10] \u0026#34;T cells regulatory (Tregs)\u0026#34; \u0026#34;T cells gamma delta\u0026#34; \u0026#34;NK cells resting\u0026#34; # [13] \u0026#34;NK cells activated\u0026#34; \u0026#34;Monocytes\u0026#34; \u0026#34;Macrophages M0\u0026#34; # [16] \u0026#34;Macrophages M1\u0026#34; \u0026#34;Macrophages M2\u0026#34; \u0026#34;Dendritic cells resting\u0026#34; # [19] \u0026#34;Dendritic cells activated\u0026#34; \u0026#34;Mast cells resting\u0026#34; \u0026#34;Mast cells activated\u0026#34; # [22] \u0026#34;Eosinophils\u0026#34; \u0026#34;Neutrophils\u0026#34; ##（2） mixture_file：待预测细胞组成的表达矩阵文件名 # 如果是array，不需要额外标准化；如果是RNAseq，需要TPM/FPKM/TPM。 # 对于基因ID格式需要是symbol格式。 # 将符合上述两个条件的表达矩阵储存为Tab分割的TXT文件（行名转为第一列数据，列名为“symbol”，不储存行名） 示例分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ##(1)加载脚本 source(\u0026#34;CIBERSORT1.03.R\u0026#34;) ##(2)示例表达数据：仍使用上面xCell内嵌的array数据 sdy = readRDS(\u0026#39;sdy420.rds\u0026#39;) expr = sdy$expr dim(expr) #104个样本的12027个样本 # [1] 12027 104 expr[1:4,1:4] expr2 = tibble::rownames_to_column(expr, \u0026#34;symbol\u0026#34;) expr2[1:4,1:4] # symbol SUB137169 SUB137172 SUB137208 # 1 A1CF 6.3480 6.1807 5.9556 # 2 A2LD1 6.8177 8.6354 7.2744 # 3 A2M 6.7169 6.9159 7.3686 # 4 A2ML1 7.8906 9.8874 10.5970 write.table(expr2, row.names = F,quote = F,sep = \u0026#34;\\t\u0026#34;, file = \u0026#34;exp_array.txt\u0026#34;) ##(3)官方提供的参考细胞类型特征表达矩阵文件：\u0026#34;LM22.txt\u0026#34; ##(4)CIBERSORT预测 results = CIBERSORT(sig_matrix = \u0026#34;LM22.txt\u0026#34;, mixture_file = \u0026#34;exp_array.txt\u0026#34;, perm = 1000, QN = T) dim(results) # [1] 104 25 results[1:4,1:4] # B cells naive B cells memory Plasma cells T cells CD8 # SUB137169 0.04924204 0 0.0000000000 0.2643171 # SUB137172 0.07936758 0 0.0147950385 0.2623424 # SUB137208 0.03038180 0 0.0004003184 0.1864818 # SUB137209 0.07007071 0 0.0089139936 0.1127511 更新：immunedeconv包 集成了多种常见的免疫浸润分析算法，提供了便捷的分析接口\n官方手册：https://github.com/omnideconv/immunedeconv 原始论文：10.1093/bioinformatics/btz363 1 2 3 4 5 6 7 # 安装方式 ## (1) 官方推荐在linux使用conda安装 conda install -c bioconda -c conda-forge r-immunedeconv ## (2) 经实操后，window上也可正常使用 install.packages(\u0026#34;remotes\u0026#34;) remotes::install_github(\u0026#34;omnideconv/immunedeconv\u0026#34;) 1、内置算法类型 1.1 按支持物种分 （1）human 1 2 3 4 5 6 7 8 9 10 11 deconvolution_methods # quantiseq # timer # cibersort # cibersort_abs # mcp_counter # xcell # epic # abis # consensus_tme # estimate （2）mouse 1 2 3 4 5 deconvolution_methods_mouse # mmcp_counter # seqimmucc # dcq # base 1.2 按结果解读分 （1）同一细胞在不同样本的比例比较 1 2 3 4 5 6 7 8 # MCP-counter # xCell # TIMER # ConsensusTME # ESTIMATE # ABIS # mMCP-counter (mouse based) # BASE (mouse based) （2）同一样本内不同细胞比例比较 1 2 # CIBERSORT # DCQ (mouse based) （3）上述均可 1 2 3 4 # EPIC # quanTIseq # CIBERSORT abs. mode # seqImmuCC (mouse based) 1.3 算法细胞类型 immunedeconv包一方面可以将每种算法的原始结果作为输出，另一方面也综合所有算法的细胞类型进行了细胞类型统一。\nhttps://github.com/grst/immunedeconv/blob/master/inst/extdata/cell_type_mapping.xlsx 1 2 3 4 5 6 7 8 cell_types = readxl::read_xlsx(\u0026#34;cell_type_mapping.xlsx\u0026#34;,sheet = \u0026#34;mapping\u0026#34;) ## (1) 原始细胞类型 cell_types %\u0026gt;% dplyr::distinct(method_dataset, method_cell_type) ## (2) 统一细胞类型 cell_types %\u0026gt;% dplyr::distinct(method_dataset, cell_type) 2、基本使用方式 Step1：准备基因表达矩阵\n行名是基因(symbol)、列名是样本名的表达矩阵； 一般情况下需要进行TPM标准化，但不需进一步log处理 对于xcell、MCP-counter算法不进行标准化也可 1 2 3 4 5 6 7 8 # 包示例数据 expr_mat = dataset_racle$expr_mat head(expr_mat) # LAU125 LAU355 LAU1255 LAU1314 # A1BG 0.82 0.58 0.81 0.71 # A1CF 0.00 0.01 0.00 0.00 # A2M 247.15 24.88 2307.94 20.30 # A2M-AS1 1.38 0.20 2.60 0.28 Step2：选择合适算法，直接运行即可得到结果\n每一种算法均有两种使用方式，以xcell算法为例\n（1）deconvolute()，其分析结果为统一后的细胞类型 1 2 3 4 5 6 method = \u0026#34;xcell\u0026#34; scores = deconvolute(expr_mat, method=method) dim(scores) # [1] 39 5 ## deconvolute_mouse() （2）deconvolute_xcell()函数，其分析结果是原始结果 1 2 3 scores = deconvolute_xcell(expr_mat, arrays=F) dim(scores) # [1] 67 4 目前感觉更推荐第二种使用方式。（1）首先输出结果为原始算法类型，（2）函数的参数为针对该算法所设\n3、特殊使用方式 （1）对于一些算法，表达数据类型如果是芯片数据需要特别声明；例如quantiseq、cibersort、xcell等\n1 2 method = \u0026#34;quantiseq\u0026#34; scores = deconvolute(expr_mat, method = method, arrays = FALSE) （2）对于timer算法，需要交代每个样本的样本类型\n1 2 3 4 5 6 method = \u0026#34;timer\u0026#34; method = \u0026#34;ConsensusTME\u0026#34; # 所支持的样本类型 # https://gdc.cancer.gov/resources-tcga-users/tcga-code-tables/tcga-study-abbreviations timer_available_cancers scores = deconvolute(expr_mat, method = method, indications = c(\u0026#34;kich\u0026#34;, \u0026#34;blca\u0026#34;, \u0026#34;brca\u0026#34;, \u0026#34;brca\u0026#34;)) （3）对于cibersort算法，需要提供两个文件的路径\n1 2 3 4 5 method = \u0026#34;cibersort\u0026#34; method = \u0026#34;cibersort_abs\u0026#34; set_cibersort_binary(\u0026#34;./CIBERSORT1.04.R\u0026#34;) set_cibersort_mat(\u0026#34;./LM22.txt\u0026#34;) scores = deconvolute(expr_mat, method = method) （4）ESTIMATE算法用于预测肿瘤样本的肿瘤、免疫、基质分数以及肿瘤纯净度\n1 2 3 4 5 6 scores = deconvolute_estimate(expr_mat) # LAU125 LAU355 LAU1255 LAU1314 # StromalScore -1294.7848659 -653.7842997 -499.1445971 -1144.8145113 # ImmuneScore 17.3822270 3722.9742037 3033.2695535 3550.9927343 # ESTIMATEScore -1277.4026389 3069.1899040 2534.1249564 2406.1782230 # TumorPurity 0.9141139 0.4927852 0.5595386 0.5750048 对于小鼠表达数据，可以使用专门针对鼠的算法，也可将其基因名进行同源转换，再使用针对人的算法。在针对鼠的算法中， seqimmucc支持两种不同方式（\u0026ldquo;SVR\u0026rdquo;/\u0026ldquo;LLSR\u0026rdquo;）。对于前者，需要按照CIBERSORT流程声明两个文件的路径\n（5）其中有4种算法支持用户提供自定义的细胞类型特征进行预测\nbase: deconvolute_base_custom() cibersort norm/abs: deconvolute_cibersort_custom() epic: deconvolute_epic_custom() consensus_tme: deconvolute_consensus_tme_custom() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/072xcell%E4%B8%8Ecibersort%E7%AD%89%E5%85%8D%E7%96%AB%E6%B5%B8%E6%B6%A6%E5%88%86%E6%9E%90/","summary":"\u003ch2 id=\"xcell\"\u003exCell\u003c/h2\u003e\n\u003ch4 id=\"xcell包\"\u003exCell包\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edevtools::install_github(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;dviraran/xCell\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(xCell)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;xCell.data\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##查看支持的64种细胞类型，同下图\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecolnames(xCell.data$spill$K)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##预测函数的关键参数解释\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e?xCellAnalysis()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# expr =   交代表达矩阵；\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##如果是array，不需要额外标准化；如果是RNAseq，需要TPM/FPKM/TPM。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##对于基因ID格式需要是symbol格式。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# rnaseq = TRUE 数据是否为RNAseq数据，如果是芯片数据设置为FALSE\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# cell.types.use = NULL 提供一个字符串，说明想要预测64种细胞中的哪些细胞类型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# parallel.sz = 4 调用的线程数，默认为4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eNOTE：\u003c/p\u003e","title":"xCell与CIBERSORT等免疫浸润分析"},{"content":" ClusterGVis包是中国药科大学Jun Zhang博士开发的系列可视化工具包之一，可以基因表达矩阵进行高级的热图可视化分析。如下根据其github以及微信教程简单整理一下自己感兴趣的用法。\nGithub：https://github.com/junjunlab/ClusterGVis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 devtools::install_github(\u0026#34;junjunlab/ClusterGVis\u0026#34;) packageVersion(\u0026#34;ClusterGVis\u0026#34;) # [1] ‘0.0.8’ library(ClusterGVis) # 示例数据:标准化的 tpm/fpkm/rpkm 表达矩阵 data(exps) dim(exps) # [1] 3767 6 head(exps,3) # zygote t2.cell t4.cell t8.cell tmorula blastocyst # Oog4 1.3132282 1.237078 1.325978 1.262073 0.6549312 0.2067114 # Psmd9 1.0917337 1.315989 1.174417 1.064756 0.8685598 0.4845448 # Sephs2 0.9859232 1.201026 1.123076 1.084673 0.8878931 0.7174088 1、基因聚类 1.1 聚类 1 2 3 4 5 6 7 8 9 10 11 12 # (1)确定合适的聚类数 getClusters(exp = exps) # (2)两种聚类方式 c(\u0026#34;mfuzz\u0026#34;,\u0026#34;kmeans\u0026#34;) cm \u0026lt;- clusterData(exp = exps, cluster.method = \u0026#34;mfuzz\u0026#34;, cluster.num = 8, # subcluster = 1:6, #保留其中的1-6群 seed = 42) table(cm$long.res$cluster) # 1 2 3 4 5 6 7 8 # 1590 5532 2070 5310 2418 2538 1680 1464 1.2 线图 1 2 3 4 5 6 7 # 一条线代表一个基因 visCluster(object = cm, plot.type = \u0026#34;line\u0026#34;) #左 visCluster(object = cm, plot.type = \u0026#34;line\u0026#34;, ms.col = c(\u0026#34;green\u0026#34;,\u0026#34;orange\u0026#34;,\u0026#34;red\u0026#34;), add.mline = FALSE) #右 2、热图可视化 2.1 基础绘制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pdf(\u0026#34;tmp1.pdf\u0026#34;, width=8, height=10) visCluster(object = cm, plot.type = \u0026#34;heatmap\u0026#34;) dev.off() # 左 pdf(\u0026#34;tmp2.pdf\u0026#34;, width=8, height=10,onefile=FALSE) markGenes = rownames(exps)[sample(1:nrow(exps),30,replace = F)] visCluster(object = cm, plot.type = \u0026#34;heatmap\u0026#34;, show_row_dend = F, #不显示聚类树 column_names_rot = 45, #列标题角度 annnoblock.text = F, #行注释块不显示基因数量 ctAnno.col = ggsci::pal_npg()(8), #行注释块颜色 markGenes = markGenes, #注释部分基因名 genes.gp = c(\u0026#39;italic\u0026#39;,fontsize = 12), #基因名显示格式 cluster.order = c(1:9), # 行clster的顺序 # sample.group = rep(c(\u0026#34;group1\u0026#34;,\u0026#34;group2\u0026#34;,\u0026#34;group3\u0026#34;),each = 2), #添加样本分组 # sample.col = rep(ggsci::pal_aaas()(3), each=2), sample.order = colnames(exps) # 列sample的顺序 ) dev.off() # 右 2.2 添加线/箱图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 热图+线图 pdf(\u0026#34;tmp1.pdf\u0026#34;, width=8, height=10) visCluster(object = cm, plot.type = \u0026#34;both\u0026#34;, show_row_dend = F, textbox.size = 5, annnoblock.text = F) dev.off() # 热图+箱图 pdf(\u0026#34;tmp2.pdf\u0026#34;, width=8, height=10) visCluster(object = cm, plot.type = \u0026#34;both\u0026#34;, add.box = T, add.line = F, boxcol = ggsci::pal_npg()(8)) dev.off() 2.3 添加通路注释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 head(termanno)\t# id term # 1 C1 developmental process # 2 C1 anatomical structure development # 3 C1 multicellular organism development pdf(\u0026#34;tmp1.pdf\u0026#34;, width=8, height=10) visCluster(object = cm, plot.type = \u0026#34;both\u0026#34;, show_row_dend = F, annoTerm.data = termanno, line.side = \u0026#34;left\u0026#34;) dev.off() head(termanno2, 3) # id term pval # 1 C1 developmental process 3.17e-69 # 2 C1 anatomical structure development 1.44e-68 # 3 C1 multicellular organism development 1.36e-66 pdf(\u0026#34;tmp2.pdf\u0026#34;, width=12, height=10) visCluster(object = ck, plot.type = \u0026#34;both\u0026#34;, annoTerm.data = termanno2, line.side = \u0026#34;left\u0026#34;, #线图设置在左侧 show_row_dend = F, #不显示聚类层级图 go.col = rep(ggsci::pal_d3()(8),each = 3), #直接指定颜色 go.size = \u0026#34;pval\u0026#34;, #大小映射P值 add.bar = T, textbar.pos = c(0.8,0.2), annoTerm.mside = \u0026#34;left\u0026#34; # 增加条形图表示通路的P值， -log10转换 # sample.order = rev(colnames(exps)), # 指定样本你顺序 # subgroup.anno = c(\u0026#34;C4\u0026#34;,\u0026#34;C6\u0026#34;,\u0026#34;C8\u0026#34;) #只针对亚群注释 ) dev.off() 3、单细胞数据 （1）鉴定出细胞群的marker基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 library(Seurat) sce = pbmc3k.SeuratData::pbmc3k sce$celltype = as.character(sce$seurat_annotations) Idents(sce) = \u0026#34;celltype\u0026#34; deg_wilcox = Seurat::FindAllMarkers(sce, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25) deg_wilcox_top = deg_wilcox %\u0026gt;% dplyr::group_by(cluster) %\u0026gt;% dplyr::top_n(n = 20, wt = avg_log2FC) table(deg_wilcox_top$cluster) # Memory CD4 T B CD14+ Mono NK CD8 T Naive CD4 T FCGR3A+ Mono DC Platelet # 20 20 20 20 20 20 20 20 20 （2）准备绘图的输入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # [1] 以细胞群的均值作为输入,且默认对基因进行去重 st.data1 \u0026lt;- prepareDataFromscRNA(object = sce, diffData = deg_wilcox_top, showAverage = TRUE) # [2] 不对基因进行去重处理，添加后缀 st.data2 \u0026lt;- prepareDataFromscRNA(object = sce, diffData = deg_wilcox_top, showAverage = TRUE, keep.uniqGene = FALSE, sep = \u0026#34;_\u0026#34;) #\u0026#34;gene_1\u0026#34;,\u0026#34;gene_2\u0026#34;,.... # [3] 以每个细胞单独的表达作为输入 st.data3 \u0026lt;- prepareDataFromscRNA(object = sce, diffData = deg_wilcox_top, showAverage = FALSE) （3）通路富集分析，选取Top通路 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 这里使用该包自带的GO富集方法 library(org.Hs.eg.db) enrich \u0026lt;- enrichCluster(object = st.data, OrgDb = org.Hs.eg.db, type = \u0026#34;BP\u0026#34;, organism = \u0026#34;hsa\u0026#34;, pvalueCutoff = 0.5, topn = 3, seed = 5201314) head(enrich, 3) # group Description pvalue ratio # GO:0002181...1 C1 cytoplasmic translation 1.318764e-10 36.84211 # GO:1903131 C1 mononuclear cell differentiation 4.891104e-06 31.57895 # GO:0030217 C1 T cell differentiation 8.839690e-06 26.31579 （4）热图可视化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 pdf(\u0026#39;tmp1.pdf\u0026#39;,height = 10,width = 12,onefile = F) visCluster(object = st.data1, plot.type = \u0026#34;both\u0026#34;, show_row_dend = F, markGenes.side = \u0026#34;left\u0026#34;, annoTerm.data = enrich, line.side = \u0026#34;left\u0026#34;, go.col = rep(jjAnno::useMyCol(\u0026#34;stallion\u0026#34;,n = 9),each = 3)) dev.off() pdf(\u0026#39;tmp2.pdf\u0026#39;,height = 10,width = 14,onefile = F) visCluster(object = st.data3, plot.type = \u0026#34;both\u0026#34;, show_row_dend = F, markGenes.side = \u0026#34;left\u0026#34;, annoTerm.data = enrich, line.side = \u0026#34;left\u0026#34;, go.col = rep(jjAnno::useMyCol(\u0026#34;stallion\u0026#34;,n = 9),each = 3), add.bar = T, annoTerm.mside = \u0026#34;left\u0026#34;, show_column_names = F) dev.off() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/073clustergvis%E5%8C%85%E7%BB%98%E5%88%B6%E5%9F%BA%E5%9B%A0%E8%A1%A8%E8%BE%BE%E7%9F%A9%E9%98%B5%E7%83%AD%E5%9B%BE/","summary":"\u003cblockquote\u003e\n\u003cp\u003eClusterGVis包是中国药科大学Jun Zhang博士开发的系列可视化工具包之一，可以基因表达矩阵进行高级的热图可视化分析。如下根据其github以及微信教程简单整理一下自己感兴趣的用法。\u003c/p\u003e","title":"ClusterGVis包绘制基因表达矩阵热图"},{"content":" 生存分析(survival analysis)的主要目的是发现与患者生存事件相关的指标因素，例如年龄性别、基因表达/突变等。如下学习相关基础知识及几种常见的生存分析方法。\n参考教程：http://www.sthda.com/english/wiki/survival-analysis-basics\n1、基础知识 （1）event：表示“生存”结束的事件，最常见的形式是患者死亡，或者疾病复发等。\n（2）survival time：从开始记录(通常是初次诊断患病)，到event事件发生的时间。\nsurvival time的长短直接取决于对于事件的定义方法。 在UCSC xena整理的TCGA数据库中收集了4种事件定义方法，如下表所示。 开始日期 结束日期(事件发生) 特征 OS (overall survial) 初次诊断 患者死亡(任何原因) longest DSS (disease-specific survival) 初次诊断 因该病导致死亡 / PFI (progression-free interval) 初次诊断 经治疗后，该疾病首次恶化或导致患者死亡 shortest DFI (disease-free interval) 初次诊断 经治疗未发现肿瘤后，又复发或导致患者死亡 / [1] PFI里的恶化可包括疾病严重/局部区域复发/远处转移/新生肿瘤等指标。PFS(progression-free survival)指标与PFI基本类似，区别在于不关注死亡原因。\n[2] DFI里的复发可包括原位复发、远处转移、新生肿瘤（同器官）。DFS(disease-free survival)指标与DFI基本类似，区别在于同样不关注死亡原因。\n参考来源：\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC6066282/ Definitions and derivation of clinical survival outcome endpoints部分\nOS/PFS/PFI/DFS/DFI/DSS各种生存指标定义 – 王进的个人网站 (jingege.wang)\n（3）Censor 删失值\n在随访的过程中，可能无法全部病人都可以收集到准确地生存时间。\n一方面由于随访项目时间限制，直至随访结束，病人仍在世； 一方面可能在随访期间，病人失联、或者因其它原因去世等，无法继续随访。 这样的数据就称之为Censor，而此时的生存时间即为所能记录到的最长生存时间。病人的status要么是事件发生了，要么就是Censor。\n2、分析包与示例数据 （1）分析R包\n1 2 3 # install.packages(c(\u0026#34;survival\u0026#34;, \u0026#34;survminer\u0026#34;)) library(\u0026#34;survival\u0026#34;) #生存分析 library(\u0026#34;survminer\u0026#34;) #结果可视化 （2）示例数据 lung {survival}\n228个被诊断患有肺癌的病人开始长期的随访 如果病人死亡；则随访结束，并记录生存时间（从确诊到死亡的时间） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 head(lung) # inst time status age sex ph.ecog ph.karno pat.karno meal.cal wt.loss # 1 3 306 2 74 1 1 90 100 1175 NA # 2 3 455 2 68 1 0 90 90 1225 15 # 3 3 1010 1 56 1 0 90 90 NA 15 # 4 5 210 2 57 1 1 90 60 1150 11 # 5 1 883 2 60 1 0 100 90 NA 0 # 6 12 1022 1 74 1 1 50 80 513 0 # inst: Institution code # time: Survival time in days(*) 生存时间 # status: censoring status 1=censored, 2=dead(*) 事件是否发生 # age: Age in years # sex: Male=1 Female=2 # ph.ecog: ECOG performance score (0=good 5=dead) # ph.karno: Karnofsky performance score (bad=0-good=100) rated by physician # pat.karno: Karnofsky performance score as rated by patient # meal.cal: Calories consumed at meals # wt.loss: Weight loss in last six months 如果挖掘TCGA的数据，通常1表示事件发生，0表示censored\n3、Log-rank test分析 （1）对于一种表型因素将患者分成两组，分析是否具有显著生存差异；\n性别、基因突变、疾病阶段等可根据表型特性分组； 年龄、基因表达等可设置特定阈值进行分组。 （2）survfit()分析，后续可对其结果进行绘图：\nn表示每组的病人数； events表示每组有多少病人死亡； median 表示中位生存率所对应的生存时间； 最后两列表示第三列的95%置信区间。 1 2 3 4 5 6 7 8 9 10 11 fit \u0026lt;- survfit(Surv(time, status) ~ sex, data = lung) print(fit) # Call: survfit(formula = Surv(time, status) ~ sex, data = lung) # # n events median 0.95LCL 0.95UCL # sex=1 138 112 270 212 310 # sex=2 90 53 426 348 550 res.sum \u0026lt;- surv_summary(fit) head(res.sum[res.sum$sex==1,]) head(res.sum[res.sum$sex==2,]) （3）survdiff() 分析显著性P值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 surv_diff \u0026lt;- survdiff(Surv(time, status) ~ sex, data = lung) # Call: # survdiff(formula = Surv(time, status) ~ sex, data = lung) # # N Observed Expected (O-E)^2/E (O-E)^2/V # sex=1 138 112 91.6 4.55 10.3 # sex=2 90 53 73.4 5.68 10.3 # # Chisq= 10.3 on 1 degrees of freedom, p= 0.001 #虽然如上结果是有P值的，但是尝试之后发现从对象中只能提取chisq的值，然后再进一步转换 p.val = 1 - pchisq(surv_diff$chisq, length(surv_diff$n) - 1) p.val # [1] 0.001311165 （4）最优分组阈值 ☆\n对于连续型变量（例如基因表达），需要手动设置一个阈值对样本进行二分组（或多分组），再进行生存分析。最常见的选择是中位数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 以其中的年龄为例 median_cut = median(lung$age) # 57 lung$age_group = ifelse(lung$age \u0026gt; median_cut, \u0026#34;Old\u0026#34;, \u0026#34;Young\u0026#34;) table(lung$age_group) # Old Young # 111 117 surv_diff \u0026lt;- survdiff(Surv(time, status) ~ age_group, data = lung) p.val = 1 - pchisq(surv_diff$chisq, length(surv_diff$n) - 1) p.val # [1] 0.1702206 寻找最优阈值，使得组间的生存差异最显著。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 使用survminer包的surv_cutpoint函数 res.cut \u0026lt;- surv_cutpoint(lung, time = \u0026#34;time\u0026#34;, event = \u0026#34;status\u0026#34;, variables = c(\u0026#34;age\u0026#34;)) summary(res.cut) # cutpoint statistic # age 70 2.013619 # best cut best_cut = summary(res.cut)[\u0026#34;age\u0026#34;,\u0026#34;cutpoint\u0026#34;] # [1] 70 lung$age_group_best = ifelse(lung$age \u0026gt; best_cut, \u0026#34;Old\u0026#34;, \u0026#34;Young\u0026#34;) table(lung$age_group_best) # Old Young # 46 182 surv_diff \u0026lt;- survdiff(Surv(time, status) ~ age_group_best, data = lung) p.val = 1 - pchisq(surv_diff$chisq, length(surv_diff$n) - 1) p.val # [1] 0.0312283 # 这里的p值结果相较上述的中位数分析更为显著 4、Log-rank test可视化 （1）绘制生存曲线，如下图所示默认绘制两个部分\n上图：时间对应的生存率的生存曲线图，曲线中的短竖线表示在时间点有缺失值病人。不同颜色表示不同分组，阴影部分表示95%置信区间；左下角p值表示基于log-rank test计算得到的P值。 下表：不同时间点对应每组尚未发生事件(死亡)的数目。 1 2 3 ggsurvplot(fit, pval = TRUE, conf.int = TRUE, risk.table = TRUE) （2）可调整的图形参数(结合具体代码理解)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 p1 = ggsurvplot( fit, pval = TRUE, conf.int = TRUE, risk.table = TRUE, # Add risk table risk.table.col = \u0026#34;strata\u0026#34;, # Change risk table color by groups linetype = \u0026#34;strata\u0026#34;, # Change line type by groups surv.median.line = \u0026#34;hv\u0026#34;, # Specify median survival ggtheme = theme_bw(), # Change ggplot2 theme palette = c(\u0026#34;#E7B800\u0026#34;, \u0026#34;#2E9FDF\u0026#34;) ) p2 = ggsurvplot( fit, # survfit object with calculated statistics. pval = TRUE, # show p-value of log-rank test. conf.int = TRUE, # show confidence intervals for # point estimaes of survival curves. conf.int.style = \u0026#34;step\u0026#34;, # customize style of confidence intervals xlab = \u0026#34;Time in days\u0026#34;, # customize X axis label. break.time.by = 200, # break X axis in time intervals by 200. ggtheme = theme_light(), # customize plot and risk table with a theme. risk.table = \u0026#34;abs_pct\u0026#34;, # absolute number and percentage at risk. risk.table.y.text.col = T,# colour risk table text annotations. risk.table.y.text = FALSE,# show bars instead of names in text annotations # in legend of risk table. ncensor.plot = TRUE, # plot the number of censored subjects at time t surv.median.line = \u0026#34;hv\u0026#34;, # add the median survival pointer. legend.labs = c(\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;), # change legend labels. palette = c(\u0026#34;#E7B800\u0026#34;, \u0026#34;#2E9FDF\u0026#34;) # custom color palettes. ) arrange_ggsurvplots(list(p1,p2)) （3）如上是经典的生存曲线，同时也支持绘制其它类型曲线\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 参数`fun=\u0026#34;event\u0026#34;`，表示cumulative event事件累计发生率 p3=ggsurvplot( fit, conf.int = TRUE, risk.table.col = \u0026#34;strata\u0026#34;, # Change risk table color by groups ggtheme = theme_bw(), # Change ggplot2 theme palette = c(\u0026#34;#E7B800\u0026#34;, \u0026#34;#2E9FDF\u0026#34;), fun = \u0026#34;event\u0026#34; ) # 参数`fun=\u0026#34;cumhaz\u0026#34;`，表示cummulative hazard表示累计风险水平（在时刻t，事件发生的可能性） p4=ggsurvplot( fit, conf.int = TRUE, risk.table.col = \u0026#34;strata\u0026#34;, # Change risk table color by groups ggtheme = theme_bw(), # Change ggplot2 theme palette = c(\u0026#34;#E7B800\u0026#34;, \u0026#34;#2E9FDF\u0026#34;), fun = \u0026#34;cumhaz\u0026#34; ) arrange_ggsurvplots(list(p3,p4)) 5、比例风险模型分析 比例风险模型又称Cox Proportional-Hazards Model，用于量化每个表型对于事件发生的影响大小。\n表型可以是分类变量或者是连续变量； 衡量影响大小的指标称为Hazard rate(风险因子)，简称HR Hazard ratio(HR)=exp(coef) HR\u0026lt;1(coef\u0026lt;0) 表明负相关\u0026mdash;该变量值越大，事件发生风险越低，生存率越高； HR\u0026gt;1(coef\u0026gt;0) 表明正相关\u0026mdash;该变量值越大，事件发生风险越高，生存率越小。 （1） 单变量Cox回归\n1 2 3 4 5 6 7 8 9 10 11 12 13 res.cox \u0026lt;- coxph(Surv(time, status) ~ sex, data = lung) res.cox # Call: # coxph(formula = Surv(time, status) ~ sex, data = lung) # # coef exp(coef) se(coef) z p # sex -0.5310 0.5880 0.1672 -3.176 0.00149 # # Likelihood ratio test=10.63 on 1 df, p=0.001111 # n= 228, number of events= 165 exp(res.cox$coefficients) # sex # 0.5880028 （2）对多个变量分别进行单变量Cox回归\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #分别回归 covariates \u0026lt;- c(\u0026#34;age\u0026#34;, \u0026#34;sex\u0026#34;, \u0026#34;ph.karno\u0026#34;, \u0026#34;ph.ecog\u0026#34;, \u0026#34;wt.loss\u0026#34;) univ_formulas \u0026lt;- sapply(covariates, function(x) as.formula(paste(\u0026#39;Surv(time, status)~\u0026#39;, x))) univ_models \u0026lt;- lapply( univ_formulas, function(x){coxph(x, data = lung)}) #提取各个变量的回归结果 univ_results \u0026lt;- lapply(univ_models, function(x){ x \u0026lt;- summary(x) p.value\u0026lt;-signif(x$wald[\u0026#34;pvalue\u0026#34;], digits=2) wald.test\u0026lt;-signif(x$wald[\u0026#34;test\u0026#34;], digits=2) beta\u0026lt;-signif(x$coef[1], digits=2);#coeficient beta HR \u0026lt;-signif(x$coef[2], digits=2);#exp(beta) HR.confint.lower \u0026lt;- signif(x$conf.int[,\u0026#34;lower .95\u0026#34;], 2) HR.confint.upper \u0026lt;- signif(x$conf.int[,\u0026#34;upper .95\u0026#34;],2) HR \u0026lt;- paste0(HR, \u0026#34; (\u0026#34;, HR.confint.lower, \u0026#34;-\u0026#34;, HR.confint.upper, \u0026#34;)\u0026#34;) res\u0026lt;-c(beta, HR, wald.test, p.value) names(res)\u0026lt;-c(\u0026#34;beta\u0026#34;, \u0026#34;HR (95% CI for HR)\u0026#34;, \u0026#34;wald.test\u0026#34;, \u0026#34;p.value\u0026#34;) return(res) #return(exp(cbind(coef(x),confint(x)))) }) res \u0026lt;- t(as.data.frame(univ_results, check.names = FALSE)) as.data.frame(res) # beta HR (95% CI for HR) wald.test p.value # age 0.019 1 (1-1) 4.1 0.042 # sex -0.53 0.59 (0.42-0.82) 10 0.0015 # ph.karno -0.016 0.98 (0.97-1) 7.9 0.005 # ph.ecog 0.48 1.6 (1.3-2) 18 2.7e-05 # wt.loss 0.0013 1 (0.99-1) 0.05 0.83 （3）多变量Cox回归(多元回归)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 res.cox \u0026lt;- coxph(Surv(time, status) ~ age + sex + ph.ecog, data = lung) summary(res.cox) # Call: # coxph(formula = Surv(time, status) ~ age + sex + ph.ecog, data = lung) # # n= 227, number of events= 164 # (因为不存在，1个观察量被删除了) # # coef exp(coef) se(coef) z Pr(\u0026gt;|z|) # age 0.011067 1.011128 0.009267 1.194 0.232416 # sex -0.552612 0.575445 0.167739 -3.294 0.000986 *** # ph.ecog 0.463728 1.589991 0.113577 4.083 4.45e-05 *** # --- # Signif. codes: 0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 # # exp(coef) exp(-coef) lower .95 upper .95 # age 1.0111 0.9890 0.9929 1.0297 # sex 0.5754 1.7378 0.4142 0.7994 # ph.ecog 1.5900 0.6289 1.2727 1.9864 # # Concordance= 0.637 (se = 0.025 ) # Likelihood ratio test= 30.5 on 3 df, p=1e-06 # Wald test = 29.93 on 3 df, p=1e-06 # Score (logrank) test = 30.5 on 3 df, p=1e-06 ggforest(res.cox, data = lung, main = \u0026#34;Hazard ratio\u0026#34;, cpositions = c(0.10, 0.22, 0.4), fontsize = 1.0) 6、cox模式lasso回归 lasso回归是一种特殊的多元线性回归，可通过正则化惩罚项将冗余变量的系数变为0（即舍弃该变量）。\nglmnet包可实现多种类型的lasso回归，其中包括以生存时间和事件为结局的cox回归。\n1 2 install.packages(\u0026#34;glmnet\u0026#34;) library(glmnet) （1）示例数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(survival) data(CoxExample) x \u0026lt;- CoxExample$x y \u0026lt;- CoxExample$y ## 标签数据(生存资料) dim(y) # [1] 1000 2 head(y) # time status # [1,] 1.76877757 1 # [2,] 0.54528404 1 # [3,] 0.04485918 0 ## 特征数据(类似基因表达数据) dim(x) # [1] 1000 30 x[1:4,1:4] # [,1] [,2] [,3] [,4] # [1,] -0.8767670 -0.6135224 -0.5675738 0.6621599 # [2,] -0.7463894 -1.7519457 0.2854590 1.1392105 # [3,] 1.3759148 -0.2641132 0.8872741 0.3841870 # [4,] 0.2375820 0.7859162 -0.8967028 -0.8339338 （2）lasso分析\n1 2 3 4 5 6 fit \u0026lt;- glmnet(x, y, family = \u0026#34;cox\u0026#34;) print(fit) plot(fit, xvar = \u0026#34;norm\u0026#34;, label = FALSE) # default # plot(fit, xvar = \u0026#34;lambda\u0026#34;, label = FALSE) # plot(fit, xvar = \u0026#34;dev\u0026#34;, label = FALSE) 如下图所示：\n下轴：不同的L1 norm惩罚值； 上轴：在相应L1 norm惩罚值里，当前系数非0的变量个数； 左轴：变量的系数值 （3）交叉验证\n在cox模式的lasso回归交叉验证中，支持两类评价指标\ndeviance：为默认指标；该值越小，模型预测效果越好 C：即C-index，类似AUC；该值越大，模型预测效果越好 1 2 3 4 set.seed(1) cvfit \u0026lt;- cv.glmnet(x, y, family = \u0026#34;cox\u0026#34;, type.measure = \u0026#34;deviance\u0026#34;) # cvfit \u0026lt;- cv.glmnet(x, y, family = \u0026#34;cox\u0026#34;, type.measure = \u0026#34;C\u0026#34;) plot(cvfit) 如下图，两条虚线分别表示两个λ值\n左边的虚线→lambda.min ：表示评价指标最优的λ取值； 右边的虚线→lambda.1se：表示lambda.min的一倍标准差下对模型更为严格惩罚的λ取值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 cvfit$lambda.min # [1] 0.01920429 cvfit$lambda.1se # 1] 0.04436439 coef(cvfit, s = cvfit$lambda.min) library(tidyverse) coef(cvfit, s=\u0026#34;lambda.min\u0026#34;) %\u0026gt;% as.matrix() %\u0026gt;% as.data.frame() %\u0026gt;% tibble::rownames_to_column(var = \u0026#34;mRNA\u0026#34;) %\u0026gt;% dplyr::rename(coef=`1`) %\u0026gt;% dplyr::filter(coef!=0) # mRNA coef # 1 V1 0.47972069 # 2 V2 -0.16674492 # 3 V3 -0.21014303 # 4 V4 0.16781912 # 5 V5 -0.17951289 # 6 V6 -0.48058218 # 7 V7 0.32603876 # 8 V8 0.08646499 # 9 V9 0.44014703 # 10 V10 0.10854409 # 11 V13 0.01304299 # 12 V17 -0.01388096 # 13 V25 -0.01830447 # 14 V30 -0.00301953 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/059survival%E5%8C%85%E7%94%9F%E5%AD%98%E5%88%86%E6%9E%90%E5%8F%8Aglmnet%E5%8C%85lasso%E5%9B%9E%E5%BD%92/","summary":"\u003cblockquote\u003e\n\u003cp\u003e生存分析(survival analysis)的主要目的是发现与患者生存事件相关的指标因素，例如年龄性别、基因表达/突变等。如下学习相关基础知识及几种常见的生存分析方法。\u003c/p\u003e","title":"survival包生存分析及glmnet包lasso回归"},{"content":" MuSiC(MUlti-Subject SIngle Cell deconvolution)是来自宾夕法尼亚大学Biostatistics, Epidemiology and Informatics系的Mingyao Li课题组于2019年发表于Nature Communication的一个工具R包，可根据单细胞转录组信息推测Bulk RNA-seq细胞组成。而后，该团队又于2022年在Briefing in bioinformatics发表了扩展版本MuSiC2，可以考虑更复杂的场景。\nPaper\u0026ndash;MuSic：https://doi.org/10.1038/s41467-018-08023-x Paper\u0026ndash;MuSic2：https://doi.org/10.1093/bib/bbac430 Github：https://xuranw.github.io/MuSiC/index.html 1、算法简介 1.1 MuSiC 如下是流程图，由于单细胞数据一般存在多个样本，MuSiC的核心是“marker gene consistency”，即基因的表达一致性体现在同种细胞类型间(cross cell)，也体现在不同样本间(cross subject)。在去卷积注释时针对这些基因会赋予较高的权重。 另一方面考虑到，作者认为Solid tissues often contain closely related cell types，即一般算法难以对这些类似的细胞进行区分。对此，MuSiC分两步预测。首先进行general prediction，然后针对每个cluster分别单独预测具体的细胞类型比例。 1.2 MuSiC2 MuSiC2算法在上述基础考虑到Bulk RNAseq的组间差异带来的影响。一般单细胞数据来自健康人组织，而Bulk RNAseq可能有健康，疾病等多组。 作者认为需要避免健康与疾病组间的差异基因表达对细胞类型去卷积产生的干扰，即选择stable genes对疾病组样本注释(删去组间细胞类型差异表达基因)。 2、R包用法 1 2 3 4 5 6 7 8 # 安装 # BiocManager::install(\u0026#34;TOAST\u0026#34;) devtools::install_github(\u0026#39;xuranw/MuSiC\u0026#39;) ## 参考Github教程提前下载示例数据 # Bulk data为ExpressionSet格式 # scRNA-seq data为SingleCellExperiment format格式 # 表达矩阵均为原始read counts，不需要标准化 2.1 MuSiC简单用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # (1) Bulk data GSE50244.bulk.eset = readRDS(\u0026#39;./GSE50244bulkeset.rds\u0026#39;) dim(GSE50244.bulk.eset) # Features Samples # 32581 89 bulk.mtx = exprs(GSE50244.bulk.eset) # (2) scRNA-seq data EMTAB.sce = readRDS(\u0026#39;./EMTABsce_healthy.rds\u0026#39;) dim(EMTAB.sce) # [1] 25453 1097 # 主要需要两列注释信息：样本名与细胞类型 table(EMTAB.sce$cellType, EMTAB.sce$sampleID) # 1 2 4 5 6 8 # acinar 4 20 3 80 3 2 # alpha 28 117 92 26 136 44 # beta 12 48 35 32 34 10 # co-expression 3 3 6 5 6 3 # delta 7 21 12 2 7 10 # ductal 4 19 14 67 8 23 # endothelial 1 1 8 0 1 2 # epsilon 0 1 3 1 0 0 # ...... # (3) Estimate cell type proportions music_pred_obj = music_prop(bulk.mtx = bulk.mtx, # bulk exp sc.sce = EMTAB.sce, # scRNAseq obj clusters = \u0026#39;cellType\u0026#39;, # cluster column samples = \u0026#39;sampleID\u0026#39;, # sample column select.ct = c(\u0026#39;alpha\u0026#39;, \u0026#39;beta\u0026#39;, \u0026#39;delta\u0026#39;, \u0026#39;gamma\u0026#39;, \u0026#39;acinar\u0026#39;, \u0026#39;ductal\u0026#39;), verbose = F) names(music_pred_obj) # [1] \u0026#34;Est.prop.weighted\u0026#34; \u0026#34;Est.prop.allgene\u0026#34; \u0026#34;Weight.gene\u0026#34; \u0026#34;r.squared.full\u0026#34; \u0026#34;Var.prop\u0026#34; ## 前两者分别表示MuSiC与NNLS算法的结果：每个样本(行)对于每种细胞类型(列)的比例，并进行样本水平归一化 music_pred_obj$Est.prop.weighted[1:4,] # alpha beta delta gamma acinar ductal # Sub1 0.2079168 0.1746030 0.002203054 0.0015887041 0.09597685 0.5177117 # Sub2 0.6964173 0.1197928 0.003683287 0.0007471486 0.03078049 0.1485789 # Sub3 0.1913485 0.3521117 0.032037770 0.0003117540 0.19143687 0.2327533 # Sub4 0.2339358 0.4673282 0.009425930 0.0226075392 0.05385258 0.2128500 2.2 MuSiC分步预测 即针对细胞类型相似的Bulk组织类型（Solid tissues often contain closely related cell types）\n（1）预处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Mouse.bulk.eset = readRDS(\u0026#39;./Mousebulkeset.rds\u0026#39;) Mouse.bulk.eset # 10 19033 Mousesub.sce = readRDS(\u0026#39;./Mousesub_sce.rds\u0026#39;) Mousesub.sce # 10000 16273 Mousesub.basis = music_basis(Mousesub.sce, clusters = \u0026#39;cellType\u0026#39;, samples = \u0026#39;sampleID\u0026#39;, select.ct = c(\u0026#39;Endo\u0026#39;, \u0026#39;Podo\u0026#39;, \u0026#39;PT\u0026#39;, \u0026#39;LOH\u0026#39;, \u0026#39;DCT\u0026#39;, \u0026#39;CD-PC\u0026#39;, \u0026#39;CD-IC\u0026#39;, \u0026#39;Fib\u0026#39;,\u0026#39;Macro\u0026#39;, \u0026#39;Neutro\u0026#39;,\u0026#39;B lymph\u0026#39;, \u0026#39;T lymph\u0026#39;, \u0026#39;NK\u0026#39;)) （2）根据单细胞的标签定义相似的细胞组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 d \u0026lt;- dist(t(log(Mousesub.basis$Disgn.mtx + 1e-6)), method = \u0026#34;euclidean\u0026#34;) # d \u0026lt;- dist(t(log(Mousesub.basis$M.theta + 1e-8)), method = \u0026#34;euclidean\u0026#34;) hc1 \u0026lt;- hclust(d, method = \u0026#34;complete\u0026#34; ) plot(hc1, cex = 0.6, hang = -1, main = \u0026#39;Cluster log(Design Matrix)\u0026#39;) clusters.type = list(C1 = \u0026#39;Neutro\u0026#39;, C2 = \u0026#39;Podo\u0026#39;, C3 = c(\u0026#39;Endo\u0026#39;, \u0026#39;CD-PC\u0026#39;, \u0026#39;LOH\u0026#39;, \u0026#39;CD-IC\u0026#39;, \u0026#39;DCT\u0026#39;, \u0026#39;PT\u0026#39;), C4 = c(\u0026#39;Macro\u0026#39;, \u0026#39;Fib\u0026#39;, \u0026#39;B lymph\u0026#39;, \u0026#39;NK\u0026#39;, \u0026#39;T lymph\u0026#39;)) # 添加到单细胞数据中 cl.type = as.character(Mousesub.sce$cellType) for(cl in 1:length(clusters.type)){ cl.type[cl.type %in% clusters.type[[cl]]] = names(clusters.type)[cl] } Mousesub.sce$clusterType = factor(cl.type, levels = c(names(clusters.type), \u0026#39;CD-Trans\u0026#39;, \u0026#39;Novel1\u0026#39;, \u0026#39;Novel2\u0026#39;)) （3）鉴定每大组内的组间marker基因(marker genes within each group) 1 2 3 4 5 6 7 8 9 load(\u0026#39;./IEmarkers.RData\u0026#39;) IEmarkers = list(NULL, NULL, Epith.marker, Immune.marker) names(IEmarkers) = c(\u0026#39;C1\u0026#39;, \u0026#39;C2\u0026#39;, \u0026#39;C3\u0026#39;, \u0026#39;C4\u0026#39;) str(IEmarkers) # List of 4 # $ C1: NULL # $ C2: NULL # $ C3: chr [1:2614] \u0026#34;Rp1\u0026#34; \u0026#34;Sox17\u0026#34; \u0026#34;1700034P13Rik\u0026#34; \u0026#34;Prex2\u0026#34; ... # $ C4: chr [1:8126] \u0026#34;Sox17\u0026#34; \u0026#34;Gm37988\u0026#34; \u0026#34;Gm26901\u0026#34; \u0026#34;Mybl1\u0026#34; ... （4）Estimate cell type proportions 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 music_pred_obj = music_prop.cluster(bulk.mtx = exprs(Mouse.bulk.eset), sc.sce = Mousesub.sce, group.markers = IEmarkers, clusters = \u0026#39;cellType\u0026#39;, groups = \u0026#39;clusterType\u0026#39;, samples = \u0026#39;sampleID\u0026#39;, clusters.type = clusters.type) dim(music_pred_obj$Est.prop.weighted.cluster) # 10, 13 music_pred_obj$Est.prop.weighted.cluster[1:4, 1:4] # Neutro Podo Endo CD-PC # control.NA.27 0 0.009505281 0.04474493 0.02680222 # control.NA.30 0 0.021948575 0.04305809 0.02687187 # control.NA.39 0 0.005628454 0.04412269 0.02802505 # control.NAP.3 0 0.018769776 0.04305809 0.02655007 2.3 MuSiC2用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # (1) 50个对照与50个疾病，共100个样本的Bulk data benchmark.eset = readRDS(\u0026#34;./bulk-eset.rds\u0026#34;) benchmark.eset table(benchmark.eset$group) # healthy t2d # 50 50 # (2) 来自健康样本的scRNA-seq Data seger.sce = readRDS(\u0026#34;./EMTABsce_healthy.rds\u0026#34;) seger.sce # (3) Estimate cell type proportions music2_pred_obj = music2_prop(bulk.control.mtx = bulk.control.mtx, bulk.case.mtx = bulk.case.mtx, sc.sce = seger.sce, clusters = \u0026#39;cellType\u0026#39;, samples = \u0026#39;sampleID\u0026#39;, select.ct = c(\u0026#39;acinar\u0026#39;,\u0026#39;alpha\u0026#39;,\u0026#39;beta\u0026#39;,\u0026#39;delta\u0026#39;,\u0026#39;ductal\u0026#39;,\u0026#39;gamma\u0026#39;), n_resample=20, sample_prop=0.5, cutoff_c=0.05,cutoff_r=0.01) dim(music2_pred_obj$Est.prop) # [1] 100 6 # acinar alpha beta delta ductal gamma # 1 0.154031473 0.03854683 0.5124088 0.001545064 0.29346786 0.000000000 # 10 0.559249172 0.13773168 0.2220337 0.005554692 0.07290038 0.002530353 # 12 0.062448310 0.57696213 0.1321646 0.000000000 0.22842496 0.000000000 # 14 0.113631970 0.34670271 0.3154881 0.000000000 0.16988614 0.054291121 # 17 0.078927767 0.31450931 0.2647605 0.000000000 0.34180242 0.000000000 # 2 0.008209709 0.41839211 0.1390657 0.019564262 0.41476824 0.000000000 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/074music%E5%8C%85%E6%A0%B9%E6%8D%AEscrnaseq%E9%A2%84%E6%B5%8Bbulk%E7%BB%86%E8%83%9E%E7%BB%84%E6%88%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eMuSiC(MUlti-Subject SIngle Cell deconvolution)是来自宾夕法尼亚大学Biostatistics, Epidemiology and Informatics系的Mingyao Li课题组于2019年发表于Nature Communication的一个工具R包，可根据单细胞转录组信息推测Bulk RNA-seq细胞组成。而后，该团队又于2022年在Briefing in bioinformatics发表了扩展版本MuSiC2，可以考虑更复杂的场景。\u003c/p\u003e","title":"MuSiC包根据scRNAseq预测Bulk细胞组成"},{"content":" RNA-seq数据比对流程主要分为三步（1）整理数据；（2）质控；（3）比对。其中每一步都涉及到若干软件的用法，如下简单整理基本的分析流程。\n示例数据：GSE158623中6个样本的RNA-seq测序结果(human)，对应SRR12720999~SRR12721004\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE158623 https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA665998 1 2 3 4 5 6 7 cat SraAccList.txt SRR12720999 SRR12721000 SRR12721001 SRR12721002 SRR12721003 SRR12721004 0、搭建conda环境 根据需要，搭建两个conda分析环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ### (1) 下载数据 conda activate download #ascp的aspera高速下载 conda install -c hcc aspera-cli #prefech下载sra文件 conda install -c bioconda sra-tools # 基因组下载商店 # conda install refgenie # QC质控 conda install -c bioconda trim-galore multiqc ### (2) 比对分析 conda activate fq_map #不同类型的比对软件 conda install -c bioconda hisat2 conda install -c bioconda star=2.7.1a conda install -c bioconda bwa conda install -c bioconda bowtie2 conda install -c bioconda salmon=1.5.2 # 汇总比对结果 conda install -c bioconda multiqc # 基因组下载商店 # conda install refgenie # sam2bam转换 conda install -c bioconda samtools # 基因表达定量 conda install -c bioconda subread 如上，默认下载软件的最新版本即可，但结合尝试、探索，star与salmon比对软件的版本信息必须与构建对应索引文件的软件版本一致(refgenie构建)。因此安装了上述指定的版本。\n1、下载数据 （1）下载公共测序数据：参考之前笔记，有aspera/prefetch/wget等三种下载方式，如下为aspera的下载代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 批量生成下载链接 # era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/SRR166/009/SRR1663609/SRR1663609_1.fastq.gz touch ascp.link cat SraAccList.txt | while read id do echo \u0026#34;era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/0${id:0-2}/${id}/${id}_1.fastq.gz\u0026#34; \u0026gt;\u0026gt; ascp.link echo \u0026#34;era-fasp@fasp.sra.ebi.ac.uk:/vol1/fastq/${id:0:6}/0${id:0-2}/${id}/${id}_2.fastq.gz\u0026#34; \u0026gt;\u0026gt; ascp.link done #ascp高速下载 cat ascp.link |while read sample do ascp -QT -l 300m -P33001 \\ -i ~/miniconda3/envs/download/etc/asperaweb_id_dsa.openssh \\ $sample . done （2）下载基因组相关参考数据：主要包括基因组序列fasta、基因组注释文件gtf、各类比对软件的基因组索引文件。\n参考之前笔记，上述文件均可通过refgenie工具下载。如下为下载代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 refgenie init -c ~/refgenie/genome_config.yaml refgenie listr -c ~/refgenie/genome_config.yaml refgenie listr -g hg38 -c ~/refgenie/genome_config.yaml #参考基因组 refgenie pull hg38/fasta -c ~/refgenie/genome_config.yaml refgenie pull hg38_cdna/fasta -c ~/refgenie/genome_config.yaml #参考注释信息 refgenie pull hg38/gencode_gtf -c ~/refgenie/genome_config.yaml #比对软件的索引文件 refgenie pull hg38/bowtie2_index -c ~/refgenie/genome_config.yaml refgenie pull hg38/bwa_index -c ~/refgenie/genome_config.yaml refgenie pull hg38/star_index -c ~/refgenie/genome_config.yaml refgenie pull hg38/hisat2_index -c ~/refgenie/genome_config.yaml refgenie pull hg38_cdna/salmon_index -c ~/refgenie/genome_config.yaml #列出本地已经下载的数据 refgenie list -c ~/refgenie/genome_config.yaml 2、测序数据质控 主要目的是为了过滤测序数据中的低质量reads。\n相关RNAseq质控软件有很多，如下以trim_glaore软件用法为例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # (1)以其中一个作为示例 pare_dir=/home/data/****/mapping fq1=${pare_dir}/raw/ebi/SRR12720999_1.fastq.gz fq2=${pare_dir}/raw/ebi/SRR12720999_2.fastq.gz trim_galore -j 8 -q 25 --phred33 --length 36 \\ -paired -o ${pare_dir}/trim \\ $fq1 $fq2 # (2)批量分析 cat ${pare_dir}/SraAccList.txt | while read id do echo $id trim_galore -j 8 -q 25 --phred33 --length 36 \\ -paired -o ${pare_dir}/trim \\ ${pare_dir}/raw/ebi/${id}_1.fastq.gz \\ ${pare_dir}/raw/ebi/${id}_2.fastq.gz done # (3)查看质控之后的fatsq.gz质量 fastqc $(ls ${pare_dir}/trim/*gz) -o ${pare_dir}/trim/ -t 10 multiqc ./ -n trim_multiqc_report.html 3、各类比对软件 RNAseq比对软件有很多，常见的包括hisat2、star、bowtie2、bwa以及salmon； 命令调用均主要包括参数：参考基因组索引文件、 测序数据、输出结果名，以及线程数 比对结果通常是.sam文件，一般需要转为.bam格式，最后提取出count表达数据； （1）以其中一对fatsq.gz文件为例，总结各个比对软件的用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 conda activate fq_map pare_dir=/home/data/****/mapping fq1=${pare_dir}/trim/SRR12720999_1_val_1.fq.gz fq2=${pare_dir}/trim/SRR12720999_2_val_2.fq.gz #hisat2 ref_idx_hisat2=$(refgenie seek hg38/hisat2_index -c ~/refgenie/genome_config.yaml) time hisat2 -t -p 10 -x $ref_idx_hisat2 -1 $fq1 -2 $fq2 -S test.sam #STAR ref_idx_star=$(refgenie seek hg38/star_index -c ~/refgenie/genome_config.yaml) time STAR --genomeDir $ref_idx_star \\ --runThreadN 10 --readFilesCommand zcat \\ --readFilesIn $fq1 $fq2 \\ --outSAMtype SAM --outFileNamePrefix test #Bowtie2 ref_idx_bowtie2=$(refgenie seek hg38/bowtie2_index -c ~/refgenie/genome_config.yaml) time bowtie2 -p 10 -x $ref_idx_bowtie2 -1 $fq1 -2 $fq2 -S test.sam #BWA ref_idx_bwa=$(refgenie seek hg38/bwa_index -c ~/refgenie/genome_config.yaml) time bwa mem -t 10 $ref_idx_bwa $fq1 $fq2 -o test.sam #salmon ref_idx_salmon=$(refgenie seek hg38_cdna/salmon_index -c ~/refgenie/genome_config.yaml) time salmon quant -i $ref_idx_salmon -l A \\ -1 $fq1 -2 $fq2 \\ -p 10 -o test_quant （2）基于全部数据，总结每个比对软件的批量比对全流程用法\n[1] hisat2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #1、定义变量 ref_idx_hisat2=$(refgenie seek hg38/hisat2_index -c ~/refgenie/genome_config.yaml) ref_gtf=$(refgenie seek hg38/gencode_gtf -c ~/refgenie/genome_config.yaml) pare_dir=/home/data/****/mapping #2、批量比对 cat ${pare_dir}/SraAccList.txt | while read id do echo $id #首先进行比对，生成sam文件 echo \u0026#34;Start hisat mapping....\u0026#34; hisat2 -p 10 -x $ref_idx_hisat2 \\ -1 ${pare_dir}/trim/${id}_1_val_1.fq.gz \\ -2 ${pare_dir}/trim/${id}_2_val_2.fq.gz \\ -S ${pare_dir}/hisat2/${id}.sam #然后sam转bam,同时删除内存较大的bam echo \u0026#34;Start sam2bam....\u0026#34; samtools view -S ${pare_dir}/hisat2/${id}.sam \\ -@ 10 -b \u0026gt; ${pare_dir}/hisat2/${id}.bam rm ${pare_dir}/hisat2/${id}.sam done #3、featureCounts提取表达信息 featureCounts -p -T 10 -t exon -g gene_name -a $ref_gtf -o hisat2_exp_counts.txt *.bam #第1列为基因名，第7至最后1列为各个样本的表达信息 #4、各个样本比对率概况 multiqc ./ -n hisat2_multiqc_report.html [2] STAR 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #1、定义变量 ref_idx_star=$(refgenie seek hg38/star_index -c ~/refgenie/genome_config.yaml) ref_gtf=$(refgenie seek hg38/gencode_gtf -c ~/refgenie/genome_config.yaml) pare_dir=/home/data/****/mapping #2、批量比对 # 尝试换用for循环，本质都一样 for sample in $(cat ${pare_dir}/SraAccList.txt) do echo \u0026#34;START sample ${sample}\u0026#34; echo \u0026#34;Start STAR mapping...\u0026#34; #首先进行比对，生成sam文件 STAR --genomeDir $ref_idx_star \\ --runThreadN 10 --readFilesCommand zcat \\ --readFilesIn ${pare_dir}/trim/${sample}_1_val_1.fq.gz ${pare_dir}/trim/${sample}_2_val_2.fq.gz \\ --outSAMtype SAM --outFileNamePrefix ${sample} echo \u0026#34;Start sam2bam...\u0026#34; #然后sam转bam,同时删除内存较大的bam samtools view -S ${pare_dir}/star/${sample}Aligned.out.sam \\ -@ 10 -b \u0026gt; ${pare_dir}/star/${sample}.bam rm ${pare_dir}/star/${sample}Aligned.out.sam done #3、featureCounts提取表达信息 featureCounts -p -T 10 -t exon -g gene_name -a $ref_gtf -o star_exp_counts.txt *.bam #第1列为基因名，第7至最后1列为各个样本的表达信息 #4、各个样本比对率概况 multiqc ./ -n star_multiqc_report.html [3] Bowtie2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #1、定义变量 ref_idx_bowtie2=$(refgenie seek hg38/bowtie2_index -c ~/refgenie/genome_config.yaml) ref_gtf=$(refgenie seek hg38/gencode_gtf -c ~/refgenie/genome_config.yaml) pare_dir=/home/data/****/mapping #2、批量比对 for sample in $(cat ${pare_dir}/SraAccList.txt) do echo \u0026#34;START sample ${sample}\u0026#34; echo \u0026#34;Start Bowtie2 mapping...\u0026#34; bowtie2 -p 10 -x $ref_idx_bowtie2 \\ -1 ${pare_dir}/trim/${sample}_1_val_1.fq.gz \\ -2 ${pare_dir}/trim/${sample}_2_val_2.fq.gz \\ -S ${pare_dir}/bowtie2/${sample}.sam echo \u0026#34;Start sam2bam...\u0026#34; samtools view -S ${pare_dir}/bowtie2/${sample}.sam \\ -@ 10 -b \u0026gt; ${pare_dir}/bowtie2/${sample}.bam rm ${pare_dir}/bowtie2/${sample}.sam done #3、featureCounts提取表达信息 featureCounts -p -T 10 -t exon -g gene_name -a $ref_gtf -o bowtie2_exp_counts.txt *.bam #第1列为基因名，第7至最后1列为各个样本的表达信息 #4、各个样本比对率概况 multiqc ./ -n bowtie2_multiqc_report.html [4] BWA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #1、定义变量 ref_idx_bwa=$(refgenie seek hg38/bwa_index -c ~/refgenie/genome_config.yaml) ref_gtf=$(refgenie seek hg38/gencode_gtf -c ~/refgenie/genome_config.yaml) pare_dir=/home/data/****/mapping #2、批量比对 for sample in $(cat ${pare_dir}/SraAccList.txt) do echo \u0026#34;START sample ${sample}\u0026#34; echo \u0026#34;Start BWA mapping...\u0026#34; bwa mem -t 10 $ref_idx_bwa \\ ${pare_dir}/trim/${sample}_1_val_1.fq.gz \\ ${pare_dir}/trim/${sample}_2_val_2.fq.gz \\ -S -o ${pare_dir}/bwa/${sample}.sam echo \u0026#34;Start sam2bam...\u0026#34; samtools view -S ${pare_dir}/bwa/${sample}.sam \\ -@ 10 -b \u0026gt; ${pare_dir}/bwa/${sample}.bam rm ${pare_dir}/bwa/${sample}.sam done #3、featureCounts提取表达信息 featureCounts -p -T 10 -t exon -g gene_name -a $ref_gtf -o bwa_exp_counts.txt *.bam #第1列为基因名，第7至最后1列为各个样本的表达信息 #4、各个样本比对率概况 multiqc ./ -n bwa_multiqc_report.html [5] salmon\nsalmon的比对结果并非sam文件，需要配合相关R包tximport提取表达矩阵\n1 2 3 4 5 6 7 8 9 10 11 12 13 #1、定义变量 refgenie list -g hg38_cdna -c ~/refgenie/genome_config.yaml ref_idx_salmon=$(refgenie seek hg38_cdna/salmon_index -c ~/refgenie/genome_config.yaml) pare_dir=/home/data/****/mapping #2、批量比对 cat ${pare_dir}/SraAccList.txt | while read id do echo $id salmon quant -i $ref_idx_salmon -l A \\ -1 ${pare_dir}/trim/${id}_1_val_1.fq.gz \\ -2 ${pare_dir}/trim/${id}_2_val_2.fq.gz \\ -p 10 -o ${pare_dir}/salmon/${id}_quant done 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 library(tximport) library(readr) library(biomaRt) ensembl = useMart(\u0026#34;ensembl\u0026#34;,dataset=\u0026#34;hsapiens_gene_ensembl\u0026#34;) attributes = listAttributes(ensembl) attributes[1:5,] # library(httr) # httr::set_config(config(ssl_verifypeer = 0L)) gene_ids \u0026lt;- getBM(attributes= c(\u0026#34;hgnc_symbol\u0026#34;,\u0026#34;ensembl_transcript_id\u0026#34;), mart= ensembl) gene_ids = gene_ids[!duplicated(gene_ids[,2]),]\tcolnames(gene_ids) = c(\u0026#34;gene_id\u0026#34;,\u0026#34;tx_id\u0026#34;) gene_ids = gene_ids[,c(\u0026#34;tx_id\u0026#34;,\u0026#34;gene_id\u0026#34;)] files \u0026lt;- list.files(pattern = \u0026#39;*sf\u0026#39;,recursive = T, full.names=T) txi \u0026lt;- tximport(files, type = \u0026#34;salmon\u0026#34;, tx2gene = gene_ids, ignoreTxVersion = T, ignoreAfterBar=T) class(txi) names(txi) head(txi$length) head(txi$counts) srrs = stringr::str_extract(files, \u0026#34;SRR[:digit:]+\u0026#34;) salmon_expr \u0026lt;- txi$counts salmon_expr \u0026lt;- apply(salmon_expr, 2, as.integer) rownames(salmon_expr) \u0026lt;- rownames(txi$counts) colnames(salmon_expr) \u0026lt;- srrs save(salmon_expr, file=\u0026#34;./salmon_expr.rda\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/060%E4%BB%8Ernaseq%E7%9A%84fastq.gz%E6%8F%90%E5%8F%96%E8%A1%A8%E8%BE%BE%E7%9F%A9%E9%98%B5/","summary":"\u003cblockquote\u003e\n\u003cp\u003eRNA-seq数据比对流程主要分为三步（1）整理数据；（2）质控；（3）比对。其中每一步都涉及到若干软件的用法，如下简单整理基本的分析流程。\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-c3ca775f4c1f19d6.png\" alt=\"image.png\" style=\"zoom:67%;\" /\u003e\u003c/blockquote\u003e\n\u003cp\u003e示例数据：GSE158623中6个样本的RNA-seq测序结果(human)，对应SRR12720999~SRR12721004\u003c/p\u003e","title":"从RNAseq的fastq.gz提取表达矩阵"},{"content":"1、HPA HPA：the Human Protein Atlas，由2003年来自瑞典的科研机构发起，旨在绘制综合性人类蛋白质图谱。 https://www.proteinatlas.org/ 蛋白质表达数据库，常见用途包括： （1）查看特定基因在不同组织、脑区，细胞类型，组织细胞类型，疾病（癌症），免疫细胞，肿瘤细胞系等表达情况。 （2）数据挖掘类文章常使用其进行比较基因在肿瘤部位与相应正常部位的蛋白水平表达差异。 2、ENCORI ENCORI，The Encyclopedia of RNA Interactomes，由中山大学生命科学学院屈良鹄团队开发，于2014年发表于Nucleic Acids Res。 https://starbase.sysu.edu.cn/index.php miRNA、lncRNA、RBP等多维相互作用网络，常见用途包括 miRNA/RBP的靶标查询(mRNA,lncRNA\u0026hellip;) RNA interaction, ceRNA network TCGA肿瘤的差异表达，生存分析，相关性等 3、TCIA TCIA，The Cancer Immunome Database，由来自奥地利的因斯布鲁克大学医学院Zlatko Trajanoski团队开发，于2017年发表于Cell Reports https://tcia.at/home 20种solid cancer的免疫相关分析，例如 免疫基因表达、细胞浸润、肿瘤亚克隆等 亮点之一是提出Immunophenoscore指标用于预测免疫治疗响应 https://github.com/icbi-lab/Immunophenogram 样本临床信息也整理的较为完整 4、GSCA GSCA，Gene Set Cancer Analysis，由来自华中科技大学的郭安源团队开发/更新，于2022年11月发表于Briefings in Bioinformatics http://bioinfo.life.hust.edu.cn/GSCA/#/ 单基因/基因集与33种癌症在基因表达、免疫浸润、突变变异、药物敏感度等4个方面的综合分析平台 基因集分析主要通过GSVA/GSEA两种方式进行打分，再与临床信息相关联 比较适合基因/基因集的泛癌分析，出图较为精美 提供原始数据可供下载 5、GEPIA2 Gene Expression Profiling Interactive Analysis (V2)，由北京大学张泽民研究团队开发，于2019年7月发表于Nucleic Acids Research http://gepia2.cancer-pku.cn/ 主要功能在基因在多肿瘤/正常组织（TCGA+GTEx）的常规分析 基因为主体 差异分析、生存分析 基因对相关性分析/基因最相关基因分析 特定基因集降维信息 肿瘤为主体 差异基因集、生存相关基因集 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/075%E7%94%9F%E4%BF%A1%E7%9B%B8%E5%85%B3%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E9%94%A6/","summary":"\u003ch2 id=\"1hpa\"\u003e1、HPA\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eHPA：the Human Protein Atlas，由2003年来自瑞典的科研机构发起，旨在绘制综合性人类蛋白质图谱。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.proteinatlas.org/\"\u003ehttps://www.proteinatlas.org/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e蛋白质表达数据库，常见用途包括：\n\u003cul\u003e\n\u003cli\u003e（1）查看特定基因在不同组织、脑区，细胞类型，组织细胞类型，疾病（癌症），免疫细胞，肿瘤细胞系等表达情况。\u003c/li\u003e\n\u003cli\u003e（2）数据挖掘类文章常使用其进行比较基因在肿瘤部位与相应正常部位的蛋白水平表达差异。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401152922221.png\" alt=\"image-20230401152922221\" style=\"zoom:80%;\" /\u003e\r\n\u003ch2 id=\"2encori\"\u003e2、ENCORI\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eENCORI，The Encyclopedia of RNA Interactomes，由中山大学生命科学学院屈良鹄团队开发，于2014年发表于Nucleic Acids Res。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://starbase.sysu.edu.cn/index.php\"\u003ehttps://starbase.sysu.edu.cn/index.php\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003emiRNA、lncRNA、RBP等多维相互作用网络，常见用途包括\n\u003cul\u003e\n\u003cli\u003emiRNA/RBP的靶标查询(mRNA,lncRNA\u0026hellip;)\u003c/li\u003e\n\u003cli\u003eRNA interaction, ceRNA network\u003c/li\u003e\n\u003cli\u003eTCGA肿瘤的差异表达，生存分析，相关性等\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230402101214897.png\" alt=\"image-20230402101214897\" style=\"zoom: 80%;\" /\u003e\r\n\u003ch2 id=\"3tcia\"\u003e3、TCIA\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eTCIA，The Cancer Immunome Database，由来自奥地利的因斯布鲁克大学医学院Zlatko Trajanoski团队开发，于2017年发表于Cell Reports\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://tcia.at/home\"\u003ehttps://tcia.at/home\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e20种solid cancer的免疫相关分析，例如\n\u003cul\u003e\n\u003cli\u003e免疫基因表达、细胞浸润、肿瘤亚克隆等\u003c/li\u003e\n\u003cli\u003e亮点之一是提出\u003cstrong\u003eImmunophenoscore\u003c/strong\u003e指标用于预测免疫治疗响应\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/icbi-lab/Immunophenogram\"\u003ehttps://github.com/icbi-lab/Immunophenogram\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e样本临床信息也整理的较为完整\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230402150744208.png\" alt=\"image-20230402150744208\"  /\u003e\r\n\u003c/p\u003e","title":"生信相关网站数据库集锦"},{"content":"1、TCGAbiolinks下载数据 使用TCGAbiolinks下载特定肿瘤类型的SNV数据 https://bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/mutation.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(TCGAbiolinks) query \u0026lt;- GDCquery( project = \u0026#34;TCGA-CHOL\u0026#34;, data.category = \u0026#34;Simple Nucleotide Variation\u0026#34;, access = \u0026#34;open\u0026#34;, legacy = FALSE, data.type = \u0026#34;Masked Somatic Mutation\u0026#34;) GDCdownload(query) maf \u0026lt;- GDCprepare(query) dim(maf) # [1] 3764 141 ## (1) 因后续需要，修改Tumor_Sample_Barcode列 maf$long_Barcode = maf$Tumor_Sample_Barcode maf$Tumor_Sample_Barcode = substr(maf$Tumor_Sample_Barcode,1,12) length(unique(maf$Tumor_Sample_Barcode)) # 51 ## (2) 读取临床生存数据 clinical = readxl::read_xlsx(\u0026#34;TCGA_Pan_Cancer_Clinical_Data_mmc1.xlsx\u0026#34;) clinical_sle = clinical %\u0026gt;% dplyr::filter(type==\u0026#34;CHOL\u0026#34;) %\u0026gt;% dplyr::select(bcr_patient_barcode, OS, OS.time, clinical_stage) %\u0026gt;% dplyr::rename(Tumor_Sample_Barcode=bcr_patient_barcode) dim(clinical_sle) # 45 2、maftools可视化 https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html https://www.jieandze1314.com/post/cnposts/237/ 1 2 3 4 5 6 7 8 9 library(maftools) maf_obj = read.maf(maf = maf, clinicalData = clinical_sle) #每个样本的突变情况统计 getSampleSummary(maf_obj) #每个基因的突变类型统计 getGeneSummary(maf_obj) 2.1概括图 1 2 3 plotmafSummary(maf = maf_obj, rmOutlier = TRUE, addStat = \u0026#39;median\u0026#39;, dashboard = TRUE, titvRaw = FALSE) 2.2 基因瀑布图 1 2 3 4 5 6 7 8 9 10 11 12 13 oncoplot(maf = maf_obj, top = 10) # 如下图 ## 添加临床注释 oncoplot(maf = maf_obj, top = 10, clinicalFeatures = c(\u0026#39;clinical_stage\u0026#39;,\u0026#34;OS\u0026#34;), draw_titv = TRUE) ## 选择特定基因集 set.seed(42) genes = sample(maf_obj@data$Hugo_Symbol,10) oncoplot(maf = maf_obj, genes = genes, clinicalFeatures = c(\u0026#39;clinical_stage\u0026#39;,\u0026#34;OS\u0026#34;), draw_titv = TRUE) 2.3 转换颠倒统计 1 2 3 4 5 # Transition 转换 ： 嘌呤(AG)或嘧啶(CT)内部之间转换 # Transversions 颠倒：嘌呤与嘧啶间互相转换 maf_obj.titv = titv(maf = maf_obj, plot = FALSE, useSyn = TRUE) plotTiTv(res = maf_obj.titv) 2.4 基因对突变统计 1 2 3 4 5 6 7 8 # green: co-occuring # yellow: mutually exclusive somaticInteractions(maf = maf_obj, top = 25, pvalue = c(0.05, 0.1)) set.seed(42) genes = sample(maf_obj@data$Hugo_Symbol,25) somaticInteractions(maf = maf_obj, genes = genes , pvalue = c(0.05, 0.1)) 2.5 生存分析 根据特定基因是否突变将病人分成WT与Mutant两组 1 2 3 4 5 6 7 8 9 10 11 mafSurvival(maf = maf_obj, genes = \u0026#39;TP53\u0026#39;, time = \u0026#39;OS.time\u0026#39;, Status = \u0026#39;OS\u0026#39;) # Group medianTime N # 1: Mutant 732 4 # 2: WT 650 41 ## 提取信息 # maf_obj@clinical.data %\u0026gt;% # dplyr::mutate(Group=ifelse(Tumor_Sample_Barcode %in% # subset(maf_obj@data, Hugo_Symbol==\u0026#34;TP53\u0026#34;)$Barcode, # \u0026#34;Mutant\u0026#34;,\u0026#34;WT\u0026#34;)) 2.6 基因对的生存相关性 1 2 3 4 5 6 7 8 9 10 prog_geneset = survGroup(maf = maf_obj, top = 200, geneSetSize = 2, time = \u0026#34;OS.time\u0026#34;, Status = \u0026#34;OS\u0026#34;, verbose = FALSE,minSamples = 3) prog_geneset # Gene_combination P_value hr WT Mutant # 1: PBRM1_PLXNA4 0.243 2.36e+00 42 3 # 2: PBRM1_PCLO 0.294 3.46e-01 42 3 # 3: PBRM1_TP53 0.320 3.64e-01 42 3 mafSurvGroup(maf = maf_obj, geneSet = c(\u0026#34;PBRM1\u0026#34;, \u0026#34;PLXNA4\u0026#34;), time = \u0026#34;OS.time\u0026#34;, Status = \u0026#34;OS\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/076tcga%E7%9A%84snv%E6%95%B0%E6%8D%AE%E4%B8%8B%E8%BD%BD%E4%B8%8Emaftools%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003ch3 id=\"1tcgabiolinks下载数据\"\u003e1、TCGAbiolinks下载数据\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e使用TCGAbiolinks下载特定肿瘤类型的SNV数据\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/mutation.html\"\u003ehttps://bioconductor.org/packages/release/bioc/vignettes/TCGAbiolinks/inst/doc/mutation.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(TCGAbiolinks)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003equery \u0026lt;- GDCquery(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    project = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;TCGA-CHOL\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    data.category = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Simple Nucleotide Variation\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    access = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;open\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    legacy = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    data.type = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Masked Somatic Mutation\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGDCdownload(query)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emaf \u0026lt;- GDCprepare(query)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(maf)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 3764  141\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) 因后续需要，修改Tumor_Sample_Barcode列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emaf$long_Barcode = maf$Tumor_Sample_Barcode \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emaf$Tumor_Sample_Barcode = substr(maf$Tumor_Sample_Barcode,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elength(unique(maf$Tumor_Sample_Barcode))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 51\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) 读取临床生存数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclinical = readxl::read_xlsx(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;TCGA_Pan_Cancer_Clinical_Data_mmc1.xlsx\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclinical_sle = clinical %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdplyr::filter(type==\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;CHOL\u0026#34;\u003c/span\u003e)  %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdplyr::select(bcr_patient_barcode, OS, OS.time, clinical_stage) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tdplyr::rename(Tumor_Sample_Barcode=bcr_patient_barcode)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(clinical_sle)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 45 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2maftools可视化\"\u003e2、maftools可视化\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html\"\u003ehttps://bioconductor.org/packages/release/bioc/vignettes/maftools/inst/doc/maftools.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.jieandze1314.com/post/cnposts/237/\"\u003ehttps://www.jieandze1314.com/post/cnposts/237/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(maftools)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emaf_obj = read.maf(maf = maf, clinicalData = clinical_sle)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#每个样本的突变情况统计\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egetSampleSummary(maf_obj)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#每个基因的突变类型统计\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egetGeneSummary(maf_obj)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"21概括图\"\u003e2.1概括图\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplotmafSummary(maf = maf_obj, rmOutlier = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t   addStat = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;median\u0026#39;\u003c/span\u003e, dashboard = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t   titvRaw = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409170234902.png\" alt=\"image-20230409170234902\" style=\"zoom:50%;\" /\u003e\r\n\u003ch4 id=\"22-基因瀑布图\"\u003e2.2 基因瀑布图\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoncoplot(maf = maf_obj, top = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e# 如下图\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 添加临床注释\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoncoplot(maf = maf_obj, top = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t  \t clinicalFeatures = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;clinical_stage\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;OS\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t  \t draw_titv = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 选择特定基因集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes = sample(maf_obj@data$Hugo_Symbol,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoncoplot(maf = maf_obj, genes = genes,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t  \t clinicalFeatures = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;clinical_stage\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;OS\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t  \t draw_titv = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409170615418.png\" alt=\"image-20230409170615418\" style=\"zoom: 50%;\" /\u003e\r\n\u003ch4 id=\"23-转换颠倒统计\"\u003e2.3 转换颠倒统计\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Transition 转换 ： 嘌呤(AG)或嘧啶(CT)内部之间转换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Transversions 颠倒：嘌呤与嘧啶间互相转换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emaf_obj.titv = titv(maf = maf_obj, plot = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e, useSyn = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplotTiTv(res = maf_obj.titv)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409171216097.png\" alt=\"image-20230409171216097\" style=\"zoom:50%;\" /\u003e\r\n\u003ch4 id=\"24-基因对突变统计\"\u003e2.4 基因对突变统计\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# green: co-occuring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# yellow: mutually exclusive\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esomaticInteractions(maf = maf_obj, top = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e25\u003c/span\u003e, pvalue = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.05\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes = sample(maf_obj@data$Hugo_Symbol,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e25\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esomaticInteractions(maf = maf_obj, genes  = genes , pvalue = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.05\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409171336514.png\" alt=\"image-20230409171336514\" style=\"zoom:50%;\" /\u003e\r\n\u003ch4 id=\"25-生存分析\"\u003e2.5 生存分析\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e根据特定基因是否突变将病人分成WT与Mutant两组\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emafSurvival(maf = maf_obj, genes = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;TP53\u0026#39;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\ttime = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;OS.time\u0026#39;\u003c/span\u003e, Status = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;OS\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     Group medianTime  N\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1: Mutant        732  4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2:     WT        650 41\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 提取信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# maf_obj@clinical.data %\u0026gt;% \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \tdplyr::mutate(Group=ifelse(Tumor_Sample_Barcode %in% \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \t\tsubset(maf_obj@data, Hugo_Symbol==\u0026#34;TP53\u0026#34;)$Barcode,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \t\t\u0026#34;Mutant\u0026#34;,\u0026#34;WT\u0026#34;)) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409171710303.png\" alt=\"image-20230409171710303\" style=\"zoom: 67%;\" /\u003e\r\n\u003ch4 id=\"26-基因对的生存相关性\"\u003e2.6 基因对的生存相关性\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprog_geneset = survGroup(maf = maf_obj, top = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, geneSetSize = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t time = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;OS.time\u0026#34;\u003c/span\u003e, Status = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;OS\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t verbose = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e,minSamples = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprog_geneset\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    Gene_combination P_value       hr WT Mutant\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1:     PBRM1_PLXNA4   0.243 2.36e+00 42      3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2:       PBRM1_PCLO   0.294 3.46e-01 42      3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3:       PBRM1_TP53   0.320 3.64e-01 42      3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emafSurvGroup(maf = maf_obj, geneSet = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;PBRM1\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;PLXNA4\u0026#34;\u003c/span\u003e), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t time = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;OS.time\u0026#34;\u003c/span\u003e, Status = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;OS\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409171856663.png\" alt=\"image-20230409171856663\" style=\"zoom: 67%;\" /\u003e","title":"TCGA的SNV数据下载与maftools可视化"},{"content":" ConsensusClusterPlus包是肿瘤分型研究的常用工具，其于2010年发表于Bioinformatics。\nPaper：https://academic.oup.com/bioinformatics/article/26/12/1572/281699 Tutorial：https://bioconductor.org/packages/release/bioc/vignettes/ConsensusClusterPlus/inst/doc/ConsensusClusterPlus.pdf 1 2 # BiocManager::install(\u0026#34;ConsensusClusterPlus\u0026#34;) library(ConsensusClusterPlus) 1、示例表达矩阵 行名为基因，列名为样本的基因表达矩阵；根据需要，进行标准化处理 基因集的选择是关键的一步，可根据统计学（高变基因）或者生物学（特定功能相关基因）进行选择 如下是参考教程的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 library(ALL) data(ALL) d=exprs(ALL) dim(d) # [1] 12625 128 mads=apply(d,1,mad) d=d[rev(order(mads))[1:5000],] # 筛选高方差基因 dim(d) # [1] 5000 128 ## 标准化处理：每行（基因）减去每行的中位数 d = sweep(d,1, apply(d,1,median,na.rm=T)) d[1:4,1:4] # 01005 01010 03002 04006 # 36638_at 1.556121 0.9521271 -0.05018082 4.780378 # 39318_at 1.191353 2.5013225 -2.38793537 -1.199521 # 38514_at 1.020716 3.2785671 1.55949145 -3.345919 # 266_s_at 1.829260 0.3624327 1.54913247 -1.286294 2、样本亚型鉴定 实际就是一个函数即可：ConsensusClusterPlus() 其中涉及到较多参数的选择，具体如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 ## 默认参数 ConsensusClusterPlus(d, maxK=3, reps=10, pItem=0.8, pFeature=1, title=\u0026#34;untitled_consensus_cluster\u0026#34;, clusterAlg=\u0026#34;hc\u0026#34;, distance=\u0026#34;pearson\u0026#34;, plot=NULL, writeTable=FALSE, seed=42) ## 参数含义 # maxK：考虑的最大聚类数，建议取10~20 # reps：抽样次数，建议1000 # pItem与pFeature：分别表示对样本与基因的抽样比例 # title：图片或文件的保存路径 # clusterAlg：聚类方式 c(\u0026#34;hc\u0026#34;,\u0026#34;pam\u0026#34;,\u0026#34;km\u0026#34;) # distance: 距离计算方式 c(\u0026#34;pearson\u0026#34;,\u0026#34;spearman\u0026#34;,\u0026#34;euclidean\u0026#34;,\u0026#34;binay\u0026#34;,\u0026#34;maximum\u0026#34;,\u0026#34;canberra\u0026#34;,\u0026#34;minkowski\u0026#34;) # plot : 是否绘图，以及图形类型 c(NULL, \u0026#34;pdf\u0026#34;, \u0026#34;png\u0026#34;, \u0026#34;pngBMP\u0026#34;) # writeTable: 是否保存文件 # seed：随机种子 results = ConsensusClusterPlus(d, maxK=10, reps=1000, pItem=0.8, pFeature=1, title=\u0026#34;./tmp/\u0026#34;, clusterAlg=\u0026#34;hc\u0026#34;, distance=\u0026#34;pearson\u0026#34;, plot=\u0026#34;pdf\u0026#34;, writeTable=FALSE, seed=42) R对象结果：list格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 查看聚类数为2的结果信息 names(results[[3]]) # [1] \u0026#34;consensusMatrix\u0026#34; \u0026#34;consensusTree\u0026#34; \u0026#34;consensusClass\u0026#34; \u0026#34;ml\u0026#34; \u0026#34;clrs\u0026#34; table(results[[3]]$consensusClass) # 1 2 3 # 69 28 31 dim(results[[3]]$consensusMatrix) # [1] 128 128 results[[3]]$consensusMatrix[1:4,1:4] # [,1] [,2] [,3] [,4] # [1,] 1.0000000 0.3408360 0.7996870 0.3515249 # [2,] 0.3408360 1.0000000 0.1224806 1.0000000 # [3,] 0.7996870 0.1224806 1.0000000 0.1190108 # [4,] 0.3515249 1.0000000 0.1190108 1.0000000 ## consensus values 0 (never clustered together) ## consensus values 1 (always clustered together) 图形输出结果，主要两类图 （1）特定聚类结果的热图\n（2）所有聚类结果的consensus value累计分布图\n根据上图结果，可以优先考虑分为4~6类亚型的结果。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/077%E8%82%BF%E7%98%A4%E4%BA%9A%E5%9E%8B%E5%88%86%E7%BE%A4%E5%B7%A5%E5%85%B7consensusclusterplus/","summary":"\u003cblockquote\u003e\n\u003cp\u003eConsensusClusterPlus包是肿瘤分型研究的常用工具，其于2010年发表于Bioinformatics。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePaper：https://academic.oup.com/bioinformatics/article/26/12/1572/281699\u003c/li\u003e\n\u003cli\u003eTutorial：https://bioconductor.org/packages/release/bioc/vignettes/ConsensusClusterPlus/inst/doc/ConsensusClusterPlus.pdf\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# BiocManager::install(\u0026#34;ConsensusClusterPlus\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ConsensusClusterPlus)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1示例表达矩阵\"\u003e1、示例表达矩阵\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e行名为基因，列名为样本的基因表达矩阵；根据需要，进行标准化处理\u003c/li\u003e\n\u003cli\u003e基因集的选择是关键的一步，可根据统计学（高变基因）或者生物学（特定功能相关基因）进行选择\u003c/li\u003e\n\u003cli\u003e如下是参考教程的数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ALL)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(ALL)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ed=exprs(ALL)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(d)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 12625   128\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emads=apply(d,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,mad)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ed=d[rev(order(mads))[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5000\u003c/span\u003e],]  \u003cspan style=\"color:#007f7f\"\u003e# 筛选高方差基因\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(d)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 5000  128\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 标准化处理：每行（基因）减去每行的中位数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ed = sweep(d,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, apply(d,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,median,na.rm=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eT\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ed[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#             01005     01010       03002     04006\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 36638_at 1.556121 0.9521271 -0.05018082  4.780378\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 39318_at 1.191353 2.5013225 -2.38793537 -1.199521\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 38514_at 1.020716 3.2785671  1.55949145 -3.345919\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 266_s_at 1.829260 0.3624327  1.54913247 -1.286294\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2样本亚型鉴定\"\u003e2、样本亚型鉴定\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e实际就是一个函数即可：\u003ccode\u003eConsensusClusterPlus()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e其中涉及到较多参数的选择，具体如下\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 默认参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eConsensusClusterPlus(d,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     maxK=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,      \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     reps=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     pItem=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.8\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     pFeature=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     title=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;untitled_consensus_cluster\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     clusterAlg=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hc\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     distance=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;pearson\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     plot=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNULL\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     writeTable=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                     seed=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 参数含义\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# maxK：考虑的最大聚类数，建议取10~20\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# reps：抽样次数，建议1000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# pItem与pFeature：分别表示对样本与基因的抽样比例\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# title：图片或文件的保存路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# clusterAlg：聚类方式 c(\u0026#34;hc\u0026#34;,\u0026#34;pam\u0026#34;,\u0026#34;km\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# distance: 距离计算方式 c(\u0026#34;pearson\u0026#34;,\u0026#34;spearman\u0026#34;,\u0026#34;euclidean\u0026#34;,\u0026#34;binay\u0026#34;,\u0026#34;maximum\u0026#34;,\u0026#34;canberra\u0026#34;,\u0026#34;minkowski\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# plot : 是否绘图，以及图形类型 c(NULL, \u0026#34;pdf\u0026#34;, \u0026#34;png\u0026#34;, \u0026#34;pngBMP\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# writeTable: 是否保存文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# seed：随机种子\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresults = ConsensusClusterPlus(d,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               maxK=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,      \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               reps=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               pItem=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.8\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               pFeature=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               title=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./tmp/\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               clusterAlg=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hc\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               distance=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;pearson\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               plot=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;pdf\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               writeTable=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               seed=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eR对象结果：list格式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 查看聚类数为2的结果信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enames(results[[3]])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;consensusMatrix\u0026#34; \u0026#34;consensusTree\u0026#34;   \u0026#34;consensusClass\u0026#34; \u0026#34;ml\u0026#34;    \u0026#34;clrs\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etable(results[[3]]$consensusClass)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  1  2  3 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 69 28 31 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(results[[3]]$consensusMatrix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 128 128\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresults[[3]]$consensusMatrix[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#           [,1]      [,2]      [,3]      [,4]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1,] 1.0000000 0.3408360 0.7996870 0.3515249\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [2,] 0.3408360 1.0000000 0.1224806 1.0000000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [3,] 0.7996870 0.1224806 1.0000000 0.1190108\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [4,] 0.3515249 1.0000000 0.1190108 1.0000000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## consensus values 0 (never clustered together) \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## consensus values 1 (always clustered together)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e图形输出结果，主要两类图\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（1）特定聚类结果的热图\u003c/p\u003e","title":"肿瘤亚型分群工具ConsensusClusterPlus"},{"content":" https://bioconductor.org/packages/release/bioc/html/IsoformSwitchAnalyzeR.html 1、背景知识 The usage of Alternative Transcription Start sites (aTSS可选择转录起始位点), Alternative Splicing (AS可选择剪切位点) and alternative Transcription Termination Sites (aTTS可选择终止位点) are collectively collectively results in the production of different isoforms. Alternative isoforms are widely used as recently demonstrated by The ENCODE Consortium, which found that on average, 6.3 different transcripts are generated per gene; a number which may vary considerably per gene.\n目前基因转录本水平的定量表达分析软件有：Kallisto, Salmon, RSEM or StringTie等\nIsoformSwitchAnalyzeR包可基于上述转录本定量结果，分析同一基因在对照/实验条件下(normal/disease)是否会表达不同比例的转录本。\n如上图所示，IsoformSwitchAnalyzeR分析流程主要分为两大部分：(1) identify isoform switch[基础分析]; (2) predict potential functional consequences of the identified isoform switches[进阶分析]\n2、基础分析 1 2 3 library(IsoformSwitchAnalyzeR) library(tidyverse) library(data.table) 2.1 初步创建switchAnalyzeRlist对象 2.1.1 导入转录本定量数据 使用的是IsoformSwitchAnalyzeR的示例数据，为salmon软件的定量结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #2组，各两个样本 list.files(\u0026#34;data/salmon\u0026#34;, recursive = T, full.names = T) # [1] \u0026#34;data/salmon/hESC_0/quant.sf.gz\u0026#34; # [2] \u0026#34;data/salmon/hESC_1/quant.sf.gz\u0026#34; # [3] \u0026#34;data/salmon/iPS_0/quant.sf.gz\u0026#34; # [4] \u0026#34;data/salmon/iPS_1/quant.sf.gz\u0026#34; fread(\u0026#34;data/salmon/hESC_0/quant.sf.gz\u0026#34;) %\u0026gt;% head #包含5列，分别为转录本id， 转录本长度， 有效长度，TPM标准化，原始count # Name Length EffectiveLength TPM NumReads # 1: TCONS_00000001 1652 1652 0.000 0.00000 # 2: TCONS_00000002 1488 1488 0.000 0.00000 # 3: TCONS_00000003 1595 1595 0.000 0.00000 # 4: TCONS_00000006 78 78 1377990.000 4.67384 # 5: TCONS_00000007 2750 2750 329.487 589.15400 # 6: TCONS_00000008 4369 4369 358.067 1050.07000 #importIsoformExpression会自动识别salmon的定量结果，储存到list对象里 salmonQuant \u0026lt;- importIsoformExpression( parentDir = \u0026#34;data/salmon\u0026#34; ) salmonQuant$abundance %\u0026gt;% head(3) # isoform_id hESC_0 hESC_1 iPS_0 iPS_1 # 1 TCONS_00000001 0 0.000000 0.000000 4.659597 # 2 TCONS_00000002 0 1.564879 5.504247 2.818824 # 3 TCONS_00000003 0 0.000000 0.000000 0.000000 salmonQuant$counts %\u0026gt;% head(3) # isoform_id hESC_0 hESC_1 iPS_0 iPS_1 # 1 TCONS_00000001 0 0.0000000 0.00000 18.13313 # 2 TCONS_00000002 0 0.1116201 21.10248 10.96964 # 3 TCONS_00000003 0 0.0000000 0.00000 0.00000 2.1.2 样本分组信息 1 2 3 4 5 6 7 8 myDesign \u0026lt;- data.frame( sampleID = c(\u0026#34;hESC_0\u0026#34;, \u0026#34;hESC_1\u0026#34;, \u0026#34;iPS_0\u0026#34;, \u0026#34;iPS_1\u0026#34;), condition = c(\u0026#34;hESC\u0026#34;, \u0026#34;hESC\u0026#34;, \u0026#34;iPS\u0026#34;, \u0026#34;iPS\u0026#34;)) # sampleID condition # 1 hESC_0 hESC # 2 hESC_1 hESC # 3 iPS_0 iPS # 4 iPS_1 iPS 2.1.3 其它注释信息 （1）gtf文件: 转录本的外显子组成以及对应基因 1 2 3 4 5 6 7 8 9 10 11 12 13 fread(\u0026#34;data/example.gtf.gz\u0026#34;) %\u0026gt;% head(2) # V1 V2 V3 V4 V5 V6 V7 V8 # 1: chr1 cufflinks exon 11874 12227 . + . # 2: chr1 cufflinks exon 11874 12227 . + . # V9 # 1: transcript_id \u0026#34;TCONS_00000001\u0026#34;; gene_id \u0026#34;XLOC_000001\u0026#34;; # 2: transcript_id \u0026#34;TCONS_00000002\u0026#34;; gene_id \u0026#34;XLOC_000001\u0026#34;; fread(\u0026#34;data/example.gtf.gz\u0026#34;) %\u0026gt;% dplyr::count(V3) # V3 n # 1: CDS 9612 # 2: exon 10929 （2）fasta文件：转录本的核苷酸序列 1 2 3 4 5 6 7 8 fread(\u0026#34;data/example_isoform_nt.fasta\u0026#34;) %\u0026gt;% head() # \u0026gt;TCONS_00000001 # 1: CTTGCCGTCAGCCTTTTCTTTGACCTCTTCTTTCTGTTCATGTGTATTTGCTGTCTCTTAGCCCAGACTTCCCGTGTCCT # 2: TTCCACCGGGCCTTTGAGAGGTCACAGGGTCTTGATGCTGTGGTCTTCATCTGCAGGTGTCTGACTTCCAGCAACTGCTG # 3: GCCTGTGCCAGGGTGCAAGCTGAGCACTGGAGTGGAGTTTTCCTGTGGAGAGGAGCCATGCCTAGAGTGGGATGGGCCAT # 4: TGTTCATCTTCTGGCCCCTGTTGTCTGCATGTAACTTAATACCACAACCAGGCATAGGGGAAAGATTGGAGGAAAGATGA # 5: GTGAGAGCATCAACTTCTCTCACAACCTAGGCCAGTGTGTGGTGATGCCAGGCATGCCCTTCCCCAGCATCAGGTCTCCA # 6: GAGCTGCAGAAGACGACGGCCGACTTGGATCACACTCTTGTGAGTGTCCCCAGTGTTGCAGAGGCAGGGCCATCAGGCAC 2.1.4 创建switchAnalyzeRlist对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 sar1 \u0026lt;- importRdata( isoformCountMatrix = salmonQuant$counts, isoformRepExpression = salmonQuant$abundance, designMatrix = myDesign, isoformExonAnnoation = \u0026#34;data/example.gtf.gz\u0026#34;, isoformNtFasta = \u0026#34;data/example_isoform_nt.fasta\u0026#34; ) sar1 %\u0026gt;% length() # 11 names(sar1) # [1] \u0026#34;isoformFeatures\u0026#34; \u0026#34;exons\u0026#34; \u0026#34;conditions\u0026#34; # [4] \u0026#34;designMatrix\u0026#34; \u0026#34;sourceId\u0026#34; \u0026#34;isoformCountMatrix\u0026#34; # [7] \u0026#34;isoformRepExpression\u0026#34; \u0026#34;runInfo\u0026#34; \u0026#34;orfAnalysis\u0026#34; # [10] \u0026#34;isoformRepIF\u0026#34; \u0026#34;ntSequence\u0026#34; sar1$isoformFeatures %\u0026gt;% head(2) # iso_ref/gene_ref : 新的唯一编号，不重复 # gene_overall_mean/iso_overall_mean : 基因/转录本在所有样本的平均表达量 # IF_overall(isoform fraction=isoform_exp / gene_exp): 在所有样本中，特定基因表达该转录本的比例 # iso_ref gene_ref isoform_id gene_id condition_1 condition_2 # 280 isoComp_00000001 geneComp_00000001 TCONS_00000316 AADACL3 hESC iPS # 281 isoComp_00000002 geneComp_00000001 TCONS_00000317 AADACL3 hESC iPS # gene_name gene_biotype iso_biotype gene_overall_mean gene_value_1 gene_value_2 # 280 AADACL3 NA NA 25.37693 32.66891 18.08494 # 281 AADACL3 NA NA 25.37693 32.66891 18.08494 # gene_stderr_1 gene_stderr_2 gene_log2_fold_change gene_q_value iso_overall_mean # 280 10.1063 6.337321 -0.8527734 NA 3.704839 # 281 10.1063 6.337321 -0.8527734 NA 21.672089 # iso_value_1 iso_value_2 iso_stderr_1 iso_stderr_2 iso_log2_fold_change iso_q_value # 280 4.846923 2.562755 3.823911 2.562511 -0.9167289 NA # 281 27.821989 15.522189 6.282387 3.774811 -0.8414829 NA # IF_overall IF1 IF2 dIF isoform_switch_q_value gene_switch_q_value PTC # 280 0.114475 0.124 0.10495 -0.01905 NA NA FALSE # 281 0.885525 0.876 0.89505 0.01905 NA NA FALSE sar1$isoformFeatures %\u0026gt;% dplyr::filter(gene_id==\u0026#34;AADACL3\u0026#34;) %\u0026gt;% dplyr::select(isoform_id, gene_id, dplyr::contains(\u0026#34;IF\u0026#34;)) # isoform_id gene_id IF_overall IF1 IF2 dIF # 1 TCONS_00000316 AADACL3 0.114475 0.124 0.10495 -0.01905 # 2 TCONS_00000317 AADACL3 0.885525 0.876 0.89505 0.0190 #ORF转录本开放阅读框注释 sar1$orfAnalysis %\u0026gt;% head(2) # orfTransciptStart/orfTransciptEnd 基于转录本核苷酸序列(剪切后)的起始位置 # orfStartGenomic/orfEndGenomic 基于基因组坐标(剪切前)的起始位置 # isoform_id orfTransciptStart orfTransciptEnd orfTransciptLength # 1 TCONS_00000001 1402 1629 228 # 2 TCONS_00000002 317 715 399 # orfStarExon orfEndExon orfStartGenomic orfEndGenomic # 1 3 3 14159 14386 # 2 1 3 12190 13636 # stopDistanceToLastJunction stopIndex PTC orf_origin # 1 -1163 3 FALSE Annotation # 2 -231 3 FALSE Annotation 2.2 过滤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 sar2 \u0026lt;- preFilter(sar1) #默认过滤标准 # geneExpressionCutoff = 1 : 根据gene_overall_mean列过滤低表达基因 # isoformExpressionCutoff = 0 : 根据iso_overall_mean列过滤低表达基因 # IFcutoff=0.01: 根据IF_overall过滤 # dIFcutoff = 0.1: 根据dIF过滤（绝对值） # removeSingleIsoformGenes = TRUE: 删除只有一个转录本的基因 dim(sar1) # [1] 1060 30 dim(sar2) # [1] 760 30 sar2 # This switchAnalyzeRlist list contains: # 760 isoforms from 208 genes # 1 comparison from 2 conditions (in total 4 samples) # # Feature analyzed: # [1] \u0026#34;ORFs, ntSequence\u0026#34; 2.3 isoformSwitch分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 sar3 \u0026lt;- isoformSwitchTestDEXSeq(sar2) sar3$isoformFeatures %\u0026gt;% head(2) # 如下，主要增加了isoform_switch_q_value与gene_switch_q_value两列信息 # iso_ref gene_ref isoform_id gene_id condition_1 # 557 isoComp_00000004 geneComp_00000003 TCONS_00003880 ACAP3 hESC # 558 isoComp_00000005 geneComp_00000003 TCONS_00003881 ACAP3 hESC # condition_2 gene_name gene_biotype iso_biotype gene_overall_mean # 557 iPS ACAP3 NA NA 910.5955 # 558 iPS ACAP3 NA NA 910.5955 # gene_value_1 gene_value_2 gene_stderr_1 gene_stderr_2 # 557 1771.599 49.59168 377.02 15.68552 # 558 1771.599 49.59168 377.02 15.68552 # gene_log2_fold_change gene_q_value iso_overall_mean iso_value_1 # 557 -5.158528 NA 241.0513 478.7646 # 558 -5.158528 NA 186.6521 365.0107 # iso_value_2 iso_stderr_1 iso_stderr_2 iso_log2_fold_change # 557 3.337951 175.44243 3.337951 -7.159924 # 558 8.293521 89.61604 1.997000 -5.458111 # iso_q_value IF_overall IF1 IF2 dIF # 557 NA 0.156075 0.26100 0.05115 -0.20985 # 558 NA 0.188100 0.20455 0.17165 -0.03290 # isoform_switch_q_value gene_switch_q_value PTC # 557 0.2601812 0.02341811 FALSE # 558 0.7079831 0.02341811 FALSE #如下结果gene_switch_q_value即为isoform_switch_q_value的最小值 sar3$isoformFeatures %\u0026gt;% dplyr::filter(gene_id==\u0026#34;ACAP3\u0026#34;) %\u0026gt;% dplyr::select(isoform_id, gene_id,dIF, dplyr::contains(\u0026#34;switch\u0026#34;)) # isoform_id gene_id dIF isoform_switch_q_value gene_switch_q_value # 1 TCONS_00003880 ACAP3 -0.20985 0.26018123 0.02341811 # 2 TCONS_00003881 ACAP3 -0.03290 0.70798307 0.02341811 # 3 TCONS_00003882 ACAP3 0.29825 0.02341811 0.02341811 # 4 TCONS_00003883 ACAP3 -0.05555 0.58385549 0.02341811 switchPlot(sar3, gene = \u0026#39;ACAP3\u0026#39;, condition1=\u0026#34;hESC\u0026#34;, condition2=\u0026#34;iPS\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 #四个子图 switchPlotGeneExp(sar3, gene = \u0026#39;ACAP3\u0026#39;, condition1=\u0026#34;hESC\u0026#34;, condition2=\u0026#34;iPS\u0026#34;) switchPlotIsoExp(sar3, gene = \u0026#39;ACAP3\u0026#39;, condition1=\u0026#34;hESC\u0026#34;, condition2=\u0026#34;iPS\u0026#34;) switchPlotIsoUsage(sar3, gene = \u0026#39;ACAP3\u0026#39;, condition1=\u0026#34;hESC\u0026#34;, condition2=\u0026#34;iPS\u0026#34;) switchPlotTranscript(sar3, gene = \u0026#39;ACAP3\u0026#39;, condition1=\u0026#34;hESC\u0026#34;, condition2=\u0026#34;iPS\u0026#34;) 2.4 isoformSwitch结果探索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sar3$isoformSwitchAnalysis %\u0026gt;% head() # iso_ref gene_ref isoform_id condition_1 condition_2 dIF pvalue # 1 isoComp_00000922 geneComp_00000294 TCONS_00000007 hESC iPS 0.01615 8.645971e-01 # 2 isoComp_00000923 geneComp_00000294 TCONS_00000008 hESC iPS -0.25885 4.859083e-02 # 3 isoComp_00000924 geneComp_00000294 TCONS_00000009 hESC iPS 0.24275 7.547031e-05 # 4 isoComp_00000929 geneComp_00000298 TCONS_00000017 hESC iPS 0.08785 7.690961e-01 # 5 isoComp_00000930 geneComp_00000298 TCONS_00000018 hESC iPS -0.47220 6.113540e-14 # 6 isoComp_00000931 geneComp_00000298 TCONS_00000019 hESC iPS 0.23965 2.119346e-03 # padj IF1 IF2 # 1 9.665421e-01 0.51665 0.53280 # 2 1.464787e-01 0.48320 0.22435 # 3 7.536969e-04 0.00015 0.24290 # 4 9.355274e-01 0.00000 0.08785 # 5 3.815868e-12 0.47220 0.00000 # 6 1.250306e-02 0.00000 0.23965 2.4.1 Top Switches\u0026ndash;gene 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 sar.ge_df=extractTopSwitches( sar3, filterForConsequences = FALSE, n = NA, extractGenes = TRUE, # when FALSE isoforms are returned sortByQvals = TRUE ) dim(sar.ge_df) # [1] 68 7 head(sar.ge_df) # gene_ref gene_id gene_name condition_1 condition_2 gene_switch_q_value Rank # 1 geneComp_00000088 ENO1 ENO1 hESC iPS 2.429932e-90 1 # 4 geneComp_00000324 XLOC_001217 \u0026lt;NA\u0026gt; hESC iPS 1.464063e-24 2 # 5 geneComp_00000171 NBL1 NBL1 hESC iPS 1.039215e-21 3 # 7 geneComp_00000053 CASP9 CASP9 hESC iPS 5.232094e-18 4 # 10 geneComp_00000282 UBR4 UBR4 hESC iPS 1.597415e-17 5 # 14 geneComp_00000072 CROCC CROCC hESC iPS 1.752050e-17 6 2.4.2 Top Switches\u0026ndash;isoform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 sar.iso_df=extractTopSwitches( sar3, filterForConsequences = FALSE, n = NA, extractGenes = FALSE, # when FALSE isoforms are returned sortByQvals = TRUE ) dim(sar.iso_df) # [1] 121 12 head(sar.iso_df) # iso_ref gene_ref isoform_id gene_id gene_name condition_1 condition_2 IF1 # 1 isoComp_00000297 geneComp_00000088 TCONS_00004087 ENO1 ENO1 hESC iPS 0.157 # 2 isoComp_00000985 geneComp_00000324 TCONS_00003819 XLOC_001217 \u0026lt;NA\u0026gt; hESC iPS 0.084 # 3 isoComp_00000551 geneComp_00000171 TCONS_00000463 NBL1 NBL1 hESC iPS 0.112 # 4 isoComp_00000549 geneComp_00000171 TCONS_00000460 NBL1 NBL1 hESC iPS 0.881 # 5 isoComp_00000152 geneComp_00000053 TCONS_00004180 CASP9 CASP9 hESC iPS 0.474 # 6 isoComp_00000242 geneComp_00000072 TCONS_00000420 CROCC CROCC hESC iPS 0.683 # IF2 dIF isoform_switch_q_value Rank # 1 0.000 -0.157 2.429932e-90 1 # 2 0.434 0.350 1.464063e-24 2 # 3 1.000 0.888 1.039215e-21 3 # 4 0.000 -0.881 1.194327e-19 4 # 5 0.000 -0.474 5.232094e-18 5 # 6 0.173 -0.510 1.752050e-17 6 2.4.3 火山图 1 2 3 4 5 6 7 8 9 10 ggplot(data=sar3$isoformFeatures, aes(x=dIF, y=-log10(isoform_switch_q_value))) + geom_point( aes( color=abs(dIF) \u0026gt; 0.1 \u0026amp; isoform_switch_q_value \u0026lt; 0.05 ), # default cutoff size=1 ) + geom_hline(yintercept = -log10(0.05), linetype=\u0026#39;dashed\u0026#39;) + # default cutoff geom_vline(xintercept = c(-0.1, 0.1), linetype=\u0026#39;dashed\u0026#39;) + # default cutoff scale_color_manual(\u0026#39;Signficant\\nIsoform Switch\u0026#39;, values = c(\u0026#39;black\u0026#39;,\u0026#39;red\u0026#39;)) + labs(x=\u0026#39;dIF\u0026#39;, y=\u0026#39;-Log10 ( Isoform Switch Q Value )\u0026#39;) + theme_bw() 3、进阶分析 对于不同组样本的某一基因，存在其中一种isoform相对上调，另一种isoform相对下调的情况。可以对isoform的特点进行分析，从而进一步分析isoformswitch的影响与意义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sar3 # This switchAnalyzeRlist list contains: # 312 isoforms from 68 genes # 1 comparison from 2 conditions (in total 4 samples) # # Switching features: # Comparison Isoforms Switches Genes # 1 hESC vs iPS 121 95 68 # # Feature analyzed: # [1] \u0026#34;Isoform Switch Identification, ORFs, ntSequence\u0026#34; names(sar3) # [1] \u0026#34;isoformFeatures\u0026#34; \u0026#34;exons\u0026#34; \u0026#34;conditions\u0026#34; \u0026#34;designMatrix\u0026#34; # [5] \u0026#34;sourceId\u0026#34; \u0026#34;isoformCountMatrix\u0026#34; \u0026#34;isoformRepExpression\u0026#34; \u0026#34;runInfo\u0026#34; # [9] \u0026#34;orfAnalysis\u0026#34; \u0026#34;isoformRepIF\u0026#34; \u0026#34;ntSequence\u0026#34; 3.1 可变剪切Alternative Splicing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sar4 \u0026lt;- analyzeAlternativeSplicing(sar3) sar4$AlternativeSplicingAnalysis %\u0026gt;% head(2) # isoform_id ES ES_genomic_start ES_genomic_end MEE MEE_genomic_start MEE_genomic_end MES # 1 TCONS_00003880 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 # 2 TCONS_00003881 1 1230098 1230196 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 # MES_genomic_start MES_genomic_end IR IR_genomic_start IR_genomic_end A5 A5_genomic_start A5_genomic_end # 1 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; # 2 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; # A3 A3_genomic_start A3_genomic_end ATSS # 1 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 1 # 2 0 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 1 # ATSS_genomic_start # 1 1234725;1235211;1235353;1235538;1235889;1237368;1238302;1238542;1239466;1243149;1244822 # 2 1243149;1244822 # ATSS_genomic_end ATTS # 1 1234736;1235285;1235448;1235582;1236072;1237426;1238355;1238661;1241309;1243269;1244989 0 # 2 1243269;1244989 0 # ATTS_genomic_start ATTS_genomic_end # 1 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; # 2 \u0026lt;NA\u0026gt; \u0026lt;NA\u0026gt; 1 2 extractSplicingSummary(sar4) # 一个significant isoform如果发生了A3事件，如果其dIF\u0026gt;0,则iPS相对hESC used more;反之used less 1 extractSplicingEnrichment(sar4) 1 extractSplicingGenomeWide(sar4) 3.2 isoform Consequences预测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 sar5 \u0026lt;- extractSequence(sar4, writeToFile=TRUE, pathToOutput = \u0026#39;data/output\u0026#39;) list.files(\u0026#34;data/output/\u0026#34;) # [1] \u0026#34;isoformSwitchAnalyzeR_isoform_AA.fasta\u0026#34; # [2] \u0026#34;isoformSwitchAnalyzeR_isoform_nt.fasta\u0026#34; sar5$ntSequence %\u0026gt;% head(3) #DNAStringSet object of length 6: # width seq names # [1] 2750 GGGTCTCCCTCTGTTG...CCCACGCGGACAGAG TCONS_00000007 # [2] 4369 TTACTGTTGATTGTGA...AAAATATCGCCCACG TCONS_00000008 # [3] 4272 TTACTGTTGATTGTGA...AAAATATCGCCCACG TCONS_00000009 sar5$aaSequence %\u0026gt;% head(3) #AAStringSet object of length 3: # width seq names # [1] 389 MLLPPGSLSRPRTFSS...QAQLLPHSGPFRPNS TCONS_00000007 # [2] 389 MLLPPGSLSRPRTFSS...QAQLLPHSGPFRPNS TCONS_00000008 # [3] 389 MLLPPGSLSRPRTFSS...QAQLLPHSGPFRPNS TCONS_00000009 CPAT : The Coding-Potential Assessment Tool which is a tool for predicting whether an isoform is coding or not. (_nt.fasta) CPC2 : The Coding Potential Calculator 2 which is a tool for predicting whether an isoform is coding or not. (_nt.fasta) Pfam : Prediction of protein domains (_AA.fasta) SignalP : Prediction of Signal Peptides(_AA.fasta) IUPred2A: Predicts Intrinsically Disordered Regions (IDR) and Intrinsically Disordered Binding Regions (IDBR)(_AA.fasta) NetSurfP-2 : Prediction of Intrinsically Disordered Regions (IDR) (_AA.fasta) 上传核苷酸/氨基酸序列到相应网站，下载预测的结果，再导入到switchAnalyzeRlist对象中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 sar6 \u0026lt;- analyzeCPAT( switchAnalyzeRlist = sar5, pathToCPATresultFile = \u0026#34;data/external/cpat_results.txt\u0026#34;, codingCutoff = 0.725, removeNoncodinORFs = TRUE ) sar6 \u0026lt;- analyzePFAM( switchAnalyzeRlist = sar6, pathToPFAMresultFile = \u0026#34;data/external/pfam_results.txt\u0026#34; ) sar6 \u0026lt;- analyzeSignalP( switchAnalyzeRlist = sar6, pathToSignalPresultFile = \u0026#34;data/external/signalP_results.txt\u0026#34; ) sar6 \u0026lt;- analyzeIUPred2A( switchAnalyzeRlist = sar6, pathToIUPred2AresultFile = \u0026#34;data/external/iupred2a_result.txt.gz\u0026#34; ) sar7 \u0026lt;- analyzeSwitchConsequences(sar6) length(sar7) # [1] 18 names(sar7) # [1] \u0026#34;isoformFeatures\u0026#34; \u0026#34;exons\u0026#34; # [3] \u0026#34;conditions\u0026#34; \u0026#34;designMatrix\u0026#34; # [5] \u0026#34;sourceId\u0026#34; \u0026#34;isoformCountMatrix\u0026#34; # [7] \u0026#34;isoformRepExpression\u0026#34; \u0026#34;runInfo\u0026#34; # [9] \u0026#34;orfAnalysis\u0026#34; \u0026#34;isoformRepIF\u0026#34; # [11] \u0026#34;ntSequence\u0026#34; \u0026#34;isoformSwitchAnalysis\u0026#34; # [13] \u0026#34;AlternativeSplicingAnalysis\u0026#34; \u0026#34;aaSequence\u0026#34; # [15] \u0026#34;domainAnalysis\u0026#34; \u0026#34;signalPeptideAnalysis\u0026#34; # [17] \u0026#34;idrAnalysis\u0026#34; \u0026#34;switchConsequence\u0026#34; sar7$switchConsequence %\u0026gt;% dplyr::filter(isoformsDifferent==\u0026#34;TRUE\u0026#34;) %\u0026gt;% head() # gene_ref gene_id gene_name condition_1 condition_2 isoformUpregulated # 1 geneComp_00000003 ACAP3 ACAP3 hESC iPS TCONS_00003882 # 2 geneComp_00000004 ACOT7 ACOT7 hESC iPS TCONS_00004035 # 3 geneComp_00000004 ACOT7 ACOT7 hESC iPS TCONS_00004035 # 4 geneComp_00000004 ACOT7 ACOT7 hESC iPS TCONS_00004035 # 5 geneComp_00000004 ACOT7 ACOT7 hESC iPS TCONS_00004035 # 6 geneComp_00000004 ACOT7 ACOT7 hESC iPS TCONS_00004036 # isoformDownregulated iso_ref_up iso_ref_down featureCompared # 1 TCONS_00003880 isoComp_00000006 isoComp_00000004 ORF_seq_similarity # 2 TCONS_00004039 isoComp_00000010 isoComp_00000014 ORF_seq_similarity # 3 TCONS_00004039 isoComp_00000010 isoComp_00000014 NMD_status # 4 TCONS_00004039 isoComp_00000010 isoComp_00000014 domains_identified # 5 TCONS_00004039 isoComp_00000010 isoComp_00000014 IDR_identified # 6 TCONS_00004039 isoComp_00000011 isoComp_00000014 NMD_status # isoformsDifferent switchConsequence # 1 TRUE ORF is longer # 2 TRUE ORF is longer # 3 TRUE NMD insensitive # 4 TRUE Domain gain # 5 TRUE IDR gain # 6 TRUE NMD insensitive extractConsequenceSummary(sar7) 1 extractConsequenceEnrichment(sar7) 1 2 3 switchPlot(sar7, gene = \u0026#39;ACAP3\u0026#39;, condition1=\u0026#34;hESC\u0026#34;, condition2=\u0026#34;iPS\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/070%E4%BD%BF%E7%94%A8isoformswitchanalyzer%E5%8C%85%E8%BF%9B%E8%A1%8C%E5%8F%AF%E5%8F%98%E5%89%AA%E5%88%87%E5%88%86%E6%9E%90/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bioconductor.org/packages/release/bioc/html/IsoformSwitchAnalyzeR.html\"\u003ehttps://bioconductor.org/packages/release/bioc/html/IsoformSwitchAnalyzeR.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1背景知识\"\u003e1、背景知识\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eThe usage of Alternative Transcription Start sites (aTSS可选择转录起始位点), Alternative Splicing (AS可选择剪切位点) and alternative Transcription Termination Sites (aTTS可选择终止位点) are collectively collectively results in the production of \u003cstrong\u003edifferent isoforms.\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://www.researchgate.net/publication/327264306/figure/fig1/AS:664597191204868@1535463726583/A-Schematic-representation-of-a-mRNA-transcript-Isoforms-can-be-generated-by.png\" alt=\"A) Schematic representation of a mRNA transcript. Isoforms can be... |  Download Scientific Diagram\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eAlternative isoforms are widely used as recently demonstrated by The ENCODE Consortium, which found that on average, \u003cstrong\u003e6.3 different transcripts are generated per gene\u003c/strong\u003e; a number which may vary considerably per gene.\u003c/p\u003e","title":"使用IsoformSwitchAnalyzeR包进行可变剪切分析"},{"content":" 肿瘤预后类文章的常规步骤之一是绘制诺模图，并进行相关分析。以下总结了相关基础绘制工具。\n示例数据集 1 2 3 4 5 6 library(survival) head(lung) # inst time status age sex ph.ecog ph.karno pat.karno meal.cal wt.loss # 1 3 306 2 74 1 1 90 100 1175 NA # 2 3 455 2 68 1 0 90 90 1225 15 # 3 3 1010 1 56 1 0 90 90 NA 15 1、rms包 参考用法：https://atm.amegroups.com/article/view/14736/15089 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 library(rms) # var.labels = c(age=\u0026#34;Age in Years\u0026#34;, # lac=\u0026#34;lactate\u0026#34;, # sex=\u0026#34;Sex of the participant\u0026#34;, # shock=\u0026#34;shock\u0026#34;, # y=\u0026#34;outcome\u0026#34;, # Y=\u0026#34;ordinal\u0026#34;) # label(data) = lapply(names(var.labels), # function(x) label(data[,x]) = var.labels[x]) mod.cox \u0026lt;- cph(Surv(time,status) ~ ph.ecog+sex+age,lung, surv=TRUE) ddist \u0026lt;- datadist(lung) options(datadist=\u0026#39;ddist\u0026#39;) surv.cox \u0026lt;- Survival(mod.cox) # 定义函数 med \u0026lt;- Quantile(mod.cox) surv \u0026lt;- Survival(mod.cox) nom.cox \u0026lt;- nomogram(mod.cox, # 根据total point进行特定函数计算 fun=list(function(x) surv.cox(365, x), # 一年生存率 function(x) med(lp=x, q=0.5)), # 中位生存时间 funlabel=c(\u0026#34;200-Day Sur. Prob.\u0026#34;, \u0026#34;Median Survival Time\u0026#34;), lp=F, # 不展示Linear Predictor conf.int=c(0.1,0.5) # 两个置信区间 ) plot(nom.cox, col.conf=c(\u0026#39;red\u0026#39;,\u0026#39;green\u0026#39;), # 置信区间的颜色 col.grid = c(\u0026#34;grey30\u0026#34;,\u0026#34;grey\u0026#34;) # 网格的颜色 ) # f = cph(Surv(time, status) ~ age + sex + ph.karno, data = lung, # x = T, y = T, sur = T) # pred_score = apply(lung, 1, function(x){ # pred=Predict(f, age=x[\u0026#34;age\u0026#34;], sex=x[\u0026#34;sex\u0026#34;], ph.karno=x[\u0026#34;ph.karno\u0026#34;]) # return(pred$yhat) # }) %\u0026gt;% unlist() # summary(pred_score) 校准曲线\nhttps://rpubs.com/Lucent/815446\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mod.cox.1 \u0026lt;- cph(Surv(time,status) ~ ph.ecog+sex+age,lung, x=T,y=T,surv = T, time.inc = 365) cal1 \u0026lt;- calibrate(mod.cox.1, cmethod=\u0026#39;KM\u0026#39;, method=\u0026#34;boot\u0026#34;, u=365, m=60, B=1000) mod.cox.2 \u0026lt;- cph(Surv(time,status) ~ ph.ecog+sex+age,lung, x=T,y=T,surv = T, time.inc = 365*2) cal2 \u0026lt;- calibrate(mod.cox.2, cmethod=\u0026#39;KM\u0026#39;, method=\u0026#34;boot\u0026#34;, u=365*2, m=60, B=1000) par(mar=c(7,5,1,1),cex = 0.75) plot(cal1,lwd=2,lty=1, errbar.col=\u0026#34;#FC4E07\u0026#34;, #线上面的竖线 xlim=c(0,1),ylim=c(0,1), xlab=\u0026#34;Nomogram-Predicted Probability of 1,2 Year OS\u0026#34;, ylab=\u0026#34;Actual 1,1 Year OS (proportion)\u0026#34;, col=\u0026#34;#FC4E07\u0026#34;) plot(cal2, add=T, conf.int=T, subtitles = F, cex.subtitles=0.8, lwd=2, lty=1, errbar.col=\u0026#34;#00AFBB\u0026#34;, col=\u0026#34;#00AFBB\u0026#34;) #加上图例 legend(\u0026#34;bottomright\u0026#34;, legend=c(\u0026#34;1 years\u0026#34;, \u0026#34;2 years\u0026#34;), col=c(\u0026#34;#FC4E07\u0026#34;,\u0026#34;#00AFBB\u0026#34;), lwd=2) #调整对角线 abline(0,1,lty=3,lwd=1,col=\u0026#34;grey\u0026#34;) 2、regplot包 https://zhuanlan.zhihu.com/p/496165999 1 2 3 4 5 6 7 8 9 10 11 library(regplot) lung2 = lung lung2$sex = factor(lung2$sex) mod.cox \u0026lt;- coxph(Surv(time,status) ~ ph.ecog+sex+age,lung2) regplot(mod.cox, points=TRUE, plots=c(\u0026#34;density\u0026#34;,\u0026#34;boxes\u0026#34;), # 连续型与离散型的可视化 dencol=\u0026#34;green\u0026#34;, boxcol=\u0026#34;yellow\u0026#34;, observation=lung2[15,], droplines=TRUE, # 对特定样本的可视化打分 title=\u0026#34;Survival Nomogram\u0026#34;, prfail=T, # 生存T/死亡F failtime=c(366,731,1000)) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/078%E8%AF%BA%E6%A8%A1%E5%9B%BE%E6%88%96%E5%88%97%E7%BA%BF%E5%9B%BE%E7%BB%98%E5%88%B6%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e肿瘤预后类文章的常规步骤之一是绘制诺模图，并进行相关分析。以下总结了相关基础绘制工具。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e示例数据集\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(survival)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(lung)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   inst time status age sex ph.ecog ph.karno pat.karno meal.cal wt.loss\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1    3  306      2  74   1       1       90       100     1175      NA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2    3  455      2  68   1       0       90        90     1225      15\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3    3 1010      1  56   1       0       90        90       NA      15\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1rms包\"\u003e1、rms包\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e参考用法：https://atm.amegroups.com/article/view/14736/15089\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(rms)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# var.labels = c(age=\u0026#34;Age in Years\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                lac=\u0026#34;lactate\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                sex=\u0026#34;Sex of the participant\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                shock=\u0026#34;shock\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                y=\u0026#34;outcome\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                Y=\u0026#34;ordinal\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# label(data) = lapply(names(var.labels),\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                      function(x) label(data[,x]) = var.labels[x])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emod.cox \u0026lt;- cph(Surv(time,status) ~ ph.ecog+sex+age,lung, surv=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eddist \u0026lt;- datadist(lung)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions(datadist=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;ddist\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esurv.cox \u0026lt;- Survival(mod.cox)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 定义函数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emed \u0026lt;- Quantile(mod.cox)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esurv \u0026lt;- Survival(mod.cox)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enom.cox \u0026lt;- nomogram(mod.cox,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   \u003cspan style=\"color:#007f7f\"\u003e# 根据total point进行特定函数计算\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   fun=list(\u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(x) surv.cox(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e365\u003c/span\u003e, x),   \u003cspan style=\"color:#007f7f\"\u003e# 一年生存率\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                            \u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(x) med(lp=x, q=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e)),  \u003cspan style=\"color:#007f7f\"\u003e# 中位生存时间\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   funlabel=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;200-Day Sur. Prob.\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                              \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Median Survival Time\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   lp=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eF\u003c/span\u003e, \u003cspan style=\"color:#007f7f\"\u003e# 不展示Linear Predictor\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   conf.int=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e# 两个置信区间\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eplot(nom.cox,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     col.conf=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;red\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;green\u0026#39;\u003c/span\u003e),     \u003cspan style=\"color:#007f7f\"\u003e# 置信区间的颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     col.grid = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;grey30\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;grey\u0026#34;\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e# 网格的颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# f = cph(Surv(time, status) ~ age + sex + ph.karno, data = lung,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         x = T, y = T, sur = T)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# pred_score = apply(lung, 1, function(x){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   pred=Predict(f, age=x[\u0026#34;age\u0026#34;], sex=x[\u0026#34;sex\u0026#34;], ph.karno=x[\u0026#34;ph.karno\u0026#34;])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   return(pred$yhat)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# }) %\u0026gt;% unlist()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# summary(pred_score)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230428113638766.png\" alt=\"image-20230428113638766\" style=\"zoom: 67%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e校准曲线\u003c/p\u003e","title":"诺模图或列线图绘制分析"},{"content":" UCSCXenaShiny是基于集成了多种肿瘤数据库的UCSCXena平台，进行数据下载、分析、可视化的Shiny工具（以及同名R包），由上海科技大学王诗翔博士等共同开发；于2021年6月发表于Bioinformatics。下面主要学习其R包的相关函数，了解其核心功能。\nhttps://doi.org/10.1093/bioinformatics/btab561 https://github.com/openbiox/UCSCXenaShiny https://shiny.hiplot.cn/ucsc-xena-shiny/ 1、数据关系 1.1 Hub/Cohort等\nHub：不同的大型项目，例如TCGA、GTEx Cohort：不同的队列，可以表示一独立的研究，例如一种肿瘤 Subtype：数据类型，例如表达矩阵/表型/突变数据 Dataset：最终的数据实体，例如不同标准化方式的表达矩阵 所有的数据关系具体可通过如下查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 data_stat = UCSCXenaTools::XenaGenerate() ## hosts → cohorts → datasets data_hosts = data_stat@hosts # 11 data_cohorts = data_stat@cohorts # 159 data_datasets = data_stat@datasets # 1681 data_meta = UCSCXenaTools::XenaData t(data_meta[1,]) # [,1] # XenaHosts \u0026#34;https://ucscpublic.xenahubs.net\u0026#34; # XenaHostNames \u0026#34;publicHub\u0026#34; # XenaCohorts \u0026#34;Breast Cancer Cell Lines (Neve 2006)\u0026#34; # XenaDatasets \u0026#34;ucsfNeve_public/ucsfNeveExp_genomicMatrix\u0026#34; # SampleCount \u0026#34;51\u0026#34; # DataSubtype \u0026#34;gene expression\u0026#34; # Label \u0026#34;Neve Cell Line gene expression\u0026#34; # Type \u0026#34;genomicMatrix\u0026#34; # AnatomicalOrigin \u0026#34;Breast\u0026#34; # SampleType \u0026#34;cell line\u0026#34; # Tags \u0026#34;cell lines,breast cancer\u0026#34; # ProbeMap \u0026#34;probeMap/affyU133_ucscGenomeBrowser_hg18.probeMap\u0026#34; # LongTitle \u0026#34;Cell Line Gene Expression (Neve et al. Cancer Cell 2006)\u0026#34; # Citation \u0026#34;Cancer Cell. 2006 Dec;10(6):515-27.\u0026#34; # Version \u0026#34;2011-11-01\u0026#34; # Unit NA # Platform NA table(data_meta$Type) # clinicalMatrix genomicMatrix genomicSegment mutationVector # 345 981 152 203 clinicalMatrix主要包括survival data与phenotype data；\ngenomicMatrix包括所有可以表示为：行名是molecule，列名是sample的矩阵数据，例如基因表达矩阵等\ngenomicSegment主要针对CNV数据；mutationVector主要针对SNV数据\n1.2 常用Hub\nTCGA与TARGET均是由NIH与NCI等机构完成，二者均涉及多种癌症的多组学分析，而后者更专注于少年儿童肿瘤研究； GTEx主要关注正常组织的相关测序数据； CCLE是针对癌症细胞系的多组学研究以及药物敏感性的相关数据； PCAWG是ICGC的子项目之一，也是一项大规模的癌症基因组学研究； TOIL是一个数据计算框架，对上述数据进行单独/整合分析，例如TCGA+TARGET+GETx 1.3 两个R包\nUCSCXenaShiny网站主要以两个R包作为底层基础：\n（1）UCSCXenaTools包是从UCSCXena下载数据/查询数据的工具包；\nhttps://github.com/ropensci/UCSCXenaTools （2）UCSCXenaShiny包基于获取到的数据进行多种生信分析以及可视化。下面主要学习下这个R包的系列函数\nhttps://openbiox.github.io/UCSCXenaShiny/reference/index.html 2、UCSCXenaShiny包 2.1 内置数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 TCGA.organ # TCGA缩写 tcga_gtex # 样本所属的组织，分组(肿瘤/正常) tcga_clinical # 肿瘤所属样本年龄性别，肿瘤分期等 tcga_subtypes # 肿瘤亚型 tcga_surv # 肿瘤的4种生存数据 ## 肿瘤其它的不同属性 tcga_genome_instability tcga_purity tcga_tmb ccle_info # 细胞系基本信息 toil_info # toil样本基本信息（TCGA+TARGET+GTEX） pcawg_info #pcawg肿瘤基本信息（包括肿瘤分析，样本OS生存资料等） ## ccle、pcawg的肿瘤纯度信息 ccle_absolute pcawg_purity 此外还有部分数据由于体量大等原因放在了Zenodo数据库，相关分析用到时可另行下载到R包安装路径的extdata文件夹内。\n2.2 查询单个数据 查询任一ense (Genomic) Matrix Dataset（上述1.1）的某个molecule/signature的样本(表达)数据 1 2 3 4 5 6 query_molecule_value() query_molecule_value(dataset=, molecule=) dataset \u0026lt;- \u0026#34;ccle/CCLE_copynumber_byGene_2013-12-03\u0026#34; x \u0026lt;- query_molecule_value(dataset, \u0026#34;TP53\u0026#34;) head(x) 直接查询3大肿瘤Hub(toil/ccle/pcawg)中的某个molecule/signature的样本(表达)数据 1 2 3 4 5 6 7 8 9 query_pancan_value() query_pancan_value(molecule=, data_type= c(\u0026#34;mRNA\u0026#34;, \u0026#34;transcript\u0026#34;, \u0026#34;protein\u0026#34;, \u0026#34;mutation\u0026#34;, \u0026#34;cnv\u0026#34;, \u0026#34;cnv_gistic2\u0026#34;, \u0026#34;methylation\u0026#34;, \u0026#34;miRNA\u0026#34;, \u0026#34;fusion\u0026#34;, \u0026#34;promoter\u0026#34;, \u0026#34;APOBEC\u0026#34;), database= c(\u0026#34;toil\u0026#34;, \u0026#34;ccle\u0026#34;, \u0026#34;pcawg\u0026#34;)) query_pancan_value(\u0026#34;KRAS\u0026#34;) query_pancan_value(\u0026#34;KRAS\u0026#34;, database = \u0026#34;ccle\u0026#34;) query_pancan_value(\u0026#34;KRAS\u0026#34;, database = \u0026#34;pcawg\u0026#34;) 2.3 肿瘤相关可视化 这是Shiny网页版的Quick PanCan Analysis模块的分析相关函数\n（1）差异基因分析可视化\n1 2 3 4 vis_toil_TvsN() vis_toil_TvsN_cancer() vis_pcawg_dist() （2）基因表达相关性\n1 2 3 4 5 6 vis_gene_cor() # TCGA vis_gene_cor_cancer() vis_ccle_gene_cor() vis_pcawg_gene_cor() （3）基因表达与肿瘤指标的相关性\n1 2 3 4 5 vis_gene_TIL_cor() vis_gene_immune_cor() vis_gene_stemness_cor() vis_gene_tmb_cor() vis_gene_msi_cor() （4）生存相关分析\n1 2 3 4 5 6 7 8 9 10 11 12 # survival分析 ## step1：获取数据：分子表达+生存资料 sur_data = tcga_surv_get(item=, TCGA_cohort=, profile=) sur_data = tcga_surv_get(\u0026#34;TP53\u0026#34;, \u0026#34;BRCA\u0026#34;, \u0026#34;mRNA\u0026#34;) ## step2 绘图可视化：默认取最佳分组，可自定义阈值 tcga_surv_plot( sur_data, time = \u0026#34;OS.time\u0026#34;, status = \u0026#34;OS\u0026#34;) # 单变量Cox回归 vis_unicox_tree() vis_pcawg_unicox_tree() （5）药物敏感度相关分析\n1 2 3 4 5 6 7 # 在多种肿瘤细胞系中，基因表达与药物敏感性的相关性分析 analyze_gene_drug_response_asso(\u0026#34;TP53\u0026#34;) vis_gene_drug_response_asso(\u0026#34;TP53\u0026#34;) # 在多种肿瘤细胞系中，根据某基因高低表达分组，药物敏感性的差异 data = analyze_gene_drug_response_diff(\u0026#34;TP53\u0026#34;) vis_gene_drug_response_diff(\u0026#34;TP53\u0026#34;) 共涉及20余个药物。\n2.4 一般分析 这是Shiny网页版的General Analysis模块的分析相关函数\n1 2 3 4 5 6 7 8 9 10 11 # 两两相关性可视化（点图） vis_identifier_cor() # 多个间相关性（热图） vis_identifier_multi_cor() # 分组表达差异 vis_identifier_grp_comparison() # 分组生存分析 vis_identifier_grp_surv() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/079ucscxenashiny%E5%8C%85%E8%82%BF%E7%98%A4%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003cblockquote\u003e\n\u003cp\u003eUCSCXenaShiny是基于集成了多种肿瘤数据库的UCSCXena平台，进行数据下载、分析、可视化的Shiny工具（以及同名R包），由上海科技大学王诗翔博士等共同开发；于2021年6月发表于Bioinformatics。下面主要学习其R包的相关函数，了解其核心功能。\u003c/p\u003e","title":"UCSCXenaShiny包肿瘤数据分析可视化"},{"content":" EnhancedVolcano包可根据差异分析结果，基于ggplot2绘图结构，方便地绘制美观的火山图，下面根据自己的理解小结下基本用法。\n官方全面的教程：https://github.com/kevinblighe/EnhancedVolcano 示例差异基因数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 library(airway) library(magrittr) data(\u0026#39;airway\u0026#39;) airway$dex %\u0026lt;\u0026gt;% relevel(\u0026#39;untrt\u0026#39;) ens \u0026lt;- rownames(airway) library(org.Hs.eg.db) symbols \u0026lt;- mapIds(org.Hs.eg.db, keys = ens, column = c(\u0026#39;SYMBOL\u0026#39;), keytype = \u0026#39;ENSEMBL\u0026#39;) symbols \u0026lt;- symbols[!is.na(symbols)] symbols \u0026lt;- symbols[match(rownames(airway), names(symbols))] rownames(airway) \u0026lt;- symbols keep \u0026lt;- !is.na(rownames(airway)) airway \u0026lt;- airway[keep,] library(\u0026#39;DESeq2\u0026#39;) dds \u0026lt;- DESeqDataSet(airway, design = ~ cell + dex) dds \u0026lt;- DESeq(dds, betaPrior=FALSE) res \u0026lt;- results(dds, contrast = c(\u0026#39;dex\u0026#39;,\u0026#39;trt\u0026#39;,\u0026#39;untrt\u0026#39;)) res \u0026lt;- lfcShrink(dds, contrast = c(\u0026#39;dex\u0026#39;,\u0026#39;trt\u0026#39;,\u0026#39;untrt\u0026#39;), res=res, type = \u0026#39;normal\u0026#39;) res \u0026lt;- as.data.frame(res) head(res) # baseMean log2FoldChange lfcSE stat pvalue padj # TSPAN6 710.0931707 -0.37807189 0.09851236 -3.8404448 0.0001228116 0.0009522932 # TNMD 0.0000000 NA NA NA NA NA # DPM1 521.2572396 0.19826365 0.10931684 1.8155169 0.0694445184 0.1910397405 # SCYL3 237.6068046 0.03234467 0.13821470 0.2371917 0.8125081096 0.9118161375 # C1orf112 58.0358739 -0.08835419 0.25056704 -0.3194810 0.7493618190 0.8773885438 # FGR 0.3194343 -0.08459224 0.15186225 -0.3948862 0.6929268648 NA 如上，只要包含包含基因名、差异倍数、P值三部分信息的差异结果就可以用于绘制火山图。\n安装、加载包 1 2 # BiocManager::install(\u0026#39;EnhancedVolcano\u0026#39;) library(EnhancedVolcano) 基本绘制 如下代码，需要分别交代基因名；x轴为差异倍数；y轴为P值\n1 2 3 4 EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;) 如下图结果，基本绘制了不错的火山图。\nEnhancedVolcano()也提供了很多调整的参数，可供优化选择\n1、标题修改 title = 主标题 subtitle = 副标题，默认为 \u0026ldquo;EnhancedVolcano\u0026rdquo; caption = 图注，默认为基因总数统计 1 2 3 4 5 6 7 EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;, title = \u0026#39;Disease versus Normal\u0026#39;, subtitle = NULL, caption = NULL) 2、阈值修改 差异倍数：pCutoff = 10e-32 p值：FCcutoff = 2 1 2 3 4 5 6 EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;, pCutoff = 10e-32, FCcutoff = 3) 3、点point的修改 点的大小：pointSize = 2 点的不透明度(0~1)：colAlpha = 1/2 点的颜色col = c(\u0026quot;grey30\u0026quot;, \u0026quot;forestgreen\u0026quot;, \u0026quot;royalblue\u0026quot;, \u0026quot;red2\u0026quot;)，分别对应NS，仅差异倍数，仅P值，差异倍数与P值 1 2 3 4 5 6 7 EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;, pointSize = 1, colAlpha = 0.3, col = c(\u0026#34;black\u0026#34;,\u0026#34;black\u0026#34;,\u0026#34;black\u0026#34;,\u0026#34;red\u0026#34;)) 4、legend的修改 legendLabels=修改legend的标签内容 legendLabSize = 14 修改legend的标签大小 legendPosition = \u0026quot;top\u0026quot;修改legend的位置 legendIconSize = 5 修改legend的图标大小 1 2 3 4 5 6 7 8 9 10 11 EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;, legendLabels=c(\u0026#39;Not sig.\u0026#39;, \u0026#39;Log (base 2) FC\u0026#39;, \u0026#39;p-value\u0026#39;, \u0026#39;p-value \u0026amp; Log (base 2) FC\u0026#39;), legendPosition = \u0026#39;right\u0026#39;, legendLabSize = 5, legendIconSize = 5.0) 可使用ggplot2的语法 + theme(legend.position=\u0026quot;none\u0026quot;) 设置取消legend\n5、设置point label 如上面的图，EnhancedVolcano()会显示部分具有显著意义的基因名。我们也可以自定义修改显示哪些基因的标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 p1 = EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;, selectLab = c(\u0026#39;VCAM1\u0026#39;,\u0026#39;KCTD12\u0026#39;,\u0026#39;ADAM12\u0026#39;, \u0026#39;CXCL12\u0026#39;,\u0026#39;CACNB2\u0026#39;,\u0026#39;SPARCL1\u0026#39;, \u0026#39;DUSP1\u0026#39;,\u0026#39;SAMHD1\u0026#39;,\u0026#39;MAOA\u0026#39;), drawConnectors = TRUE) p2 = EnhancedVolcano(res, lab = rownames(res), x = \u0026#39;log2FoldChange\u0026#39;, y = \u0026#39;pvalue\u0026#39;, col = c(\u0026#34;black\u0026#34;,\u0026#34;black\u0026#34;,\u0026#34;black\u0026#34;,\u0026#34;red\u0026#34;), selectLab = \u0026#34;\u0026#34;) + theme(legend.position=\u0026#34;none\u0026#34;) library(patchwork) p1 | p2 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/080enhancedvolcano%E5%8C%85%E7%BB%98%E5%88%B6%E7%81%AB%E5%B1%B1%E5%9B%BE/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ccode\u003eEnhancedVolcano\u003c/code\u003e包可根据差异分析结果，基于ggplot2绘图结构，方便地绘制美观的火山图，下面根据自己的理解小结下基本用法。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e官方全面的教程：https://github.com/kevinblighe/EnhancedVolcano\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"示例差异基因数据\"\u003e示例差异基因数据\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(airway)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(magrittr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;airway\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eairway$dex %\u0026lt;\u0026gt;% relevel(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;untrt\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eens \u0026lt;- rownames(airway)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(org.Hs.eg.db)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esymbols \u0026lt;- mapIds(org.Hs.eg.db, keys = ens,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                  column = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;SYMBOL\u0026#39;\u003c/span\u003e), keytype = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;ENSEMBL\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esymbols \u0026lt;- symbols[!is.na(symbols)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esymbols \u0026lt;- symbols[match(rownames(airway), names(symbols))]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erownames(airway) \u0026lt;- symbols\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ekeep \u0026lt;- !is.na(rownames(airway))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eairway \u0026lt;- airway[keep,]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;DESeq2\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edds \u0026lt;- DESeqDataSet(airway, design = ~ cell + dex)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edds \u0026lt;- DESeq(dds, betaPrior=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres \u0026lt;- results(dds,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               contrast = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;dex\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;trt\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;untrt\u0026#39;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres \u0026lt;- lfcShrink(dds,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                 contrast = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;dex\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;trt\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;untrt\u0026#39;\u003c/span\u003e), res=res, type = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;normal\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres \u0026lt;- as.data.frame(res)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(res)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#             baseMean log2FoldChange      lfcSE       stat       pvalue         padj\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# TSPAN6   710.0931707    -0.37807189 0.09851236 -3.8404448 0.0001228116 0.0009522932\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# TNMD       0.0000000             NA         NA         NA           NA           NA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# DPM1     521.2572396     0.19826365 0.10931684  1.8155169 0.0694445184 0.1910397405\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# SCYL3    237.6068046     0.03234467 0.13821470  0.2371917 0.8125081096 0.9118161375\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# C1orf112  58.0358739    -0.08835419 0.25056704 -0.3194810 0.7493618190 0.8773885438\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# FGR        0.3194343    -0.08459224 0.15186225 -0.3948862 0.6929268648           NA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e如上，只要包含包含\u003ccode\u003e基因名\u003c/code\u003e、\u003ccode\u003e差异倍数\u003c/code\u003e、\u003ccode\u003eP值\u003c/code\u003e三部分信息的差异结果就可以用于绘制火山图。\u003c/p\u003e","title":"EnhancedVolcano包绘制火山图"},{"content":" IOBR包集signature打分与免疫浸润分析为一体的肿瘤数据分析工具，由南方医科大学南方医院廖旺军教授，曾东强博士等人于2021年7月发表于Frontiers in Immunology，引用数以超过100余次。现根据其github教程学习其部分功能用法。\nPaper：IOBR: Multi-Omics Immuno-Oncology Biological Research to Decode Tumor Microenvironment and Signatures DOI：https://doi.org/10.3389/fimmu.2021.687975 Github：https://github.com/IOBR/IOBR 1、安装R包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # options(\u0026#34;repos\u0026#34;= c(CRAN=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/\u0026#34;)) # options(BioC_mirror=\u0026#34;http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\u0026#34;) if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly = TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) depens\u0026lt;-c(\u0026#39;tibble\u0026#39;, \u0026#39;survival\u0026#39;, \u0026#39;survminer\u0026#39;, \u0026#39;sva\u0026#39;, \u0026#39;limma\u0026#39;, \u0026#34;DESeq2\u0026#34;,\u0026#34;devtools\u0026#34;, \u0026#39;limSolve\u0026#39;, \u0026#39;GSVA\u0026#39;, \u0026#39;e1071\u0026#39;, \u0026#39;preprocessCore\u0026#39;, \u0026#39;ggplot2\u0026#39;, \u0026#34;biomaRt\u0026#34;, \u0026#39;ggpubr\u0026#39;, \u0026#34;devtools\u0026#34;, \u0026#34;tidyHeatmap\u0026#34;, \u0026#34;caret\u0026#34;, \u0026#34;glmnet\u0026#34;, \u0026#34;ppcor\u0026#34;,\u0026#34;timeROC\u0026#34;,\u0026#34;pracma\u0026#34;) for(i in 1:length(depens)){ depen\u0026lt;-depens[i] if (!requireNamespace(depen, quietly = TRUE)) BiocManager::install(depen) } if (!requireNamespace(\u0026#34;remotes\u0026#34;, quietly = TRUE)) install(\u0026#34;remotes\u0026#34;) if (!requireNamespace(\u0026#34;EPIC\u0026#34;, quietly = TRUE)) remotes::install_github(\u0026#34;GfellerLab/EPIC\u0026#34;, build_vignettes=TRUE) if (!requireNamespace(\u0026#34;MCPcounter\u0026#34;, quietly = TRUE)) remotes::install_github(\u0026#34;ebecht/MCPcounter\u0026#34;,ref=\u0026#34;master\u0026#34;, subdir=\u0026#34;Source\u0026#34;) if (!requireNamespace(\u0026#34;estimate\u0026#34;, quietly = TRUE)){ rforge \u0026lt;- \u0026#34;http://r-forge.r-project.org\u0026#34; install.packages(\u0026#34;estimate\u0026#34;, repos=rforge, dependencies=TRUE) } if (!requireNamespace(\u0026#34;IOBR\u0026#34;, quietly = TRUE)) remotes::install_github(\u0026#34;IOBR/IOBR\u0026#34;,ref=\u0026#34;master\u0026#34;) library(IOBR) 2、准备数据 对于RNAseq数据 作者建议使用UCSCXenaTools下载肿瘤表达数据，再结合IOBR函数进行TPM标准化（如下）； 之前学习了解过TCGAbiolinks，可以直接提取TPM数据，觉得更合适些。 1 2 3 4 5 6 7 8 9 10 11 12 13 # \u0026#34;https://gdc.xenahubs.net/download/TCGA-STAD.htseq_counts.tsv.gz\u0026#34; eset_stad = data.table::fread(\u0026#34;TCGA-STAD.htseq_counts.tsv.gz\u0026#34;) %\u0026gt;% as.data.frame() eset_stad$Ensembl_ID\u0026lt;-substring(eset_stad$Ensembl_ID, 1, 15) eset_stad\u0026lt;-column_to_rownames(eset_stad, var = \u0026#34;Ensembl_ID\u0026#34;) # Revert back to original format because the data from UCSC was log2(x+1)transformed. eset_stad\u0026lt;-(2^eset_stad)+1 eset_stad\u0026lt;-count2tpm(countMat = eset_stad, idType = \u0026#34;Ensembl\u0026#34;, org=\u0026#34;hsa\u0026#34;) eset_stad[1:4,1:4] # TCGA-D7-5577-01A TCGA-D7-6818-01A TCGA-BR-7958-01A TCGA-D7-8572-01A # TSPAN6 33.4223214 16.91678635 24.2417334 20.2423671 # TNMD 0.1237997 0.06738584 0.1224305 0.1696897 # DPM1 15.9824956 5.35050514 11.1627196 16.3248532 # SCYL3 4.9644353 3.15739307 5.5790120 8.0491354 对于array数据 一般使用GEOquery包直接下载即可，关键步骤是根据芯片ID注释基因名 IOBR提供了相关注释函数，仅需提供注释信息即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 library(\u0026#34;GEOquery\u0026#34;) # NOTE: This process may take a few minutes which depends on the internet connection speed. Please wait for its completion. eset_geo\u0026lt;-getGEO(GEO = \u0026#34;GSE100935\u0026#34;, getGPL = F, destdir = \u0026#34;./\u0026#34;) eset \u0026lt;-eset_geo[[1]] eset \u0026lt;-exprs(eset) head(anno_hug133plus2) # # A tibble: 6 × 2 # probe_id symbol # \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt; # 1 1007_s_at MIR4640 # 2 1053_at RFC2 # 3 117_at HSPA6 # 4 121_at PAX8 # 5 1255_g_at GUCA1A # 6 1294_at MIR5193 eset\u0026lt;-anno_eset(eset = eset, annotation = anno_hug133plus2, symbol = \u0026#34;symbol\u0026#34;, probe = \u0026#34;probe_id\u0026#34;, method = \u0026#34;mean\u0026#34;) eset[1:4, 1:4] # GSM2696792 GSM2696793 GSM2696794 GSM2696795 # SH3KBP1 14.30308 14.56398 14.37668 14.47983 # RPL41 14.36095 14.32783 14.33181 14.34614 # LOC101928826 14.18638 14.38247 14.34530 14.26433 # EEF1A1 14.13245 14.15141 14.08980 14.05879 3、signature打分 内置signature基因集（list对象） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # (1)全部 str(signature_collection) # 264 dim(signature_collection_citation) # (2)可分为3大类 str(signature_tme) #119 str(signature_metabolism) #114 str(signature_tumor) # 16 # (3) 又可分为40个主题 str(sig_group) table(names(signature_collection) %in% unlist(sig_group)) # FALSE TRUE # 22 242 打分函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 calculate_sig_score sig_score \u0026lt;-calculate_sig_score(pdata = NULL, eset = eset_stad, signature = signature_tme, method = \u0026#34;pca\u0026#34;, mini_gene_count = 2) # pdata：样本表型，如无可忽略 # eset ：标准化表达矩阵 # signature ：list格式的基因集 ## 内置包括 \u0026#39;signature_tme\u0026#39;, \u0026#39;signature_metabolism\u0026#39;,\u0026#39;signature_collection\u0026#39;, \u0026#39;go_bp\u0026#39;,\u0026#39;kegg\u0026#39;,\u0026#39;hallmark\u0026#39; # method ：打分方法 ## 可选 \u0026#39;pca\u0026#39;, \u0026#39;ssgsea\u0026#39;, \u0026#39;zscore\u0026#39;,\u0026#39;integration\u0026#39;（前3种都计算一遍） # mini_gene_count：单个基因集包含的最小基因数 # parallel.size ： 调用线程数 sig_tme\u0026lt;-calculate_sig_score(pdata = NULL, eset = eset_stad, signature = signature_tme, method = \u0026#34;pca\u0026#34;, mini_gene_count = 2) sig_tme[1:4,1:4] # # A tibble: 4 × 4 # ID CD_8_T_effector DDR APM # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 TCGA-D7-5577-01A 5.00 1.63 2.82 # 2 TCGA-D7-6818-01A -2.45 0.199 0.373 # 3 TCGA-BR-7958-01A 6.38 3.58 3.34 # 4 TCGA-D7-8572-01A 0.848 12.2 0.272 4、联合表型分析 在进行一系列signature打分之分后，可根据样本表型进行分组比较\n若表型是二分类变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 data(\u0026#34;imvigor210_pdata\u0026#34;) imvigor210_pdata[1:5, 1:5] pdata_group\u0026lt;-imvigor210_pdata[!imvigor210_pdata$BOR_binary==\u0026#34;NA\u0026#34;,c(\u0026#34;ID\u0026#34;,\u0026#34;BOR\u0026#34;,\u0026#34;BOR_binary\u0026#34;)] res\u0026lt;-iobr_cor_plot(pdata_group = pdata_group, #样本分组 id1 = \u0026#34;ID\u0026#34;, group = \u0026#34;BOR_binary\u0026#34;, is_target_continuous = FALSE, target = NULL, feature_data = imvigor210_sig, #样本打分结果 id2 = \u0026#34;ID\u0026#34;, category = \u0026#34;signature\u0026#34;, signature_group = sig_group[c(1)], # 一个主题的signature list index = 1, #文件前缀名 ProjectID = \u0026#34;IMvigor210\u0026#34;, #文件项目名 path = \u0026#34;1-BOR-relevant-signatures\u0026#34;, #文件夹名 palette_box = \u0026#34;paired1\u0026#34;, palette_corplot = \u0026#34;pheatmap\u0026#34;, palette_heatmap = 2 ) head(res) # # A tibble: 6 × 8 # sig_names p.value NR R statistic p.adj log10pvalue stars # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; # 1 Mismatch_Repair 0.00000921 -0.142 0.479 -0.620 0.0000608 5.04 **** # 2 Cell_cycle 0.0000105 -0.143 0.484 -0.627 0.0000608 4.98 **** # 3 DDR 0.0000152 -0.140 0.474 -0.614 0.0000608 4.82 **** # 4 Homologous_recombination 0.0000331 -0.134 0.453 -0.587 0.0000893 4.48 **** # 5 Histones 0.0000372 -0.127 0.429 -0.556 0.0000893 4.43 **** # 6 CellCycle_Reg 0.00134 -0.105 0.354 -0.459 0.00267 2.87 ** 若表型是连续数值变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 res2 \u0026lt;-iobr_cor_plot(pdata_group = pdata_group, id1 = \u0026#34;ID\u0026#34;, is_target_continuous = TRUE, target = \u0026#34;HCP5\u0026#34;, group = \u0026#34;group3\u0026#34;, feature_data = imvigor210_sig, id2 = \u0026#34;ID\u0026#34;, category = \u0026#34;signature\u0026#34;, signature_group = sig_group[c(1)], padj_cutoff = 1, index = 2, ProjectID = \u0026#34;IMvigor210\u0026#34;, path = \u0026#34;3-HCP5-relevant-signatures\u0026#34;, palette_box = \u0026#34;set2\u0026#34;, palette_corplot = \u0026#34;pheatmap\u0026#34;, palette_heatmap = 2 ) head(res2) # # A tibble: 6 × 6 # sig_names p.value statistic p.adj log10pvalue stars # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; # 1 Positive_regulation_of_exosomal_secretion 2.80e-14 -0.393 3.36e-13 13.6 \u0026#34;****\u0026#34; # 2 Ferroptosis 1.02e- 7 0.281 6.11e- 7 6.99 \u0026#34;****\u0026#34; # 3 EV_Cell_2020 5.14e- 7 0.265 2.06e- 6 6.29 \u0026#34;****\u0026#34; # 4 Nature_metabolism_Hypoxia 1.36e- 4 -0.203 4.09e- 4 3.87 \u0026#34;***\u0026#34; # 5 CellCycle_Reg 4.07e- 1 0.0446 9.07e- 1 0.391 \u0026#34;+\u0026#34; # 6 Homologous_recombination 5.56e- 1 -0.0316 9.07e- 1 0.255 \u0026#34;\u0026#34; 5、免疫浸润分析 IOBR包继承了8种免疫浸润分析的方法，使用方法如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cibersort\u0026lt;-deconvo_tme(eset = eset_stad[,1:10,], method = \u0026#34;cibersort\u0026#34;, arrays = FALSE, perm = 200 ) epic\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], method = \u0026#34;epic\u0026#34;, arrays = FALSE) mcp\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], method = \u0026#34;mcpcounter\u0026#34;) xcell\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], method = \u0026#34;xcell\u0026#34;,arrays = FALSE) estimate\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], method = \u0026#34;estimate\u0026#34;) timer\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], method = \u0026#34;timer\u0026#34;, group_list = rep(\u0026#34;stad\u0026#34;,10)) quantiseq\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], tumor = TRUE, arrays = FALSE, scale_mrna = TRUE, method = \u0026#34;quantiseq\u0026#34;) ips\u0026lt;-deconvo_tme(eset = eset_stad[,1:10], method = \u0026#34;ips\u0026#34;, plot= FALSE) 结果可视化 1 2 library(tidyverse) cell_bar_plot(input = epic, title = \u0026#34;Deconvolution Cell Fraction\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/081iobr%E5%8C%85%E8%82%BF%E7%98%A4signature%E6%89%93%E5%88%86%E4%B8%8E%E5%85%8D%E7%96%AB%E6%B5%B8%E6%B6%A6%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eIOBR包集signature打分与免疫浸润分析为一体的肿瘤数据分析工具，由南方医科大学南方医院廖旺军教授，曾东强博士等人于2021年7月发表于Frontiers in Immunology，引用数以超过100余次。现根据其github教程学习其部分功能用法。\u003c/p\u003e","title":"IOBR包肿瘤signature打分与免疫浸润分析"},{"content":" BayesPrism是由美国康奈尔大学Tin Yi Chu等人开发的R包工具，于2022年4月发表在Nature Cancer。简单来说，该方法使用单细胞RNA-seq作为先验信息，通过估计批量样本中细胞类型比例和细胞类型特异性基因表达的联合后验分布。P(θ,Z|X,ϕ)，参数概念如下\nϕ：输入数据 \u0026ndash; 单细胞表达矩阵，及相关注释结果； X：输入数据 \u0026ndash; Bulk RNA-seq表达矩阵； θ：输出结果 \u0026ndash; Bulk样本的细胞组成； Z：输出结果 \u0026ndash; 每一种细胞类型的Bulk基因表达矩阵。 DOI：https://www.nature.com/articles/s43018-022-00356-3\nGithub：https://github.com/Danko-Lab/BayesPrism\n1、安装R包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 检查是否安装相关依赖包 for (pkg in c(\u0026#34;snowfall\u0026#34;, \u0026#34;NMF\u0026#34;, \u0026#34;gplots\u0026#34;, \u0026#34;scran\u0026#34;, \u0026#34;BiocParallel\u0026#34;)){ print(requireNamespace(pkg, quietly = TRUE)) } # install.packages(\u0026#34;snowfall\u0026#34;) # install.packages(\u0026#34;NMF\u0026#34;) # install.packages(\u0026#34;gplots\u0026#34;) # BiocManager::install(\u0026#34;scran\u0026#34;) # BiocManager::install(\u0026#34;BiocParallel\u0026#34;) # 在线或下载到本地安装 # https://github.com/Danko-Lab/BayesPrism/tree/main # list.files(\u0026#34;BayesPrism-main/BayesPrism/\u0026#34;) # # [1] \u0026#34;DESCRIPTION\u0026#34; \u0026#34;inst\u0026#34; \u0026#34;man\u0026#34; \u0026#34;NAMESPACE\u0026#34; \u0026#34;R\u0026#34; devtools::install_local(\u0026#34;BayesPrism-main/BayesPrism/\u0026#34;) 2、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 load(\u0026#34;./BayesPrism-main/tutorial.dat/tutorial.gbm.rdata\u0026#34;) ## (1) Bulk RNA-seq dim(bk.dat) # [1] 169 60483 bk.dat[1:4,1:2] # ENSG00000000003.13 ENSG00000000005.5 # TCGA-06-2563-01A-01R-1849-01 5033 12 # TCGA-06-0749-01A-01R-1849-01 3422 62 # TCGA-06-5418-01A-01R-1849-01 4976 17 # TCGA-06-0211-01B-01R-1849-01 5770 5 ## (2) scRNA-seq dim(sc.dat) # [1] 23793 60294 sc.dat[1:4,1:2] # ENSG00000130876.10 ENSG00000134438.9 # PJ016.V3 0 0 # PJ016.V4 0 0 # PJ016.V5 0 0 # PJ016.V6 0 0 ## (3) 主要细胞类型注释结果 str(cell.type.labels) # chr [1:23793] \u0026#34;tumor\u0026#34; \u0026#34;tumor\u0026#34; \u0026#34;tumor\u0026#34; \u0026#34;tumor\u0026#34; \u0026#34;tumor\u0026#34; \u0026#34;tumor\u0026#34; \u0026#34;tumor\u0026#34; ... sort(table(cell.type.labels)) # tcell oligo pericyte endothelial myeloid tumor # 67 160 489 492 2505 20080 ## (4) 细胞亚群注释结果 str(cell.state.labels) # chr [1:23793] \u0026#34;PJ016-tumor-0\u0026#34; \u0026#34;PJ016-tumor-0\u0026#34; \u0026#34;PJ016-tumor-3\u0026#34; ... sort(table(cell.state.labels)) %\u0026gt;% head # PJ017-tumor-6 PJ032-tumor-5 myeloid_8 PJ032-tumor-4 PJ032-tumor-3 # 22 41 49 57 62 *表达数据均推荐使用raw count；另外相当于细胞亚型的state标签，要确保每一类亚型要有一定量的细胞（\u0026gt;20）\n3、单细胞数据质控 3.1 细胞注释的合理性\n观察相同类型的细胞是否聚类在一起 1 2 3 4 5 6 7 8 9 10 11 12 13 plot.cor.phi(input=sc.dat, input.labels=cell.state.labels, title=\u0026#34;cell state correlation\u0026#34;, #specify pdf.prefix if need to output to pdf #pdf.prefix=\u0026#34;gbm.cor.cs\u0026#34;, cexRow=0.2, cexCol=0.2, margins=c(2,2)) plot.cor.phi(input=sc.dat, input.labels=cell.type.labels, title=\u0026#34;cell type correlation\u0026#34;, #specify pdf.prefix if need to output to pdf #pdf.prefix=\u0026#34;gbm.cor.ct\u0026#34;, cexRow=0.5, cexCol=0.5) 3.2 筛选基因\n删除核糖体，线粒体，性染色体等基因，以及低表达基因 1 2 3 4 5 6 7 sc.dat.filtered \u0026lt;- cleanup.genes(input=sc.dat, input.type=\u0026#34;count.matrix\u0026#34;, species=\u0026#34;hs\u0026#34;, gene.group=c( \u0026#34;Rb\u0026#34;,\u0026#34;Mrp\u0026#34;,\u0026#34;other_Rb\u0026#34;,\u0026#34;chrM\u0026#34;,\u0026#34;MALAT1\u0026#34;,\u0026#34;chrX\u0026#34;,\u0026#34;chrY\u0026#34;) , exp.cells=5) dim(sc.dat.filtered) # [1] 23793 31737 仅保留蛋白质编码基因 1 2 3 4 sc.dat.filtered.pc \u0026lt;- select.gene.type(sc.dat.filtered, gene.type = \u0026#34;protein_coding\u0026#34;) dim(sc.dat.filtered.pc) # [1] 23793 16148 4、BayesPrism预测 4.1 构建prism对象\n1 2 3 4 5 6 7 8 9 10 myPrism \u0026lt;- new.prism( reference=sc.dat.filtered.pc, mixture=bk.dat, input.type=\u0026#34;count.matrix\u0026#34;, cell.type.labels = cell.type.labels, cell.state.labels = cell.state.labels, key=\u0026#34;tumor\u0026#34;, #如若有肿瘤细胞类型，需要在此交代 outlier.cut=0.01, outlier.fraction=0.1, ) 4.2 prism预测\n1 2 3 # 耗时 bp.res \u0026lt;- run.prism(prism = myPrism, n.cores=50) # save(bp.res, file=\u0026#34;bp.res.rda\u0026#34;) 4.3 提取结果\n对于Bulk样本的细胞组成预测结果 1 2 3 4 5 6 theta_type = get.fraction(bp.res, which.theta=\u0026#34;final\u0026#34;, #c(\u0026#34;first\u0026#34;, \u0026#34;final\u0026#34;) state.or.type=\u0026#34;type\u0026#34; #c(\u0026#34;state\u0026#34;, \u0026#34;type\u0026#34;) ) dim(theta_type) # [1] 169 6 对于每一种细胞类型下，Bulk样本的表达矩阵 1 2 3 4 5 6 7 8 Z_tumor = get.exp(bp.res, state.or.type=\u0026#34;type\u0026#34;, # c(\u0026#34;state\u0026#34;, \u0026#34;type\u0026#34;) cell.name = \u0026#34;tumor\u0026#34;) dim(Z_tumor) # [1] 169 16145 dim(bk.dat) # [1] 169 60483 5、肿瘤模块NMF分析 因十分耗时，暂时仅记录如下。如需用到可参考Github介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 Z.tum.norm \u0026lt;- t(bp.res@reference.update@psi_mal) dim(Z.tum.norm) # [1] 16145 169 estim.Z.tum.norm \u0026lt;- nmf(Z.tum.norm, rank=2:12, seed=123456) plot(estim.Z.tum.norm) consensusmap(estim.Z.tum.norm, labCol=NA, labRow=NA) ebd.res \u0026lt;- learn.embedding.nmf(bp = bp.res, K = 5, cycle = 50, compute.elbo = T) 6、注意事项 根据Github的FAQ部分总结相关注意点如下：\n**（1）**应该使用包含肿瘤组织全部细胞类型的完整scRNA-seq数据作为参考。对于第一级的细胞标签（type），如果明确细胞亚型已知（例如CD4+ T等），应当用之。更高分辨率的注释可以做为第二级的state；\n**（2）**对于tumor细胞的第二级注释，推荐在每个样本内进行再聚类分析。\n**（3）**在包含肿瘤细胞的参考数据中，需要注意肿瘤细胞与高度类似于肿瘤细胞的正常细胞关系。例如分析胶质母细胞瘤（GBM）时，将正常星形细胞纳入参考可能导致对星形细胞的过高估计和恶性细胞的低估。但不影响其它细胞类型的分析。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/082bayesprism%E5%8C%85%E6%A0%B9%E6%8D%AEscrnaseq%E9%A2%84%E6%B5%8Bbulk%E7%BB%86%E8%83%9E%E7%BB%84%E6%88%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eBayesPrism是由美国康奈尔大学Tin Yi Chu等人开发的R包工具，于2022年4月发表在Nature Cancer。简单来说，该方法使用单细胞RNA-seq作为先验信息，通过估计批量样本中细胞类型比例和细胞类型特异性基因表达的联合后验分布。\u003cstrong\u003eP(θ,Z|X,ϕ)\u003c/strong\u003e，参数概念如下\u003c/p\u003e","title":"BayesPrism包根据scRNAseq预测Bulk细胞组成"},{"content":" （1）NMF是非负矩阵分解（Non-negative Matrix Factorization）的缩写。它是将一个非负数据矩阵分解为两个非负矩阵的乘积，其中一个矩阵表示特征的基矩阵，另一个矩阵表示每个样本在这些特征上的系数矩阵。这样的分解可以将原始数据表示为一组非负基向量的加权组合，从而实现数据的降维和特征提取。\n（2）结合Bulk RNA-seq表达矩阵（Original Matrix）可以更直观地理解为拆分成：基因与细胞类型矩阵(基矩阵)，以及细胞比例与样本矩阵(系数矩阵)。下面结合R包NMF学习其基础用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 模拟数据：100个样本的30个基因表达矩阵 set.seed(42) exp_mat = matrix(abs(rnorm(3000)), nrow = 30) colnames(exp_mat) = paste0(\u0026#34;sp\u0026#34;,1:100) rownames(exp_mat) = paste0(\u0026#34;gene\u0026#34;,1:30) dim(exp_mat) # [1] 30 100 exp_mat[1:4,1:4] # sp1 sp2 sp3 sp4 # gene1 1.3709584 0.4554501 0.3672346 1.3921164 # gene2 0.5646982 0.7048373 0.1852306 0.4761739 # gene3 0.3631284 1.0351035 0.5818237 0.6503486 # gene4 0.6328626 0.6089264 1.3997368 1.3911105 1、基础用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 library(NMF) # 支持算法：c(\u0026#34;brunet\u0026#34;,\u0026#34;lee\u0026#34;,\u0026#34;ls-nmf\u0026#34;,\u0026#34;nsNMF\u0026#34;,\u0026#34;offset\u0026#34;,\u0026#34;pe-nmf\u0026#34;,\u0026#34;snmf/r\u0026#34;,\u0026#34;snmf/l\u0026#34;) nmf_model \u0026lt;- nmf(exp_mat, rank = 3, method = \u0026#34;brunet\u0026#34;, seed = 42) # 获取基矩阵（基因--细胞） basis_matrix \u0026lt;- basis(nmf_model) dim(basis_matrix) # [1] 30 3 head(basis_matrix) # [,1] [,2] [,3] # gene1 1.7436283 0.7842223 3.0718832 # gene2 1.0542018 0.9599996 2.8275129 # gene3 2.7498596 1.4277110 1.0828163 # gene4 0.8918389 1.8432274 2.7861665 # gene5 4.2662810 0.8883752 0.3467359 # gene6 5.8054591 0.6420813 0.2967837 # 获取系数矩阵（细胞--样本） coef_matrix \u0026lt;- coef(nmf_model) dim(coef_matrix) # [1] 3 100 head(coef_matrix[,1:3]) # sp1 sp2 sp3 # [1,] 0.002897117 0.02866644 0.02137146 # [2,] 0.131645724 0.14692969 0.04635707 # [3,] 0.022945508 0.05598917 0.11973042 # [4,] 0.169223269 0.06491003 0.13558182 # [5,] 0.088389864 0.10569255 0.12587923 2、挑选Rank 1 2 3 4 5 6 # 遍历2~10种候选值，每个重复10次 nmf_model_candi \u0026lt;- nmf(exp_mat, rank = 2:10, method = \u0026#34;brunet\u0026#34;, nrun=10) pdf(\u0026#34;candi_ranks.pdf\u0026#34;, width=8, height=8) plot(nmf_model_candi) dev.off() 1 2 3 pdf(\u0026#34;candi_ranks_consensusmap.pdf\u0026#34;, width=10, height=10) consensusmap(nmf_model_candi) dev.off() 3、结果可视化 根据上述结果，选择k=4作为比较合适的rank值\n1 2 3 nmf_model = nmf(exp_mat, rank = 4, method = \u0026#34;brunet\u0026#34;, nrun=100) basis_matrix \u0026lt;- basis(nmf_model) coef_matrix \u0026lt;- coef(nmf_model) 参考https://cran.r-project.org/web/packages/NMF/vignettes/heatmaps.pdf，进行绘图\n可视化基矩阵(基因\u0026ndash;细胞) 1 2 3 pdf(\u0026#34;basismap.pdf\u0026#34;, width = 10, height = 10) basismap(nmf_model) dev.off() 可视化系数矩阵(细胞\u0026ndash;样本) 1 2 3 pdf(\u0026#34;coefmap.pdf\u0026#34;, width = 10, height = 10) coefmap(nmf_model) dev.off() 可视化样本consensus聚类 1 2 3 pdf(\u0026#34;consensusmap.pdf\u0026#34;, width = 10, height = 10) consensusmap(nmf_model, labCol=NA, labRow=NA) dev.off() 4、知二求一 1 2 3 4 5 6 set.seed(42) V = matrix(abs(rnorm(50)), nrow =5) set.seed(42) W = matrix(abs(rnorm(20)), nrow =5) set.seed(42) H = matrix(abs(rnorm(40)), nrow =4) 根据原始矩阵V与基矩阵W，求系数矩阵H 1 2 3 4 nmf_obj \u0026lt;- nmf(V, 4, W = W, method = \u0026#34;brunet\u0026#34;, nrun = 100) fit(nmf_obj) H2 \u0026lt;- coef(nmf_obj) H2[,1:4] 根据原始矩阵V与系数矩阵H，求基矩阵W 1 2 3 4 nmf_obj \u0026lt;- nmf(V, 4, H = H, method = \u0026#34;brunet\u0026#34;, nrun = 100) fit(nmf_obj) W2 \u0026lt;- coef(nmf_obj) W2[,1:4] *在nrun足够大的情况下，可以得到相对稳定的结果\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/083r%E5%8C%85nmf%E9%9D%9E%E8%B4%9F%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/","summary":"\u003cblockquote\u003e\n\u003cp\u003e（1）NMF是非负矩阵分解（Non-negative Matrix Factorization）的缩写。它是将一个非负数据矩阵分解为两个非负矩阵的乘积，其中一个矩阵表示特征的基矩阵，另一个矩阵表示每个样本在这些特征上的系数矩阵。这样的分解可以将原始数据表示为一组非负基向量的加权组合，从而实现数据的降维和特征提取。\u003c/p\u003e","title":"R包NMF非负矩阵分解"},{"content":" Github仓库：https://github.com/openbiox/UCSCXenaShiny\nOnline App：https://shiny.zhoulab.ac.cn/UCSCXenaShiny/\nTutorial Book：https://lishensuo.github.io/UCSCXenaShiny_Book/\n文章发表：Communications Biology, https://www.nature.com/articles/s42003-024-06891-2\n2024年9月，UCSCXenashiny v2版本正式发表在Communication Biology期刊上。此时更新旨在给用户以更加个性化、多元化的角度，高效地探索TCGA等大型肿瘤多组学队列数据。\n关于UCSCXenashiny的详细介绍与功能用法，用户可参考我们精心准备的教程文档。下面将简要介绍工具各个板块的快速入门使用帮助。\n1. 安装/访问 UCSCXenashiny是基于R语言开发的Shiny项目。用户有如下两种方式进入Shiny网页\n（1）直接在线访问我们已经部署好的Shiny网站：https://shiny.zhoulab.ac.cn/UCSCXenaShiny/ 或者 https://shiny.hiplot.cn/ucsc-xena-shiny\n优点：简单、直接 缺点：由于网络拥堵等原因时，偶尔可能会无法访问（如果长时间遇到这个问题，可通过Github或者邮件联系我们） （2）在用户的R环境安装UCSCXenashiny包后，再本地启动Shiny网页\n优点：相对比较稳定，R包也提供很多分析函数可供调用 缺点：需要对R语言操作有一定了解，对电脑内存有一定要求 对于第二种方式，我们提供了多种安装方式，包括CRAN、Conda、docker等。下面以CRAN为例：\n1 2 3 4 5 6 7 8 # 安装 install.packages(\u0026#34;UCSCXenaShiny\u0026#34;) # 加载 library(UCSCXenaShiny) # 启动Shiny页面。第一次启动需要下载必要的补充数据 app_run() 2. 首页导航 进入Shiny App的首页面后，最上方的导航栏展示了目前UCSCXenashiny支持的全部功能。 接下来是关于 V2版本的概述，以及两个特别设计的快速功能面板 Daily Gene：每天展示一个基因，介绍它在哪一种TCGA肿瘤中相对正常样本差异表达最显著； Pan-Cancer Query：用户输入一个多组学分子后，可生成一个TCGA泛癌分析报告。 再往下分别是关于UCSCXenashiny的核心功能动态展示、TPC功能快速链接、以及更新日志。 此外，用户可在导航栏的Help部分进入Quick Guide页面，查看每个模块的布局介绍。 3. TPC分析 TPC 表示三个常见的大型肿瘤多组学项目，分别是TCGA, PCAWG, CCLE 基于UCSC Xena平台的数据优势，我们设计了两个系列的交互式分析页面，作为UCSCXenashiny的核心功能 3.1 TPC Modules 特点：功能相对具体，页面布局简洁，用户仅需要较少的步骤得到结果\n以TCGA为例，我们共提供了3类模块：\n比较分析类：① Tumor VS Normal (Box plot); ② Tumor VS Normal (Anatomy plot); ③ Mutation VS Wild\n相关性分析类：① Molecule-Molecule; ② Molecule-Tumor Immune Infiltration; ③ Molecule-Immune Signature; ④ Molecule-TMB/Stemness/MSI; ⑤ Molecule-Pathway\n生存分析类：① Kaplan-Meier; ② Cox regression\n3.2 TPC pipelines TPC分析流程的设计是本次V2更新的核心之一。以TCGA为例，共包括相关性分析、分组比较分析、生存分析三类流程，具有如下特点：\n数据层面：大量的数据整合于一体，增加了分析的广度\n7种组学分子：Gene Expression, Transcript Expression, DNA Methylation, Protein Expression, miRNA Expression, Gene Mutation, Copy Number Variation 4种非组学分子：4类Clinical Phenotype，3类Pathway Activity，7类Immune Infiltration，5类Tumor Index 操作层面：多元的操作设计，增加了分析的深度\n个性化的数据样本过滤与分组功能，使得用户可以针对具有某种分子特征的肿瘤亚群进行特定分析； 除了基础分析模式外，我们还支持泛癌分析模式以及批量筛选模式，扩大了Pipeline的应用场景。 4. 其它功能 4.1 General Analysis 除了TPC数据以外，Xena平台还整理了其它很多队列的肿瘤组学数据。 General Analysis页面则允许用户以更通用的角度，探索Xena平台大部分的数据集。 4.2 Download 除了分析功能以外，UCSCXenashiny提供了数据下载的功能。\nRepository页面可以查询Xena大部分的数据集，以及多样的下载方式； Download页面可以帮助用户从特定数据集中，下载指定的一个或多个分子的数据。 4.3 PharmacoGenomics 此外，肿瘤细胞系的药物敏感性数据在治疗相关的分子机制研究和药物筛选中具有重要作用。 在V2版本的开发过程中，我们集成了彭宇中博士开发的OmicsPharDB工具 (https://github.com/mugpeng/OmicsPharDB) 其收集了来自GDSC1/2，CTRP1/2，PRISM，gCSI等药物数据，实现了多个具有特色的组学联合分析模块。 综上，简要介绍了UCSCXenaShiny v2版本更新后的使用方式与功能概述。我们的教程文档以及操作视频（https://lishensuo.github.io/UCSCXenaShiny_Book/）都提供了详细的帮助信息，使得用户可以快速上手。在后续，我们也会针对上述提到的每项功能，结合实例分享相关的使用经验。\n最后，如果你在操作过程中，碰到意外的报错或Bug，欢迎随时通过Github或者邮件联系我们。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/084ucscxenashiny-v2%E7%AE%80%E8%A6%81%E6%95%99%E7%A8%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003eGithub仓库：https://github.com/openbiox/UCSCXenaShiny\u003c/p\u003e\n\u003cp\u003eOnline App：https://shiny.zhoulab.ac.cn/UCSCXenaShiny/\u003c/p\u003e","title":"UCSCXenaShiny V2简要教程"},{"content":" https://mlr3book.mlr-org.com/ 1 2 3 4 5 6 7 8 9 10 library(mlr3verse) library(tidyverse) tsks() #预置数据任务 lrns() #机器学习算法 msrs() #性能评价指标 as.data.table() 1. Task 任务 https://mlr3book.mlr-org.com/chapters/chapter2/data_and_basic_modeling.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tsk() #预置数据任务 as.data.table(tsk()) tsk(\u0026#34;mtcars\u0026#34;) #自定义任务 tsk_mtcars = as_task_regr(mtcars, target = \u0026#34;mpg\u0026#34;, id = \u0026#34;cars\u0026#34;) #target参数指定标签列，id参数（可选）设置任务名 as_task_classif() #支持对任务对象进行数据查看、修改等操作，不一一列举，详见上述链接 #有两点需要重点说明 tsk_mtcars$row_ids #不等于一般的行序号。一旦定义任务，row_ids就确定不变了，可以理解为row name。方便后续数据分割。 tsk_mtcars_another = tsk_mtcars$clone() #想要独立的复制任务时，需要使用clone() 对于分类任务基本类似。值得注意的是在二分类问题时，需要进一步指定阳性标签\n1 2 3 4 5 data(Sonar, package = \u0026#34;mlbench\u0026#34;) # specifying the positive class: tsk_classif = as_task_classif(Sonar, target = \u0026#34;Class\u0026#34;, positive = \u0026#34;R\u0026#34;) tsk_classif$positive tsk_classif$positive = \u0026#34;M\u0026#34; #修改 2. Learner 算法 https://mlr3book.mlr-org.com/chapters/chapter2/data_and_basic_modeling.html https://mlr-org.com/learners.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # mlr3learners包支持~10种常见的机器学习算法，建议在建模时优先尝试 # mlr3extralearners包支持了更多种(\u0026gt;100)算法【需要单独安装】 # 0) 查看所有算法简介（或者点击上述链接） learners_dt = as.data.table(lrns()) learners_dt learners_dt %\u0026gt;% dplyr::filter(grepl(\u0026#34;mlr3learners\u0026#34;,packages)) %\u0026gt;% dplyr::filter(task_type==\u0026#34;classif\u0026#34;) # 1) 定义并使用算法 lrn_rpart = lrn(\u0026#34;regr.rpart\u0026#34;) #在分类问题，可额外设置 predict_type = \u0026#34;prob\u0026#34;/\u0026#34;response\u0026#34; 表示预测概率值/类别结果 # 2) 简单分割数据为训练集与测试集 tsk_mtcars = as_task_regr(mtcars, target = \u0026#34;mpg\u0026#34;, id = \u0026#34;cars\u0026#34;) splits = partition(tsk_mtcars) str(splits) # 3) 训练、查看模型 lrn_rpart$train(tsk_mtcars, row_ids = splits$train) lrn_rpart$model # 4) 模型预测 prediction = lrn_rpart$predict(tsk_mtcars, row_ids = splits$test) #测试集 prediction2 = lrn_rpart$predict_newdata(mtcars_new) #新数据 关于模型的超参数：\n上述训练示例，使用了算法的默认超参数； 也可以在训练前自定义设置一组超参数 1 2 3 4 5 6 7 8 9 10 lrn_rpart = lrn(\u0026#34;regr.rpart\u0026#34;) lrn_rpart$param_set #查看支持的超参数类型 lrn_rpart$param_set$values #查看当前设置的超参数值 #设置超参数方法 lrn_rpart = lrn(\u0026#34;regr.rpart\u0026#34;, maxdepth = 1) #or lrn_rpart$param_set$values$maxdepth = 2 #or lrn_rpart$param_set$set_values(xval = 2, cp = 0.5) 3. Measure 指标 https://mlr3book.mlr-org.com/chapters/chapter2/data_and_basic_modeling.html#sec-eval 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # mlr3measures包提供了常见分类或回归任务的评价指标 # 0) 查看所有指标 measures_dt = as.data.table(msrs()) measures_dt %\u0026gt;% dplyr::filter(grepl(\u0026#34;mlr3measures\u0026#34;,packages)) %\u0026gt;% dplyr::filter(task_type==\u0026#34;classif\u0026#34;) # 1)前景提要 lrn_rpart = lrn(\u0026#34;regr.rpart\u0026#34;) tsk_mtcars = tsk(\u0026#34;mtcars\u0026#34;) splits = partition(tsk_mtcars) lrn_rpart$train(tsk_mtcars, splits$train) prediction = lrn_rpart$predict(tsk_mtcars, splits$test) # 2)选择指标 measure = msr(\u0026#34;regr.mae\u0026#34;) measure # 3)指标评价 prediction$score(measure) # 4)支持同时多个指标。注意，此时需要使用msrs(),而不是msr() measures = msrs(c(\u0026#34;regr.mse\u0026#34;, \u0026#34;regr.mae\u0026#34;)) prediction$score(measures) Tip：对于分类任务\n相关指标，有的是适用于\u0026quot;prob\u0026quot;（概率值），有的是适用于\u0026quot;response\u0026quot;（标签结果）。\n在评价前，可以修改默认的分类阈值，并查看相关的混淆矩阵\n1 2 prediction$set_threshold(0.7) prediction$confusion 4. Resampling 交叉验证 https://mlr3book.mlr-org.com/chapters/chapter3/evaluation_and_benchmarking.html#sec-resampling 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 查看所支持的交叉验证方式，详细介绍参考上述链接 resampling_dt = as.data.table(rsmps()) # 1) 定义交叉验证方式 # three-fold CV cv3 = rsmp(\u0026#34;cv\u0026#34;, folds = 3) # 2-repeats 5-fold CV rcv25 = rsmp(\u0026#34;repeated_cv\u0026#34;, repeats = 2, folds = 5) # 2) 定义任务/算法 tsk_mtcars = tsk(\u0026#34;mtcars\u0026#34;) lrn_rpart = lrn(\u0026#34;regr.rpart\u0026#34;) # 3) 执行交叉验证 rr = resample(tsk_mtcars, lrn_rpart, cv3) rr rr$score(msr(\u0026#34;regr.mse\u0026#34;)) #计算每折的指标结果 rr$aggregate(msr(\u0026#34;regr.mse\u0026#34;)) #计算综合的评价结果 rr$predictions() #查看每折对验证集的预测结果 rr$prediction() #查看全部对验证集的预测结果 Tips:\n在执行交叉验证前，可提前查看每折的样本分割方式\n1 2 3 4 cv3$instantiate(tsk_mtcars) # 查看第一次拆分的训练集与测试集id cv3$train_set(1) cv3$test_set(1) 在resample()分析结果默认不保存每折的训练模型，可通过设置参数进行保存\n1 2 rr = resample(tsk_mtcars, lrn_rpart, cv3, store_models = T) rr$learners[[1]]$model 特殊CV：由于数据样本的特殊性，在样本分割时可进行额外的设置\nGrouped Resampling：保证同一组的数据不会既在训练集，也在测试集中；可参考如下图进行理解\nhttps://mlr3book.mlr-org.com/chapters/chapter3/Figures/mlr3book_figures-7.svg\n1 2 3 4 5 6 7 # 如下将penguins任务的year列设置为group的依据 tsk_grp = tsk(\u0026#34;penguins\u0026#34;) tsk_grp$set_col_roles(\u0026#34;year\u0026#34;, \u0026#34;group\u0026#34;) rsmp_loo = rsmp(\u0026#34;loo\u0026#34;) #使用leave-one-out方法，每次留一组的样本作为测试集 rsmp_loo$instantiate(tsk_grp) table(tsk_grp$data(rows = rsmp_loo$train_set(1), cols = \u0026#34;year\u0026#34;)) Stratified Sampling：保证每次样本拆分时，某一特征的分布保持一致；可参考下图进行理解\nhttps://mlr3book.mlr-org.com/chapters/chapter3/Figures/mlr3book_figures-8.svg\n1 2 3 4 5 6 7 8 9 10 tsk_str = tsk(\u0026#34;penguins\u0026#34;) # set species to have both the \u0026#39;target\u0026#39; and \u0026#39;stratum\u0026#39; column role tsk_str$set_col_roles(\u0026#34;species\u0026#34;, c(\u0026#34;target\u0026#34;, \u0026#34;stratum\u0026#34;)) cv3$instantiate(tsk_str) fold1 = prop.table(table(tsk_str$data(rows = cv3$test_set(1), cols = \u0026#34;species\u0026#34;))) fold2 = prop.table(table(tsk_str$data(rows = cv3$test_set(2), cols = \u0026#34;species\u0026#34;))) rbind(\u0026#34;Fold 1\u0026#34; = fold1, \u0026#34;Fold 2\u0026#34; = fold2) 5. Benchmark 基准 https://mlr3book.mlr-org.com/chapters/chapter3/evaluation_and_benchmarking.html#sec-benchmarking 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 1) 设计基准测试任务 # 不同的数据 tasks = list(tsk(\u0026#34;penguins\u0026#34;), tsk(\u0026#34;sonar\u0026#34;)) # 不同的算法 learners = list(lrn(\u0026#34;classif.featureless\u0026#34;), lrn(\u0026#34;classif.rpart\u0026#34;)) # 不同的交叉验证 resamplings = list(rsmp(\u0026#34;cv\u0026#34;), rsmp(\u0026#34;subsampling\u0026#34;)) # Set a seed to ensure reproducibility of the resampling instantiation set.seed(123) design = benchmark_grid(tasks, learners, resamplings) design # 2) 执行 bmr = benchmark(design) bmr bmr$score(msr(c(\u0026#34;classif.acc\u0026#34;))) bmr$aggregate(msr(c(\u0026#34;classif.acc\u0026#34;))) 6. HPO超参数优化 https://mlr3book.mlr-org.com/chapters/chapter4/hyperparameter_optimization.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 1) 设置算法超参数空间 # 查看支持的超参数类型 lrn(\u0026#34;classif.svm\u0026#34;)$param_set # 使用to_tune()设置候选范围 learner = lrn(\u0026#34;classif.svm\u0026#34;, type = \u0026#34;C-classification\u0026#34;, kernel = to_tune(c(\u0026#34;radial\u0026#34;, \u0026#34;linear\u0026#34;)), #字符向量设置候选范围 cost = to_tune(1e-1, 1e5, logscale = T), #对于指数分布范围，进行log转换，合理采样 gamma = to_tune(c(0.1, 0.2, 0.5, 1)) #对于数值类型，也可以指定候选值 ) learner # 2) 停止搜索的条件,参考链接详细介绍 https://mlr-org.com/terminators.html as.data.table(trm()) # 例如 trm(\u0026#34;none\u0026#34;) #不做限制 trm(\u0026#34;evals\u0026#34;, n_evals = 5) #只搜索5次 trm(\u0026#34;run_time\u0026#34;, secs = 1800) #运行时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 3) 创建一个HPO实例 tsk_sonar = tsk(\u0026#34;sonar\u0026#34;) learner = lrn(\u0026#34;classif.svm\u0026#34;, cost = to_tune(1e-1, 1e5, logscale = T), gamma = to_tune(1e-1, 1), kernel = \u0026#34;radial\u0026#34;, type = \u0026#34;C-classification\u0026#34; ) instance = ti( task = tsk_sonar, #数据任务 learner = learner, #学习算法（超参数空间） resampling = rsmp(\u0026#34;cv\u0026#34;, folds = 3), #交叉验证 measures = msr(\u0026#34;classif.ce\u0026#34;), #评价指标 terminator = trm(\u0026#34;none\u0026#34;) #停止条件 ) instance Tips:\n也可以ps()设置超参数空间，提供给ti()的search_space参数，详细参看https://mlr3book.mlr-org.com/chapters/chapter4/hyperparameter_optimization.html#sec-tune-ps 1 2 3 4 5 6 7 8 9 10 11 12 13 search_space = ps( cost = p_dbl(lower = 1e-1, upper = 1e5, trafo = function(x) exp(x)), gamma = p_dbl(lower=0.1, upper = 1) ) instance = ti( task = tsk_sonar, learner = lrn(\u0026#34;classif.svm\u0026#34;,kernel = \u0026#34;radial\u0026#34;,type = \u0026#34;C-classification\u0026#34;), resampling = rsmp(\u0026#34;cv\u0026#34;, folds = 3), measures = msr(\u0026#34;classif.ce\u0026#34;), terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) mlr3团队基于以往研究，收集了常见机器学习模型的常用超参数设置，可供用户直接使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 library(mlr3tuningspaces) as.data.table(mlr_tuning_spaces) lts_svm = lts(\u0026#34;classif.svm.default\u0026#34;) lts_svm instance = ti( task = tsk_sonar, learner = lrn(\u0026#34;classif.svm\u0026#34;,type = \u0026#34;C-classification\u0026#34;), resampling = rsmp(\u0026#34;cv\u0026#34;, folds = 3), measures = msr(\u0026#34;classif.ce\u0026#34;), terminator = trm(\u0026#34;none\u0026#34;), search_space = lts_svm ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 4) 定义超参数搜索方法，参看链接说明 https://mlr-org.com/tuners.html tnr() as.data.table(tnr()) # 例如 tnr(\u0026#34;random_search\u0026#34;) #随机搜索 tnr(\u0026#34;grid_search\u0026#34;) #笛卡尔积 tnr(\u0026#34;mbo\u0026#34;) #贝叶斯优化 tnr(\u0026#34;design_points\u0026#34;, design = design) #自定义搜索范围 # 选择一种方法对上述示例进行调参 tuner = tnr(\u0026#34;grid_search\u0026#34;, resolution = 5, batch_size = 10) #5*5 tuner = tnr(\u0026#34;grid_search\u0026#34;, param_resolutions = c(cost = 5, gamma = 3), batch_size = 10) #3*5 # resolution表示对连续型超参数范围，取n个值 # batch_size可以简单理解为线程数 tuner tuner$optimize(instance) instance$result$learner_param_vals #查看最优模型对应的超参数 instance$archive #查看所有遍历的训练结果 # 5) 使用最佳超参数建立最终模型 lrn_svm_tuned = lrn(\u0026#34;classif.svm\u0026#34;) lrn_svm_tuned$param_set$values = instance$result_learner_param_vals lrn_svm_tuned$train(tsk_sonar)$model #所有数据建模 嵌套交叉验证（Nested-CV）：Nested resampling is a method to compare models and to estimate the generalization performance of a tuned model, however, this is the performance based on multiple different configurations (one from each outer fold) and not performance based on a single configuration.\n其直观、清晰的步骤解释可参看这张图的介绍：https://mlr3book.mlr-org.com/chapters/chapter4/Figures/mlr3book_figures-11.svg\n首先，需要介绍auto_tuner()。它将HPO过程包装为一个类似learner的对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 at = auto_tuner( tuner = tnr(\u0026#34;grid_search\u0026#34;, resolution = 3, batch_size = 5), learner = lrn(\u0026#34;classif.svm\u0026#34;,type = \u0026#34;C-classification\u0026#34;), resampling = rsmp(\u0026#34;cv\u0026#34;, folds = 3), measure = msr(\u0026#34;classif.ce\u0026#34;), search_space = lts(\u0026#34;classif.svm.default\u0026#34;) ) at split = partition(tsk_sonar) at$train(tsk_sonar, row_ids = split$train) #首先通过训练集交叉验证找到一组最优超参数 #然后使用该超参数在全部训练集数据建模 at$predict(tsk_sonar, row_ids = split$test)$score() #测试集评价 然后，Nested CV本质可以理解为对上述示例，再次进行外部的交叉验证 1 2 3 4 5 6 7 8 9 rr = resample(tsk_sonar, at, rsmp(\u0026#34;cv\u0026#34;, folds = 2), store_models = TRUE) #查看外部交叉验证的结果 rr$score(msr(\u0026#34;classif.ce\u0026#34;)) rr$aggregate(msr(\u0026#34;classif.ce\u0026#34;)) #查看内部交叉验证的结果 extract_inner_tuning_results(rr) extract_inner_tuning_archives(rr) 7. FS 特征选择 https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html 思路1：基于mlr3filters包，对每个特征进行单独打分，再设置阈值筛选\n所有支持的打分方法有：https://mlr3filters.mlr-org.com/ 1 2 3 4 5 6 7 8 9 10 # 1) 定义任务 tsk_pen = tsk(\u0026#34;penguins\u0026#34;) # 2) 选择打分指标 flt_gain = flt(\u0026#34;information_gain\u0026#34;) # flt_cor = flt(\u0026#34;correlation\u0026#34;, method = \u0026#34;spearman\u0026#34;) # 3) 计算打分 flt_gain$calculate(tsk_pen) as.data.table(flt_gain) # 最后设定预测（打分高于设定阈值，或者打分排名高于设定阈值），筛选预期特征集合 此外，有两个依赖于特定算法的打分指标\n\u0026ldquo;importance\u0026rdquo;: If only a single filter method is to be used, the authors recommend to use a feature importance filter using random forest permutation importance\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # importance是比较推荐的一种打分，需要结合支持的算法（其中，比较推荐随机森林） as.data.table(mlr_learners)[ sapply(properties, function(x) \u0026#34;importance\u0026#34; %in% x)] lrn(\u0026#34;classif.ranger\u0026#34;)$param_set$levels$importance # [1] \u0026#34;none\u0026#34; \u0026#34;impurity\u0026#34; \u0026#34;impurity_corrected\u0026#34; \u0026#34;permutation\u0026#34; lrn_ranger = lrn(\u0026#34;classif.ranger\u0026#34;, importance = \u0026#34;permutation\u0026#34;) # 由于ranger算法的Properties没有“missing”，也就是说不能处理缺失值，这里需要手动处理一下 tsk_pen = tsk(\u0026#34;penguins\u0026#34;) tsk_pen$filter(tsk_pen$row_ids[complete.cases(tsk_pen$data())]) flt_importance = flt(\u0026#34;importance\u0026#34;, learner = lrn_ranger) flt_importance$calculate(tsk_pen) as.data.table(flt_importance) \u0026ldquo;selected_features\u0026quot;：对于部分ML模型（例如决策树），其在建模过程中，仅会选择部分模型，可以作为特征选择的依据。\n1 2 3 4 5 6 7 8 9 10 # 查看支持的ML算法 as.data.table(mlr_learners)[ sapply(properties, function(x) \u0026#34;selected_features\u0026#34; %in% x)] # 示例 tsk_pen = tsk(\u0026#34;penguins\u0026#34;) lrn_rpart = lrn(\u0026#34;classif.rpart\u0026#34;) flt_selected = flt(\u0026#34;selected_features\u0026#34;, learner = lrn_rpart) flt_selected$calculate(tsk_pen) as.data.table(flt_selected) 思路2：基于mlr3fselect包，直接遍历、搜索最优的特征集合（类似于HPO过程）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 1) 定义实例 instance = fsi( task = tsk(\u0026#34;penguins\u0026#34;), learner = lrn(\u0026#34;classif.rpart\u0026#34;), resampling = rsmp(\u0026#34;cv\u0026#34;, folds = 3), measure = msr(\u0026#34;classif.acc\u0026#34;), terminator = trm(\u0026#34;evals\u0026#34;, n_evals = 20) #停止条件 ) # 2) 选择搜索算法 # as.data.table(fs()) fselector = fs(\u0026#34;random_search\u0026#34;) # fselector = fs(\u0026#34;genetic_search\u0026#34;) # 3) 执行搜索 fselector$optimize(instance) instance$result_feature_set #搜索的最优特征集合 as.data.table(instance$archive) #搜索记录 auto_fselector() 支持基于嵌套交叉验证的特征集合选择，详见 https://mlr3book.mlr-org.com/chapters/chapter6/feature_selection.html#sec-autofselect\n8. Pipeline流程 https://mlr3book.mlr-org.com/chapters/chapter7/sequential_pipelines.html\n首先：PipeOp提供了很多模块化操作，对输入数据进行特定的处理，再输出。（https://mlr-org.com/pipeops.html）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 实例化模块 po_pca = po(\u0026#34;pca\u0026#34;, center = TRUE) po_pca #输入数据 tsk_small = tsk(\u0026#34;penguins_simple\u0026#34;)$select(c(\u0026#34;bill_depth\u0026#34;, \u0026#34;bill_length\u0026#34;)) poin = list(tsk_small$clone()$filter(1:5)) # \u0026#34;模块训练\u0026#34; poout = po_pca$train(poin) # poin: Task in a list poout # list with a single element \u0026#39;output\u0026#39; poout$output$head() # \u0026#34;模块预测\u0026#34; tsk_onepenguin = tsk_small$clone()$filter(42) poin = list(tsk_onepenguin) # list poout = po_pca$predict(poin) poout[[1]]$data() Tips：模块的训练/预测数据格式都需要为list对象\n然后：Graph可以将多个模块连接为一个\u0026quot;图\u0026rdquo;，进行整体的操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 1) 定义两个独立模块 po_mutate = po(\u0026#34;mutate\u0026#34;, mutation = list(bill_ratio = ~bill_length / bill_depth) ) po_scale = po(\u0026#34;scale\u0026#34;) # 2) 使用 %\u0026gt;\u0026gt;% 连接成图 graph = po_mutate %\u0026gt;\u0026gt;% po_scale graph graph$plot(horizontal = TRUE) graph$pipeops # 3) 图整体的训练/预测等操作 res_train = graph$train(tsk_small) res_train tsk_onepenguin = tsk_small$clone()$filter(42) res_predict = graph$predict(tsk_onepenguin) res_predict[[1]]$head() 最常用的是将数据预处理与建模过程进行结合，再转为GraphLearner对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 1) 将模块（含learner）连接成图 lrn_logreg = lrn(\u0026#34;classif.log_reg\u0026#34;) graph = po(\u0026#34;imputesample\u0026#34;) %\u0026gt;\u0026gt;% lrn_logreg # graph = po(\u0026#34;imputesample\u0026#34;) %\u0026gt;\u0026gt;% po(\u0026#34;learner\u0026#34;, lrn_logreg) graph$plot(horizontal = TRUE) # 2) 将Graph转为GraphLearner glrn_sample = as_learner(graph) glrn_mode = as_learner(po(\u0026#34;imputemode\u0026#34;) %\u0026gt;\u0026gt;% lrn_logreg) # 3) 进行learner的常规操作，例如交叉验证、Benchmark等 design = benchmark_grid(tsk(\u0026#34;pima\u0026#34;), list(glrn_sample, glrn_mode), rsmp(\u0026#34;cv\u0026#34;, folds = 3)) bmr = benchmark(design) aggr = bmr$aggregate()[, .(learner_id, classif.ce)] aggr Tips: https://mlr3book.mlr-org.com/chapters/chapter8/non-sequential_pipelines_and_tuning.html\n（1） 上述介绍的graph，多为sequential类型（一条直线）。此外也可以通过gunion，常见non-sequential类型的Pipeline。\n（2）此外，也内置了许多预定义好的Pipeline（ppl()），共方便的使用。例如：\nppl(\u0026quot;bagging\u0026quot;, graph): 可以方便地对一种算法进行bagging集成； ppl(\u0026quot;robustify\u0026quot;): 整合了多种数据的预处理方法，从而提供适合算法的输入数据。 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/099%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr30--mlr3%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B_v2/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://mlr3book.mlr-org.com/\"\u003ehttps://mlr3book.mlr-org.com\u003c/a\u003e\u003ca href=\"https://mlr3book.mlr-org.com/\"\u003e/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(mlr3verse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etsks() \u003cspan style=\"color:#007f7f\"\u003e#预置数据任务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elrns() \u003cspan style=\"color:#007f7f\"\u003e#机器学习算法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emsrs() \u003cspan style=\"color:#007f7f\"\u003e#性能评价指标\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eas.data.table()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1-task-任务\"\u003e1. Task 任务\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://mlr3book.mlr-org.com/chapters/chapter2/data_and_basic_modeling.html\"\u003ehttps://mlr3book.mlr-org.com/chapters/chapter2/data_and_basic_modeling.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etsk()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#预置数据任务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eas.data.table(tsk()) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etsk(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mtcars\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#自定义任务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etsk_mtcars = as_task_regr(mtcars, target = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mpg\u0026#34;\u003c/span\u003e, id = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;cars\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#target参数指定标签列，id参数（可选）设置任务名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eas_task_classif()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#支持对任务对象进行数据查看、修改等操作，不一一列举，详见上述链接\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#有两点需要重点说明\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etsk_mtcars$row_ids \u003cspan style=\"color:#007f7f\"\u003e#不等于一般的行序号。一旦定义任务，row_ids就确定不变了，可以理解为row name。方便后续数据分割。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etsk_mtcars_another = tsk_mtcars$clone() \u003cspan style=\"color:#007f7f\"\u003e#想要独立的复制任务时，需要使用clone()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e对于分类任务基本类似。值得注意的是在二分类问题时，需要进一步指定阳性标签\u003c/p\u003e","title":"机器学习基于R(0)--mlr3基本流程 V2"},{"content":" 1 2 library(mlr3verse) library(tidyverse) 1、Task训练数据与目的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## 分类任务 task_classif = as_task_classif(data, target = \u0026#34;col_target\u0026#34;) #根据预测结果又可分为：twoclass二分类, multiclass多分类 ## 回归任务 task_regr = as_task_regr(data, target = \u0026#34;col_target\u0026#34;) task$ncol task$nrow task$feature_names task$feature_types task$target_names task$task_type task$data() task$col_roles 2、Learner 机器学习算法 mlr3learners包提供了基本的机器学习算法（如下图） https://github.com/mlr-org/mlr3learners\nmlr3extralearners包在上述基本算法之上提供更加全面的机器学习算法https://mlr3extralearners.mlr-org.com/articles/learners/list_learners.html\n1 2 3 4 mlr_learners$keys() ALL_mlr_lrn = as.data.table(mlr_learners) dim(ALL_mlr_lrn) # [1] 135 7 2.1 分类算法 1 2 3 4 5 6 7 8 9 10 11 12 13 ## mlr3extralearners包所支持的全部分类机器学习算法 mlr_learners$keys() %\u0026gt;% grep(\u0026#34;classif\u0026#34;, . , value=TRUE) # [1] \u0026#34;classif.AdaBoostM1\u0026#34; \u0026#34;classif.bart\u0026#34; \u0026#34;classif.C50\u0026#34; \u0026#34;classif.catboost\u0026#34; # [5] \u0026#34;classif.cforest\u0026#34; \u0026#34;classif.ctree\u0026#34; \u0026#34;classif.cv_glmnet\u0026#34; \u0026#34;classif.debug\u0026#34; # [9] \u0026#34;classif.earth\u0026#34; \u0026#34;classif.featureless\u0026#34; \u0026#34;classif.fnn\u0026#34; \u0026#34;classif.gam\u0026#34; # [13] \u0026#34;classif.gamboost\u0026#34; \u0026#34;classif.gausspr\u0026#34; \u0026#34;classif.gbm\u0026#34; \u0026#34;classif.glmboost\u0026#34; # [17] \u0026#34;classif.glmnet\u0026#34; \u0026#34;classif.IBk\u0026#34; \u0026#34;classif.J48\u0026#34; \u0026#34;classif.JRip\u0026#34; # [21] \u0026#34;classif.kknn\u0026#34; \u0026#34;classif.ksvm\u0026#34; \u0026#34;classif.lda\u0026#34; \u0026#34;classif.liblinear\u0026#34; # [25] \u0026#34;classif.lightgbm\u0026#34; \u0026#34;classif.LMT\u0026#34; \u0026#34;classif.log_reg\u0026#34; \u0026#34;classif.lssvm\u0026#34; # [29] \u0026#34;classif.mob\u0026#34; \u0026#34;classif.multinom\u0026#34; \u0026#34;classif.naive_bayes\u0026#34; \u0026#34;classif.nnet\u0026#34; # [33] \u0026#34;classif.OneR\u0026#34; \u0026#34;classif.PART\u0026#34; \u0026#34;classif.qda\u0026#34; \u0026#34;classif.randomForest\u0026#34; # [37] \u0026#34;classif.ranger\u0026#34; \u0026#34;classif.rfsrc\u0026#34; \u0026#34;classif.rpart\u0026#34; \u0026#34;classif.svm\u0026#34; # [41] \u0026#34;classif.xgboost\u0026#34; 2.2 回归算法 1 2 3 4 5 6 7 8 9 10 11 ## mlr3extralearners包所支持的全部回归机器学习算法 mlr_learners$keys() %\u0026gt;% grep(\u0026#34;regr\u0026#34;, . , value=TRUE) # [1] \u0026#34;regr.bart\u0026#34; \u0026#34;regr.catboost\u0026#34; \u0026#34;regr.cforest\u0026#34; \u0026#34;regr.ctree\u0026#34; # [5] \u0026#34;regr.cubist\u0026#34; \u0026#34;regr.cv_glmnet\u0026#34; \u0026#34;regr.debug\u0026#34; \u0026#34;regr.earth\u0026#34; # [9] \u0026#34;regr.featureless\u0026#34; \u0026#34;regr.fnn\u0026#34; \u0026#34;regr.gam\u0026#34; \u0026#34;regr.gamboost\u0026#34; # [13] \u0026#34;regr.gausspr\u0026#34; \u0026#34;regr.gbm\u0026#34; \u0026#34;regr.glm\u0026#34; \u0026#34;regr.glmboost\u0026#34; # [17] \u0026#34;regr.glmnet\u0026#34; \u0026#34;regr.IBk\u0026#34; \u0026#34;regr.kknn\u0026#34; \u0026#34;regr.km\u0026#34; # [21] \u0026#34;regr.ksvm\u0026#34; \u0026#34;regr.liblinear\u0026#34; \u0026#34;regr.lightgbm\u0026#34; \u0026#34;regr.lm\u0026#34; # [25] \u0026#34;regr.lmer\u0026#34; \u0026#34;regr.M5Rules\u0026#34; \u0026#34;regr.mars\u0026#34; \u0026#34;regr.mob\u0026#34; # [29] \u0026#34;regr.randomForest\u0026#34; \u0026#34;regr.ranger\u0026#34; \u0026#34;regr.rfsrc\u0026#34; \u0026#34;regr.rpart\u0026#34; # [33] \u0026#34;regr.rvm\u0026#34; \u0026#34;regr.svm\u0026#34; \u0026#34;regr.xgboost\u0026#34; 2.3 算法超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 learner = lrn(\u0026#34;classif.kknn\u0026#34;) learner # \u0026lt;LearnerClassifKKNN:classif.kknn\u0026gt; # * Model: - # * Parameters: k=7 # * Packages: mlr3, mlr3learners, kknn # * Predict Type: response # * Feature types: logical, integer, numeric, factor, ordered # * Properties: multiclass, twoclass ## 对于分类算法的预测结果默认的Predict Type为response ## 设置为prob，则会返回属于每一类别的概率 # learner = lrn(\u0026#34;classif.kknn\u0026#34;, predict_type = \u0026#34;prob\u0026#34;) #算法的超参数 learner$param_set # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default value # 1: k ParamInt 1 Inf Inf 7 7 # 2: distance ParamDbl 0 Inf Inf 2 # 3: kernel ParamFct NA NA 10 optimal # 4: scale ParamLgl NA NA 2 TRUE # 5: ykernel ParamUty NA NA Inf # 6: store_model ParamLgl NA NA 2 FALSE #修改设置超参数 learner$param_set$values # $k # [1] 7 learner$param_set$values$k = 3 3、交叉验证评价模型 1 2 3 4 ALL_mlr_resample = as.data.table(mlr_resamplings) mlr_resamplings$keys() # [1] \u0026#34;bootstrap\u0026#34; \u0026#34;custom\u0026#34; \u0026#34;custom_cv\u0026#34; \u0026#34;cv\u0026#34; \u0026#34;holdout\u0026#34; \u0026#34;insample\u0026#34; # [7] \u0026#34;loo\u0026#34; \u0026#34;repeated_cv\u0026#34; \u0026#34;subsampling\u0026#34; 3.1 评价指标 mlr3包提供了评价分类、回归模型的多种评价指标。\n其中对于分类模型，根据是多分类还是二分类、预测结果形式是response还是prop有不同的评价指标，注意区分。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mlr_measures$keys() ALL_mlr_msr = as.data.table(mlr_measures) head(ALL_mlr_msr) # key label task_type packages predict_type task_properties # 1: aic Akaika Information Criterion \u0026lt;NA\u0026gt; mlr3 response # 2: bic Bayesian Information Criterion \u0026lt;NA\u0026gt; mlr3 response # 3: classif.acc Classification Accuracy classif mlr3,mlr3measures response # 4: classif.auc Area Under the ROC Curve classif mlr3,mlr3measures prob twoclass # 5: classif.bacc Balanced Accuracy classif mlr3,mlr3measures response # 6: classif.bbrier Binary Brier Score classif mlr3,mlr3measures prob twoclass ALL_mlr_msr %\u0026gt;% dplyr::filter(task_type==\u0026#34;classif\u0026#34;, predict_type==\u0026#34;response\u0026#34;, task_properties!=\u0026#34;twoclass\u0026#34;) %\u0026gt;% .[,c(1,2)] # key label # 1: classif.acc Classification Accuracy # 2: classif.bacc Balanced Accuracy # 3: classif.ce Classification Error # 4: classif.costs Cost-sensitive Classification 3.2 留出法交叉验证 将数据分为训练集与测试集。首先在训练集训练模型参数，然后在测试集测试模型性能。\n（1）手动拆分数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 task = as_task_classif(diabetes, target = \u0026#34;class\u0026#34;) split = partition(task, ratio = 0.6, stratify = T) str(split) # List of 2 # $ train: int [1:88] 2 3 5 6 7 9 10 11 12 13 ... # $ test : int [1:57] 1 4 8 17 19 20 21 22 23 24 ... learner = lrn(\u0026#34;classif.kknn\u0026#34;) #先用训练集训练模型 learner$train(task, row_ids = split$train) #再在测试集评价模型 prediction = learner$predict(task, row_ids = split$test) as.data.table(prediction) %\u0026gt;% head # row_ids truth response # 1: 2 Normal Normal # 2: 5 Normal Normal # 3: 7 Normal Normal #指标评价 prediction$score(msr(\u0026#34;classif.acc\u0026#34;)) （2）使用holdout验证方法(推荐) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 task$col_roles$stratum = \u0026#34;class\u0026#34; #对于交叉验证，分训练集与测试集时根据 class列进行分层抽样 resampling = rsmp(\u0026#34;holdout\u0026#34;) print(resampling) resampling$param_set$values # $ratio # [1] 0.6666667 # 默认2/3 训练集 1/3测试集 # split = resampling$instantiate(task) # str(split$instance) # # List of 2 # # $ train: int [1:97] 1 3 4 5 6 7 12 14 15 17 ... # # $ test : int [1:48] 2 8 9 10 11 13 16 21 23 28 ... rr = resample(task, learner, resampling) str(rr) # Classes \u0026#39;ResampleResult\u0026#39;, \u0026#39;R6\u0026#39; \u0026lt;ResampleResult\u0026gt; rr$prediction() # \u0026lt;PredictionClassif\u0026gt; for 48 observations: ## 对于测试集的预测结果 rr$prediction() %\u0026gt;% as.data.table() %\u0026gt;% head # row_ids truth response # 1: 2 Normal Normal # 2: 8 Normal Normal # 3: 9 Normal Normal rr$score(msr(\u0026#34;classif.acc\u0026#34;))[,c(-1,-3,-5,-8)] # task_id learner_id resampling_id iteration classif.acc # 1: diabetes classif.kknn holdout 1 0.8541667 rr$score(msrs(c(\u0026#34;classif.acc\u0026#34;,\u0026#34;classif.bacc\u0026#34;,\u0026#34;classif.ce\u0026#34;)))[,c(-1,-3,-5,-8)] # task_id learner_id resampling_id iteration classif.acc classif.bacc classif.ce # 1: diabetes classif.kknn holdout 1 0.8541667 0.8397436 0.1458333 3.3 K折交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 resampling = rsmp(\u0026#34;cv\u0026#34;) print(resampling) resampling$param_set$values # $folds # [1] 10 # 默认10折交叉验证 rr = resample(task, learner, resampling) str(rr) # Classes \u0026#39;ResampleResult\u0026#39;, \u0026#39;R6\u0026#39; \u0026lt;ResampleResult\u0026gt; rr$prediction() # \u0026lt;PredictionClassif\u0026gt; for 145 observations: ## 对于测试集的预测结果 rr$prediction() %\u0026gt;% as.data.table() %\u0026gt;% head ##性能评价 rr$score(msr(\u0026#34;classif.acc\u0026#34;))[,c(-1,-3,-5,-8)] # task_id learner_id resampling_id iteration classif.acc # 1: diabetes classif.kknn cv 1 1.0000000 # 2: diabetes classif.kknn cv 2 0.9333333 # 3: diabetes classif.kknn cv 3 0.8000000 # 4: diabetes classif.kknn cv 4 0.8000000 # 5: diabetes classif.kknn cv 5 0.8666667 # 6: diabetes classif.kknn cv 6 0.9285714 # 7: diabetes classif.kknn cv 7 0.9285714 # 8: diabetes classif.kknn cv 8 0.9285714 # 9: diabetes classif.kknn cv 9 0.9285714 # 10: diabetes classif.kknn cv 10 0.9285714 rr$aggregate(msr(\u0026#34;classif.acc\u0026#34;)) # classif.acc # 0.9042857 rr$aggregate(msrs(c(\u0026#34;classif.acc\u0026#34;,\u0026#34;classif.bacc\u0026#34;,\u0026#34;classif.ce\u0026#34;))) # classif.acc classif.bacc classif.ce # 0.90428571 0.88711520 0.09571429 4、超参数优化 每种机器学习算法都有特定含义的超参数。\n超参数优化是指寻找一个超参数使得模型的性能相对来说由于其它超参数。\n首先需要选择候选超参数，其次需要定义模型性能的评价方式与指标。\n4.1 简单流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 task = as_task_classif(diabetes, target = \u0026#34;class\u0026#34;) learner = lrn(\u0026#34;classif.kknn\u0026#34;) ##定义候选超参数范围--3、4、5、6、7、8、9、10 search_space \u0026lt;- ps( k = p_int(lower = 3, upper = 10) ) ##定义模型评价方式--10折交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) ##定义模型评价指标--分类错误率 measure = msr(\u0026#34;classif.ce\u0026#34;) ##根据可用的预算提前终止训练 terminator = trm(\u0026#34;none\u0026#34;) instance = TuningInstanceSingleCrit$new( task = task, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;grid_search\u0026#34;) #默认resolution=10 tuner$optimize(instance) instance$archive %\u0026gt;% as.data.table() %\u0026gt;% .[,c(1,2)] # k classif.ce # 1: 4 0.10333333 # 2: 6 0.09619048 # 3: 9 0.08952381 # 4: 3 0.08952381 # 5: 10 0.10285714 # 6: 5 0.10333333 # 7: 8 0.08952381 # 8: 7 0.09619048 ##最优超参数 instance$result_learner_param_vals # $k # [1] 8 ##最优超参数的模型指标 instance$result_y # classif.ce # 0.07619048 4.2 设置超参数空间 支持4种基本超参数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 整型 p_int(lower=1,upper=10) # 小数 p_dbl(lower=0.01,upper=1) # 字符类型 p_fct(c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) # 逻辑值 p_lgl() search_space \u0026lt;- ps( hp1 = p_int(lower=1,upper=10), hp2 = p_dbl(lower=0.01,upper=1), hp3 = p_fct(c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;)) ) # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default value # 1: hp1 ParamInt 1.00 10 10 \u0026lt;NoDefault[3]\u0026gt; # 2: hp2 ParamDbl 0.01 1 Inf \u0026lt;NoDefault[3]\u0026gt; # 3: hp3 ParamFct NA NA 3 \u0026lt;NoDefault[3]\u0026gt; 如上，当设置小数类型的超参数时，默认有无限种可能。因此需要resolution参数限定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # (1)resolution 默认以上下边界值的n个等距值 # 3*3*3 = 27 generate_design_grid(search_space, resolution = 3) # \u0026lt;Design\u0026gt; with 27 rows: # hp1 hp2 hp3 # 1: 1 0.010 a # 2: 1 0.010 b # 3: 1 0.010 c # (2)param_resolutions为不同的超参数设置不同的resolution generate_design_grid(search_space, param_resolutions = c(hp1 = 5, hp2 = 3)) # \u0026lt;Design\u0026gt; with 45 rows: # hp1 hp2 hp3 # 1: 1 0.010 a # 2: 1 0.010 b # 3: 1 0.010 c # (3) trafo定义不等间距的超参数范围 search_space = ps( hp1 = p_int(-1,2, trafo = function(x) 10^x), hp2 = p_int(1,5, trafo = function(x) 2^x) ) data.table::rbindlist(generate_design_grid(search_space, param_resolutions = c(hp1 = 4, hp2 = 5))$transpose()) # hp1 hp2 # 1: 0.1 2 # 2: 0.1 4 # 3: 0.1 8 # 4: 0.1 16 # 5: 0.1 32 4.3 设置遍历方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 as.data.table(mlr_tuners)[,c(1,2)] # key label # 1: cmaes Covariance Matrix Adaptation Evolution Strategy # 2: design_points Design Points # 3: gensa Generalized Simulated Annealing # 4: grid_search Grid Search # 5: irace Iterated Racing # 6: nloptr Non-linear Optimization # 7: random_search Random Search ## grid_search 会将每一种超参数组合计算一遍 ## design_points仅遍历自定义的超参数组合范围(推荐) ##(1) 上面提到的resolution方式 search_space = ps( k = p_int(lower = 3, upper = 50) ) design = generate_design_grid(search_space, resolution = 5) design$data # k # 1: 3 # 2: 14 # 3: 26 # 4: 38 # 5: 50 tuner = tnr(\u0026#34;design_points\u0026#34;, design = design$data) tuner$optimize(instance) # 需要注意design的候选超参数必须包括在instance的search_space范围内 ##(2) 完全自定义的获选超参数 design = data.frame(k=c(3,5,7,9)) %\u0026gt;% as.data.table() tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) tuner$optimize(instance) 4.4 关于terminator 当提供的候选超参数组合过多，占据太多计算资源时，设置TuningInstanceSingleCrit$new()的terminator参数提前种终止遍历。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 as.data.table(mlr_terminators) # key label properties unit # 1: clock_time Clock Time single-crit,multi-crit seconds # 2: combo Combination single-crit,multi-crit percent # 3: evals Number of Evaluation single-crit,multi-crit evaluations # 4: none None single-crit,multi-crit percent # 5: perf_reached Performance Level single-crit percent # 6: run_time Run Time single-crit,multi-crit seconds # 7: stagnation Stagnation single-crit percent # 8: stagnation_batch Stagnation Batch single-crit percent # clock_time--在给定时间后终止 # evals--在给定的迭代量之后终止 # perf_reached--在达到特定性能后终止 # stagnation--当优化没有改善时终止 # none--不设置终止条件 5、训练最终模型与预测新数据 根据超参数优化结果，基于全部数据，选用最佳的超参数训练得到最终的机器学习模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 task = as_task_classif(diabetes, target = \u0026#34;class\u0026#34;) learner = lrn(\u0026#34;classif.kknn\u0026#34;) learner$param_set$values$k = 8 learner$train(task) #查看模型 learner$model #使用模型预测新数据 new_data = data.frame(glucose=c(200,300), insulin=c(500,1000), sspg=c(100,50)) new_data # glucose insulin sspg # 1 200 500 100 # 2 300 1000 50 learner$predict_newdata(new_data) # \u0026lt;PredictionClassif\u0026gt; for 2 observations: # row_ids truth response # 1 \u0026lt;NA\u0026gt; Overt # 2 \u0026lt;NA\u0026gt; Overt # 保存模型 saveRDS(learner, \u0026#39;diabetes_knn.rds\u0026#39;) model = readRDS(\u0026#39;diabetes_knn.rds\u0026#39;) model$predict_newdata(new_data) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/099%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr30--mlr3%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(mlr3verse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1task训练数据与目的\"\u003e1、Task训练数据与目的\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 分类任务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask_classif = as_task_classif(data, target = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;col_target\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#根据预测结果又可分为：twoclass二分类, multiclass多分类\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 回归任务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask_regr = as_task_regr(data, target = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;col_target\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$ncol\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$nrow\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$feature_names\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$feature_types\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$target_names\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$task_type\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$data()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask$col_roles\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2learner-机器学习算法\"\u003e2、Learner 机器学习算法\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ccode\u003emlr3learners\u003c/code\u003e包提供了基本的机器学习算法（如下图） \u003ca href=\"https://github.com/mlr-org/mlr3learners\"\u003ehttps://github.com/mlr-org/mlr3learners\u003c/a\u003e\u003c/p\u003e","title":"机器学习基于R(0)--mlr3基本流程"},{"content":"KNN\u0026ndash;K近邻 1、KNN的步骤 （1）计算输入数据与训练数据的距离（一般欧几里得距离）； （2）从训练集中，选取距离输入数据点最近的k个数据； （3）对于分类任务【常见】，取这k个训练数据类别的众数；对于回归任务，取这k个训练数据值的平均数。 特点 （1）如上步骤，KNN没有模型训练的过程。需要预测数据时，直接与训练数据集进行计算即可。 （2）KNN算法中最重要的超参数就是K的选择，会在下面具体操作中介绍。 （3）因为需要计算距离，所以需要进行数值变量标准化，以及类别变量转化（如果有分类变量的话）。 （4）KNN在数据量小或者维度较小的情况下效果很好，但不适用于大规模的数据（计算量大）。 关于距离，欧几里得距离，归一化（中心化）\nKNN在训练阶段不进行任何计算，直到进入预测阶段之后才进行具体的计算。这在机器学习中是比较少见的，又称为“懒惰”的学习。\n2、mlr3建模 1 2 library(mlr3verse) library(tidyverse) 2.1 糖尿病数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 data(diabetes, package = \u0026#34;mclust\u0026#34;) head(diabetes) # class glucose insulin sspg # 1 Normal 80 356 124 # 2 Normal 97 289 117 # 3 Normal 105 319 143 # 4 Normal 90 356 199 # 5 Normal 90 323 240 # 6 Normal 86 381 157 summary(diabetes) # class glucose insulin sspg # Chemical:36 Min. : 70 Min. : 45.0 Min. : 10.0 # Normal :76 1st Qu.: 90 1st Qu.: 352.0 1st Qu.:118.0 # Overt :33 Median : 97 Median : 403.0 Median :156.0 # Mean :122 Mean : 540.8 Mean :186.1 # 3rd Qu.:112 3rd Qu.: 558.0 3rd Qu.:221.0 # Max. :353 Max. :1568.0 Max. :748.0 2.2 确定预测目标与训练方法 （1）确定预测目的：根据三个指标insulin, sspg, glucose 对糖尿病状态class进行诊断 1 2 3 4 5 6 7 8 task_classif = as_task_classif(diabetes, target = \u0026#34;class\u0026#34;) task_classif$col_roles$stratum = \u0026#34;class\u0026#34; # \u0026lt;TaskClassif:diabetes\u0026gt; (145 x 4) # * Target: class # * Properties: multiclass, strata # * Features (3): # - dbl (3): glucose, insulin, sspg # * Strata: class （2）确定预测方法：使用KNN分类算法，超参数设为4 1 2 3 4 5 6 7 8 9 10 11 12 learner = lrn(\u0026#34;classif.kknn\u0026#34;, predict_type=\u0026#34;prob\u0026#34;) learner$param_set # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default value # 1: k ParamInt 1 Inf Inf 7 7 # 2: distance ParamDbl 0 Inf Inf 2 # 3: kernel ParamFct NA NA 10 optimal # 4: scale ParamLgl NA NA 2 TRUE # 5: ykernel ParamUty NA NA Inf # 6: store_model ParamLgl NA NA 2 FALSE ##如上默认会对数据进行归一化、默认k=7 2.3 模型训练、预测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ## 如下使用60%数据训练、40%数据验证 split = partition(task_classif, ratio = 0.6, stratify = T) learner$train(task_classif, row_ids = split$train) prediction = learner$predict(task_classif, row_ids = split$test) prediction$confusion # truth # response Chemical Normal Overt # Chemical 12 1 2 # Normal 2 29 0 # Overt 0 0 11 as.data.table(prediction) %\u0026gt;% head # row_ids truth response prob.Chemical prob.Normal prob.Overt # 1: 1 Normal Normal 0.00000000 1.0000000 0 # 2: 6 Normal Normal 0.00000000 1.0000000 0 # 3: 11 Normal Normal 0.00000000 1.0000000 0 # 4: 14 Normal Normal 0.01729054 0.9827095 0 # 5: 15 Normal Normal 0.00000000 1.0000000 0 # 6: 16 Normal Chemical 0.52837210 0.4716279 0 prediction$score(msr(\u0026#34;classif.acc\u0026#34;)) #classif.acc # 0.9122807 ##确定最终模型及模型预测 learner$train(task_classif) learner$model new_data = data.frame(glucose=c(200,300), insulin=c(500,1000), sspg=c(100,50)) learner$predict_newdata(new_data) 2.4 交叉验证优化超参数 交叉验证是将数据分为两部分：训练集+测试集。在训练集中训练模型，在测试集中评估模型的性能，从而避免过拟合的情况。 如果对交叉验证的结果满意，最后就可以使用所有数据（训练集+测试集）来训练模型。 有3种常见的交叉验证方法：（1）留出法(如上2.3)；（2）K-折；（3）留一法。K折交叉验证更常用，演示如下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 search_space = ps( #候选超参数 k = p_int(lower = 3, upper = 20) ) resampling = rsmp(\u0026#34;cv\u0026#34;) #交叉验证方式 measure = msr(\u0026#34;classif.acc\u0026#34;) #评价比较指标,可以多个指标 terminator = trm(\u0026#34;none\u0026#34;) #是否设置提前终止 instance = TuningInstanceSingleCrit$new( task = task_classif, learner = learner, resampling = resampling, measure = measure, terminator = terminator, search_space = search_space ) #遍历超参数方式 tuner = tnr(\u0026#34;grid_search\u0026#34;, resolution=search_space$nlevels) tuner$optimize(instance) as.data.table(instance$archive)[,c(1,2)] # k classif.acc # 1: 14 0.8858974 # 2: 6 0.9117308 # 3: 12 0.9060897 # 4: 13 0.8983974 # 5: 17 0.8715385 # 6: 7 0.9183974 # 7: 16 0.8792308 # 8: 19 0.8715385 # 9: 20 0.8715385 # 10: 4 0.9040385 # 11: 3 0.9107051 # 12: 8 0.9183974 # 13: 18 0.8715385 # 14: 5 0.9117308 # 15: 10 0.9060897 # 16: 11 0.9060897 # 17: 15 0.8792308 # 18: 9 0.9260897 instance$result_learner_param_vals #最佳超参数 # $k # [1] 9 instance$result_y #最佳超参数的CV结果 # classif.acc # 0.9260897 #使用最佳超参数训练模型 learner$param_set$values$k = instance$result_learner_param_vals$k learner$train(task_classif) learner$model ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/100%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr31--%E5%88%86%E7%B1%BB--knn/","summary":"\u003ch1 id=\"knnk近邻\"\u003eKNN\u0026ndash;K近邻\u003c/h1\u003e\n\u003ch3 id=\"1knn的步骤\"\u003e1、KNN的步骤\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e（1）计算输入数据与训练数据的距离（一般欧几里得距离）；\u003c/li\u003e\n\u003cli\u003e（2）从训练集中，选取距离输入数据点最近的k个数据；\u003c/li\u003e\n\u003cli\u003e（3）对于分类任务【常见】，取这k个训练数据类别的众数；对于回归任务，取这k个训练数据值的平均数。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://s2.loli.net/2022/03/31/CxUbFDcshLmnIoi.png\" alt=\"img\" style=\"zoom: 33%;\" /\u003e\r\n\u003ch5 id=\"特点\"\u003e特点\u003c/h5\u003e\n\u003cul\u003e\n\u003cli\u003e（1）如上步骤，KNN没有模型训练的过程。需要预测数据时，直接与训练数据集进行计算即可。\u003c/li\u003e\n\u003cli\u003e（2）KNN算法中最重要的超参数就是K的选择，会在下面具体操作中介绍。\u003c/li\u003e\n\u003cli\u003e（3）因为需要计算距离，所以需要进行数值变量标准化，以及类别变量转化（如果有分类变量的话）。\u003c/li\u003e\n\u003cli\u003e（4）KNN在数据量小或者维度较小的情况下效果很好，但不适用于大规模的数据（计算量大）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e关于距离，欧几里得距离，归一化（中心化）\u003c/p\u003e","title":"机器学习基于R包mlr3(1)--分类--KNN"},{"content":" 在R、shell，Python等进行字符串处理时，常常使用正则表达式进行高效的文本编辑。下面小结一下关于正则表达式的基础用法\n1、匹配字符（集） . : 可以匹配除换行符外的任意字符\n\\d：匹配数字\n\\s：可以匹配任意空白符\n\\b：匹配单词间的边界\n\\w : 匹配字母或数字或下划线或汉字\n\\W : 匹配任意不是字母，数字，下划线，汉字的字符\n[abc] : 匹配字母a，或者b，或者c\n[A-z] : 匹配所有大小写字母；[a-z] : 匹配小写字母；[A-Z] : 匹配小写字母\n[0-9]：匹配数字；[a-c0-5]：匹配字符abc以及数字012345\n[^abc] : 匹配非abc以外的其它字符\n^ 从字符串开头进行匹配\n$ 从字符串末尾进行匹配\n上述使用中括号[]方法可提供多个候选单字符匹配方式。如果想匹配多个候选字符串的话，可使用管道符号|。例如p(ython|erl)可匹配python或者perl。\n2、匹配次数 * : 重复零次或更多次\n+ : 重复一次或更多次\n? : 重复零次或一次\n{n} : 重复n次\n{n,} : 复n次或更多次\n{,m} ：最多匹配 m 次\n{n,m} : 重复n到m次\n（1）默认对前面的单字符进行多次匹配。当匹配字数的字数为多字符时，可使用()括起来。\n（2）上述正则表达式默认是贪婪的，即匹配所允许的、尽可能多的内容。可通过在后面加上问号将其指定为分贪婪模式，即尽可能少的重复。例如*?，+?\n正则表达式在线测试：\nhttps://c.runoob.com/front-end/854/\n","permalink":"https://lishensuo.github.io/en/posts/program/100%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在R、shell，Python等进行字符串处理时，常常使用正则表达式进行高效的文本编辑。下面小结一下关于正则表达式的基础用法\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1匹配字符集\"\u003e1、匹配字符（集）\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003e.\u003c/code\u003e  :  可以匹配除换行符外的任意字符\u003c/p\u003e","title":"正则表达式基础"},{"content":" AD星形胶质细胞与小胶质细胞的snRNA-seq数据分析\nDiverse human astrocyte and microglial transcriptional responses to Alzheimer’s pathology\nActa Neuropathologica (2022) 143:75–91\nIF=17\nhttps://doi.org/10.1007/s00401-021-02372-6\n1、测序样本 24个样本：AD与NDC的EC(entorhinal)与SSC(somatosensory) cortical region(2×2×6) 使用Immunohistochemistry量化每个样本的p-Tau与Amyloid-beta指标 本文是想研究astrocyte星形胶质细胞与microglial小胶质细胞在AD中所发挥的作用。但是The proportions of microglia and astrocytes defined by snR- NASeq of nuclei isolated from the human brain post-mortem are low and variable。 因此本文采取的方式是使用阴性选择方法去除样本中的neuron与oligodendroglia，间接富集Astro与Micro，再进行snRNA-seq测序。测序数据已经上传到GSE160936。 2、鉴定细胞类型 经数据预处理后，使用AUCell，结合细胞marker基因进行细胞类型注释，如下图所示Astro(52706)与Micro(27592)占大部分\n文章为了验证所富集的Astro与Micro不存在偏差bias，做了进一步的分析。即对上述24个样本又做了非富集的snRNAseq测序，注释出细胞类型。通过比较同一样本的富集与非富集的Astro(Micro)细胞类型的Top10% HVG高变基因的相关性，从而表示富集到Astro(Micro)不存在bias。\n24+24=48个snRNAseq，这篇文章应该花了很多钱。\n3、差异基因分析 文章并非按一般的AD/NAD差异分析，而是将基因表达与样本的p-Tau(或Amyloid-beta)指标进行回归分析，并校正性别、线粒体含量等因素。\n此时基因差异表达倍数的含义表示为pTau (or amyloid density)发生一单位的变化，基因表达差异的log2倍数（斜率）。如下例图所示\n文章提到是使用MAST包的zlm()进行的回归分析。\n按照上述思路可分别对Astro与Micro进行Amyloid-beta、pTau两个指标的回归分析，即得到4类差异基因。如下图所示在Astro中的两类差异基因火山图。从右侧的韦恩图可以得到有208个基因表达与Amyloid-beta、pTau正相关等信息。 继续以Astro差异基因为例。文章将Amyloid-beta、pTau两个指标的回归差异基因进行通路富集分析(GO/Reactome/Wikipathways)，得出结论：Increased expression of genes related to metal ion homeostasis, proteostasis, and inflammation in astrocytes with AD pathology。同法，也对Micro差异基因结果进行类似的分析。\n4、细胞通讯分析 使用CellChat包对Astro与Micro进行ligand–receptor的细胞间通讯分析。 根据配受体基因与Amyloid-beta、pTau两个指标的相关性，将CellChat结果分为3类：（1）Amyloid-beta and pTau；（2）Amyloid-beta only；（3）pTau only 如下图是Amyloid-beta and pTau的结果，可结合配受体对的功能展开分析与讨论。 5、共表达网络分析 文章使用MEGENA进行共表达网络分析，计算得到astrocytes与microglia分别在EC与SSC的module；使用SCENIC进行转录因子分析，也分别得到astrocytes与microglia分别在EC与SSC的regulons。\n然后使用AUCell包计算出每个细胞核的对应细胞类型模块的score。然后结合Aβ/pTau指标进行类似上述差异基因的回归分析。即Aβ/pTau指标变化与模块表达score是否存在相关性。根据分析结果，初步得到结论：The EC and SSC show similar co‑expression signatures。如下图展示部分module与regulon\n根据上述得到的基因模块表达特征与功能特征，分析AD GWAS基因所发挥的cell-specific功能。例如下图所示：GPNMB已知是AD的biomarker，它是Micro的amyloid-beta and pTau 正相关模块(module11)的hub gene；而且该基因在AD的Micro中也是相对高表达。 6、亚群特征分析 根据之前的细胞类型注释，将Astro与Micro进行在亚群分析。\n在亚群分析时，主要结合细胞亚群的marker基因功能，是否为上述的差异基因；亚群细胞是否特异表达/参与上述计算得到的module/regulon等，具体可参看原文献。\n我的想法：这篇单细胞文章测序样本量大，且有创新之处，即富集的Astro与Micro。而且计算差异基因方式很有新意，即进行病理指标的回归，也许更可以反映出基因表达水平与AD病理特征的关系。文章也使用多种多样的单细胞数据分析手段，例如亚群分析、细胞通讯分析、转录因子分析。总之无论是测序数据还是分析方法，都挺有借鉴价值的。\n","permalink":"https://lishensuo.github.io/en/posts/basic/100%E6%96%87%E7%8C%AE--ad%E6%98%9F%E5%BD%A2%E8%83%B6%E8%B4%A8%E7%BB%86%E8%83%9E%E4%B8%8E%E5%B0%8F%E8%83%B6%E8%B4%A8%E7%BB%86%E8%83%9E%E7%9A%84%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eAD星形胶质细胞与小胶质细胞的snRNA-seq数据分析\u003c/p\u003e\n\u003cp\u003eDiverse human astrocyte and microglial transcriptional responses to Alzheimer’s pathology\u003c/p\u003e\n\u003cp\u003eActa Neuropathologica (2022) 143:75–91\u003c/p\u003e\n\u003cp\u003eIF=17\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://doi.org/10.1007/s00401-021-02372-6\"\u003ehttps://doi.org/10.1007/s00401-021-02372-6\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220414201022304.png\" alt=\"文章分析思路\"  /\u003e\r\n\u003c/p\u003e\n\u003ch3 id=\"1测序样本\"\u003e1、测序样本\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e24个样本：AD与NDC的EC(entorhinal)与SSC(somatosensory) cortical region(2×2×6)\u003c/li\u003e\n\u003cli\u003e使用Immunohistochemistry量化每个样本的p-Tau与Amyloid-beta指标\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220414173342171.png\" alt=\"image-20220414173342171\"  /\u003e\r\n\u003c/p\u003e","title":"文献--AD星形胶质与小胶质细胞的单细胞数据分析"},{"content":" 博客网页：https://lishensuo.github.io/ github：https://github.com/lishensuo/lishensuo.github.io 1、安装hugo （1）首先下载安装包https://github.com/gohugoio/hugo/releases\n我的是window电脑，其次需选择extended版本 选择的是 hugo_extended_0.96.0_Windows-64bit.zip （2）解压、点击安装后，将hugo路径添加到环境变量。\n（3）在任意文件进入cmd模式，输入hugo version。如果正常返回版本信息，表明已经成功安装。\n1 2 hugo version #hugo v0.96.0-2fd4a7d3d6845e75f8b8ae3a2a7bd91438967bbb+extended windows/amd64 BuildDate=2022-03-26T09:15:58Z VendorInfo=gohugoio hugo的操作都是命令行式。之后的cmd操作都是基于gitbash操作模式下，可自行安装探索一下。下述的演示在 C:\\Users\\xiaoxin\\Desktop\\test目录下\n2、新建站点 在test文件夹，进入gitbash的cmd模式 1 2 3 4 5 6 7 8 9 10 11 12 hugo new site myblog #会新建一个 myblog 的文件夹 ls ./myblog # archetypes/ config.toml content/ data/ # layouts/ static/ themes/ ##我目前了解如下 #config.toml 进行参数配置，与之后的theme相关 #content 之后博客(.md)的文件都储存在这里 #layout 可个性化修改博客的展示细节，需要懂网络架构知识 #static 储存一些静态文件，比如本地图片，插入到博客中 #themes 主题，接下来会介绍 关于配置文件toml，类似于yaml。不同人有不同的偏好，对于hugo，优先toml；但也支持yaml。\n3、下载主题 有多种hugo主题可供下载：https://themes.gohugo.io/ 我这里选择的是PaperMod主题，比较简约，适合记笔记。https://adityatelange.github.io/hugo-PaperMod/ 这个博客是对于PaperMod主题的一个示例展示。 点击具体每一种主题，都能找到提供的下载方式。最简单的是git下载到上面提到的theme文件夹\n1 2 3 4 5 6 7 cd ./myblog git clone https://github.com/adityatelange/hugo-PaperMod themes/PaperMod ls ./themes # PaperMod/ ls ./themes/PaperMod/ # LICENSE README.md assets/ go.mod i18n/ images/ layouts/ theme.toml 4、修改配置 按照我参考的示例博客比较推荐yaml，因此这里删除原来的config.toml，改为config.yaml。\n然后进行博客主题的配置：一些基本配置在所有主题中都一样；但也有一些参数是每个主题的自定义的。\n通用配置参数查询：https://gohugo.io/getting-started/configuration/ PaperMod自定义参数查询：https://adityatelange.github.io/hugo-PaperMod/posts/papermod/papermod-features/ 示例配置：https://www.sulvblog.cn/posts/blog/build_hugo/#4%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 暂时先配置最重要参数：theme\n1 2 3 4 5 cat config.yaml # baseURL: https://www.*****.cn #绑定的域名 # languageCode: zh-cn # en-us # title: My first Blog # theme: PaperMod # 主题名字，和themes文件夹下的一致 5、新建笔记 接下来就是写一些博客笔记，需要有头文件的markdown格式。 头文件可以设置每篇博客的属性，例如标题，日期，作者等。 详见https://gohugo.io/content-management/front-matter/ 其中draft表示该博客是否为草稿。如果是的话，之后不会被展示。 可通过下述命令，创建博客（也可以完全自己建一个）。然后按照markdown的格式增添内容即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 hugo new posts/fisrt-blog.md cat ./content/posts/fisrt-blog.md # --- # title: \u0026#34;Fisrt Blog\u0026#34; # date: 2022-04-16T11:47:19+08:00 # draft: true # --- #示例fisrt-blog.md cat ./content/posts/fisrt-blog.md # --- # title: \u0026#34;Fisrt Blog\u0026#34; # date: 2022-04-16T11:47:19+08:00 # draft: false # --- # # this is a blog # welcome to my blog # blalalalalala........ # 这里插入一张网上的图片 # ![](https://s2.loli.net/2022/04/10/A5Th7VIcXHxY9Rj.png) # End 6、测试博客 根据下述命令提示，进入本地连接http://localhost:1313/ 查看博客的样式 1 2 3 4 5 6 7 8 9 hugo server # Built in 48 ms # Watching for changes in C:\\Users\\xiaoxin\\Desktop\\test\\myblog\\{archetypes,content,data,layouts,static,themes} # Watching for config changes in C:\\Users\\xiaoxin\\Desktop\\test\\myblog\\config.yaml # Environment: \u0026#34;development\u0026#34; # Serving pages from memory # Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender # Web Server is available at //localhost:1313/ (bind address 127.0.0.1) # Press Ctrl+C to stop 博客的首页主题样式 一篇博客的内容 7、绑定域名 之后就是将博客内容上传到网上，有很多方式。我之前是上传到github，简单介绍如下； （1）需要先在个人的github账号中创建github.io仓库，参考一张别人的图。\n（2）将当前博客内容编译为html，放到public文件夹\n1 2 3 4 5 6 7 8 9 10 11 #首先需要记得修改 config.yaml文件的 baseURL参数设置为你想要绑定的域名 ## baseURL: https://www.username.github.io ##然后使用hugo编译 hugo # hugo -F --cleanDestinationDir # 加了上述参数表示表示每次生成的public都是全新的，会覆盖原来的。 ls ./public # 404.html assets/ categories/ index.html index.xml # page/ posts/ sitemap.xml tags/ （3）使用git将public文件夹的内容上传到github.io仓库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 cd public/ #(1)第一次上传 git init git add . #添加当前路径的所有文件 git commit -m \u0026#39;create blog\u0026#39; git remote add origin https://github.com/username/username.github.io.git #根据gitbash提示操作 git push -u origin master ##如果push失败，比如time out...可尝试下面的命令 git config --global http.sslVerify \u0026#34;false\u0026#34; git config --global --unset http.proxy git config --global --unset https.proxy # https://blog.csdn.net/ESCM_/article/details/124498679?spm=1001.2101.3001.6650.1\u0026amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124498679-blog-117925677.pc_relevant_default\u0026amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-124498679-blog-117925677.pc_relevant_default\u0026amp;utm_relevant_index=2 #(2)之后再修改、更新博客 git add . git commit -m \u0026#39;add blogs\u0026#39; git push -u origin master 如上操作后，理论上再访问 https://username.github.io/ 就是一个博客的页面了。当第一次操作时总会遇到各种各样的问题，比如我自己。就是不断尝试、报错、再修改过程。\n8、个性化修改 启用PaperMod主题自带的Search功能：搜索博客 （1）先在content文件夹新建search.md\n1 2 3 4 --- title: \u0026#34;Search\u0026#34; layout: \u0026#34;search\u0026#34; --- （2）然后在config.yaml文件修改相关参数\n1 2 3 4 5 #https://www.sulvblog.cn/posts/blog/build_hugo/#4%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6 - identifier: search name: 搜索 url: search weight: 80 启用PaperMod主题的Archive栏：记录所有博客的发表时间 ·（1）先在content文件夹新建archive.md\n1 2 3 4 5 --- title: \u0026#34;Archive\u0026#34; layout: \u0026#34;archives\u0026#34; summary: \u0026#34;archives\u0026#34; --- （2）然后在config.yaml文件修改相关参数\n1 2 3 4 - identifier: archives name: 归档 url: archives/ weight: 41 此外参考https://www.sulvblog.cn/posts/blog/博客，修改了博客文章的侧边栏TOC目录悬浮窗，标签云展示、SEO优化等；\n参考卜蒜子http://ibruce.info/2015/04/04/busuanzi/，为网站添加了访问量记录。因为很多是细节的修改，就不细述了。\n","permalink":"https://lishensuo.github.io/en/posts/program/101hugo+github%E6%90%AD%E5%BB%BA%E6%88%91%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","summary":"\u003cul\u003e\n\u003cli\u003e博客网页：https://lishensuo.github.io/\u003c/li\u003e\n\u003cli\u003egithub：https://github.com/lishensuo/lishensuo.github.io\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1安装hugo\"\u003e1、安装hugo\u003c/h1\u003e\n\u003cp\u003e（1）首先下载安装包https://github.com/gohugoio/hugo/releases\u003c/p\u003e","title":"hugo+github搭建我的个人博客"},{"content":" Spatial Transcriptomics and In Situ Sequencing to Study Alzheimer\u0026rsquo;s Disease\nCell. 2020 Aug 20 | IF=41.5\nDOI: 10.1016/j.cell.2020.06.038\n这是关于AD的第一次空间转录组学的相关研究。如下为该文章中涉及空间转录组分析部分的简要笔记，具体可参看原文。\n1、实验设计 小鼠模型 AD模型小鼠3月龄、18月龄各2只；6月龄、12月龄各1只；共8只。正常对照小鼠同。\n每次取小鼠脑组织3张连续的切片，中间一张用于空间转录组测序、两旁的切片用于免疫组化检测。\n对于3月龄、18月龄小鼠，分别取左右脑的冠状切片；对于6月龄、12月龄的小鼠仅取右脑的冠状切面。所以共有20组切片数据。\n空间转录组测序 对于每张切片，测序单位为直径100um的TD(tissue domain，可以理解为spot)；平均每个TD测得6578个基因表达信息。\n平均每张切片有500个TD，总共10327个TD，共覆盖了14个脑组织区域\n免疫组化实验 对于每张切片，共检测4种指标：\nAβ load (6E10 staining)\nreactive astrocytes (GFAP)\npresence of neurons (NeuN)\nnuclei (DAPI)\n由于3张连续切片，每张切片10um厚度，因此文章认为可将对应TD的基因表达与免疫组化指标关联起来。\n其中对于关键的Aβ load指标，根据TD区域内的荧光信号标准差计算每个TD的Aβ index。\n从文章给出数据来看，正常组小鼠的Aβ index均为0。而在AD模型小鼠中，从3月到18月，Aβ index不断增高。\n其中在18月龄的AD模型鼠中平均每张切片有1565个 Aβ plaques，平面面积在 78.5–4,950 um2\n2、两次差异分析 使用EdgeR包拟合GLM分布，然后进行quasi-likelihood F-test差异分析\n2.1 genotype model 3月龄的AD模型鼠与正常对照鼠的TD差异基因 18月龄的AD模型鼠与正常对照鼠的TD差异基因 2.2 Aβ model 研究不同TD的基因表达变化与Aβ index的关系\n计算得到的LFC表示每增加一单位的Aβ index，TD中基因表达的变化Log倍数。\n同样也是分为3月与18月龄小鼠单独分析。\n2.3 通路关联分析 将上述两类差异基因综合考虑(genotype model与Aβ model)，可以反应基因不同层次的表达依赖关系。可进一步将差异基因关联到通路，将通路组成基因的两种平均LFC作为该通路的差异表达特征。\n如下左图可以看出Antigen processing, chemotaxis, lysosomal degradation,以及 inﬂammation通路在18月龄鼠的结果中都具有正的LFC值。\n而有意思的是Myelin通路在3月与18月的Aβ model 具有相反的变化，即随着Aβ index的增多，3月龄中该通路正相关；18月龄中该通路负相关。\n3、WGCNA分析 对全部的10327个TD做WGCNA分析\n选取了Top50方差(高变)基因，分为了12个模块。每个模块的组成基因见附件Table S3。\nWGCNA包分析的相关指标：(1)Soft power 14；(2)deepSplit = 4; (3)signed network\n（1）根据模块的组成基因与cell signature基因集的超几何检验分析，判断每个模块的细胞类型特征。\n如下图，是去除了没有任何显著富集或者组成基因数过多的模块。\n其中热图中有颜色的第一个格子的上面数字表示交集基因数；中间数字表示预期交集基因数；下面数字表示矫正后的P值\nDAM : disease-associated microglia; A1：inflammatoryastrocytes\n（2）取模块组成基因的两类平均LFC，作为该通路的差异表达特征。\n如下图所示，Purple与Red的模块差异变化特征最明显。根据\n之后主要关注了与Aβ最相关的red与purple模块。\n（3）对red与purple模块内基因的通路富集分析表明\nred模块与myelin category相关，在AD的早期活跃、晚期不活跃。 purple模块与chemotaxis, lysosomal degradation, inflammation, antigen processing categories相关。 4、PIG Module Purple module，57个基因组成，Plaque-induced genes(PIGs)\n（1）PIGs模块的两类LFC在18月份都为最大值\n如下图A：在genotype model比较中，随着年龄的增长，AD中PIGs基因相较于对照组高表达的程度越明显。 如下图B：在Aβ model中，相较于AD组3月龄鼠，18月龄数各个区域的PIGs基因表达水平都显著增高。 （2）通过GO通路富集分析，发现PIGs基因与经典补体级联、以及与补体级联相关的endocytosis、lysosomal degradation、antigen processing and presentation、immune response、oxidation-reduction富集相关\n（3）通过cellular signature的基因集富集分析，发现PIGs基因与DAM/RAM小胶质细胞、A1星形胶质细胞相关。\n如下图中标红的为PIGs的hub基因。\nactivated microglia (disease-associated microglia [DAM] or activated response microglia [ARM]\ninflammatory astrocytes (A1)\n（3）进一步对PIGs基因，根据正常对照小鼠中的TD做WGCNA分析，分为3个sub module\ngreen cluster组成基因与astroglia-expressed genes相关\nblue/orange cluster与microglia相关\n根据每个TD的Aβ index大小将AD对照组中的TD分为从高到低分为Q1、Q2、Q3、Q4共4组。\n总体来看从对照组到AD组，从Q4到Q1，不同sub module之间的共表达程度增强。具体增强的基因对涉及哪些含义文章有详细论述。\n5、OLIG module Red module，165个基因组成，主要与oligodendrocytes相关(OLIGs)\n（1）通路富集分析表明主要与myelin sheath髓鞘相关；cellular signature富集分析、hub基因表明均与少突胶质细胞相关\n（2）基因差异分析表明\n相比正常小鼠，AD鼠中OLGs基因均显著高表达； 在3月AD鼠中，随着Aβ index增大，OLGs基因表达增多；在18月AD鼠中，随着Aβ index增大，OLGs基因表达反而降低。 在18月中，Genotype正相关，而Abeta负相关\n（3）文章进一步发现其实OLGs基因表达在不同年龄段存在不同的脑区域特异性。\n在3月AD鼠的FB、TH、HY区域中的TD与Aβ index呈正相关，而ENTI等区域与之呈负相关 在18月AD鼠中AUDs呈负相关，ENTI等区域则呈正相关 （4）按照Aβ index不断增大的Q4-Q1区域划分，比较不同区域的OLGs基因表达水平。\n在3月时，观察搭配在Q4~Q2时(mild Aβ index)，随着Aβ的增大，OLGs基因高表达；但是在最高的Q1，则低表达。 在18月份，OLGs基因普遍低表达，可能是由于Aβ index普遍增强相关。 6、结论 plaque-induced genes (PIGs) 模块表征了多种细胞类型的共表达网络关系，尤其是在AD晚期阶段参与了 complement system, oxidative stress, lysosomes, and inflammation等过程。\noligodendrocytegenes(OLIGs)模块基因参与AD早期病变过程，其中主要涉及myelin髓鞘相关通路。\n7、数据获取 将文章中所涉及到的所有图片整理、汇总到https://alzmap.org/网站中，可供交互式浏览。\n将空间转录组基因表达测序数据上传到GSE152506中\n文章中所有的图片、测序数据都可在https://www.synapse.org/#!Synapse:syn22153884/wiki/603937中获取。\n","permalink":"https://lishensuo.github.io/en/posts/basic/101%E6%96%87%E7%8C%AE--ad%E5%B0%8F%E9%BC%A0%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eSpatial Transcriptomics and In Situ Sequencing to Study Alzheimer\u0026rsquo;s Disease\u003c/p\u003e\n\u003cp\u003eCell. 2020 Aug 20 | IF=41.5\u003c/p\u003e\n\u003cp\u003eDOI: 10.1016/j.cell.2020.06.038\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220610155820989.png\" alt=\"image-20220610155820989\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这是关于AD的第一次空间转录组学的相关研究。如下为该文章中\u003cstrong\u003e涉及空间转录组分析部分\u003c/strong\u003e的简要笔记，具体可参看原文。\u003c/p\u003e","title":"文献--AD小鼠空间转录组数据分析"},{"content":"1、逻辑回归的算法理解 逻辑回归 = 线性回归 + Sigmoid函数 与线性回归相同的是同样需要学习变量的权重(系数)与偏置(截距)；与线性回归不同的是逻辑回归的输出必须限制在0和1之间，即解释为概率（二分类）。 一般来说：P\u0026gt;0.5,分类为1，P\u0026lt;0.5分类为0 2、mlr建模 1 2 library(mlr3verse) library(tidyverse) 2.1 泰坦尼克号示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 data(titanic_train, package = \u0026#34;titanic\u0026#34;) titanicSub = titanic_train[,c(\u0026#34;Survived\u0026#34;,\u0026#34;Sex\u0026#34;,\u0026#34;Pclass\u0026#34;, \u0026#34;Age\u0026#34;,\u0026#34;Fare\u0026#34;,\u0026#34;SibSp\u0026#34;,\u0026#34;Parch\u0026#34;)] summary(titanicSub) # Survived Sex Pclass Age Fare SibSp Parch # Min. :0.0000 Length:891 Min. :1.000 Min. : 0.42 Min. : 0.00 Min. :0.000 Min. :0.0000 # 1st Qu.:0.0000 Class :character 1st Qu.:2.000 1st Qu.:20.12 1st Qu.: 7.91 1st Qu.:0.000 1st Qu.:0.0000 # Median :0.0000 Mode :character Median :3.000 Median :28.00 Median : 14.45 Median :0.000 Median :0.0000 # Mean :0.3838 Mean :2.309 Mean :29.70 Mean : 32.20 Mean :0.523 Mean :0.3816 # 3rd Qu.:1.0000 3rd Qu.:3.000 3rd Qu.:38.00 3rd Qu.: 31.00 3rd Qu.:1.000 3rd Qu.:0.0000 # Max. :1.0000 Max. :3.000 Max. :80.00 Max. :512.33 Max. :8.000 Max. :6.0000 # 第一列：生存与否0/1 # 第二列：性别 # 第三列：头等舱、二等舱、三等舱 1/2/3 # 第四列：年龄 # 第五列：票价 # 第六列：兄弟姐妹+配偶人数 # 第七列：父母和孩子总人数 数据预处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #删除含有缺失值的行 titanicSub = na.omit(titanicSub) #对于分类变量因子化 titanicSub$Survived = factor(titanicSub$Survived) titanicSub$Sex = factor(titanicSub$Sex) titanicSub$Pclass = factor(titanicSub$Pclass) head(titanicSub) # Survived Sex Pclass Age Fare SibSp Parch # 1 0 male 3 22 7.2500 1 0 # 2 1 female 1 38 71.2833 1 0 # 3 1 female 3 26 7.9250 0 0 # 4 1 female 1 35 53.1000 1 0 # 5 0 male 3 35 8.0500 0 0 # 7 0 male 1 54 51.8625 0 0 2.2 确定预测目标与训练方法 （1）确定预测目的：根据5个变量Pclass，Sex ，Age，Fare 以及FamSize预测是否会生存 1 2 3 task_classif = as_task_classif(titanicSub, target = \u0026#34;Survived\u0026#34;) task_classif$col_roles$stratum = \u0026#34;Survived\u0026#34; task_classif$col_roles （2）确定预测方法：使用逻辑回归算法，无可调超参数 1 2 3 #设置predict.type参数为\u0026#34;prob\u0026#34;，则预测输出不仅仅是分类变量，还有概率值 learner = lrn(\u0026#34;classif.log_reg\u0026#34;, predict_type = \u0026#34;prob\u0026#34;) learner$param_set 2.3 模型训练、预测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #使用训练集训练模型 split = partition(task_classif, ratio = 0.6, stratify = T) learner$train(task_classif, row_ids = split$train) #使用测试集预测模型 prediction = learner$predict(task_classif, row_ids = split$test) prediction$confusion # truth # response 0 1 # 0 138 36 # 1 32 80 as.data.table(prediction) %\u0026gt;% head # row_ids truth response prob.0 prob.1 # 1: 1 0 0 0.9240149 0.07598510 # 2: 17 0 1 0.4895318 0.51046818 # 3: 28 0 0 0.7318201 0.26817990 ##对于二分类问题可以查看AUC值等指标 prediction$score(msrs(c(\u0026#34;classif.acc\u0026#34;,\u0026#34;classif.auc\u0026#34;))) #classif.acc classif.auc # 0.7622378 0.8245436 autoplot(prediction, type = \u0026#34;roc\u0026#34;) 理解模型的系数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 learner$model$coefficients # (Intercept) Age Fare Parch Pclass2 Pclass3 Sexmale SibSp # -4.776866553 0.055414781 -0.001065547 -0.024478041 1.081818050 2.554926703 3.027348240 0.481382618 #指数转换 exp(cbind(Odds_Ratio = learner$model$coefficients)) # Odds_Ratio # (Intercept) 0.008422349 # Age 1.056978939 # Fare 0.998935021 # Parch 0.975819117 # Pclass2 2.950037995 # Pclass3 12.870356259 # Sexmale 20.642421208 # SibSp 1.618310361 #对于连续变量的解释：例如Age：表示其它变量不变，每Age增长1岁，生存率降低1% #对于分类变量的解释，需要有参照：例如Sexmale：表示男性的生存率仅为女性的20% 模型预测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 data(titanic_test, package = \u0026#34;titanic\u0026#34;) #无生存信息 titanicNewClean = titanic_test[,c(\u0026#34;Sex\u0026#34;,\u0026#34;Pclass\u0026#34;, \u0026#34;Age\u0026#34;,\u0026#34;Fare\u0026#34;,\u0026#34;SibSp\u0026#34;,\u0026#34;Parch\u0026#34;)] titanicNewClean = na.omit(titanicNewClean) titanicNewClean$Sex = factor(titanicNewClean$Sex) titanicNewClean$Pclass = factor(titanicNewClean$Pclass) learner$predict_newdata(titanicNewClean) # \u0026lt;PredictionClassif\u0026gt; for 331 observations: # row_ids truth response prob.0 prob.1 # 1 \u0026lt;NA\u0026gt; 0 0.92308299 0.07691701 # 2 \u0026lt;NA\u0026gt; 0 0.61325375 0.38674625 # 3 \u0026lt;NA\u0026gt; 0 0.92323646 0.07676354 # --- # 329 \u0026lt;NA\u0026gt; 1 0.35533044 0.64466956 # 330 \u0026lt;NA\u0026gt; 1 0.04779831 0.95220169 # 331 \u0026lt;NA\u0026gt; 0 0.93389621 0.06610379 2.4 交叉验证模型 10次重复的5折交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 resampling = rsmp(\u0026#34;repeated_cv\u0026#34;) resampling$param_set$values$repeats = 5 resampling$param_set$values$folds = 5 rr$prediction() rr$score(msr(\u0026#34;classif.auc\u0026#34;))[,c(-1,-3,-5,-8)] # task_id learner_id resampling_id iteration classif.auc # 1: titanicSub classif.log_reg repeated_cv 1 0.8539554 # 2: titanicSub classif.log_reg repeated_cv 2 0.8385396 # 3: titanicSub classif.log_reg repeated_cv 3 0.8392495 # 4: titanicSub classif.log_reg repeated_cv 4 0.8678499 # 5: titanicSub classif.log_reg repeated_cv 5 0.8663793 # 6: titanicSub classif.log_reg repeated_cv 6 0.8709939 # 7: titanicSub classif.log_reg repeated_cv 7 0.8847870 # 8: titanicSub classif.log_reg repeated_cv 8 0.8330629 # 9: titanicSub classif.log_reg repeated_cv 9 0.8314402 # 10: titanicSub classif.log_reg repeated_cv 10 0.8467775 # 11: titanicSub classif.log_reg repeated_cv 11 0.7981744 # 12: titanicSub classif.log_reg repeated_cv 12 0.8308316 # 13: titanicSub classif.log_reg repeated_cv 13 0.8947262 # 14: titanicSub classif.log_reg repeated_cv 14 0.8658215 # 15: titanicSub classif.log_reg repeated_cv 15 0.8723317 # 16: titanicSub classif.log_reg repeated_cv 16 0.8669371 # 17: titanicSub classif.log_reg repeated_cv 17 0.8277890 # 18: titanicSub classif.log_reg repeated_cv 18 0.8336714 # 19: titanicSub classif.log_reg repeated_cv 19 0.8377282 # 20: titanicSub classif.log_reg repeated_cv 20 0.8955255 # 21: titanicSub classif.log_reg repeated_cv 21 0.8566937 # 22: titanicSub classif.log_reg repeated_cv 22 0.8292089 # 23: titanicSub classif.log_reg repeated_cv 23 0.9101420 # 24: titanicSub classif.log_reg repeated_cv 24 0.7997972 # 25: titanicSub classif.log_reg repeated_cv 25 0.8844417 rr$aggregate(msrs(c(\u0026#34;classif.auc\u0026#34;,\u0026#34;classif.prauc\u0026#34;))) # classif.auc classif.prauc # 0.8534742 0.8735251 autoplot(rr, type = \u0026#34;prc\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/101%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr32--%E5%88%86%E7%B1%BB--%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/","summary":"\u003ch2 id=\"1逻辑回归的算法理解\"\u003e1、逻辑回归的算法理解\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e逻辑回归 = 线性回归 + \u003cstrong\u003eSigmoid\u003c/strong\u003e函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2022/04/01/WFdNuX6vo42BGY3.png\" alt=\"img\"  /\u003e\r\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e与线性回归相同的是同样需要学习变量的权重(系数)与偏置(截距)；与线性回归不同的是逻辑回归的输出必须限制在0和1之间，即解释为概率（二分类）。\u003c/li\u003e\n\u003cli\u003e一般来说：P\u0026gt;0.5,分类为1，P\u0026lt;0.5分类为0\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://s2.loli.net/2022/04/01/z4TEL26t3AvlPQi.png\" alt=\"image-20220401171633594\" style=\"zoom: 33%;\" /\u003e\r\n\u003ch2 id=\"2mlr建模\"\u003e2、mlr建模\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(mlr3verse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"21-泰坦尼克号示例数据\"\u003e2.1 泰坦尼克号示例数据\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(titanic_train, package = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;titanic\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicSub = titanic_train[,c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Survived\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Sex\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Pclass\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Age\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Fare\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SibSp\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Parch\u0026#34;\u003c/span\u003e)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esummary(titanicSub)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Survived          Sex                Pclass           Age             Fare            SibSp           Parch       \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Min.   :0.0000   Length:891         Min.   :1.000   Min.   : 0.42   Min.   :  0.00   Min.   :0.000   Min.   :0.0000  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1st Qu.:0.0000   Class :character   1st Qu.:2.000   1st Qu.:20.12   1st Qu.:  7.91   1st Qu.:0.000   1st Qu.:0.0000  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Median :0.0000   Mode  :character   Median :3.000   Median :28.00   Median : 14.45   Median :0.000   Median :0.0000  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Mean   :0.3838                      Mean   :2.309   Mean   :29.70   Mean   : 32.20   Mean   :0.523   Mean   :0.3816  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3rd Qu.:1.0000                      3rd Qu.:3.000   3rd Qu.:38.00   3rd Qu.: 31.00   3rd Qu.:1.000   3rd Qu.:0.0000  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Max.   :1.0000                      Max.   :3.000   Max.   :80.00   Max.   :512.33   Max.   :8.000   Max.   :6.0000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第一列：生存与否0/1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第二列：性别\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第三列：头等舱、二等舱、三等舱 1/2/3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第四列：年龄\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第五列：票价\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第六列：兄弟姐妹+配偶人数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第七列：父母和孩子总人数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e数据预处理\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#删除含有缺失值的行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicSub = na.omit(titanicSub)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#对于分类变量因子化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicSub$Survived = factor(titanicSub$Survived)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicSub$Sex = factor(titanicSub$Sex)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicSub$Pclass = factor(titanicSub$Pclass)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(titanicSub)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Survived    Sex Pclass Age    Fare SibSp Parch\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1        0   male      3  22  7.2500     1     0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2        1 female      1  38 71.2833     1     0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3        1 female      3  26  7.9250     0     0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4        1 female      1  35 53.1000     1     0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5        0   male      3  35  8.0500     0     0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 7        0   male      1  54 51.8625     0     0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"22-确定预测目标与训练方法\"\u003e2.2 确定预测目标与训练方法\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e（1）确定预测目的：根据5个变量Pclass，Sex ，Age，Fare 以及FamSize预测是否会生存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask_classif = as_task_classif(titanicSub, target = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Survived\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask_classif$col_roles$stratum = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Survived\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask_classif$col_roles\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e（2）确定预测方法：使用逻辑回归算法，无可调超参数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#设置predict.type参数为\u0026#34;prob\u0026#34;，则预测输出不仅仅是分类变量，还有概率值\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner = lrn(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;classif.log_reg\u0026#34;\u003c/span\u003e, predict_type = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;prob\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$param_set\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"23-模型训练预测\"\u003e2.3 模型训练、预测\u003c/h4\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#使用训练集训练模型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esplit = partition(task_classif, ratio = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.6\u003c/span\u003e, stratify = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eT\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$train(task_classif, row_ids = split$train)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#使用测试集预测模型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprediction = learner$predict(task_classif, row_ids = split$test)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprediction$confusion\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         truth\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# response   0   1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        0 138  36\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        1  32  80\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eas.data.table(prediction) %\u0026gt;% head\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    row_ids truth response    prob.0     prob.1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1:       1     0        0 0.9240149 0.07598510\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2:      17     0        1 0.4895318 0.51046818\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3:      28     0        0 0.7318201 0.26817990\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##对于二分类问题可以查看AUC值等指标\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprediction$score(msrs(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;classif.acc\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;classif.auc\u0026#34;\u003c/span\u003e)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#classif.acc classif.auc \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  0.7622378   0.8245436 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eautoplot(prediction, type = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;roc\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220701132152087.png\" alt=\"image-20220701132152087\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e理解模型的系数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$model$coefficients\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (Intercept)          Age         Fare        Parch      Pclass2      Pclass3      Sexmale        SibSp \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -4.776866553  0.055414781 -0.001065547 -0.024478041  1.081818050  2.554926703  3.027348240  0.481382618 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#指数转换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexp(cbind(Odds_Ratio = learner$model$coefficients))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#               Odds_Ratio\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (Intercept)  0.008422349\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Age          1.056978939\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Fare         0.998935021\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Parch        0.975819117\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Pclass2      2.950037995\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Pclass3     12.870356259\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Sexmale     20.642421208\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# SibSp        1.618310361\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#对于连续变量的解释：例如Age：表示其它变量不变，每Age增长1岁，生存率降低1%\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#对于分类变量的解释，需要有参照：例如Sexmale：表示男性的生存率仅为女性的20%\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e模型预测\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(titanic_test, package = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;titanic\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#无生存信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicNewClean = titanic_test[,c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Sex\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Pclass\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                  \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Age\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Fare\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SibSp\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Parch\u0026#34;\u003c/span\u003e)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicNewClean = na.omit(titanicNewClean)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicNewClean$Sex = factor(titanicNewClean$Sex)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etitanicNewClean$Pclass = factor(titanicNewClean$Pclass)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$predict_newdata(titanicNewClean)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u0026lt;PredictionClassif\u0026gt; for 331 observations:\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     row_ids truth response     prob.0     prob.1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#           1  \u0026lt;NA\u0026gt;        0 0.92308299 0.07691701\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#           2  \u0026lt;NA\u0026gt;        0 0.61325375 0.38674625\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#           3  \u0026lt;NA\u0026gt;        0 0.92323646 0.07676354\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ---                                             \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         329  \u0026lt;NA\u0026gt;        1 0.35533044 0.64466956\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         330  \u0026lt;NA\u0026gt;        1 0.04779831 0.95220169\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         331  \u0026lt;NA\u0026gt;        0 0.93389621 0.06610379\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"24-交叉验证模型\"\u003e2.4 交叉验证模型\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e10次重复的5折交叉验证\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresampling = rsmp(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;repeated_cv\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresampling$param_set$values$repeats = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresampling$param_set$values$folds = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003err$prediction()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003err$score(msr(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;classif.auc\u0026#34;\u003c/span\u003e))[,c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-5\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-8\u003c/span\u003e)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        task_id      learner_id resampling_id iteration classif.auc\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  1: titanicSub classif.log_reg   repeated_cv         1   0.8539554\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  2: titanicSub classif.log_reg   repeated_cv         2   0.8385396\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  3: titanicSub classif.log_reg   repeated_cv         3   0.8392495\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  4: titanicSub classif.log_reg   repeated_cv         4   0.8678499\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  5: titanicSub classif.log_reg   repeated_cv         5   0.8663793\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  6: titanicSub classif.log_reg   repeated_cv         6   0.8709939\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  7: titanicSub classif.log_reg   repeated_cv         7   0.8847870\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  8: titanicSub classif.log_reg   repeated_cv         8   0.8330629\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  9: titanicSub classif.log_reg   repeated_cv         9   0.8314402\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 10: titanicSub classif.log_reg   repeated_cv        10   0.8467775\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 11: titanicSub classif.log_reg   repeated_cv        11   0.7981744\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 12: titanicSub classif.log_reg   repeated_cv        12   0.8308316\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 13: titanicSub classif.log_reg   repeated_cv        13   0.8947262\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 14: titanicSub classif.log_reg   repeated_cv        14   0.8658215\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 15: titanicSub classif.log_reg   repeated_cv        15   0.8723317\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 16: titanicSub classif.log_reg   repeated_cv        16   0.8669371\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 17: titanicSub classif.log_reg   repeated_cv        17   0.8277890\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 18: titanicSub classif.log_reg   repeated_cv        18   0.8336714\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 19: titanicSub classif.log_reg   repeated_cv        19   0.8377282\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 20: titanicSub classif.log_reg   repeated_cv        20   0.8955255\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 21: titanicSub classif.log_reg   repeated_cv        21   0.8566937\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 22: titanicSub classif.log_reg   repeated_cv        22   0.8292089\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 23: titanicSub classif.log_reg   repeated_cv        23   0.9101420\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 24: titanicSub classif.log_reg   repeated_cv        24   0.7997972\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 25: titanicSub classif.log_reg   repeated_cv        25   0.8844417\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003err$aggregate(msrs(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;classif.auc\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;classif.prauc\u0026#34;\u003c/span\u003e)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# classif.auc classif.prauc \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   0.8534742     0.8735251 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eautoplot(rr, type = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;prc\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220701134748760.png\" alt=\"image-20220701134748760\" style=\"zoom:50%;\" /\u003e","title":"机器学习基于R包mlr3(2)--分类--逻辑回归.md"},{"content":" Expression of Immune Related Genes and Possible Regulatory Mechanisms in Alzheimer’s Disease\ndoi: 10.3389/fimmu.2021.768966\n05 November 2021\n核心结论：AD病人外周血中的NK细胞浸润到大脑中参与AD病理过程的免疫反应。\n1、公共数据 1.1 测序数据集 （1）GSE181279：AD+Control的外周血 scRNA-seq\n（2）GSE33000： AD+Control的脑组织芯片microaray测序\n（3）GSE142853：小鼠AD造模的brain sorted NK cell scRNAseq\n1.2 其它数据集： （1）ImmPort数据库收集的免疫相关基因 https://www.immport.org/shared/home\n（2）HumanTFDB注释的转录调节因子列表 http:// bioinfo.life.hust.edu.cn/HumanTFDB/#!/\n（3）STRING蛋白质相互作用数据\n2、主要分析步骤 1、PBMC单细胞数据分析 （1）质控降维\u0026mdash;聚类分群\u0026ndash;marker注释细胞 （2） AD的NK细胞比例(5%)显著低于NC细胞类型(21%) （3） 所有cluster的DEGs中有212个是IRGs(Immune Related Genes)，使用AUCell发现NK与DC细胞类型对于上述IRGs相对表达活性最高。 （4）对于NK细胞相对于其它细胞类型的差异基因进行GO/KEGG通路富集分析，发现与主要与抗原加工、免疫反应等相关。 2、结合AD brain的Bulk测序数据分析 （1） 差异分析得到AD brain中的5339个上调基因与5542个下调基因，富集分析得到与1.4中类似的富集结果。 （2）NK DEG与Brian DEG的交集结果中有70个是IRGs，17个是TF，根据PPI关系，其中STATS3是hub TF （3）结合3XTg-AD 小鼠的brain sorted NK scRNA-seq进一步确认AD brain中的NK cell(cluster6)多于NC。 小体会：这是一篇纯数据挖掘的文章，主要研究AD相关的NK细胞浸润。这篇是去年11月发表的，主要用到了单细胞测序数据，感觉分析方法都比较基础。这篇文章出彩的地方应该是所关注的问题比较有新意，之前研究相对比较少。\n","permalink":"https://lishensuo.github.io/en/posts/basic/102%E6%96%87%E7%8C%AE--%E6%8C%96%E6%8E%98ad%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90nk%E6%B5%B8%E6%B6%A6/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eExpression of Immune Related Genes and Possible Regulatory Mechanisms in Alzheimer’s Disease\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003edoi: 10.3389/fimmu.2021.768966\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e05 November 2021\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e核心结论：AD病人外周血中的NK细胞浸润到大脑中参与AD病理过程的免疫反应。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20221030104346017.png\" alt=\"image-20221030104346017\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1公共数据\"\u003e1、公共数据\u003c/h2\u003e\n\u003ch3 id=\"11-测序数据集\"\u003e1.1 测序数据集\u003c/h3\u003e\n\u003cp\u003e（1）GSE181279：AD+Control的外周血 scRNA-seq\u003c/p\u003e","title":"文献--挖掘AD单细胞数据分析NK浸润"},{"content":"1、概述 LDA与QDA可以简单理解为有监督的降维，将多个预测变量信息压缩成少数（类别数-1）新的预测变量。\n每一个新的预测变量称之为判别函数，由所有原始变量的线性组合。\n所以对类别区分贡献大的变量具有绝对值最大的系数（也称为标准判别函数系数），而包含很少或者不包含类别分离信息的变量的系数约等于0\n在分类时，表现最好的是第一个判别函数，其次是第二个\u0026hellip;以此类推。\nLDA(Linear discriminant analysis)，为线性判别分析，可以学习不同类别之间的线性的决策边界；\nQDA(Quadratic discriminant analysis)，为二次判别分析，可以学习不同类别之间的曲线的决策边界\nLDA与QDA均假设所有预测变量呈正态分布；LAD则进一步假设数据集里每一个类别，预测变量之间具有相同的协方差；而QDA没有这一假设。\n协方差可以简单理解为变量之间的相关性。\n在分类预测时，使用贝叶斯准则预测属于每一种类别的概率，选择概率最大的类别。 2、mlr建模 1 2 library(mlr3verse) library(tidyverse) 2.1 葡萄酒数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # install.packages(\u0026#34;HDclassif\u0026#34;) data(wine, package = \u0026#34;HDclassif\u0026#34;) wineTib = wine # set meaning colnames colnames(wineTib) = c(\u0026#34;Class\u0026#34;, \u0026#34;Alco\u0026#34;, \u0026#34;Malic\u0026#34;, \u0026#34;Ash\u0026#34;, \u0026#34;Alk\u0026#34;, \u0026#34;Mag\u0026#34;, \u0026#34;Phe\u0026#34;, \u0026#34;Flav\u0026#34;, \u0026#34;Non_flav\u0026#34;, \u0026#34;Proan\u0026#34;, \u0026#34;Col\u0026#34;, \u0026#34;Hue\u0026#34;, \u0026#34;OD\u0026#34;, \u0026#34;Prol\u0026#34;) # set class column as factor wineTib$Class \u0026lt;- as.factor(wineTib$Class) head(wineTib) # Class Alco Malic Ash Alk Mag Phe Flav Non_flav Proan Col Hue OD Prol # 1 1 14.23 1.71 2.43 15.6 127 2.80 3.06 0.28 2.29 5.64 1.04 3.92 1065 # 2 1 13.20 1.78 2.14 11.2 100 2.65 2.76 0.26 1.28 4.38 1.05 3.40 1050 # 3 1 13.16 2.36 2.67 18.6 101 2.80 3.24 0.30 2.81 5.68 1.03 3.17 1185 # 4 1 14.37 1.95 2.50 16.8 113 3.85 3.49 0.24 2.18 7.80 0.86 3.45 1480 # 5 1 13.24 2.59 2.87 21.0 118 2.80 2.69 0.39 1.82 4.32 1.04 2.93 735 # 6 1 14.20 1.76 2.45 15.2 112 3.27 3.39 0.34 1.97 6.75 1.05 2.85 1450 ##第一列是分类信息，其余是化合物的成分含量信息 2.2 确定预测目标与训练方法 1 2 3 4 5 6 7 8 9 10 #根据化合物不同成分含量信息预测葡萄酒类别 task_classif = as_task_classif(wineTib, target = \u0026#34;Class\u0026#34;) task_classif$col_roles$stratum = \u0026#34;Class\u0026#34; #（1）使用LDA方法 learner_lda = lrn(\u0026#34;classif.lda\u0026#34;, predict_type = \u0026#34;prob\u0026#34;) learner_lda$param_set #（2）使用QDA方法 learner_qda = lrn(\u0026#34;classif.qda\u0026#34;, predict_type = \u0026#34;prob\u0026#34;) learner_qda$param_set 2.3 模型训练、预测 （1）LDA模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ## 如下使用60%数据训练、40%数据验证 split = partition(task_classif, ratio = 0.6, stratify = T) learner_lda$train(task_classif, row_ids = split$train) ##查看每个判别函数的原始预测变量的系数 learner_lda$model$scaling %\u0026gt;% head() # LD1 LD2 # Alco -0.180181333 0.635051170 # Alk 0.165256494 -0.068839677 # Ash -0.873518671 1.616419123 # Col 0.387893842 0.430329481 # Flav -2.612862657 -0.534148633 # Hue 0.557758645 -0.757887040 prediction = learner_lda$predict(task_classif, row_ids = split$test) prediction$confusion # response 1 2 3 # 1 24 0 0 # 2 0 27 0 # 3 0 1 19 ##查看每个样本在新的预测变量(判别函数)的值 predict(learner_lda$model, task_classif$data())$x %\u0026gt;% head # LD1 LD2 # 1 -4.741629 2.136846 # 2 -4.106043 1.788338 # 3 -3.746176 1.510430 # 4 -3.588112 4.769435 # 5 -1.482220 0.614548 # 6 -3.944203 4.090119 ##可视化 ldaPreds \u0026lt;- predict(learner_lda$model, task_classif$data())$x wineTib %\u0026gt;% mutate(LD1 = ldaPreds[, 1], LD2 = ldaPreds[, 2]) %\u0026gt;% ggplot(aes(LD1, LD2, col = Class)) + geom_point() + stat_ellipse() + theme_bw() 交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 resampling = rsmp(\u0026#34;cv\u0026#34;) rr = resample(task_classif, learner_lda, resampling) rr$prediction() rr$score(msr(\u0026#34;classif.acc\u0026#34;))[,c(-1,-3,-5,-8)] # task_id learner_id resampling_id iteration classif.acc # 1: wineTib classif.lda cv 1 0.9473684 # 2: wineTib classif.lda cv 2 0.9444444 # 3: wineTib classif.lda cv 3 1.0000000 # 4: wineTib classif.lda cv 4 1.0000000 # 5: wineTib classif.lda cv 5 0.9444444 # 6: wineTib classif.lda cv 6 1.0000000 # 7: wineTib classif.lda cv 7 1.0000000 # 8: wineTib classif.lda cv 8 1.0000000 # 9: wineTib classif.lda cv 9 1.0000000 # 10: wineTib classif.lda cv 10 1.0000000 rr$aggregate(msr(\u0026#34;classif.acc\u0026#34;)) #classif.acc # 0.9836257 （2）QDA 1 2 3 4 5 6 7 8 9 10 11 ## 如下使用60%数据训练、40%数据验证 split = partition(task_classif, ratio = 0.6, stratify = T) learner_qda$train(task_classif, row_ids = split$train) prediction = learner_qda$predict(task_classif, row_ids = split$test) prediction$confusion # truth # response 1 2 3 # 1 24 0 0 # 2 0 28 0 # 3 0 0 19 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) rr = resample(task_classif, learner_qda, resampling) rr$prediction() rr$score(msr(\u0026#34;classif.acc\u0026#34;))[,c(-1,-3,-5,-8)] # task_id learner_id resampling_id iteration classif.acc # 1: wineTib classif.qda cv 1 1.0000000 # 2: wineTib classif.qda cv 2 1.0000000 # 3: wineTib classif.qda cv 3 1.0000000 # 4: wineTib classif.qda cv 4 1.0000000 # 5: wineTib classif.qda cv 5 1.0000000 # 6: wineTib classif.qda cv 6 0.9444444 # 7: wineTib classif.qda cv 7 0.9444444 # 8: wineTib classif.qda cv 8 1.0000000 # 9: wineTib classif.qda cv 9 1.0000000 # 10: wineTib classif.qda cv 10 1.0000000 rr$aggregate(msr(\u0026#34;classif.acc\u0026#34;)) #classif.acc # 0.9888889 注意到LDA与QDA的预测结果并不一致。下面通过交叉验证哪一种模型的性能更好一些。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/102%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr33--%E5%88%86%E7%B1%BB--lda%E4%B8%8Eqda/","summary":"\u003ch2 id=\"1概述\"\u003e1、概述\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eLDA与QDA可以简单理解为\u003cstrong\u003e有监督的降维\u003c/strong\u003e，将多个预测变量信息压缩成少数（类别数-1）新的预测变量。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e每一个新的预测变量称之为判别函数，由所有原始变量的线性组合。\u003c/p\u003e","title":"机器学习基于R包mlr3(3)--分类--LDA与QDA"},{"content":" 文章题目：M2-like tumor-associated macrophage-related biomarkers to construct a novel prognostic signature, reveal the immune landscape, and screen drugs in hepatocellular carcinoma\n发表期刊及日期：Front Immunol， 2022 Sep 13\nDOI：10.3389/fimmu.2022.994019\n简单背景（wikipedia）\u0026mdash;\n巨噬细胞极化是一个巨噬细胞对应微环境讯号所表现不同程式功能的过程[1]。巨噬细胞极化有多种功能型态，他们可以完全极化成特定的表型，像是M1（典型活化巨噬细胞）或是M2（另类活化巨噬细胞）。\n肿瘤相关巨噬细胞：（Tumor-associated macrophages，TAMs）是属于巨噬细胞细胞系的一种细胞，发现于肿瘤组织附近。TAM由淋巴循环中的单核细胞或组织中残留的巨噬细胞衍生而来，是浸润许多种肿瘤基质的白细胞的主要类型。\n本文提及的M2-like tumor-associated macrophage如下简称为M2-TAM\n0、文章小结 这篇文章的分析主要分为两个部分（1）结合传统转录组数据与单细胞转录组数据鉴定出与HCC M2-TAM高度相关的signature；（2）使用多种分析角度signature的重要意义，包括预后准确性分析、泛化能力验证、指导药物发现等方面。\n这应该算是一篇常规的肿瘤预后类生信挖掘文章了\u0026mdash;以signature为核心，桥接前（发现）后（论证）两大步骤，辅助以多种多样的分析策略。在本文中，单细胞数据仅出现在发现signature的步骤中。\n1、简要步骤 结合如下流程图，文章分析步骤主要包括如下4步： （1）由Bulk RNA-seq的WGCNA M2相关模块与scRNA-seq的TAM细胞类型marker得到M2-TAM genes；\n（2）从M2-TAM genes使用LASSO鉴定出最相关的signatures，并以通路富集分析、病人分群的生存分析等\n（3）基于signatures计算的risk score将病人分为high/low group，进行生存分析、ROC分析，并以测试集验证；\n（4）risk score与免疫浸润、免疫基因等的关系，并为相关药物发现提供参考依据。\n2、结果概述 2.1 Bulk RNAseq数据发现M2相关模块 （1）对来自TCGA的HCC转录组数据分别进行WGCNA分析与CIBERSORTx免疫浸润分析\n（2）寻找与样本M2细胞比例最相关的基因模块→包含405个基因的red module(correlation = 0.32, P\u0026lt;0.001)\n2.2 单细胞数据鉴定TAM的高表达基因 （1）使用GEO收集的HCC单细胞表达数据，进行质控、细胞类型注释(singleR)\n（2）共得到包括TAM在内的3类免疫细胞，并分析得到TAM的2047个高表达基因\n2.3 筛选得到最终的HCC相关M2-TAM基因 （1）取2.1得到的M2模块与2.2得到的TAM高表达基因交集，共127个基因；\n（2）先后进行单变量Cox回归与LASSO分析，得到8个基因与HCC预后高度相关的signature；\n（3）对signature组成基因进行GO通路注释；\n（4）使用signature组成基因对于病人进行分群，并以生存分析。\n2.4 基于signature计算风险因子及衍生分析 （1）使用上述8基因的lasso系数为每个病人计算风险因子，并分为高、低风险组；\n（2）结合病人的风险因子分数与高低风险组信息，进行生存分析、ROC分析、诺模图分析、GSEA分析等\n（3）在收集自GEO的HCC转录组数据验证上述signature的预后泛化能力\n2.4 基于risk score的深入分析 （1）risk score在不同临床特征亚类样本内部的可区分性（是否均显示high risk, worse prognostic）\n（2）risk score与样本的免疫浸润、免疫检查点相关基因表达程度的相关性（如下图）\n（3）risk score与样本预测的化合物IC50(“pRRophitic” package)用于发现相关药物（化合物是否对于high risk具有更低的IC50）\n","permalink":"https://lishensuo.github.io/en/posts/basic/103%E6%96%87%E7%8C%AE--%E5%9F%BA%E4%BA%8E%E8%82%9D%E7%BB%86%E8%83%9E%E7%99%8Cm2%E6%A0%B7%E8%82%BF%E7%98%A4%E5%B7%A8%E5%99%AC%E7%BB%86%E8%83%9E%E5%BB%BA%E7%AB%8B%E9%A2%84%E5%90%8E%E6%A8%A1%E5%9E%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003e文章题目：M2-like tumor-associated macrophage-related biomarkers to construct a novel prognostic signature, reveal the immune landscape, and screen drugs in hepatocellular carcinoma\u003c/p\u003e\n\u003cp\u003e发表期刊及日期：Front Immunol， 2022 Sep 13\u003c/p\u003e\n\u003cp\u003eDOI：\u003ca href=\"https://doi.org/10.3389%2Ffimmu.2022.994019\"\u003e10.3389/fimmu.2022.994019\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20221113200742170.png\" alt=\"image-20221113200742170\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e简单背景（wikipedia）\u0026mdash;\u003c/p\u003e","title":"文献--基于肝细胞癌M2样肿瘤巨噬细胞建立预后模型"},{"content":"1、朴素贝叶斯简介 Naive Bayes：预测样本属于每一类别的概率，取概率最高的类别。包含四个概念：后验概率、似然、先验概率以及全概率。如下图示例 例(1)：某人的某病诊断结果为阳性，那他实际患该病的概率是多少？\n可以视为1个预测变量（诊断结果），一个二分类标签（是否患病）。\n下图中关于似然的解释应改为：如果实际患病，那么诊断为阳的概率。\n（1）如果有多个预测变量，就单独估计每个预测变量的似然，并将它们相乘。这样做的前提是预测变量间是独立的。 （2）对于分类型预测变量可以直接计算概率；对于连续型预测变量，假设每类样本该预测变量均呈正态分布，计算概率密度，视为概率。 （3）由于全概率难以获得，且计算不同类别的后验概率，全概率值为常数，所以可以直接计算分子的乘积，进而比较不同类别的后验概率，进行分类。 例(2)：某班评三好学生，有10%名额，有三项指标。判断某同学是否有希望获奖。\n可以视为3个预测变量的二分类分体\n2、mlr建模 1 2 library(mlr3verse) library(tidyverse) 2.1 众议员投票情况示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data(HouseVotes84, package = \u0026#34;mlbench\u0026#34;) HouseVotes84_sub = na.omit(HouseVotes84) str(HouseVotes84_sub) # \u0026#39;data.frame\u0026#39;:\t232 obs. of 17 variables: # $ Class: Factor w/ 2 levels \u0026#34;democrat\u0026#34;,\u0026#34;republican\u0026#34;: 1 2 1 1 1 1 1 2 1 2 ... # $ V1 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 1 2 2 2 2 2 2 2 1 ... # $ V2 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 2 2 2 1 1 2 1 2 2 ... # $ V3 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 1 2 2 2 2 2 1 2 1 ... # $ V4 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 2 1 1 1 1 1 2 1 2 ... # $ V5 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 2 1 1 1 1 1 2 1 2 ... # $ V6 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 2 1 1 1 1 1 1 1 2 ... # $ V7 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 1 2 2 2 2 2 2 2 1 ... # $ V8 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 1 2 2 2 2 2 2 2 1 ... # $ V9 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 1 2 2 2 2 2 2 2 1 ... # $ V10 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 1 1 1 2 1 1 1 1 1 ... # $ V11 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 1 2 1 1 2 2 1 2 1 ... # $ V12 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 1 2 1 1 1 1 1 2 1 2 ... # $ V13 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 2 1 1 1 1 1 2 1 2 ... # $ V14 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 2 1 1 1 1 1 2 1 2 ... # $ V15 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 1 2 2 2 2 2 1 2 1 ... # $ V16 : Factor w/ 2 levels \u0026#34;n\u0026#34;,\u0026#34;y\u0026#34;: 2 2 2 2 2 2 2 2 2 1 ... # - attr(*, \u0026#34;na.action\u0026#34;)= \u0026#39;omit\u0026#39; Named int [1:203] 1 2 3 4 5 7 8 10 11 12 ... # ..- attr(*, \u0026#34;names\u0026#34;)= chr [1:203] \u0026#34;1\u0026#34; \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; ... #第一列：众议员的派别 #第2到17列：16次投票的表决情况 2.2 确定预测目标与训练方法 根据16次的表决情况，判断某议员是共和党还是民主党 1 2 task_classif = as_task_classif(HouseVotes84_sub, target = \u0026#34;Class\u0026#34;) task_classif$col_roles$stratum = \u0026#34;Class\u0026#34; 使用朴素贝叶斯的分类学习器 1 2 learner = lrn(\u0026#34;classif.naive_bayes\u0026#34;, predict_type=\u0026#34;prob\u0026#34;) learner$param_set #无可调超参数 2.3 模型训练、预测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## 如下使用60%数据训练、40%数据验证 split = partition(task_classif, ratio = 0.6, stratify = T) learner$train(task_classif, row_ids = split$train) prediction = learner$predict(task_classif, row_ids = split$test) prediction$confusion # truth # response democrat republican # democrat 44 2 # republican 6 41 as.data.table(prediction) %\u0026gt;% head # row_ids truth response prob.democrat prob.republican # 1: 3 democrat democrat 1 2.762994e-11 # 2: 6 democrat democrat 1 2.849338e-11 # 3: 9 democrat democrat 1 2.762994e-11 prediction$score(msr(\u0026#34;classif.auc\u0026#34;)) #classif.auc # 0.9683721 2.4 交叉验证模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #10折交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) rr = resample(task_classif, learner, resampling) rr$prediction() # \u0026lt;PredictionClassif\u0026gt; for 232 observations: # row_ids truth response prob.democrat prob.republican # 48 democrat democrat 1.000000e+00 7.489670e-12 # 50 democrat democrat 9.985252e-01 1.474753e-03 # 55 democrat democrat 1.000000e+00 6.878633e-11 # --- # 144 republican republican 9.822952e-08 9.999999e-01 # 190 republican democrat 9.999878e-01 1.215106e-05 # 200 republican republican 8.595926e-08 9.999999e-01 rr$aggregate(msr(\u0026#34;classif.auc\u0026#34;)) # classif.auc # 0.9709499 rr$aggregate(msr(\u0026#34;classif.auc\u0026#34;)) # classif.auc # 0.9709499 autoplot(rr, type = \u0026#34;roc\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/103%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr34--%E5%88%86%E7%B1%BB--%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/","summary":"\u003ch2 id=\"1朴素贝叶斯简介\"\u003e1、朴素贝叶斯简介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eNaive Bayes：预测样本属于每一类别的概率，取概率最高的类别。包含四个概念：后验概率、似然、先验概率以及全概率。如下图示例\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://s2.loli.net/2022/04/06/3JAyBg5qnEXjSso.png\" alt=\"image-20220406104834011\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e例(1)：某人的某病诊断结果为阳性，那他实际患该病的概率是多少？\u003c/strong\u003e\u003c/p\u003e","title":"机器学习基于R包mlr3(4)--分类--朴素贝叶斯"},{"content":" 文章题目：Revealing the Key MSCs Niches and Pathogenic Genes in Influencing CEP Homeostasis: A Conjoint Analysis of Single-Cell and WGCNA\n杂志/日期：Front. Immunol. / 27 June 2022\nDOI：10.3389/fimmu.2022.933721\n由于对这一领域不甚了解，主要记录、学习文章的分析方法与技术路线。简单记录相关术语如下：\nDegenerative disc disease (DDD)：椎间盘退行性疾病 nucleus pulposus (NP)：髓核 annulus fibrosis (AF)：纤维环 cartilage endplate (CEP)：软骨终板 mesenchymal stem cells：间充质干细胞 0、文献概要 如标题所述，这篇文献旨在分析软骨终板细胞中与DDD发生相关的关键基因与细胞类型。主要分为两个方面：首先通过WGCNA分析得到DDD相关的模块，围绕模块展开系列分析。其次结合单细胞数据以MSC细胞类型为核心展开多角度分析。\n1、流程总结 结合自己的理解对文献的结果部分进行总结，具体流程与图表可参看原文\n1.1 WGCNA部分 （1）从GSE153761的6个样本中（3疾病3对照）进行常规WGCNA流程分析，发现与疾病分组的核心模块，进行通路分析；\n（2）通过STRING的PPI进一步鉴定出两个子模块与5个hub基因，进行通路分析，\n（3）由于上述富集通路涉及免疫信号，文章进一步补充了CIBERSORT免疫浸润分析，发现显著差异的免疫细胞\n这一步部分的核心结论是发现了5个与degenerative CEP高度相关的5个signature gene。\n1.2 scRNA-seq部分 （1）从GSE160756收集人椎间盘CEP部位的26209个细胞测序数据，进行质控、去批次、降维、分群、细胞类型注释、亚群分析等常规步骤。共得到13个cluster，6大类细胞；其中对于mesenchymal chondrocytes得到3个亚群。\n（2）对6类细胞分析得到的marker gene进行功能注释分析；\n（3）对mesenchymal chondrocytes的3个亚型细胞命运(cytoTRACE)与轨迹分析(Monocle2)\n（4）使用CellPhoneDB对CEP的6类细胞（包括mesenchymal chondrocytes的3个亚型）进行配受体对水平的细胞通讯分析。\n这一部分的核心结论是发现了mesenchymal chondrocytes中的两个亚群在CEP稳态或恶化过程中起到关键的作用。\n个人体会：研究从两个方面独立展开，分别研究与DDD相关的基因（模块）与细胞类型。分析手段多种多样，绘图可视化值得学习，但研究的样本量较小，也并没有将两方面很好地结合起来。如文章所说，可能这方面的数据本身就偏少，也是首次在该领域进行类似的数据挖掘。\n","permalink":"https://lishensuo.github.io/en/posts/basic/104%E6%96%87%E7%8C%AE--%E6%A4%8E%E9%97%B4%E7%9B%98%E9%80%80%E8%A1%8C%E6%80%A7%E7%96%BE%E7%97%85bulk%E4%B8%8Escrna-seq%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e文章题目\u003c/strong\u003e：Revealing the Key MSCs Niches and Pathogenic Genes in Influencing CEP Homeostasis: A Conjoint Analysis of Single-Cell and WGCNA\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e杂志/日期\u003c/strong\u003e：Front. Immunol.  / 27 June 2022\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：10.3389/fimmu.2022.933721\u003c/p\u003e","title":"文献--椎间盘退行性疾病bulk与scRNA-seq数据挖掘"},{"content":"1、SVM相关 基本概念 超平面：比数据集的变量少一个维度的平面，也称为决策边界； 间隔：（对于硬间隔）训练数据中最接近决策边界的样本点与决策边界之间的距离； 支持向量：（对于硬间隔）接触间隔边界的数据样本，它们是支持超平面的位置。（对于软间隔）间隔内的样本点也属于支持向量，因为移动它们也会改变超平面的位置。 如下图所示，SVM算法将寻找一个最优的线性超平面进行分类。\n超参数类别 1、间隔与cost超参数 （1）如上图所示的间隔内没有样本点，是比较理想的超平面。\n（2）当类别并不能完美的分隔开，如果一味追求上述的结果，可能造成过拟合，甚至无法找到超平面。\n（3）cost(C)超参数用于表示对间隔内存在的样本的惩罚。cost越大，代表越不允许间隔内存在样本，容易过拟合；cost越小，代表间隔内的样本数据就越多，容易欠拟合。\n2、核函数与kernel超参数 如果当前维度的数据找不到一个合适线性超平面，SVM通过核方法会引入一个新的维度，使变得线性可分。\n（1）将线性不可分的数据（n个特征向量，n维）增加一个维度（enlarged kernel-induced feature space），从而成为线性可分数据（n+1）维；\n（2）在n+1 维的空间里确定合适的决策边界（线性）；然后投射到原来n维空间中，即得到我们真正需要的决策平面（非线性）\n常见的核方法有：多项式核函数、高斯径向基核函数、sigmoid核函数等\n3、gamma超参数 gamma超参数越大，表明单个样本对决策边界的位置影响越大，导致决策边界越复杂，越容易过拟合。 SVM的分类性能确实比其他算法好，但同时SVM模型的计算开销也大，而且有多个超参数需要优化。所以训练处性能最优的SVM模型需要花费相当长的时间。\n2、mlr建模 1 2 library(mlr3verse) library(tidyverse) 2.1 垃圾邮件特征数据 1 2 3 4 5 6 7 8 data(spam, package = \u0026#34;kernlab\u0026#34;) dim(spam) # [1] 4601 58 ##最后一列为标签列：是否为垃圾数据 ##前面的57列均为邮件的特征数据，且都是数值型。 table(spam$type) # nonspam spam # 2788 1813 Note: （1）SVM算法不能处理分类预测变量。（2）SVM算法对不同尺度的变量很敏感，需要归一化处理\n2.2 确定预测目标与训练方法 根据57列的邮件特征数据预测该邮件是否为垃圾邮件 1 2 task_classif = as_task_classif(spam, target = \u0026#34;type\u0026#34;) task_classif$col_roles$stratum = \u0026#34;type\u0026#34; 使用SVM分类算法，并设置候选超参数范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 learner = lrn(\u0026#34;classif.svm\u0026#34;, predict_type=\u0026#34;prob\u0026#34;) learner$param_set # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default parents value # 1: cachesize ParamDbl -Inf Inf Inf 40 # 2: class.weights ParamUty NA NA Inf # 3: coef0 ParamDbl -Inf Inf Inf 0 kernel # 4: cost ParamDbl 0 Inf Inf 1 type # 5: cross ParamInt 0 Inf Inf 0 # 6: decision.values ParamLgl NA NA 2 FALSE # 7: degree ParamInt 1 Inf Inf 3 kernel # 8: epsilon ParamDbl 0 Inf Inf \u0026lt;NoDefault[3]\u0026gt; # 9: fitted ParamLgl NA NA 2 TRUE # 10: gamma ParamDbl 0 Inf Inf \u0026lt;NoDefault[3]\u0026gt; kernel # 11: kernel ParamFct NA NA 4 radial # 12: nu ParamDbl -Inf Inf Inf 0.5 type # 13: scale ParamUty NA NA Inf TRUE # 14: shrinking ParamLgl NA NA 2 TRUE # 15: tolerance ParamDbl 0 Inf Inf 0.001 # 16: type ParamFct NA NA 2 C-classification ##(3)自定义超参数空间 search_space = ps( kernel = p_fct(c(\u0026#34;polynomial\u0026#34;, \u0026#34;radial\u0026#34;, \u0026#34;sigmoid\u0026#34;)), degree = p_int(lower=1,upper=3), cost = p_dbl(lower=0.1,upper=10), gamma = p_dbl(lower=0.1,upper=10), type = p_fct(\u0026#34;C-classification\u0026#34;) ) design = expand.grid(kernel=c(\u0026#34;polynomial\u0026#34;, \u0026#34;radial\u0026#34;, \u0026#34;sigmoid\u0026#34;), degree=1:2, cost=c(0.1, 1), gamma = c(0.1, 5), type = \u0026#34;C-classification\u0026#34;, stringsAsFactors = FALSE) %\u0026gt;% as.data.table() design$degree[design$kernel!=\u0026#34;polynomial\u0026#34;]=NA design = dplyr::distinct(design) # 共 16种超参数组合 Note:\n（1）对于SVM的kernel的linear等价于degree为1的polynomial。\n（2）degree参数只适用于 kernel = “polynomial”\n（3）设置cost参数，需要同时指定type = \u0026ldquo;C-classification\u0026rdquo;\n1 2 3 4 5 6 ##5折交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) resampling$param_set$values$folds=5 ##AUC模型评价指标 measure = msr(\u0026#34;classif.auc\u0026#34;) 2.3 模型训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ##创建实例 instance = TuningInstanceSingleCrit$new( task = task_classif, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) ##超参数优化 tuner$optimize(instance) as.data.table(instance$archive)[,1:6] # kernel degree cost gamma type classif.auc # 1: polynomial 1 0.1 0.1 C-classification 0.9657043 # 2: radial NA 0.1 0.1 C-classification 0.9484079 # 3: sigmoid NA 0.1 0.1 C-classification 0.9031887 # 4: polynomial 2 0.1 0.1 C-classification 0.9558911 # 5: polynomial 1 1.0 0.1 C-classification 0.9708120 # 6: radial NA 1.0 0.1 C-classification 0.9652989 # 7: sigmoid NA 1.0 0.1 C-classification 0.8696353 # 8: polynomial 2 1.0 0.1 C-classification 0.9567801 # 9: polynomial 1 0.1 5.0 C-classification 0.9717243 # 10: radial NA 0.1 5.0 C-classification 0.9006810 # 11: sigmoid NA 0.1 5.0 C-classification 0.8527801 # 12: polynomial 2 0.1 5.0 C-classification 0.9233039 # 13: polynomial 1 1.0 5.0 C-classification 0.9721692 # 14: radial NA 1.0 5.0 C-classification 0.9029953 # 15: sigmoid NA 1.0 5.0 C-classification 0.8445696 # 16: polynomial 2 1.0 5.0 C-classification 0.9236220 instance$result_learner_param_vals #最佳超参数 # $kernel # [1] \u0026#34;polynomial\u0026#34; # $degree # [1] 1 # $cost # [1] 1 # $gamma # [1] 5 # $type # [1] \u0026#34;C-classification\u0026#34; instance$result_y #最佳超参数的CV结果 # classif.auc # 0.9721692 2.4 使用最佳超参数训练最终模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 learner$param_set$values = instance$result_learner_param_vals learner$train(task_classif) learner$model # Call: # svm.default(x = data, y = task$truth(), type = \u0026#34;C-classification\u0026#34;, kernel = \u0026#34;polynomial\u0026#34;, # degree = 1L, gamma = 5, cost = 1, probability = (self$predict_type == \u0026#34;prob\u0026#34;)) # Parameters: # SVM-Type: C-classification # SVM-Kernel: polynomial # cost: 1 # degree: 1 # coef.0: 0 # Number of Support Vectors: 930 ##交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) rr = resample(task_classif, learner, resampling) rr$aggregate(msrs(c(\u0026#34;classif.auc\u0026#34;,\u0026#34;classif.fbeta\u0026#34;))) # classif.auc classif.fbeta # 0.9719342 0.9416119 autoplot(rr, type = \u0026#34;roc\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/104%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr35--%E5%88%86%E7%B1%BB--svm/","summary":"\u003ch2 id=\"1svm相关\"\u003e1、SVM相关\u003c/h2\u003e\n\u003ch3 id=\"基本概念\"\u003e基本概念\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e超平面：比数据集的变量少一个维度的平面，也称为决策边界；\u003c/li\u003e\n\u003cli\u003e间隔：（对于硬间隔）训练数据中最接近决策边界的样本点与决策边界之间的距离；\u003c/li\u003e\n\u003cli\u003e支持向量：（对于硬间隔）接触间隔边界的数据样本，它们是支持超平面的位置。（对于软间隔）间隔内的样本点也属于支持向量，因为移动它们也会改变超平面的位置。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如下图所示，SVM算法将寻找一个最优的线性超平面进行分类。\u003c/p\u003e","title":"机器学习基于R包mlr3(5)--分类--SVM"},{"content":" 题目：Single-cell RNA-seq reveals the transcriptional landscape in ischemic stroke\n期刊/日期：ournal of Cerebral Blood Flow \u0026amp; Metabolism / 24 May 2021\nDOI：10.1177/0271678X211026770\nIschemic stroke (IS)：缺血性中风\nMCAO (middle cerebral artery occlusion)：大脑中动脉闭塞\n概要简介：\n文章对IS造模与对照小鼠样本进行单细胞测序，结合多种单细胞数据分析策略，发现细胞水平中与IS炎症高度相关的biomarker与细胞亚群。（测序数据已上传至GSE174574）\n分析策略除单细胞基础分析流程外，还涉及（1）细胞比例分析（2）细胞亚群鉴定（3）转录因子分析（4）轨迹分析+BEAM（5）细胞通讯分析。由于包含疾病与对照组，上述分析均不同程度增加了两组差异对比的维度。\n分析结果：\n对文章结果进行简单的总结，对文章细节的结果与结论感兴趣的可参看原文。\n1、单细胞测序与细胞注释 （1）对3个MCAO(24h)与3个对照小鼠样本的左脑半球(left cerebral hemispheres)进行单细胞测序；\n（2）对原始数据进行常规预处理，包括质控、去批次、降维分群等，结合marker基因注释得到17类细胞群（如下）；\n（3）初步分析在MCAO组中细胞比例明显提高或者下降的细胞类型，例如MdC从sham的2%到MCAO的16%。\nvascular smooth muscle cells (SMC); perivascular fibroblast-like cells (FB); central nervous system (CNS)-associated macrophages (CAM); monocyte-derived cells (MdC); venous endothelial cells (vEC); capillary endothelial cells (capEC); arterial endothelial cells (aEC); pericytes (PC); choroid plexus capillary endothelial cells (CPC); ependymocytes (EPC); microglia (MG); neutrophils (NEUT); astrocytes (ASC); oligodendrocytes (OLG); neural progenitor cells (NPC);lymphocytes(LYM); red blood cell (RBC)\n2、MCAO细胞类型marker基因 主要围绕MCAO组中不同细胞类型相对于对照组相应细胞类型的差异基因展开不同角度分析\n（1）通路富集分析，以发现不同细胞类型对于疾病的响应功能特征；\n（2）哪一种细胞类型的差异基因数目最多，以表示受疾病的影响最大；\n（3）不同细胞类型特异的或者共享的差异基因，以分析细胞类型的unique或者general变化特征；\n（4）对于部分差异基因，进行湿实验水平的验证。\n3、细胞亚型分析 文章选取了若干种IS过程中比较重要的细胞类型进行亚型鉴定以及相关衍生分析，这里简单提一下其中两个例子。\n1） microglia 文章共鉴定出5种小胶质细胞亚型，结合每种亚型的marker基因注释其潜在的生物学功能； 进行SCENIC转录因子分析，发现每种亚型distinct转录因子。 2）外周浸润免疫细胞 对monocyte-derived cells (MdC)主要注释出3大类亚型，分别包括monocytes/macrophages(Mon/Mψ)，dendritic cells(DCs) and lymphocytes (T, B and NK cells) 其中Mon/Mψ根据不同亚群的marker注释得到不同表型的子类，并结合monecle轨迹分析推测其分化发育关系。 4、细胞通讯分析 文章最后使用CellPhoneDB进行了细胞通讯分析，阐述疾病组相对正常组特异变化的通讯类型，例如：疾病组中， FB与其它细胞类型的通讯程度减弱；microglia与CAM的通讯程度加强等。\n小体会：\n从测序数据来看，本文自测的6个样本单细胞数据（动物模型），应该是一笔不小花费。大体来看分析内容是很充实的，从单细胞基础分析到高级分析，并结合部分湿实验验证。但可能就像很多资源类型文章一样结论很多就是凸显不出重点（可能重点就是数据本身）。不过觉得挺适合作为初学者学习单细胞数据分析的示例数据集。\n","permalink":"https://lishensuo.github.io/en/posts/basic/105%E6%96%87%E7%8C%AE--%E5%B0%8F%E9%BC%A0%E7%BC%BA%E8%A1%80%E6%80%A7%E4%B8%AD%E9%A3%8E%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：Single-cell RNA-seq reveals the transcriptional landscape in ischemic stroke\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊/日期\u003c/strong\u003e：ournal of Cerebral Blood Flow \u0026amp; Metabolism / 24 May 2021\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：10.1177/0271678X211026770\u003c/p\u003e","title":"文献--小鼠缺血性中风单细胞数据分析"},{"content":"1、决策树基础 1.1 决策树的构成 （1）决策树由节点组成，可分为决策节点(Decision tree)与叶节点(leaf node)。\n（2）从上到下的第一个节点也称为根节点(Root Node)。根节点到叶节点的最长距离称为树的深度。\n（3）对于每一个决策节点，选择样本集的一个最佳预测变量，确定最佳的阈值，进行二分类；最后根据叶节点类别的众数进行分类（均数进行回归）。\n在决策树中有两个关键问题：\n（1）如何选择最佳的预测变量？以及如何确定其阈值？\n（2）如何防止决策树过拟合\n1.2 基尼系数 （1）决策树为了使表示数据杂乱程度的不纯度减小，选择预测变量的最佳cut-off进行分割。当分割出来的每个组中的标签大部分属于同种标签时，不纯度会变小。\n每一组的复杂度可通过基尼指数表示。其值越小，表示数据纯度越高 分割前后的数据复杂度变化可通过基尼增益表示。其值越大，表示数据的纯度变得越高。 （2）基尼指数与基尼增益的计算方法如下图所示：\n如公式所示，对于二分类任务的基尼指数取值范围应为0~0.5之间。当等于0时，表示由同一种标签样本组成；当等于0.5时，表示两个标签样本各占一半。\n（3）比较不同预测变量的基尼增益，其实就是比较把不同预测变量的最佳分割cut-off下的基尼增益。\n具体对于不同类型的预测变量，如上图所示，有不同的选择方法（从若干候选值中选择一个最佳的，作为该预测变量的代表）\n1.3 防止决策树过拟合 如果不对决策树做出限制，它会一直划分节点，直至所有的叶节点都是只有一个类别的纯节点。这是决策树过拟合的主要原因。\n防止过拟合的思路有两种\u0026ndash;\n① 先生成一颗冗长的树，再回过头修剪； ② 提前定义好规则，防止树出现过拟合。 关于第二种思路，有如下4个角度（超参数）\n（1）直接限制最长深度；\n（2）每一次划分所引起的最小性能改进（cp值，类似于基尼增益）；\n（3）叶节点size：如果划分一个节点会导致叶节点中包含的样本数少于规定值，则不会划分；\n（4）决策节点size：如果决策节点少于规定值，则不会被划分。（就被视为了叶节点）\n2、决策树mlr建模 2.1 动物特征数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data(Zoo, package = \u0026#34;mlbench\u0026#34;) #将逻辑变量(True/False)转为数值型因子变量 Zoo2 = Zoo %\u0026gt;% dplyr::mutate(across(where(is.logical), as.factor)) str(Zoo2) # \u0026#39;data.frame\u0026#39;:\t101 obs. of 17 variables: # $ hair : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 2 ... # $ feathers: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 1 1 1 1 ... # $ eggs : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 2 1 1 1 1 2 2 1 ... # $ milk : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 2 ... # $ airborne: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 1 1 1 1 ... # $ aquatic : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 2 1 1 1 1 2 2 1 ... # $ predator: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 1 2 2 2 1 1 1 2 1 ... # $ toothed : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 2 2 2 2 2 2 2 2 ... # $ backbone: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 2 2 2 2 2 2 2 2 ... # $ breathes: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 2 ... # $ venomous: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 1 1 1 1 ... # $ fins : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 2 1 1 1 1 2 2 1 ... # $ legs : int 4 4 0 4 4 4 4 0 0 4 ... # $ tail : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 2 2 1 2 2 2 2 2 1 ... # $ domestic: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 2 2 1 2 ... # $ catsize : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 1 ... # $ type : Factor w/ 7 levels \u0026#34;mammal\u0026#34;,\u0026#34;bird\u0026#34;,..: 1 1 4 1 1 1 1 4 4 1 ... ##第1~16列为动物特征 ##第17列type列为动物名标签 2.2 确定预测目标与训练方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #（1）根据1-16列动物特征进行动物类型预测 task_classif = as_task_classif(Zoo2, target = \u0026#34;type\u0026#34;) task_classif$col_roles$stratum = \u0026#34;type\u0026#34; #使用决策树rpart分类算法 learner = lrn(\u0026#34;classif.rpart\u0026#34;, predict_type=\u0026#34;prob\u0026#34;) learner$param_set ##（2）确定该算法的超参数空间以及遍历方法 search_space = ps( minsplit = p_int(lower=1,upper=20), minbucket = p_int(lower=1,upper=20), cp = p_dbl(lower=0, upper=1), maxdepth = p_int(lower=1,upper=20) ) design = expand.grid(minsplit=c(1, 5, 10), minbucket=c(1, 10, 20), cp=c(0.1, 0.3, 0.5, 0.9), maxdepth = c(5, 10, 15)) %\u0026gt;% as.data.table() ##5折交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) resampling$param_set$values$folds=5 ##AUC模型评价指标 measure = msr(\u0026#34;classif.acc\u0026#34;) 2.3 模型训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ##创建实例 instance = TuningInstanceSingleCrit$new( task = task_classif, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) ##超参数优化 tuner$optimize(instance) as.data.table(instance$archive)[,1:5] %\u0026gt;% head ##（1）确定最佳超参数组合 library(parallel) library(parallelMap) #调用多线程 parallelStartSocket(cpus = detectCores()) tunedTreePars \u0026lt;- tuneParams(tree, task = zooTask, # ~30 sec resampling = cvForTuning, par.set = treeParamSpace, control = randSearch) #停用多线程 parallelStop() tunedTreePars # Tune result: # Op. pars: minsplit=6; minbucket=3; cp=0.0345; maxdepth=9 # mmce.test.mean=0.1200000 ##（2）使用上述组合训练模型 tunedTree \u0026lt;- setHyperPars(tree, par.vals = tunedTreePars$x) tunedTreeModel \u0026lt;- train(tunedTree, zooTask) ##（3）可视化决策树 treeModelData \u0026lt;- getLearnerModel(tunedTreeModel) library(rpart.plot) rpart.plot(treeModelData, roundint = FALSE, type = 5) 2.4 嵌套交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #inner inner \u0026lt;- makeResampleDesc(\u0026#34;CV\u0026#34;, iters = 5) #outer outer \u0026lt;- makeResampleDesc(\u0026#34;CV\u0026#34;, iters = 3) treeWrapper \u0026lt;- makeTuneWrapper(\u0026#34;classif.rpart\u0026#34;, resampling = inner, par.set = treeParamSpace, control = randSearch) parallelStartSocket(cpus = 8) cvWithTuning \u0026lt;- resample(treeWrapper, zooTask, resampling = outer) parallelStop() cvWithTuning # Resample Result # Task: zooTib # Learner: classif.rpart.tuned # Aggr perf: mmce.test.mean=0.1295306 # Runtime: 13.4196 3、bagging与随机森林 集成学习(Ensemble Learning)是指通过训练多个模型，从而在预测时考虑所有模型的预测结果，可减少单模型的方差。可分为bagging, boosting, stacking三种。虽然集成可用于多种机器学习算法，但还是最常应用于基于树的学习器，例如接下来学到的随机森林就是bagging应用于决策树的经典算法。\nBagging, bootstrap aggregating\n（1）决定要训练多少个子模型；\n（2）对于每个子模型，进行自助法抽样(bootstrap)。即从训练集中有放回的抽样。\n（3）根据上述的抽样，训练每一个子模型；\n（4）将新数据输入到每个子模型，做出预测；\n（5）汇总所有子模型的预测结果，进行最终的预测。\n由于训练各个子模型的过程理论上互不干扰，因此当训练非常多的子模型时可应用并行化多线程处理。\n随机森林(Random forest)是Bagging应用于决策树的实现方式。\n（1）特征变量抽样：如下图所示，随机森林基于Bagging步骤又多了一步。在上述的第二步结束后，在进行第三步训练每一个决策树时，对特定树的每一个节点都随机选择一定比例的预测变量；然后再从中根据基尼增益选择用于划分的预测变量。\n（2）包外(OOB, Out of bag)数据：因为Bagging的自助法抽样，所以每个决策树总会有一些重复样本，而有一定比例的（大部分说法是1/3）样本没有被抽到。换一个角度思考，对于一个样本来说，在随机森林的k个决策树模型中，会有~1/3的决策树训练时没有用到该样本。因此可用来评价、验证模型。\n（3）超参数: ①多少个决策树(不考虑计算开销，越多越好)；②在每个节点随机采样的特征数量，即上面第一点的特征变量抽样；③叶节点的最小样本数等与决策树类似的超参数。\n（4）降低方差：bagging适合用于决策树算法，因为bagging的集成方法有利于降低不稳定的强学习器base learnner，比如决策树算法一般预测方差很大。\n4、随机森林mlr建模 仍使用上面训练决策树所用到的模型\n4.1 动物特征训练数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 library(mlr3verse) library(tidyverse) data(Zoo, package = \u0026#34;mlbench\u0026#34;) Zoo2 = Zoo %\u0026gt;% dplyr::mutate(across(where(is.logical), as.factor)) str(Zoo2) # \u0026#39;data.frame\u0026#39;:\t101 obs. of 17 variables: # $ hair : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 2 ... # $ feathers: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 1 1 1 1 ... # $ eggs : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 2 1 1 1 1 2 2 1 ... # $ milk : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 2 ... # $ airborne: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 1 1 1 1 ... # $ aquatic : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 2 1 1 1 1 2 2 1 ... # $ predator: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 1 2 2 2 1 1 1 2 1 ... # $ toothed : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 2 2 2 2 2 2 2 2 ... # $ backbone: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 2 2 2 2 2 2 2 2 ... # $ breathes: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 2 ... # $ venomous: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 1 1 1 1 ... # $ fins : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 2 1 1 1 1 2 2 1 ... # $ legs : int 4 4 0 4 4 4 4 0 0 4 ... # $ tail : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 2 2 1 2 2 2 2 2 1 ... # $ domestic: Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 1 1 1 1 1 1 2 2 1 2 ... # $ catsize : Factor w/ 2 levels \u0026#34;FALSE\u0026#34;,\u0026#34;TRUE\u0026#34;: 2 2 1 2 2 2 2 1 1 1 ... # $ type : Factor w/ 7 levels \u0026#34;mammal\u0026#34;,\u0026#34;bird\u0026#34;,..: 1 1 4 1 1 1 1 4 4 1 ... ##第1~16列为动物特征 ##第17列为动物名标签 4.2 确定预测目标与训练方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #（1）确定预测目标，根据1~16列数据预测动物类别 task_classif = as_task_classif(Zoo2, target = \u0026#34;type\u0026#34;) task_classif$col_roles$stratum = \u0026#34;type\u0026#34; #（2）指定随机森林分类算法 learner = lrn(\u0026#34;classif.rpart\u0026#34;, predict_type=\u0026#34;prob\u0026#34;) learner$param_set #（3）超参数组合以及遍历方法 search_space = ps( num.trees = p_int(lower=1,upper=1000), mtry = p_int(lower=6,upper=12), min.node.size = p_dbl(lower=1, upper=5), max.depth = p_int(lower=1,upper=20) ) design = expand.grid(num.trees=c(300, 500, 1000), mtry=c(6, 9, 12), min.node.size=c(1,2,3,4,5), max.depth = c(3, 6, 9)) %\u0026gt;% as.data.table() #（4）交叉验证方法与模型评价指标 resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;classif.acc\u0026#34;) 4.3 模型训练优化超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 ##创建实例 instance = TuningInstanceSingleCrit$new( task = task_classif, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) ##优化超参数 tuner$optimize(instance) as.data.table(instance$archive)[,1:5] # num.trees mtry min.node.size max.depth classif.acc # 1: 300 6 1 3 0.9311764 # 2: 500 6 1 3 0.9200653 # 3: 1000 6 1 3 0.9200653 # 4: 300 9 1 3 0.8814005 # 5: 500 9 1 3 0.9004481 # --- # 131: 500 9 5 9 0.9718615 # 132: 1000 9 5 9 0.9718615 # 133: 300 12 5 9 0.9623377 # 134: 500 12 5 9 0.9623377 # 135: 1000 12 5 9 0.9718615 instance$result_learner_param_vals # $num.threads # [1] 1 # $num.trees # [1] 300 # $mtry # [1] 12 # $min.node.size # [1] 4 # $max.depth # [1] 6 instance$result_y #classif.acc #0.9813853 4.4 使用最佳超参数建模 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 learner$param_set$values = instance$result_learner_param_vals learner$train(task_classif) learner$model # Ranger result # Call: # ranger::ranger(dependent.variable.name = task$target_names, data = task$data(), probability = self$predict_type == \u0026#34;prob\u0026#34;, case.weights = task$weights$weight, num.threads = 1L, num.trees = 300L, mtry = 12L, min.node.size = 4L, max.depth = 6L) # Type: Probability estimation # Number of trees: 300 # Sample size: 101 # Number of independent variables: 16 # Mtry: 12 # Target node size: 4 # Variable importance mode: none # Splitrule: gini # OOB prediction error (Brier s.): 0.04122035 predict(learner$model, task_classif) prediction = learner$predict(task_classif) prediction$confusion # truth # response mammal bird reptile fish amphibian insect mollusc.et.al # mammal 41 0 0 0 0 0 0 # bird 0 20 0 0 0 0 0 # reptile 0 0 5 0 0 0 0 # fish 0 0 0 13 0 0 0 # amphibian 0 0 0 0 4 0 0 # insect 0 0 0 0 0 8 0 # mollusc.et.al 0 0 0 0 0 0 10 prediction$score(msrs(c(\u0026#34;classif.acc\u0026#34;,\u0026#34;classif.ce\u0026#34;))) # classif.acc classif.ce # 1 0 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/105%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr36--%E5%88%86%E7%B1%BB--%E5%86%B3%E7%AD%96%E6%A0%91%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/","summary":"\u003ch2 id=\"1决策树基础\"\u003e1、决策树基础\u003c/h2\u003e\n\u003ch3 id=\"11-决策树的构成\"\u003e1.1 决策树的构成\u003c/h3\u003e\n\u003cp\u003e（1）决策树由节点组成，可分为决策节点(Decision tree)与叶节点(leaf node)。\u003c/p\u003e\n\u003cp\u003e（2）从上到下的第一个节点也称为根节点(Root Node)。根节点到叶节点的最长距离称为树的深度。\u003c/p\u003e","title":"机器学习基于R包mlr3(6)--分类--决策树与随机森林"},{"content":" 题目 ： Integrative Analysis From Multicenter Studies Identifies a WGCNA-Derived Cancer-Associated Fibroblast Signature for Ovarian Cancer\n期刊 | 日期 ： https://doi.org/10.3389/fimmu.2022.951582 | 06 June 2022\n概述：发现6个基因（COL16A1, COL5A2, GREM1, LUM, SRPX, TIMP3）组成的卵巢癌肿瘤相关成纤维细胞相关的signature\n1、数据收集与预处理 主要收集16个数据集，2742个卵巢癌病人转录组数据及对应的预后信息。\nTCGA队列：372个病人， FPKM标准化（另收集突变数据） GPL570平台的6个GSE数据集，597个病人，log2(TPM+1)标准化(下同) 对于相同平台的不同数据集使用sva::Combat校正批次(下同) GPL96平台的4个数据集，409个病人； GPL7759，GPL2986，GPL14951，各一个数据集 PD-1，PD-L1治疗后的两个GSE数据集 主要使用GPL570与TCGA两个队列，其余数据用于后续验证以及衍生分析\n2、CAF相关hub基因筛选 （1）基于IOBR包的4种算法，计算每个样本的CAF abundances and stromal scores；\n（2）根据score将病人分为高低两组，TCGA与GPL570生存分析具有均显著意义\n较高的CAF infiltration、stromal score与较差的生存预后相关 每个队列的组别划分阈值不相同可以理解，但作者并没有明确提及确定阈值的依据，包括后面的risk score分组分析。\n（3）分别对TCGA与GPL570进行WGCNA分析，各自鉴定出与样本CAF abundances and stromal scores最相关的一个模块，再取交集，得到95个CAF相关基因。\n（4）对CAF相关基因进行初步的GO，KEGG通路富集分析，阐释相关通路。\n3、构建预后模型signature 将GPL570队列用于训练集， 构建模型；将TCGA队列用于验证模型。\n（1）针对上述95个CAF相关基因进行Univariate Cox regression analysis，得到63个显著基因(p\u0026lt;0.05)\n（2）再经LASSO regression analysis，最终得到6个用于构建signature的marker基因\nCOL16A1—0.0924；COL5A2— -0.0031；GREM1— 0.0847； LUM— 0.0069；SRPX— 0.0649；TIMP3— 0.0425 （3）根据上述基因权重，计算每个样本的risk score，进一步分为高低风险组，进行生存分析\n分组具有显著生存预后意义，高分数→差预后 （4）其余4个GPL队列的数据验证，发现风险分组均具有显著意义。\n4、预后模型衍生分析 通过不同角度论证所发现的signature具有重要意义\n4.1 signature与CAF的关系\n样本risk score与CAF浸润打分的相关性 样本risk score与已知CAF marker表达的相关性 4.2 signature与免疫治疗的关系\nPD-1/PD-L1可降低免疫效应，促进肿瘤生长; PD-L1 and PD-1 blockade 肿瘤免疫治疗手段\nstable disease (SD)/progressive disease (PD) \u0026ndash; 无效\ncomplete response (CR)/ partial response (PR) \u0026ndash; 有效\nhigh risk score样本与SD/PD有关 high risk组与较差的生存预后相关 4.3 signature与肿瘤突变负荷\n一般认为肿瘤突变负荷TMB越高，免疫治疗效果越好\n结合TCGA突变数据，分析high/low risk score组的差异突变基因； 进一步分析TMB分数与risk score的相关性（maftools包的tmb函数） 4.4 signature的相关通路\nhigh/low risk score组的GSEA显著富集通路 样本risk score与ssGSEA分数的高相关性通路 4.5 其余分析\n（1）BRCA是否突变以及突变型与risk score的关系\n（2）结合pRRophetic包预测对high/low risk score组的IC50具有显著差异的药物\n（3）siganture在纤维原细胞系与卵巢癌细胞系表达差异\n（4）OV scRNAseq中高表达siganture的细胞类型\n5、小结与体会 本篇数据挖掘文章亮点之一是收集了大量样本数据，共2742个样本，并且均包含预后数据。其中主要使用的是GPL570所包含的仅600个样本数据。 分析思路主要分为3步（1）确定CAF相关基因范围；（2）建立CAF signature；（3）signature后续衍生分析 前面两步是很常规的signature挖掘过程； 后面一步则取决于个性的发挥。本篇文章花了相当的笔墨在这一步骤，可感觉有些分析实在有仅为了充实内容之嫌。 最后关于文章的存疑是目前仍未发现作者如何针对每个数据集的risk score确定分组阈值的方法，而这直接决定了生存分析结果，不知作者有意为之还是如何。 ","permalink":"https://lishensuo.github.io/en/posts/basic/106%E6%96%87%E7%8C%AE--wgcna%E5%8F%91%E7%8E%B0%E7%9A%84%E5%8D%B5%E5%B7%A2%E7%99%8C%E8%82%BF%E7%98%A4%E7%9B%B8%E5%85%B3%E6%88%90%E7%BA%A4%E7%BB%B4%E7%BB%86%E8%83%9E%E7%9A%84%E9%A2%84%E5%90%8E%E6%A8%A1%E5%9E%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e ： Integrative Analysis From Multicenter Studies Identifies a WGCNA-Derived Cancer-Associated Fibroblast Signature for Ovarian Cancer\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊 | 日期\u003c/strong\u003e ： \u003ca href=\"https://doi.org/10.3389/fimmu.2022.951582\"\u003ehttps://doi.org/10.3389/fimmu.2022.951582\u003c/a\u003e \u003cstrong\u003e|\u003c/strong\u003e  06 June 2022\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e概述\u003c/strong\u003e：发现6个基因（COL16A1, COL5A2, GREM1, LUM, SRPX, TIMP3）组成的卵巢癌肿瘤相关成纤维细胞相关的signature\u003c/p\u003e","title":"文献--WGCNA发现的卵巢癌肿瘤相关成纤维细胞的预后模型"},{"content":" 题目：Defining cellular population dynamics at single-cell resolution during prostate cancer progression\n期刊 | 日期 ：eLife | November 2022\nDOI：https://doi.org/10.7554/eLife.79076\n0、简介 本文设计了多种精细的前列腺癌小鼠模型，结合单细胞测序数据进行了深入的探索，例如前列腺癌特异相关的细胞类型，免疫特征以及Castration处理前后的多角度分析。这为理解前列腺癌的发生以及castration resistant的机制以及治疗措施提出了新的见解与观点。\n数据集已上传到：GSE171336 数据图谱已制作成交互式网页，方便查询：https://atlas.fredhutch.org/hsieh-prostate/ 此外，这篇文章的数据量、工作量较为丰富，差异分析、轨迹推断、细胞通讯分析策略值得精读、学习。原文也提供了部分分析与绘图代码：https://github.com/sonali-bioc/GermanosProstatescRNASeq/\n1、前列腺癌模型小鼠单细胞图谱 （1）测序数据\n3只对照组6月龄小鼠(WT)与2只前列腺癌模型6月龄小鼠(Pten) Pten模型组：对小鼠前列腺的基底(Basal)与管腔(Luminal)上皮细胞的肿瘤抑制基因Pten的5号外显子进行敲除。之后笔记简称Pten组\n（2）使用SingleR软件注释出3大类细胞：epithelial，stromal以及immune cells\n（3）结合文献marker，进一步注释两组的上皮细胞亚型\n对WT组释出basal(Krt5/Sox4), luminal differentiated(Nkx3-1/Sbp)以及luminal progenitor(Psca/Tactsd/Krt4)与Urethral(Aqp3/Ly6d) 对Pten上皮细胞进一步注释出basal，Urethral，luminal differentiated，以及一种intermediate luminal(Krt4/Tacstd2/Ppp1r1b，对应WT组的luminal progenitor) 2、intermediate luminal细胞发育推断分析 （1）首先观察到Pten组的intermediate比例显著高于WT组的progenitor比例；\n（2）Pten与WT组的同种细胞类型差异基因多富集在肿瘤发生、上皮细胞迁移增殖等通路；\n（3）结合细胞周期分析在Pten组的basal细胞发现两种处于不同增殖状态的亚群\nhyper-proliferative,亚群占18.6%，其中99.7%的细胞处于G2/M、S，显著高于WT的basal hypo-proliferative,亚群81.4%，其中52.2%的细胞处于G2/M，S；显著低于WT的basal （4）上述两个亚群间差异分析\nhypo-proliferative富集在迁移、发育分化通路 hyper-proliferative富集在细胞周期相关通路 （5）结合Monocle3、RNA velocity、Palantir推断出由hypo-proliferative到intermediate luminal的发育轨迹以及相关基因；\n（6）基于luminal的maker基因表达，发现intermediate luminal也有可能源自luminal progenitor发育而来。\n3 前列腺癌模型小鼠的免疫细胞特征 （1）首先观察到Pten与WT组的同种细胞类型差异基因也富集到免疫相关通路；\n（2）对免疫细胞进行亚型注释如下\nneutrophil → myeloid-derived suppressor cells (MDSCs) macrophage → TAM，M2，TRM(tissue-resident) T cell → CD8+，gamma-delta T， NKT B cell， DC细胞 （3）除B，TRM，NKT细胞外，其它细胞类型比例Pten组显著高于WT组，其中M2、TAM、MDSCs以及CD8+ T均具有促进肿瘤作用。\n（3）使用CellPhoneDB分析上皮细胞等与免疫细胞之间的配受体通讯在Pten/WT差异表达，推断M2巨噬细胞由上皮与成纤维细胞招募，进而促进MDSCs与CD8+\n4、Castration引发intermediate luminal的异质性 （1）加入新的单细胞测序数据：\n3只Pten组小鼠于4月龄时进行Castration阉割处理，待6月时取样测序 后续简称Pten cx组 （2）Pten cx组的intermediate luminal细胞比例显著扩增， 而没有differentiated luminal cells\n（3）Pten组与Pten cx组的AR基因集得分均低于WT组的luminal progenitor\n（4）对Pten与Pten cx组的intermediate细胞进行重聚类，共得到6个亚群\nC3主要来自Pten组 C3高表达AR相关基因，靠近differentiated luminal C0、1、2、4主要来自Pten cx组 C1表达basal相关基因，靠近basal C1与C4高表达翻译与增殖相关基因 6个亚群的AR分数与增殖翻译与增殖分数呈负相关 （5）加入新的单细胞测序数据\n3只Castration处理的WT小鼠取样测序 后续简称WT cx （6）WT cx的luminal类似Pten cx的intermediate高表达翻译相关基因，但是低表达增殖相关基因，表明可能与Pten相关\n5、Castration intermediate cell预后signature （1）基于人类前列腺癌数据定义androgen deprivation therapy(ADT) resistance相关基因集\n（2）Pten与Pten cx的intermediate cell差异基因GSEA分析显著富集上述基因集\n（3）上述基因集相关的Top 5 上调基因(Pten cx)包括ATP1B1、BST2、CP、IGFBP3、PTTG1，经深入分析具有如下特征：\n在Pten组的intermediate亚群均低表达 在resistance to ADT的human tumor样本中显著高表达 这些基因的(任一)高表达与较差的预后相关 这些基因在人类转移性前列腺癌中高表达 6、Castration引发的免疫细胞变化 （1）相比Pten组，Pten cx组的3种巨噬细胞以及CD8+ T比例均显著下降；\n（2）结合Pten cx组低表达的配受体通讯，分析上述比例下降的原因；\n（3）TNF的配受体细胞通讯在Pten CX组中特异性高表达。\n7、抑制翻译对Castration的杀伤作用 （1）加入新的单细胞测序数据\nPten小鼠在4月龄经doxycycline(抑制翻译)给药与castration处理，待6月取样测序 后续简称Pten cx 4ebp1 （2）Pten cx 4ebp1与Pten cx的上皮细胞比例与分布无明显差异；\n（3）transgene-positive的Pten cx 4ebp1与Pten cx的basal差异分析发现465个差异基因，进一步分析上调（细胞周期阻滞，细胞凋亡）、下调通路\n（4）与Pten cs相比，Pten cx 4ebp1显著差异的配受体通讯(Tnf, Egfr)\n","permalink":"https://lishensuo.github.io/en/posts/basic/107%E6%96%87%E7%8C%AE--%E5%B0%8F%E9%BC%A0%E5%89%8D%E5%88%97%E8%85%BA%E7%99%8C%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e题目：Defining cellular population dynamics at single-cell resolution during prostate cancer progression\u003c/p\u003e\n\u003cp\u003e期刊 | 日期 ：eLife | November 2022\u003c/p\u003e\n\u003cp\u003eDOI：https://doi.org/10.7554/eLife.79076\u003c/p\u003e","title":"文献--小鼠前列腺癌单细胞数据分析"},{"content":"1、关于线性回归 1.1 公式理解 由于实际问题很少遇到单变量线性回归，所以更常见的表示为通用线性模型： $$ y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \u0026hellip;+\\beta_kx_k + \\epsilon $$ （1）β0表示截距，即所有预测变量取0时的值；\n（2）β1等表示斜率，在其它预测变量不变时，每个预测变量每变动一个单位时输出变量的变化值。\n（3）ε表示模型的未知误差，可以理解为残差。\n如上公式，线性回归常用普通最小二乘法(OLS)寻找最佳的截距与斜率值的组合，最小化残差(预测值与真实值的差异)平方和。\n对于分类变量（k类），会选择1类作为参考水平，同时生成(k-1)个虚拟变量，进而得到(k-1)个斜率值。此时的斜率值表示，该类的预测变量结果相对于参考水平的变化倍数。\n1.2 注意点 （1）线性回归的优势在于模型的可解释性（相对于随机森林、SVM等黑匣子）。即每个预测变量都有斜率值以表示对预测变量的影响；并且不同预测变量的影响是累加的。\n（2）对于线性回归结果需要检查拟合值与真实值的残差是否满足两个条件。\n正态分布：残差值是否符合以0为均值的正态分布。 同方差：输出变量的方差不会随着预测拟合值的变化而变化，如下图a的结果是符合的。 如果不满足上面两个条件，提示可能不适合使用通用线性回归，使得模型性能降低，可以尝试之后会学习的通用线性模型。\n（3）对于回归问题的性能度量指标\n平均绝对误差MAE：残差绝对值的均值； 均方误差MSE：残差平方和的均值； 均方根误差RMSE：MSE的平方根。 2、mlr建模 1 2 library(mlr3verse) library(tidyverse) 2.1 臭氧水平空气质量数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 data(Ozone, package = \u0026#34;mlbench\u0026#34;) colnames(Ozone) = c(\u0026#34;Month\u0026#34;, \u0026#34;Date\u0026#34;, \u0026#34;Day\u0026#34;, \u0026#34;Ozone\u0026#34;, \u0026#34;Press_height\u0026#34;, \u0026#34;Wind\u0026#34;, \u0026#34;Humid\u0026#34;, \u0026#34;Temp_Sand\u0026#34;, \u0026#34;Temp_Monte\u0026#34;, \u0026#34;Inv_height\u0026#34;, \u0026#34;Press_grad\u0026#34;, \u0026#34;Inv_temp\u0026#34;, \u0026#34;Visib\u0026#34;) Ozone2 = Ozone %\u0026gt;% dplyr::mutate(across(where(is.factor), as.numeric)) %\u0026gt;% na.omit() str(Ozone2) # \u0026#39;data.frame\u0026#39;:\t203 obs. of 13 variables: # $ Month : num 1 1 1 1 1 1 1 1 1 1 ... # $ Date : num 5 6 7 8 9 12 13 14 15 16 ... # $ Day : num 1 2 3 4 5 1 2 3 4 5 ... # $ Ozone : num 5 6 4 4 6 6 5 4 4 7 ... # $ Press_height: num 5760 5720 5790 5790 5700 5720 5760 5780 5830 5870 ... # $ Wind : num 3 4 6 3 3 3 6 6 3 2 ... # $ Humid : num 51 69 19 25 73 44 33 19 19 19 ... # $ Temp_Sand : num 54 35 45 55 41 51 51 54 58 61 ... # $ Temp_Monte : num 45.3 49.6 46.4 52.7 48 ... # $ Inv_height : num 1450 1568 2631 554 2083 ... # $ Press_grad : num 25 15 -33 -28 23 9 -44 -44 -53 -67 ... # $ Inv_temp : num 57 53.8 54.1 64.8 52.5 ... # $ Visib : num 60 60 100 250 120 150 40 200 250 200 ... # - attr(*, \u0026#34;na.action\u0026#34;)= \u0026#39;omit\u0026#39; Named int [1:163] 1 2 3 4 10 11 17 18 20 24 ... # ..- attr(*, \u0026#34;names\u0026#34;)= chr [1:163] \u0026#34;1\u0026#34; \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; ... 2.2 确定预测目标与训练方法 1 2 3 4 5 ##(1)确定预测目标：根据每天的空气相关记录数据，预测那一天的臭氧水平 task_regr = as_task_regr(Ozone2, target = \u0026#34;Ozone\u0026#34;) ##(2)使用线性回归模型 learner = lrn(\u0026#34;regr.lm\u0026#34;) 2.3 特征筛选建模 这一步是去除不具备预测价值的干扰变量，提高模型精度。有如下两种思路：\n2.3.1 TopK个预测变量 这种思路是评价每一个预测变量与待拟合变量的\u0026quot;关系\u0026quot;，有很多评价指标。\n1 2 3 4 5 6 ALL_mlr_filter = as.data.table(mlr_filters) mlr_filters$keys() # [1] \u0026#34;anova\u0026#34; \u0026#34;auc\u0026#34; \u0026#34;carscore\u0026#34; \u0026#34;cmim\u0026#34; \u0026#34;correlation\u0026#34; # [6] \u0026#34;disr\u0026#34; \u0026#34;find_correlation\u0026#34; \u0026#34;importance\u0026#34; \u0026#34;information_gain\u0026#34; \u0026#34;jmi\u0026#34; # [11] \u0026#34;jmim\u0026#34; \u0026#34;kruskal_test\u0026#34; \u0026#34;mim\u0026#34; \u0026#34;mrmr\u0026#34; \u0026#34;njmim\u0026#34; # [16] \u0026#34;performance\u0026#34; \u0026#34;permutation\u0026#34; \u0026#34;relief\u0026#34; \u0026#34;selected_features\u0026#34; \u0026#34;variance\u0026#34; 然后根据指标结果，选取最有价值的若干个预测变量。具体的数量，可设置为超参数，选取最优的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##(1)计算每个预测变量与待预测变量的关系指标 filter = flt(\u0026#34;jmim\u0026#34;) filter$param_set$values filter$calculate(task_regr) as.data.table(filter) # feature score # 1: Temp_Sand 1.00000000 # 2: Press_grad 0.90909091 # 3: Date 0.81818182 # 4: Month 0.72727273 # 5: Inv_height 0.63636364 # 6: Inv_temp 0.54545455 # 7: Visib 0.45454545 # 8: Humid 0.36363636 # 9: Wind 0.27272727 # 10: Press_height 0.18181818 # 11: Temp_Monte 0.09090909 # 12: Day 0.00000000 2.3.2 遍历特征组合 相对于上一种方法考虑每个预测变量的价值，这种思路是希望选出性能最好的预测变量组合。\n具体搜索最优预测变量组合，有如下方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 All_mlr_fs = as.data.table(mlr_fselectors) mlr_fselectors$keys() # [1] \u0026#34;design_points\u0026#34; \u0026#34;exhaustive_search\u0026#34; \u0026#34;genetic_search\u0026#34; \u0026#34;random_search\u0026#34; # [5] \u0026#34;rfe\u0026#34; \u0026#34;sequential\u0026#34; \u0026#34;shadow_variable_search\u0026#34; ##穷举法：比较所有可能的预测变量组合 exhaustive_search ##随机法：随机搜索若干个预测变量组合 random_search ##顺序搜索 sequential ###具体有4种思路 ####向前搜索(sfs)：从空模型依次添加可提高性能的特征，直到不能改进为止； ####浮动向前(sffs)：从空模型，在每个步骤添加/删除对模型性能最优改进的特征，直到不再有助于改善模型性能位置 ####向后搜索(sbs)：从全特征模型依次删除可提高模型性能的特征，直到不能改进为止； ####浮动向后(sfbs)：从全特征模型模型，在每个步骤添加/删除对模型性能最优改进的特征，直到不再有助于改善模型性能位置 ##.... 下面使用浮动向前的顺序搜索组合方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 resampling = rsmp(\u0026#34;cv\u0026#34;) resampling$param_set$values$folds = 3 measure = msr(\u0026#34;regr.mse\u0026#34;) instance = FSelectInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;) ) instance future::plan(\u0026#34;multisession\u0026#34;) fselector = fs(\u0026#34;sequential\u0026#34;) fselector$param_set$values # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default value # 1: min_features ParamInt 1 Inf Inf 1 1 # 2: max_features ParamInt 1 Inf Inf \u0026lt;NoDefault[3]\u0026gt; # 3: strategy ParamFct NA NA 2 sfs sfs fselector$optimize(instance) instance$result_feature_set # [1] \u0026#34;Humid\u0026#34; \u0026#34;Month\u0026#34; \u0026#34;Press_height\u0026#34; \u0026#34;Temp_Monte\u0026#34; \u0026#34;Temp_Sand\u0026#34; instance$result_y # regr.mse # 20.23275 task_regr$select(instance$result_feature_set) learner$train(task_regr) learner$model # Call: # stats::lm(formula = task$formula(), data = task$data()) # Coefficients: # (Intercept) Humid Month Press_height Temp_Monte Temp_Sand # 46.22527 0.10291 -0.37841 -0.01293 0.51634 0.11069 ##交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) rr = resample(task_regr, learner, resampling) rr$aggregate(msrs(c(\u0026#34;regr.mse\u0026#34;))) # regr.mse # 19.51755 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/107%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr38--%E5%9B%9E%E5%BD%92--%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","summary":"\u003ch2 id=\"1关于线性回归\"\u003e1、关于线性回归\u003c/h2\u003e\n\u003ch3 id=\"11-公式理解\"\u003e1.1 公式理解\u003c/h3\u003e\n\u003cp\u003e由于实际问题很少遇到单变量线性回归，所以更常见的表示为通用线性模型：\n$$\ny = \\beta_0 + \\beta_1x_1 +  \\beta_2x_2 + \u0026hellip;+\\beta_kx_k + \\epsilon\n$$\n（1）\u003ccode\u003eβ0\u003c/code\u003e表示截距，即所有预测变量取0时的值；\u003c/p\u003e","title":"机器学习基于R包mlr3(8)--回归--线性回归"},{"content":" 题目：hECA: The cell-centric assembly of a cell atlas\n期刊 | 日期：iScience | May 20, 2022\nDOI：https://doi.org/10.1016/j.isci.2022.104318\n简介：来自清华大学自动化系的张学工课题建立一个人类综合性单细胞图谱平台\u0026ndash;hECA(human Ensemble Cell Atlas)1.0版本。这篇文章主要基于细胞为中心(cell-centric)的理念对来自人类多器官的上百万个细胞数据进行了系统性整合工作。\n网址：http://eca.xglab.tech\n1、数据规模 116份已发表单细胞数据集 38个人类器官(如下表)与11个组织系统 146种细胞类型 1,093,299个细胞(43,878个基因) 2、整合方法 （1）uGT：unified giant table\n数据储存方式是基于NoSQL数据库语言直接将多数据集合并成巨大的表达矩阵（43878×1093299），以及每个细胞的metadata，例如样本来源、数据集来源，样本信息、细胞类型等等。\n（2）uHAF：unified hierarchical annotation framework\n使用相同的细胞类型标签体系对合并的数据集进行统一的146种细胞类型注释。\n（3）ECAUGT\n开发了一个python工具包提供了API接口用于上述大规模数据的有效提取。\nhttp://eca.xglab.tech/ecaugt/index.html\n3、应用场景 文章对该平台的三种可能应用场景进行了阐释。\n3.1 \u0026lsquo;in data\u0026rsquo; cell sorting 该平台提供了一种新型的基于数据的细胞分选方式。具体来说可从网页界面或者API工具快速筛选特定样本、特定器官、特定基因表达模式的细胞群。文章举了两个小例子。\n多器官T细胞的代谢通路表达概况 首先使用ECAUGHT\u0026quot;分选\u0026quot;了来自18个器官的T细胞群，简单分为了CD4+与CD8+亚群\n然后使用GSVA对代谢相关通路进行了单细胞水平的打分，分析相应的器官活性特征。\n药物脱靶效应的副作用预测\nCD19是CAR-T治疗B细胞淋巴瘤的常见靶点，其神经毒性是其主要副作用之一。\n首先在hECA数据库中分选到2566个CD19+，其中53%是B细胞；其余细胞还包括脑内的内皮细胞、小胶质细胞与神经元，这验证了CART治疗的神经毒性。此外在心脏、肺等组织细胞具有高表达，提示了可能的脱靶效应。\n3.2 quantitative portraiture 基因水平gene portrait\n针对选定基因在hECA涉及全部(选定)器官/细胞的表达特征\n细胞水平cell type portrait\n针对特定细胞在不同细胞表达、表达marker等\n器官水平organ portait\n针对特定器官，分析其细胞组成比例等\n3.3 label transfer 使用hECA人类特定器官的单细胞表达矩阵(已基于uHAF进行细胞注释)作为reference，使用SingleR建立模型，为用户自己的数据进行细胞类型注释。\n文章建立的SingleR注释模型：https://ngdc.cncb.ac.cn/omix/release/OMIX001043\n在文章举例说明中，对两个心脏组织细胞注释的准确率可分别达到0.954、0.904；对神经元细胞注释的准确率可达到0.887。\n此外为了进一步验证平台数据的可用性，文章分别取其中的肺组织细胞、肺免疫细胞分别代替两篇文献内的control数据仍可得到相似的结果与结论。\nExample disease study: using hECA data as normal control for cancer study Example disease study: using hECA for label transfer and normal control in a COVID-19 study 4、不足之处 诚如文章所言，研究存在如下两个主要问题\n（1）数据量有限：目前hECA1.0覆盖的人体器官组织单细胞数据较为有限，例如未涉及乳腺组织等。但目前平台已搭建的框架体系，例如uHAF注释系统等为以后纳入新的数据提供了基础。\n（2）批次效应问题：hECA对不同数据集仅进行了细胞文库水平(log转换)的标准化处理。而测序平台等批次效应都交给用户自行鉴别、校正。此外平台也提供了器官内不同数据集harmony校正后的整合数据。https://ngdc.cncb.ac.cn/omix/release/OMIX001042\n","permalink":"https://lishensuo.github.io/en/posts/basic/108%E6%96%87%E7%8C%AE--heca%E4%BA%BA%E7%B1%BB%E5%8D%95%E7%BB%86%E8%83%9E%E8%A1%A8%E8%BE%BE%E5%9B%BE%E8%B0%B1%E5%B9%B3%E5%8F%B0/","summary":"\u003cblockquote\u003e\n\u003cp\u003e题目：hECA: The cell-centric assembly of a cell atlas\u003c/p\u003e\n\u003cp\u003e期刊 | 日期：iScience | May 20, 2022\u003c/p\u003e\n\u003cp\u003eDOI：https://doi.org/10.1016/j.isci.2022.104318\u003c/p\u003e","title":"文献--hECA人类单细胞表达图谱平台"},{"content":"1、关于GAM非线性回归 (1) n阶多项式 如前所说，线性回归的假设是每个预测变量与输出变量之间为线性相关。即类似 y = ax + b。\n当预测变量与输出变量之间为非线性相关，即呈曲线特征时，可尝试使用高阶多项式进行拟合。 $$ y = \\beta_0 + \\beta_1x + \\beta_2x^2 + \u0026hellip;+\\beta_nx^n + \\varepsilon $$ 一般拟合高阶多项式时，除了最高阶n外，还会包括所有低阶项(1,2,3\u0026hellip; n-1)次幂。目的是为了避免最值点必须处于x=0的位置。\n样条曲线是分段的多项式函数：将预测变量分为若干区域，每个区域单独拟合一个多项式曲线。相邻的多项式之间的连接成为knot。\n(2) GAM GAM会尝试将每个预测变量与输出变量关系拟合为平滑曲线，通常是多个样条曲线的组合，其中每一个样条曲线称为基函数。\n对于预测变量Xi，平滑函数可以表示为如下。a表示每个基函数的权重。 $$ f(x_i) = a_1b_1(x_i)+a_2b_2(x_i)+\u0026hellip;+a_nb_n(x_n) $$\n所以GAM广义加性模型公式表示为： $$ y = \\beta_0 + f_1(x_1) + f_2(x_2) + \u0026hellip; + f_n(x_n) + \\varepsilon $$\n上一节提到的通用线性模型公式为： $$ y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \u0026hellip; + \\beta_nx_n + \\varepsilon $$ 可以这么理解：通用线性模型是广义加性模型的特例。\n2、mlr建模 训练数据与目的同上一节\n1 2 library(mlr3verse) library(tidyverse) 2.1 臭氧水平空气质量数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 data(Ozone, package = \u0026#34;mlbench\u0026#34;) colnames(Ozone) = c(\u0026#34;Month\u0026#34;, \u0026#34;Date\u0026#34;, \u0026#34;Day\u0026#34;, \u0026#34;Ozone\u0026#34;, \u0026#34;Press_height\u0026#34;, \u0026#34;Wind\u0026#34;, \u0026#34;Humid\u0026#34;, \u0026#34;Temp_Sand\u0026#34;, \u0026#34;Temp_Monte\u0026#34;, \u0026#34;Inv_height\u0026#34;, \u0026#34;Press_grad\u0026#34;, \u0026#34;Inv_temp\u0026#34;, \u0026#34;Visib\u0026#34;) Ozone2 = Ozone %\u0026gt;% dplyr::mutate(across(where(is.factor), as.numeric)) %\u0026gt;% na.omit() str(Ozone2) # \u0026#39;data.frame\u0026#39;:\t203 obs. of 13 variables: # $ Month : num 1 1 1 1 1 1 1 1 1 1 ... # $ Date : num 5 6 7 8 9 12 13 14 15 16 ... # $ Day : num 1 2 3 4 5 1 2 3 4 5 ... # $ Ozone : num 5 6 4 4 6 6 5 4 4 7 ... # $ Press_height: num 5760 5720 5790 5790 5700 5720 5760 5780 5830 5870 ... # $ Wind : num 3 4 6 3 3 3 6 6 3 2 ... # $ Humid : num 51 69 19 25 73 44 33 19 19 19 ... # $ Temp_Sand : num 54 35 45 55 41 51 51 54 58 61 ... # $ Temp_Monte : num 45.3 49.6 46.4 52.7 48 ... # $ Inv_height : num 1450 1568 2631 554 2083 ... # $ Press_grad : num 25 15 -33 -28 23 9 -44 -44 -53 -67 ... # $ Inv_temp : num 57 53.8 54.1 64.8 52.5 ... # $ Visib : num 60 60 100 250 120 150 40 200 250 200 ... # - attr(*, \u0026#34;na.action\u0026#34;)= \u0026#39;omit\u0026#39; Named int [1:163] 1 2 3 4 10 11 17 18 20 24 ... # ..- attr(*, \u0026#34;names\u0026#34;)= chr [1:163] \u0026#34;1\u0026#34; \u0026#34;2\u0026#34; \u0026#34;3\u0026#34; \u0026#34;4\u0026#34; ... 2.2 确定预测目标与训练方法 1 2 3 4 5 ##(1)确定预测目标：根据每天的空气相关记录数据，预测那一天的臭氧水平 task_regr = as_task_regr(Ozone2, target = \u0026#34;Ozone\u0026#34;) ##(2)使用线性回归模型 learner = lrn(\u0026#34;regr.gam\u0026#34;) 2.3 特征筛选建模 参考上一节，有两种筛选思路。如下选取第二种筛选最佳组合的方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 resampling = rsmp(\u0026#34;cv\u0026#34;) resampling$param_set$values$folds = 3 measure = msr(\u0026#34;regr.mse\u0026#34;) instance = FSelectInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;) ) instance future::plan(\u0026#34;multisession\u0026#34;) fselector = fs(\u0026#34;sequential\u0026#34;) fselector$param_set$values # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default value # 1: min_features ParamInt 1 Inf Inf 1 1 # 2: max_features ParamInt 1 Inf Inf \u0026lt;NoDefault[3]\u0026gt; # 3: strategy ParamFct NA NA 2 sfs sfs fselector$optimize(instance) # [1] \u0026#34;Humid\u0026#34; \u0026#34;Inv_height\u0026#34; \u0026#34;Inv_temp\u0026#34; \u0026#34;Month\u0026#34; \u0026#34;Press_height\u0026#34; \u0026#34;Temp_Monte\u0026#34; \u0026#34;Temp_Sand\u0026#34; \u0026#34;Visib\u0026#34; instance$result_y # regr.mse # 18.55917 task_regr$select(instance$result_feature_set) learner$train(task_regr) learner$model # Family: gaussian # Link function: identity # Formula: # Ozone ~ Humid + Inv_height + Inv_temp + Month + Press_height + # Temp_Monte + Temp_Sand + Visib # Total model degrees of freedom 9 # GCV score: 19.72521 ##交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) rr = resample(task_regr, learner, resampling) rr$aggregate(msrs(c(\u0026#34;regr.mse\u0026#34;))) # regr.mse # 19.32496 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/108%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr39--%E5%9B%9E%E5%BD%92--gam%E9%9D%9E%E7%BA%BF%E5%9B%9E%E5%BD%92/","summary":"\u003ch1 id=\"1关于gam非线性回归\"\u003e1、关于GAM非线性回归\u003c/h1\u003e\n\u003ch2 id=\"1-n阶多项式\"\u003e(1) n阶多项式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e如前所说，线性回归的假设是每个预测变量与输出变量之间为线性相关。即类似 \u003ccode\u003ey = ax + b\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e当预测变量与输出变量之间为非线性相关，即呈曲线特征时，可尝试使用高阶多项式进行拟合。\n$$\ny = \\beta_0 + \\beta_1x + \\beta_2x^2 + \u0026hellip;+\\beta_nx^n +  \\varepsilon\n$$\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20200711194108521.png\" alt=\"正交多项式介绍及应用- 优化与算法- 博客园\" style=\"zoom: 10%;\" /\u003e\u003c/p\u003e","title":"机器学习基于R包mlr3(9)--回归--GAM非线性回归"},{"content":" 题目：Meta-Analysis of Human Cancer Single-Cell RNA-Seq Datasets Using the IMMUcan Database\n期刊/时间：Cancer Research / February 1, 2023\nDOI：doi.org/10.1158/0008-5472.CAN-22-0074\n简介：来自法国巴黎圣路易斯研究所的研究团队建立了一个综合肿瘤微环境数据库平台(IMMUcan，https://immucanscdb.vital-it.ch)。该平台基于大量的单细胞数据收集与整合分析，为挖掘肿瘤免疫微环境单细胞特点提供了便捷的工具。\n1、平台建立 1.1 数据收集 （1）共收集到人类肿瘤微环境单细胞测序的103篇文献、144个数据集，涉及56种癌症类型；\n文献查询：Pubmed，bioRxiv （2016~2021） 原始数据下载：GEO, ArrayExpress, EGA, BioProject （2）对数据集多角度的注释：文章相关信息、样本/患者相关信息、测序相关信息\n1.2 数据处理 基于进一步的筛选，文章对其中的73（现今更新为78）个数据集进行整合分析；主要使用R包Seurat编写一套代码脚本，以对每个数据集批量分析（scProcessoR，https://github.com/ImmucanWP7/immucan-scdb），其中要点如下：\n（1）标准化、高变基因、降维、分群等基本操作；\n（2）根据Shannon entropy香农熵判断批次效应，如有则使用Harmony校正；\n（3）使用CHETAH包分3个深度注释细胞类型：major、immune、minor；\n（4）使用copyKAT包判断恶性肿瘤细胞；\n（5）使用sceasy包，将上述seurat对象储存为h5ad格式(标准化表达矩阵+注释信息)；\n（6）使用genesorteR包分析每种细胞类型的marker基因。\n2、应用示例 2.1 细胞类型分析 假设问题：文章以MEL_IMM_SS2_GSE120575数据集为例，分析经免疫治疗前后，细胞比例发生明显变化的细胞类型\n初步结论：对anti-PD-1疗法有响应的黑色素瘤患者经治疗后的B细胞比例显著增加。\n2.2 特定基因分析 假设问题：已知CXCL13与CXCL9是预测ICB治疗的marker。哪些肿瘤的细胞类型高表达这两个基因？ 初步结论：基底细胞癌(BCC)等肿瘤的Tfh，CD8Tex高表达CXCL13；肝细胞癌(HCC)等肿瘤的myeloid高表达CXCL9。 2.3 共表达基因对分析 假设问题：CXCL13与PD1在哪种细胞类型存在共表达关系？ 初步结论：在BCC_BIA_10X_GSE123813数据集的exhausted CD8T细胞群中，二者存在显著的共表达。 2.4 样本表型分析 假设问题：在细胞恶化前后，T细胞与巨噬细胞发生哪些变化？ 初步结论： 筛选得到25个同时包含tumor与normal样本的数据集； 首先分析与tumor与normal组间细胞比例发生显著变化的T细胞亚型； 然后分析tumor与normal相比CD4T、CD8T与巨噬细胞的上调/下调基因。 ","permalink":"https://lishensuo.github.io/en/posts/basic/109%E6%96%87%E7%8C%AE--immucan%E8%82%BF%E7%98%A4%E5%BE%AE%E7%8E%AF%E5%A2%83%E5%8D%95%E7%BB%86%E8%83%9E%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"\u003cblockquote\u003e\n\u003cp\u003e题目：Meta-Analysis of Human Cancer Single-Cell RNA-Seq Datasets Using the IMMUcan Database\u003c/p\u003e\n\u003cp\u003e期刊/时间：Cancer Research / February 1, 2023\u003c/p\u003e\n\u003cp\u003eDOI：\u003ca href=\"https://doi.org/10.1158/0008-5472.CAN-22-0074\"\u003edoi.org/10.1158/0008-5472.CAN-22-0074\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e简介：来自法国巴黎圣路易斯研究所的研究团队建立了一个综合肿瘤微环境数据库平台(IMMUcan，https://immucanscdb.vital-it.ch)。该平台基于大量的单细胞数据收集与整合分析，为挖掘肿瘤免疫微环境单细胞特点提供了便捷的工具。\u003c/p\u003e","title":"文献--immuCan肿瘤微环境单细胞数据库"},{"content":" 在建立通用线性模型时，当模型参数即斜率值绝对值过大时，容易存在过拟合的风险。可通过下面介绍的3种正则化方法将每个预测变量的斜率参数缩小为0或者接近0。 $$ y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \u0026hellip;+\\beta_kx_k + \\epsilon $$\n1、三种正则化方法 线性回归最小二乘法损失函数：MSE\n如下公式表示在一组给定的参数值模型中 所有预测值与观测值的差值的平方和（残差和，RSS）： $$ J = \\sum_{i=1}^n(y_i-\\hat{y_i})^2 $$\n1.1 岭回归 在上述RRS损失函数公式中，添加L2范数(所有斜率值的平方和)。可通过λ参数控制惩罚的强度。 $$ J=\\sum_{i=1}^n(y_i-\\hat{y_i})^2 + \\lambda \\sum_{j=1}^p{\\beta_j^2} $$ 可结合下图理解：假设有两个预测变量，即有两个斜率参数。\n（1）绿色圆表示不同参数值组合的MSE，中心值最小，越往外越大，黑色边表示相同MSE的等高线。\n（2）蓝色圆边表示具有相同L2结果的不同参数值[r^2=β1^2+β2^2]，总会存在一组参数值对应的RSS最小（如下图所示）。\n1.2 LASSO回归 在上述RSS损失函数公式中，添加L1范数(所有斜率值的绝对值和)。可通过λ参数控制惩罚的强度。 $$ J=\\sum_{i=1}^n(y_i-\\hat{y_i})^2 + \\lambda \\sum_{j=1}^p{|\\beta_j|} $$ 可结合下图理解：假设有两个预测变量，即有两个斜率参数。\n（1）红色同心圆表示不同参数值组合的MSE，中心值最小，越往外越大，黑色边表示相同MSE的等高线。\n（2）蓝色正方形边表示具有相同L1结果的不同参数值[r=|β1|+|β2|]，总会存在一组参数值对应的RSS最小（如下图所示）。\n1.3 弹性网络 （1） 岭回归与LASSO回归比较 如上公式岭回归与LASSO回归的最主要差异在于惩罚项L2范数与L1范数的区别。 $$ J_{L2}=\\sum_{i=1}^n(y_i-\\hat{y_i})^2 + \\lambda \\sum_{j=1}^p{\\beta_j^2} $$\n$$ J_{L1}=\\sum_{i=1}^n(y_i-\\hat{y_i})^2 + \\lambda \\sum_{j=1}^p{|\\beta_j|} $$\n当λ=0时，等价于不加入惩罚项，取一组参数值使RRS值最小即可；\n当λ\u0026gt;0时，岭回归加入了L2范数，LASSO回归加入了L1范数；虽然计算方式不同，但都与斜率值参数偏离0的程度呈正比。\n当λ值不断增大时，惩罚项的权重不断增高；从而导致通过缩小斜率参数值使得损失函数总值下降的收益就越大。\n换言之考虑惩罚项下降的强度与RRS项增高的强度，此时斜率参数值越接近0越好； 考虑到LASSO回归与岭回归形状的不同，LASSO能够将小的参数值缩小至0，即在模型中删除该变量，从而实现了特征选择的目的。 （2）弹性网络 弹性网络中同时包含L2与L1正则化，通过α参数控制L2范数和L1范数的权重。所以在弹性网络中会有两个超参数。\n如下公式\nα=0时，L1范数=0，即为岭回归；α=1时，L2范数=0，即为LASSO回归\n0\u0026lt;α\u0026lt;1时，得到岭回归与LASSO回归的组合。\n$$ J_{Net} = \\sum_{i=1}^n(y_i-\\hat{y_i})^2 + \\lambda { (1-\\alpha)\\sum_{j=1}^p{\\beta_j^2} + \\alpha \\sum_{j=1}^p{|\\beta_j|} } $$\n2、mlr建模 示例数据：小麦年产量 目的：根据第1~9列的预测变量信息预测小麦的产量 根据mlr包提供的\u0026quot;regr.glmnet\u0026quot;方法，进行三种正则化建模。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 library(mlr3verse) library(tidyverse) data(Iowa, package = \u0026#34;lasso2\u0026#34;) head(Iowa) # Year Rain0 Temp1 Rain1 Temp2 Rain2 Temp3 Rain3 Temp4 Yield # 1 1930 17.75 60.2 5.83 69.0 1.49 77.9 2.42 74.4 34.0 # 2 1931 14.76 57.5 3.83 75.0 2.72 77.2 3.30 72.6 32.9 # 3 1932 27.99 62.3 5.17 72.0 3.12 75.8 7.10 72.2 43.0 # 4 1933 16.76 60.5 1.64 77.8 3.45 76.4 3.01 70.5 40.0 # 5 1934 11.36 69.5 3.49 77.2 3.85 79.7 2.84 73.4 23.0 # 6 1935 22.71 55.0 7.00 65.9 3.35 79.4 2.42 73.6 38.4 ##第10列为小麦的产量 ##其余列为小麦生长不同阶段的天气情况 task_regr = as_task_regr(Iowa, target = \u0026#34;Yield\u0026#34;) 目的：根据第1~9列的预测变量信息预测小麦的产量 2.1 岭回归 2.1.1 确定训练方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ##(1)定义学习器 learner = lrn(\u0026#34;regr.glmnet\u0026#34;) learner$param_set learner$param_set$values$alpha = 0 # getParamSet(ridge) # 默认对数据进行标准化，以避免不同尺度的斜率参数的差异影响 ##(2)定义超参数空间：s即为λ，控制惩罚项的权重 search_space = ps( s = p_dbl(lower = 0, upper = 20) ) design = data.frame(s = seq(0, 20, 0.5)) %\u0026gt;% as.data.table() ##(3)交叉验证/评价指标 resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;regr.mse\u0026#34;) 2.1.2 选取最优超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 instance = TuningInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) tuner$optimize(instance) #历史记录 as.data.table(instance$archive)[,1:2] %\u0026gt;% head() # s regr.mse # 1: 0.0 112.04095 # 2: 0.5 112.04095 # 3: 1.0 112.15121 # 4: 1.5 106.14823 # 5: 2.0 101.21156 # 6: 2.5 97.64488 #最优超参数结果 instance$result_learner_param_vals # $family # [1] \u0026#34;gaussian\u0026#34; # $alpha # [1] 0 # $s # [1] 4 instance$result_y #regr.mse #93.12861 #可视化 as.data.table(instance$archive)[,1:2] %\u0026gt;% ggplot(aes(x = s, y = regr.mse)) + geom_line() + geom_point() 2.1.3 训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ##训练模型 learner$param_set$values = instance$result_learner_param_vals learner$train(task_regr) ##查看模型结果 learner$model coef(learner$model, s = learner$param_set$values$s) # 10 x 1 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # s1 # (Intercept) -1.047533e+03 # Rain0 4.109633e-01 # Rain1 -7.624006e-01 # Rain2 2.046984e+00 # Rain3 6.438645e-01 # Temp1 -2.795682e-01 # Temp2 9.716923e-02 # Temp3 -5.171002e-01 # Temp4 -5.040869e-01 # Year 6.010389e-01 plot(learner$model, xvar = \u0026#34;lambda\u0026#34;, label = TRUE) 之前提及\u0026quot;regr.glmnet\u0026quot;会自动标准化，在计算斜率时则会自动转为变量原来的尺度。\n2.2 lasso回归 2.2.1 确定训练方法 除了定义学习器时，alpha参数改为1，其它保持不变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ##(1)定义学习器 learner = lrn(\u0026#34;regr.glmnet\u0026#34;) learner$param_set learner$param_set$values$alpha = 1 # getParamSet(ridge) # 默认对数据进行标准化，以避免不同尺度的斜率参数的差异影响 ##(2)定义超参数空间：s即为λ，控制惩罚项的权重 search_space = ps( s = p_dbl(lower = 0, upper = 20) ) design = data.frame(s = seq(0, 20, 0.5)) %\u0026gt;% as.data.table() ##(3)交叉验证/评价指标 resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;regr.mse\u0026#34;) 2.2.2 选取最优超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 instance = TuningInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) tuner$optimize(instance) #历史记录 as.data.table(instance$archive)[,1:2] %\u0026gt;% head() # s regr.mse # 1: 0.0 114.64266 # 2: 0.5 89.90857 # 3: 1.0 81.79360 # 4: 1.5 81.73846 # 5: 2.0 86.30311 # 6: 2.5 89.77685 #最优超参数结果 instance$result_learner_param_vals # $family # [1] \u0026#34;gaussian\u0026#34; # $alpha # [1] 1 # $s # [1] 1 instance$result_y #regr.mse #81.56699 #可视化 as.data.table(instance$archive)[,1:2] %\u0026gt;% ggplot(aes(x = s, y = regr.mse)) + geom_line() + geom_point() 2.2.3 训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ##训练模型 learner$param_set$values = instance$result_learner_param_vals learner$train(task_regr) ##查看模型结果 learner$model coef(learner$model, s = learner$param_set$values$s) # 10 x 1 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # s1 # (Intercept) -1421.9762963 # Rain0 0.3161326 # Rain1 . # Rain2 2.1528392 # Rain3 0.2956521 # Temp1 . # Temp2 . # Temp3 . # Temp4 -0.5843153 # Year 0.7707991 plot(learner$model, xvar = \u0026#34;lambda\u0026#34;, label = TRUE) 2.3 弹性网络 2.3.1 确定训练方法 1 2 3 4 5 6 7 8 9 10 11 12 13 ##(1)定义学习器 learner = lrn(\u0026#34;regr.glmnet\u0026#34;) learner$param_set #与上面两个不同的是，有两个超参数需要调节 search_space = ps( s = p_dbl(lower = 0, upper = 20), alpha = p_dbl(lower = 0, upper = 1) ) design = expand.grid(alpha = seq(0, 1, 0.2), s = seq(0, 20, 0.5)) %\u0026gt;% as.data.table() resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;regr.mse\u0026#34;) 2.3.2 选取最优超参数组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 instance = TuningInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) tuner$optimize(instance) as.data.table(instance$archive)[,1:3] %\u0026gt;% head() # s alpha regr.mse # 1: 0 0.0 92.62672 # 2: 0 0.2 97.45767 # 3: 0 0.4 97.34487 # 4: 0 0.6 97.28724 # 5: 0 0.8 97.24310 # 6: 0 1.0 97.24670 instance$result_learner_param_vals # $family # [1] \u0026#34;gaussian\u0026#34; # $s # [1] 1 # $alpha # [1] 1 instance$result_y #regr.mse #89.67037 2.3.3 训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ##训练模型 learner$param_set$values = instance$result_learner_param_vals learner$train(task_regr) ##查看模型结果 learner$model coef(learner$model, s = learner$param_set$values$s) # 10 x 1 sparse Matrix of class \u0026#34;dgCMatrix\u0026#34; # s1 # (Intercept) -1421.9762963 # Rain0 0.3161326 # Rain1 . # Rain2 2.1528392 # Rain3 0.2956521 # Temp1 . # Temp2 . # Temp3 . # Temp4 -0.5843153 # Year 0.7707991 plot(learner$model, xvar = \u0026#34;lambda\u0026#34;, label = TRUE) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/109%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr310--%E5%9B%9E%E5%BD%92--%E5%B2%AD%E5%9B%9E%E5%BD%92+lasson%E5%9B%9E%E5%BD%92+%E5%BC%B9%E6%80%A7%E7%BD%91%E7%BB%9C/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在建立通用线性模型时，当模型参数即\u003cstrong\u003e斜率值绝对值\u003c/strong\u003e过大时，容易存在过拟合的风险。可通过下面介绍的3种\u003cstrong\u003e正则化\u003c/strong\u003e方法将每个预测变量的斜率参数缩小为0或者接近0。\n$$\ny = \\beta_0 + \\beta_1x_1 +  \\beta_2x_2 + \u0026hellip;+\\beta_kx_k + \\epsilon\n$$\u003c/p\u003e","title":"机器学习基于R包mlr3(10)--回归--岭回归+LASSO回归+弹性网络"},{"content":" 题目：The landscape of immune dysregulation in Crohn’s disease revealed through single-cell transcriptomic profiling in the ileum and colon\n期刊 | 时间：Immunity | January 30, 2023\nDOI：https://doi.org/10.1016/j.immuni.2023.01.002\n概述：该文章对上百个样本进行了单细胞测序，得到了72w个单细胞表达数据。样本类型涉及不同临床状态、组织部位；经细胞注释涉及三大类细胞类型（上皮，基质，免疫）。作者对此进行了多角度的分析，例如细胞比例的差异与基因表达的差异性等。文章中提及的分析方法与工具对单细胞数据进阶分析提供参考。最后测序数据与样本信息以上传至Broad Single Cell Portal (SCP1884，https://singlecell.broadinstitute.org/single_cell/study/SCP1884/human-cd-atlas-study-between-colon-and-terminal-ileum)\n相关缩略词\ninflammatory bowel diseases ：IBDs 炎症性肠病\nulcerative colitis ：UC 溃疡性结肠炎\nCrohn’s disease ：CD 克罗恩病\nterminal ileum ：TI 回肠末端\ncolon ：CO 结肠\nepithelial layer ：E 上皮层\nlamina propria layer ：L 固有层\n1、测序数据 （1）共对来自46例CD病人，25例non-IBD的136个组织样本进行单细胞测序；\n（2）样本可按如下两类情况进行分组\n根据组织状态，可分为CD inflamed、CD non-inflamed、non-IBD healthy 共三组 根据组织部位，可分为回肠末端TI与结肠CO 共两组 （3）大部分样本单独取自组织的上皮层(E)或者固有层(L)，少数样本取自混合层(N)\n2、细胞类型注释 根据cell-type markers，首先注释出3种主要的细胞类型：Immune，Epithelial，Stromal；然后进一步注释出共65种细胞亚类。\nTable S2详细列出了注释上述细胞类型所使用的marker genes。\n3、细胞比例差异 首先对两个组织部位(TI/CO)的细胞组成比例在不同疾病状态下的变化展开分析\n（1）经Principal coordinates analysis(R包vegan)，发现影响样本细胞组成的最大因素是取样方法，其次是组织状态/部位；\n（2）使用Dirichlet regression(R包Dirichlet)，去除取样组织对细胞组成的影响，以分析特定部位下的不同状态样本细胞类型占比的差异。\n（3）结合存在显著差异的细胞类型展开生物学讨论。例如与上皮细胞相比，免疫细胞与基质细胞在两种部位中的不同状态下都发生较大的重构。\n4、基因表达差异 4.1 IBD风险基因 计算已知的IBD风险基因在不同组织部位的不同细胞类型的特异性表达，使用基尼系数(Gini coefficient)评价表达的特异性。 与健康状态相比，其它状态的不同细胞类型表达特定风险基因的比例差异。（如下图：一个点表示一种细胞类型对于某基因的表达比例，横、纵坐标分别表示不同状态） 4.2 MAST差异分析 使用MAST模型校正混杂因素后，分析每种组织部位里，inflamed与healthy相比的不同细胞类型的差异基因。\n（1）首先分别统计上调与下调的基因数目； （2）分析两种组织部位不同细胞类型差异表达的一致性； （3）通过KEGG的GSEA分析(R包fgsea)，发现在不同组织部位的三大类细胞类型中显著上调或下调的通路。（如下图的横坐标理解为每大类细胞类型中细胞亚类比例） 之后文章重点分析两类基因(MHC class II与细胞表面黏蛋白分子)的差异性表达(两个维度：不同状态，不同部位)展开生物学讨论。\n5、 稀有细胞类型分析 肠内分泌细胞(Enteroendocrine cells, EECs)在肠道免疫发挥重要作用，但由于占比很低，一般难以分析；\n经marker基因鉴定(CHGA,CHGB)，在TI的上皮细胞群中发现了670个EECs，并进一步分为8个亚群； 分析每个亚群里不同样本、不同状态的组成比例； 对其中两个占比较高的亚群，分析不同状态下的差异基因及其生物学意义。 6、肌成纤维细胞分析 在两个肌成纤维细胞亚型中(HHIP+NPNT+ and GREM1+GREM2+)，前者在TI的inflammed状态下扩增，并展开如下分析：\n（1）HHIP+NPNT+亚型高表达胶原蛋白相关基因；GREM1+GREM2+亚型却低表达； （2）通过拟时序分析发现驱动GREM1+GREM2+型向HHIP+NPNT+型转换的关键基因 （3）挑选出具有转录调控作用的16个轨迹发育相关基因，在人类正常肠道成纤维细胞系中做siRNA干扰实验，以做进一步验证与筛选。\n","permalink":"https://lishensuo.github.io/en/posts/basic/110%E6%96%87%E7%8C%AE--%E5%85%8B%E7%BD%97%E6%81%A9%E8%82%A0%E7%82%8E%E7%96%BE%E7%97%85%E7%9A%84%E5%A4%A7%E5%9E%8B%E5%8D%95%E7%BB%86%E8%83%9E%E5%9B%BE%E8%B0%B1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：The landscape of immune dysregulation in Crohn’s disease revealed through single-cell transcriptomic profiling in the ileum and colon\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊 | 时间\u003c/strong\u003e：Immunity | January 30, 2023\u003c/p\u003e\n\u003cp\u003eDOI：https://doi.org/10.1016/j.immuni.2023.01.002\u003c/p\u003e","title":"文献--克罗恩肠炎疾病的大型单细胞图谱"},{"content":" 1 2 library(mlr3verse) library(tidyverse) 0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 data(Iowa, package = \u0026#34;lasso2\u0026#34;) head(Iowa) # Year Rain0 Temp1 Rain1 Temp2 Rain2 Temp3 Rain3 Temp4 Yield # 1 1930 17.75 60.2 5.83 69.0 1.49 77.9 2.42 74.4 34.0 # 2 1931 14.76 57.5 3.83 75.0 2.72 77.2 3.30 72.6 32.9 # 3 1932 27.99 62.3 5.17 72.0 3.12 75.8 7.10 72.2 43.0 # 4 1933 16.76 60.5 1.64 77.8 3.45 76.4 3.01 70.5 40.0 # 5 1934 11.36 69.5 3.49 77.2 3.85 79.7 2.84 73.4 23.0 # 6 1935 22.71 55.0 7.00 65.9 3.35 79.4 2.42 73.6 38.4 ##第10列为小麦的产量 ##其余列为小麦生长不同阶段的天气情况 task_regr = as_task_regr(Iowa, target = \u0026#34;Yield\u0026#34;) 1、KNN 基于KNN，解决分类任务的步骤之前已经学习过，可参考之前的学习笔记； 而用KNN解决回归问题与之十分类似，只是最后一步变为取k的最近样本的均值。(在分类问题中是取众数) 1.1 确定学习方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ##(1) 定义学习器 learner = lrn(\u0026#34;regr.kknn\u0026#34;) learner$param_set #主要参数为k #默认scale为TRUE，即对预测变量进行标准化 ##(2) 超参数 search_space = ps( k = p_int(lower = 3, upper = 15) ) design = data.frame(k = 3:15) %\u0026gt;% as.data.table() ##(3) 交叉验证与评价指标 resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;regr.mse\u0026#34;) 1.2 选出最优超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 instance = TuningInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) tuner$optimize(instance) #历史记录 as.data.table(instance$archive)[,1:2] %\u0026gt;% head() # k regr.mse # 1: 3 98.39484 # 2: 4 95.16022 # 3: 5 94.21570 # 4: 6 93.94832 # 5: 7 93.65615 # 6: 8 93.95614 #最优超参数结果 instance$result_learner_param_vals #$k #[1] 7 instance$result_y # regr.mse # 93.65615 1.3 训练最终模型 1 2 3 learner$param_set$values$k = instance$result_learner_param_vals$k learner$train(task_regr) learner$model 2、随机森林 由许多决策树组成的随机森林同样可以用于解决回归问题；\n在决策树解决分类问题时，每次决策节点选择哪一个预测变量是由其所能带来的最大基尼增益所决定的。\n在分类问题中，则是考虑划分所能带来的最小的残差平方和。具体来说对于每种划分，计算左右划分的残差平方和，相加，取最小值。\n其余步骤以及超参数与之前学习随机森林时基本相同。\n$$ S_{split} = \\sum_{i\\in left}(y_i-\\hat y_{left})^2 + \\sum_{i\\in right}(y_i-\\hat y_{right})^2 $$\n2.1 确定学习方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ##(1) 定义学习器 learner = lrn(\u0026#34;regr.ranger\u0026#34;) learner$param_set ##(2) 超参数 search_space = ps( num.trees = p_int(lower=1,upper=1000), mtry = p_int(lower=1,upper=9), min.node.size = p_dbl(lower=1, upper=5), max.depth = p_int(lower=1,upper=20) ) design = expand.grid(num.trees=c(300, 500, 1000), mtry=c(3, 6, 9), min.node.size=c(1,2,3,4,5), max.depth = c(3, 6, 9)) %\u0026gt;% as.data.table() ##(3) 交叉验证方法与模型评价指标 resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;regr.mse\u0026#34;) 2.2 选出最优超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ##创建实例 instance = TuningInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) ##优化超参数 future::plan(\u0026#34;multisession\u0026#34;) tuner$optimize(instance) as.data.table(instance$archive)[,1:5] # num.trees mtry min.node.size max.depth regr.mse # 1: 300 3 1 3 92.69975 # 2: 500 3 1 3 91.72947 # 3: 1000 3 1 3 92.48906 # 4: 300 6 1 3 74.97336 # 5: 500 6 1 3 76.96392 # --- # 210: 500 6 5 9 69.62499 # 211: 1000 6 5 9 71.07244 # 212: 300 9 5 9 63.80304 # 213: 500 9 5 9 63.28335 # 214: 1000 9 5 9 65.71797 instance$result_learner_param_vals # $num.threads # [1] 1 # $num.trees # [1] 500 # $mtry # [1] 9 # $min.node.size # [1] 2 # $max.depth # [1] 6 instance$result_y #regr.mse #60.97301 2.3 训练最终模型 1 2 3 learner$param_set$values = instance$result_learner_param_vals learner$train(task_regr) learner$model 3、XGBoost 由于还没有学习XGBoost应用于分类问题的原理与步骤，这里主要记录一下代码 3.1 确定学习方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ##(1) 定义学习器 learner = lrn(\u0026#34;regr.xgboost\u0026#34;) learner$param_set ##(2) 超参数 search_space = ps( eta = p_dbl(lower=0,upper=1), gamma = p_dbl(lower=1,upper=5), max_depth = p_int(lower = 1, upper = 10), min_child_weight = p_dbl(lower = 1, upper = 10), subsample = p_dbl(lower = 0.5, upper = 1), colsample_bytree = p_dbl(lower = 0.5, upper = 1), nrounds = p_int(lower = 1, upper = 50) ) design = expand.grid(eta = c(0.01, 0.1, 0.5), gamma = c(1, 3), max_depth=c(4, 8), min_child_weight = c(3, 6), subsample = c(0.6, 0.9), colsample_bytree = c(0.6, 0.9), nrounds = c(10, 20), stringsAsFactors = F) %\u0026gt;% as.data.table() ##(3) 交叉验证 resampling = rsmp(\u0026#34;cv\u0026#34;) measure = msr(\u0026#34;regr.mse\u0026#34;) 3.2 选出最优超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 instance = TuningInstanceSingleCrit$new( task = task_regr, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) future::plan(\u0026#34;multisession\u0026#34;) tuner$optimize(instance) ##最优超参数 instance$result_learner_param_vals # $nrounds # [1] 20 # $nthread # [1] 1 # $verbose # [1] 0 # $eta # [1] 0.5 # $gamma # [1] 1 # $max_depth # [1] 8 # $min_child_weight # [1] 3 # $subsample # [1] 0.9 # $colsample_bytree # [1] 0.9 instance$result_y # regr.mse # 54.71813 3.3 训练最终模型 1 2 3 learner$param_set$values = instance$result_learner_param_vals learner$train(task_regr) learner$model ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/110%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr311--%E5%9B%9E%E5%BD%92--knn+%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97+xgboost/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(mlr3verse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"0示例数据\"\u003e0、示例数据\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(Iowa, package = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;lasso2\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(Iowa)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Year Rain0 Temp1 Rain1 Temp2 Rain2 Temp3 Rain3 Temp4 Yield\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 1930 17.75  60.2  5.83  69.0  1.49  77.9  2.42  74.4  34.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 1931 14.76  57.5  3.83  75.0  2.72  77.2  3.30  72.6  32.9\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 1932 27.99  62.3  5.17  72.0  3.12  75.8  7.10  72.2  43.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4 1933 16.76  60.5  1.64  77.8  3.45  76.4  3.01  70.5  40.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5 1934 11.36  69.5  3.49  77.2  3.85  79.7  2.84  73.4  23.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 1935 22.71  55.0  7.00  65.9  3.35  79.4  2.42  73.6  38.4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##第10列为小麦的产量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##其余列为小麦生长不同阶段的天气情况\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etask_regr = as_task_regr(Iowa, target = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Yield\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1knn\"\u003e1、KNN\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e基于KNN，解决分类任务的步骤之前已经学习过，可参考之前的学习笔记；\u003c/li\u003e\n\u003cli\u003e而用KNN解决回归问题与之十分类似，只是最后一步变为取\u003cstrong\u003ek的最近样本的均值\u003c/strong\u003e。(在分类问题中是取众数)\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"11-确定学习方法\"\u003e1.1 确定学习方法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) 定义学习器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner = lrn(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;regr.kknn\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$param_set\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#主要参数为k\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#默认scale为TRUE，即对预测变量进行标准化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2) 超参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esearch_space = ps(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  k = p_int(lower = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, upper = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edesign = data.frame(k = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e) %\u0026gt;% as.data.table()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(3) 交叉验证与评价指标\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eresampling = rsmp(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;cv\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emeasure = msr(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;regr.mse\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"12-选出最优超参数\"\u003e1.2 选出最优超参数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einstance = TuningInstanceSingleCrit$new(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  task = task_regr,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  learner = learner,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  resampling = resampling,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  measure = measure,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  terminator = trm(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  search_space = search_space\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etuner = tnr(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;design_points\u0026#34;\u003c/span\u003e, design = design)  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efuture::plan(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;multisession\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etuner$optimize(instance)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#历史记录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eas.data.table(instance$archive)[,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e] %\u0026gt;% head()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    k regr.mse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1: 3 98.39484\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2: 4 95.16022\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3: 5 94.21570\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4: 6 93.94832\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5: 7 93.65615\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6: 8 93.95614\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#最优超参数结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einstance$result_learner_param_vals \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#$k\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#[1] 7\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einstance$result_y\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# regr.mse \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 93.65615\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"13-训练最终模型\"\u003e1.3 训练最终模型\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$param_set$values$k = instance$result_learner_param_vals$k\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$train(task_regr)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearner$model\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2随机森林\"\u003e2、随机森林\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e由许多决策树组成的随机森林同样可以用于解决回归问题；\u003c/p\u003e","title":"机器学习基于R包mlr3(11)--回归--kNN+随机森林+XGBboost"},{"content":" 题目: Integrated analysis to identify the prognostic and immunotherapeutic roles of coagulation-associated gene signature in clear cell renal cell carcinoma\n期刊 | 日期：Frontiers in Immunology | 17 March 2023\nDOI：https://doi.org/10.3389/fimmu.2023.1107419\n凝血相关基因 coagulation-related genes,CRGs\n透明细胞肾细胞癌 clear cell renal cell carcinoma,ccRCC\n0、主要数据方面 TCGA-KIRC转录组数据 GSE159115单细胞数据(ccRCC+normal) CRGs来自MsigDB数据库(HALLMARK_COAGULATION, MALLMARK_ COMPLEMENT) 1、两个角度分析CRGs 1.1 差异基因分析 TCGA-KIRC中normal与tumor的DE CRGs(limma, P\u0026lt;0.05) scRNAseq中normal与tumor epi细胞群差异分析 使用SCEVAN软件区分肿瘤细胞 取上述二者的交集基因，共16个 1.2 样本亚群分型 使用CRGs将TCGA-KIRC样本首先分为4类，进一步合并为2类 ConsensusClusterPlus包 (maxK=7, reps=100, pItem=0.8, pFeature=1, distance=“manhattan”, clusterAlg=“pam”) 样本类群之间差异性 生存分析 通路分析\u0026ndash;ClueGO(Cytoscape) 免疫浸润分析\u0026ndash;ssGSEA 免疫治疗差异\u0026ndash;TCIA数据库 药物敏感度差异\u0026ndash;pRRophetic 2、诊断与预后模型 2.1 诊断模型 基于16个hub基因，分别使用LASSO与SVM方法识别ccRCC与normal(TCGA)间显著差异的基因组合 对得到的5个交集基因，先结合HPA数据库验证差异表达，在计算AUC指标评价 2.2 预后模型 将TCGA数据集分为训练集与测试集，再加一个外部测试集(E-MTAB-1980) 基于279个CRGs进行单变量cox回归分析，进而lasso回归，得到8个基因组合；根据权重系数计算riskscore 在每份数据集中，根据riskscore中位数分组进行生存差异分析，计算AUC指标 综合Riskscore以及Stage, Grade, Age，分析因素独立性，绘制综合诺模图，再次进行AUC评价。 文章最后一部分结合多个数据集，以及自己的湿实验(临床样本+细胞系)进一步证明了一个key CRG的差异表达。\n文章小结：属于是一类基因在一种肿瘤的分析套路。首先基于结合TCGA与scRNA-seq筛选hub基因，在结合lasso与svm筛选diagnostic gene。然后分别中TCGA亚群分析以及常规预后分析流程阐释CRGs的应用价值。部分数据分析手段以及可视化具有借鉴意义。\n","permalink":"https://lishensuo.github.io/en/posts/basic/111%E6%96%87%E7%8C%AE-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E8%82%BE%E7%99%8C%E4%B8%8E%E5%87%9D%E8%A1%80%E7%9B%B8%E5%85%B3%E5%9F%BA%E5%9B%A0/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e: Integrated analysis to identify the prognostic and immunotherapeutic roles of coagulation-associated gene signature in clear cell renal cell carcinoma\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊\u003c/strong\u003e | \u003cstrong\u003e日期\u003c/strong\u003e：Frontiers in Immunology | 17 March 2023\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.3389/fimmu.2023.1107419\u003c/p\u003e","title":"文献-数据挖掘-肾癌与凝血相关基因"},{"content":" 降维是指在保留尽可能多原始数据条件下，将许多变量(成百上千)转换为少数的、不相关的变量，从而有利于后序的数据分析与可视化。而主成分分析(PCA, Principal Component Analysis)是最常用的无监督降维算法。\n1、关于降维 1.1 高维数据的不利影响 （1）稀疏性 又称维数灾难， curse of dimensionality\n当同样样本量的数据在从一维变成二维，再到三维的过程中，样本逐渐变得稀疏。机器学习模型难以从中学习模式，相反较容易收到噪声影响（离群点）。\n（2）共线性 当变量越来越多时，更容易出现具有不同程度相关性的样本。\n当两个变量高相关时，则称这两个变量具有共线性；当存在两个以上变量相关时，称具有多重共线性。\n共线性的出现会对某些机器学习算法产生负面影响，主要是对线性回归的参数估计有不利影响。但如果主要关注预测精度，共线性则不是大问题。\n1.2 最大化方差的PCA 基于方差最大化的PCA降维聚类方法可有效解决高维度数据所带来的的不利影响\n1.2.1 步骤 （1）中心化/标准化 （1）中心化，又称Zero-centered，是指每个变量减去的所有样本均值。中心化处理后的变量均值等于0。 $$ x - \\overline{x} $$ （2）标准化，又称归一化Standardization/Normalization，是指在中心化的基础上进一步除以标准差。标准化后的变量均符合均值为0，方差为1的标准正态分布。即拥有相同的尺度。 $$ \\frac{x - \\overline{x}}{\\sigma} $$\n在PCA分析时，中心化是必要的。但是如果预测变量本身的尺度就相似，那么可以不进行标准化\n（2）寻找主成分 第一主成分方差最大化 首先先寻找第一主成分，需要满足两个条件：①穿过原点；②样本点投影到轴上的方差最大。\n第二个条件很重要，含方差分解的思想，找出能够尽可能多解释数据总方差的潜在变量。这些潜在变量(主成分)实际上是预测变量的线性组合。 $$ C_i = w_{i1}x_{1} + w_{i2}x_{2} + \u0026hellip; + w_{ip}x_{p} $$\n第二主成分正交不相关 然后继续寻找第二主成分，除了上述两个条件外，还需要满足第三条件③与上一个主成分轴相互垂直，从而得到一组彼此间不相关的主成分。\n重复上述步骤，直至选取至与原始变量数相同的主成分 一般来说，第一主成分能够解释最多的方差，其余主成分依次减小。\n（3）保留TopN主成分\u0026ndash;降维 基于上述找到的主成分轴，可以保留Top N个主成分，从而实现能够保留大部分数据信息的同时，达到降维的目的。而且这些主成分互不相关。\n关于N值的选择，有一些经验方法。\n①保留累计解释至少80%方差的主成分；\n②保留所有特征值大于等于1的主成分；\n③寻找elbow图中的拐点\u0026hellip;\n1.2.2 相关术语 特征值 原始样本点投影到该主成分的方差\n特征向量 Rotation 主成分的特征变量组合的权重值\n变量负载 每个原始变量与每个主成分之间的关联程度\n2、PCA实操 2.1 示例数据\u0026ndash;真伪钞票 如下包含100张真钞与100张假钞的特征数据 下面对这6个特征变量进行PCA降维 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 library(tidyverse) library(tidyverse) data(banknote, package = \u0026#34;mclust\u0026#34;) swissTib \u0026lt;- banknote head(swissTib) # Status Length Left Right Bottom Top Diagonal # 1 genuine 214.8 131.0 131.1 9.0 9.7 141.0 # 2 genuine 214.6 129.7 129.7 8.1 9.5 141.7 # 3 genuine 214.8 129.7 129.7 8.7 9.6 142.2 # 4 genuine 214.8 129.7 129.6 7.5 10.4 142.0 # 5 genuine 215.0 129.6 129.7 10.4 7.7 141.8 # 6 genuine 215.7 130.8 130.5 9.0 10.1 141.4 table(swissTib$Status) # counterfeit genuine # 100 100 2.2 PCA降维 使用stats包的prcomp()函数 根据数据特点，进行中心化或者标准化。如果原始变量具有相同的尺度可不必标准化。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #默认为center = TRUE, scale = FALSE pca \u0026lt;- dplyr::select(swissTib, -Status) %\u0026gt;% prcomp(center = TRUE, scale = TRUE) ##(1) 样本的主成分值 head(pca$x) # PC1 PC2 PC3 PC4 PC5 PC6 # [1,] -1.7430272 -1.64669605 -1.4201973 -2.7479691 0.003293759 0.60202200 # [2,] 2.2686248 0.53744461 -0.5313151 -0.6573558 -0.158171742 0.45654268 # [3,] 2.2717009 0.10740754 -0.7156191 -0.3408384 -0.453880889 -0.04532905 # [4,] 2.2778385 0.08743490 0.6041176 -0.3918255 -0.282913485 -0.05543875 # [5,] 2.6255397 -0.03909779 -3.1883837 0.4240168 -0.277502895 0.72026433 # [6,] -0.7565089 -3.08101359 -0.7845117 -0.5980322 0.192757017 -0.10529393 ##(2) 主成分的特征向量 pca$rotation # PC1 PC2 PC3 PC4 PC5 PC6 # Length 0.006987029 -0.81549497 0.01768066 0.5746173 -0.0587961 0.03105698 # Left -0.467758161 -0.34196711 -0.10338286 -0.3949225 0.6394961 -0.29774768 # Right -0.486678705 -0.25245860 -0.12347472 -0.4302783 -0.6140972 0.34915294 # Bottom -0.406758327 0.26622878 -0.58353831 0.4036735 -0.2154756 -0.46235361 # Top -0.367891118 0.09148667 0.78757147 0.1102267 -0.2198494 -0.41896754 # Diagonal 0.493458317 -0.27394074 -0.11387536 -0.3919305 -0.3401601 -0.63179849 ##(3) 主成分的特征值 summary(pca) # Importance of components: # PC1 PC2 PC3 PC4 PC5 PC6 # Standard deviation 1.7163 1.1305 0.9322 0.67065 0.51834 0.43460 # Proportion of Variance 0.4909 0.2130 0.1448 0.07496 0.04478 0.03148 # Cumulative Proportion 0.4909 0.7039 0.8488 0.92374 0.96852 1.00000 ##Standard deviation表示特征值的平方根 ##Proportion of Variance表示该主成分的方差解释占比 ##Cumulative Proportion表示累计方差解释占比 ##(4) 主成分的变量负载(与变量的相关性) = 特征向量 * 特征值的平方根 loadings = lapply(1:6, function(i){ pca$rotation[,i] * pca$sdev[i] }) %\u0026gt;% do.call(cbind, .) colnames(loadings) = colnames(pca$rotation) loadings # PC1 PC2 PC3 PC4 PC5 PC6 # Length 0.01199158 -0.9219364 0.01648225 0.38536590 -0.0304764 0.01349746 # Left -0.80279596 -0.3866019 -0.09637548 -0.26485400 0.3314768 -0.12940207 # Right -0.83526859 -0.2854104 -0.11510550 -0.28856524 -0.3183114 0.15174296 # Bottom -0.69810421 0.3009779 -0.54398559 0.27072283 -0.1116898 -0.20094033 # Top -0.63139786 0.1034278 0.73418921 0.07392333 -0.1139569 -0.18208461 # Diagonal 0.84690418 -0.3096965 -0.10615680 -0.26284740 -0.1763188 -0.27458160 2.3 可视化 主要使用factoextra包 1 2 library(patchwork) library(factoextra) （1） 主成分与原始变量 可视化出第一与第二主成分与每个原始变量的关系 1 2 3 p1 = fviz_pca_biplot(pca, label = \u0026#34;var\u0026#34;) p2 = fviz_pca_var(pca) p1 + p2 （2）主成分方差陡坡图 又常成为elbow图，可用于辅助判断保留主成分的个数 1 2 3 p1 = fviz_screeplot(pca, addlabels = TRUE, choice = \u0026#34;eigenvalue\u0026#34;) p2 = fviz_screeplot(pca, addlabels = TRUE, choice = \u0026#34;variance\u0026#34;) p1 + p2 （3） 样本的主成分值分布图 1 2 3 4 5 6 7 8 9 10 11 12 swissPca \u0026lt;- swissTib %\u0026gt;% mutate(PCA1 = pca$x[, 1], PCA2 = pca$x[, 2]) p1 = ggplot(swissPca, aes(PCA1, PCA2, col = Status)) + geom_point() + stat_ellipse() + theme_bw() p2 = fviz_pca_ind(pca, geom.ind = c(\u0026#34;point\u0026#34;), col.ind = swissTib$Status, addEllipses = TRUE) p1 + p2 2.4 预测新样本的主成分值 1 2 3 4 5 6 7 8 9 10 11 12 13 newBanknotes \u0026lt;- tibble( Length = c(214, 216), Left = c(130, 128), Right = c(132, 129), Bottom = c(12, 7), Top = c(12, 8), Diagonal = c(138, 142) ) newBanknotes predict(pca, newBanknotes) # PC1 PC2 PC3 PC4 PC5 PC6 # [1,] -4.729496 1.9989069 -0.1058105 -1.658777 -3.202514 1.623096 # [2,] 6.465758 -0.8918486 -0.8214539 3.468704 -1.837978 2.339436 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/111%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr312--%E9%99%8D%E7%BB%B4--pca/","summary":"\u003cblockquote\u003e\n\u003cp\u003e降维是指在保留尽可能多原始数据条件下，将许多变量(成百上千)转换为少数的、不相关的变量，从而有利于后序的数据分析与可视化。而主成分分析(PCA, Principal Component Analysis)是最常用的无监督降维算法。\u003c/p\u003e","title":"机器学习基于R包mlr3(12)--降维--PCA"},{"content":" 题目：BTG2 and SerpinB5, a novel gene pair to evaluate the prognosis of lung adenocarcinoma\n期刊 | 日期：Frontiers in Immunology | 17 March 2023\nDOI：https://doi.org/10.3389/fimmu.2023.1098700\n1、发现BTG2/SerpinB5 1.1 两次差异分析\nTCGA中539 tumor、 59 normal → 5169 DEGs\nGSE中6 tumor、6 cisplatin treated → 107 DEGs\nlimma包 \u0026ndash; P\u0026lt;0.01, |logFC|\u0026gt;1\n17个交集基因\n1.2 初步分析\nPPI互作分析 \u0026ndash; Cytoscape 两两相关性分析 差异方向分析 生存分析 http://gepia.cancer-pku.cn/ OS/PFS 泛癌分析\u0026ndash;差异表达 2、衍生多角度分析 均是两个基因分别独立展开分析\n2.1 临床指标分析\n年龄性别 N/M/T分期 独立因素与综合诺模图分析 2.2、通路网络分析\n单基因的共表达基因 两基因的共蛋白互作基因→通路富集分析 基因表达的GSEA分析 \u0026ndash; clusterProfiler lnc/miRNA网络分析 \u0026ndash; StarBase v3.0 database 两基因各自的miRNA取交集→下游的lncRNA 2.3、免疫微环境分析\n分析每个基因表达水平与下述指标的相关性或高低分组差异\nTME得分 \u0026ndash; ESTIMATE algorithm 免疫细胞比例 \u0026ndash; CIBERSORT 突变负荷 \u0026ndash; total count of somatic mutations 免疫治疗IPS \u0026ndash; https://tcia.at/home The Cancer Immunome Atlas (TCIA) A high IPS predicts a good response to anti-PD-1/PD-L1 therapy TIDE score \u0026ndash; TIDE algorithm 免疫检查点基因 3、外部数据集验证 GSE11969: 158→90 tumor / 5 normal 验证\n基因差异表达 生存分析 临床指标\u0026ndash;年龄性别分期 HPA验证蛋白表达\nqRT-PCR\n两个基因与cisplatin的分子对接 \u0026ndash; Autodock\n","permalink":"https://lishensuo.github.io/en/posts/basic/112%E6%96%87%E7%8C%AE-%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98-%E8%82%BA%E8%85%BA%E7%99%8C%E7%9B%B8%E5%85%B3%E5%9F%BA%E5%9B%A0%E5%AF%B9/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：BTG2 and SerpinB5, a novel gene pair to evaluate the prognosis of lung adenocarcinoma\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊  | 日期\u003c/strong\u003e：Frontiers in Immunology | 17 March 2023\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.3389/fimmu.2023.1098700\u003c/p\u003e","title":"文献-数据挖掘-肺腺癌相关基因对"},{"content":"算法简介 t-SNE 正态分布密度函数 ，其中σ表示标准差，μ表示均值\n第一步：计算高维空间中任意两样本点的欧几里得距离。\n第二步：对于任一特定节点，将其余节点与之的距离转换为以该节点为中心的正态分布的概率值。\n正态分布的标准差与该样本点周围数据的密度成反比，但是具体关系依赖perplex超参数。该值越大表明越关注数据的全局特征，反之越关注数据的局部结构。\n第三步：将对任一特点节点的其余节点概率处于它们的和，从而使得数据集中每个样本的概率总和为1。\n$$ 正态分布密度函数 \\quad f(x) = \\frac{1}{\\sigma \\sqrt{2\\pi}}exp(\\frac{-(x-\\mu)^2}{2\\sigma^2}) $$\n$$ 样本点j到点i的概率 \\quad P_{j|i} = \\frac{exp(-(||x_i-x_j||)^2 /2\\sigma_i^2)}{\\sum_{k\\neq i}exp(-(||x_i-x_j||)^2 /2\\sigma_i^2)} $$\n其中||Xi-Xj||表示高维空间中数据点i与数据点j的欧几里得距离\n如上以所以样本点均为中心样本进行正态分布密度转换之后，可以得到一个概率矩阵p，用以描述每个样本与其它样本的相似程度。\n在二维的空间中，对所有数据点重新排布。使用上述方法再次计算新的概率矩阵与q。使用损失函数KL散度评价两个概率矩阵的相似性。采用梯度下降的方法，不断迭代的、”移动“二维空间中数据点的位置，使得KL散度指标逐渐降低，直至达到预期水平。\nt-SNE中的t的含义是指在计算新的、二维空间中样本间的概率矩阵时，使用T分布将样本距离转换为概率值可以更好的兼容离群点的影响，识别出真正距离相近的样本。\nUMAP UMAP的思路与tSNE类似，将样本在高维空间中的距离转换到二维平面中。与tSNE不同的是UMAP采用了所谓流形的概念，测量流形中样本之间的距离。\n在学习流形时，有两个关键步骤\n（1）对于既定的样本点进行局部连接，扩展最近的样本（local_connectivity=1），这样可以确保不存在孤立的样本。\n（2）然后以局部连接样本为边界进行模糊扩展，确定近邻样本。可通过超参数设置，较大的值表示包含更多的近邻样本，更关注全局结构；反之更关注局部结构。\n计算如此得到的流形中，得到所有样本与近邻样本之间的距离。下一步将数据放在两个维度的流形中，并迭代地移动数据点，直至新流形中样本间的距离等于沿着原始高维流形中样本间的距离。损失函数为交叉熵。\n二者比较 （1）tSNE与UMAP相对于PCA均属于非线性降维方式，获得的二维平面新轴不能用原始变量直接解释\n（2）相比于tSNE，UMAP的具有更多的优势：计算开销小、同时保留了局部与全局结构；而且作为一种确定性算法，给定相同的输入可以给出相同的输出。\n（3）对于tSNE，关注的更多是局部结构，即聚为一类的数据点具有很好的相似性；但是不同聚类之间的距离并没有任何含义。\n（4）在实际分析时，往往先对高维数据进行PCA分析，然后对于保留的若干主成分再进行tSNE/UMAP降维\n代码实操 1 2 3 4 5 6 7 8 9 10 11 12 13 library(tidyverse) data(banknote, package = \u0026#34;mclust\u0026#34;) swissTib = as_tibble(banknote) # # A tibble: 6 x 7 # Status Length Left Right Bottom Top Diagonal # \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 genuine 215. 131 131. 9 9.7 141 # 2 genuine 215. 130. 130. 8.1 9.5 142. # 3 genuine 215. 130. 130. 8.7 9.6 142. # 4 genuine 215. 130. 130. 7.5 10.4 142 # 5 genuine 215 130. 130. 10.4 7.7 142. # 6 genuine 216. 131. 130. 9 10.1 141. dat = swissTib[,-1] 1、t-SNE 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 library(Rtsne) ?Rtsne ##(1) 相关参数[一般使用默认参数即可，这里主要了解一下] # perplexity = 30 # 5~50 值越大表示越保留全局特征（相对而言） # theta = 0. # 0~1 速度与精确度的平衡，越大越关注速度 # max_iter = 1000 # 迭代次数 # eta = 200 # 每次迭代，点移动的距离 # num_threads = 1 # 使用线程数 # pca = TRUE # 进行tSNE分析前，是否进行PCA分析 # initial_dims = 50 # 若进行PCA分析，保留的主成分数 # dims = 2 # 输出的tSNE维度数 ##(2) 示例分析 set.seed(123) #设置随机种子，确保分析结果的一致性 tsne.list = Rtsne(dat) tsne = tsne.list$Y %\u0026gt;% as.data.frame() colnames(tsne) = c(\u0026#34;tSNE_1\u0026#34;,\u0026#34;tSNE_2\u0026#34;) head(tsne) # tSNE_1 tSNE_2 # 1 -8.127869 5.0456539 # 2 -14.330835 4.5799939 # 3 -13.687125 5.9405066 # 4 -13.203127 -0.3737462 # 5 -12.773563 8.5912141 # 6 -8.431319 4.1007125 tsne$label = swissTib$Status ggplot(tsne, aes(x=tSNE_1,y=tSNE_2,color=label)) + geom_point() 2、UMAP 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 library(umap) ##(1) 查看默认参数 umap::umap.defaults # umap configuration parameters # n_neighbors: 15 #控制模糊搜索区域的半径，较大值的将包含更多的近邻样本，即更考虑全局结构 # n_components: 2 #输出维度数 # metric: euclidean #测量流形上样本的距离 # n_epochs: 200 #迭代次数 # input: data # init: spectral # min_dist: 0.1 # set_op_mix_ratio: 1 # local_connectivity: 1 # bandwidth: 1 # alpha: 1 # gamma: 1 # negative_sample_rate: 5 # a: NA # b: NA # spread: 1 # random_state: NA # transform_state: NA # knn: NA # knn_repeats: 1 # verbose: FALSE # umap_learn_args: NA ##(2) 示例分析 #不需要设定随机种子也能保证结果的一致性 umaps.list = umap(dat) umaps = umaps.list$layout %\u0026gt;% as.data.frame() colnames(umaps)=c(\u0026#34;UMAP_1\u0026#34;,\u0026#34;UMAP_2\u0026#34;) head(umaps) # UMAP_1 UMAP_2 # 1 1.407095 -4.126555 # 2 1.213177 -6.306884 # 3 1.980743 -6.008990 # 4 -1.303874 -6.129523 # 5 2.664741 -5.839394 # 6 1.355476 -4.351818 umaps$label = swissTib$Status ggplot(umaps, aes(x=UMAP_1, y=UMAP_2, color=label)) + geom_point() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/112%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr313--%E9%99%8D%E7%BB%B4t-sne%E4%B8%8Eumap/","summary":"\u003ch1 id=\"算法简介\"\u003e算法简介\u003c/h1\u003e\n\u003ch2 id=\"t-sne\"\u003et-SNE\u003c/h2\u003e\n\u003cp\u003e正态分布密度函数 ，其中σ表示标准差，μ表示均值\u003c/p\u003e\n\u003cp\u003e第一步：计算高维空间中任意两样本点的欧几里得距离。\u003c/p\u003e\n\u003cp\u003e第二步：对于任一特定节点，将其余节点与之的距离转换为以该节点为中心的正态分布的概率值。\u003c/p\u003e","title":"机器学习基于R包mlr3(13)--降维t-SNE与UMAP"},{"content":"1、算法简介 1.1 不同种K均值算法 k均值是常用的聚类算法之一。\n（1）首先需要预先定义样本集中存在多少种聚类（假设为k），即数据集中处在K个真正意义上的质心。\n（2）然后随机初始化k个质心，每个质心具有与样本数据相同维度的变量值。\n（3）最后通过不断迭代，使这些初始质心点向数据集中真正意义上的质心点处移动，直到得到预期的聚类结果，\nk-均值算法有多种实现形式，即不同的迭代方式。常见有如下几种\nLloyd方法 如下图所示\n（1）预设设定数据集样本可以聚为2类，随机初始化两个质心点。[如下图b]\n（2）计算所有样本与当前2个质心的距离，通常为欧几里得距离。\n（3）将样本分配给相距最近的质心所表示的聚类。[如下图c]\n（4）将每个质心放在聚类内样本的均值位置。[如下图d]\n（5）重复上述步骤（3）~（4），直到没有样本改变聚类或者达到最大迭代次数位置。[如下图e、f]\n由于涉及两点之间欧几里得距离的计算，需要先对数据进行归一化处理。下同\nMacQueen方法 （1）预设设定数据集样本可以聚为3类，随机初始化3个质心点。\n（2）计算所有样本与当前3个质心的距离，通常为欧几里得距离。\n（3）将样本分配给相距最近的质心所表示的聚类，然后将质心放到对应聚类的中心位置。\n（4）对于所有样本逐一完成下述操作\nA：计算样本与当前3个质心的距离； B：将样本分配给相距最近的质心所表示的聚类； C：如果样本改变聚类，更新有变动的聚类内的质心位置。 对于改变类别的样本，该样本的原聚类就缺失一个样本；而新聚类就增多一个样本。 （5）重复上述步骤（3）~（4），直到没有样本改变聚类或者达到最大迭代次数位置。\n如上Lloyd算法与Macqueen算法主要的区别在于更新、移动质心位置。\n前者是一次性给所有样本分配新聚类标签，然后更新所有质心位置； 后者是逐一给样本分配新聚类标签，然后逐一更新质心位置。 此外还有一种Hartigan-Wong算法基于最小化聚类误差平方和，更新、迭代质心的位置；相对来说，计算成本最高。\n1.2 聚类评价指标 聚类clusteing通常属于无监督学习。在优化超参数时，需要寻找一个能够度量聚类性能的指标。下面介绍其中两种常用的指标。\nDavies-Bouldin指标 核心是评价每个聚类与其它聚类的可区分性。\n（1）对于得到的K个聚类，计算每个聚类自身的散度，即聚类内样本到质心距离的均方差。用以评价聚类的分散程度S。\ni：k个聚类中的第i个聚类；Ti表示该聚类的样本点数；Ai表示该聚类的质心；Xj表示该聚类的第j个样本点坐标（多维）。\n$$ S_i = ( \\frac{1}{T_i} \\sum_{j=1}^{T_i}||X_j-A_i|| ) $$ （2）对于每个聚类，逐一进行如下计算\n① 计算特定聚类的质心与其余聚类质心的距离；\nAi与Aj聚类i与聚类j的质心，n表示每个数据点的维度（或者变量数）\n$$ M_{i,j} = ||A_i-A_j|| = (\\sum_{k=1}^{n}|a_{k,i}-a_{k,j}|^2)^{\\frac{1}{2}} $$\n数学符号 ：一对竖线|x|，内为实数，表示绝对值；一对双竖线||Ai - Aj||默认求L2范数，即两个向量对应每个元素平方和的平方根\n② 计算特定聚类与其余聚类的可分性R：分子\u0026ndash;两个聚类的散度和；分母\u0026ndash;两个聚类的质心距离。 该值越小，表示两个聚类的可分性越好。 $$ R_{i,j} = \\frac{S_i+S_j}{M_{i,j}} $$\n③ 取特定聚类与其余聚类可分性最差的结果，即为该聚类的间隔比率D。 $$ D_i=\\max_{j\\neq i}R_{i,j} $$ （3）计算所有聚类的间隔比率的平均值作为Davies-Bouldin index，用以评估聚类性能。、\nDB指标越小，聚类性能越好。 $$ DB=\\frac{1}{N}\\sum_{i=1}^{N}D_i $$\nsilhouette指标 又称轮廓系数，核心是评价每个样本的当前分类的性能。\n（1）计算特定样本i到所在聚类CI内其它样本的平均距离a。值越小，表明该样本越接近所在聚类。\n$$ a(i) = \\frac{1}{|C_I|-1}\\sum_{j\\in C_I,i\\neq j}d(i,j) $$\n（2）计算特点样本i到其它各个聚类内样本的平均距离b，取最小值。值越小，表明该样本越接近该聚类。 $$ b(i) = \\min_{J\\neq I} \\frac{1}{|C_J|}\\sum_{j\\in C_j}d(i,j) $$\n（3）据此计算样本i的轮廓系数s。\n越接近1（b大，a小），表明该样本当前所在的聚类越合适； 越接近-1（b小，a大），表明越不符合当前聚类。 $$ s(i) = \\frac{b(i)-a(i)}{max{a(i),b(i) }} $$ （4）最后取所有样本的轮廓系数的均值，作为该聚类性能的度量。\nsilhouette平均指标越大，表示聚类性能越好 此外还有pseudo-F指标类似于方差分析。计算两两聚类之间的F统计量：聚类之间的距离平方和(组间方差)与聚类内的距离平方和(组内方差)。pseudo-F值越大，表明两聚类间的可分性越好。\n1.3 超参数 关于K均值算法的超参数主要是聚类的K值。即对数据潜在的聚类数也不太确定时，可以遍历一定范围的K值，选择使得聚类性能指标最好的聚类。\n其次可选的超参数包括不同的K均值算法、最大迭代次数、随机初始质心组数\n（1）不同的K均值算法：包括如上所述的3种 （2）最大迭代次数。K均值迭代停止的条件有2个：要么没有样本改变聚类；要么已达到最大迭代次数。 （3）随机初始质心组数：在开始迭代前，通过初始化多组质心，选择初始聚类中平方误差和最小的质心组可有效降低需要迭代的次数。 2、mlr建模 1 2 library(mlr3verse) library(tidyverse) 2.1 细胞的4种基因表达量数据 1 2 3 4 5 6 7 8 9 10 11 data(GvHD, package = \u0026#34;mclust\u0026#34;) head(GvHD.control) # CD4 CD8b CD3 CD8 # 1 199 420 132 226 # 2 294 311 241 164 # 3 85 79 14 218 # 4 19 1 141 130 # 5 35 29 6 135 # 6 376 346 138 176 #由于涉及距离的计算，需要将数据归一化 gvhdScaled \u0026lt;- GvHD.control %\u0026gt;% scale() 2.2 确定聚类任务与训练方法 根据5种基因表达特征，使用k均值方法将细胞分为若干类 1 task_clust = as_task_clust(gvhdScaled) 确定需要遍历的超参数组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 learner = lrn(\u0026#34;clust.kmeans\u0026#34;) learner$param_set # \u0026lt;ParamSet\u0026gt; # id class lower upper nlevels default value # 1: centers ParamUty NA NA Inf 2 2 # 2: iter.max ParamInt 1 Inf Inf 10 # 3: algorithm ParamFct NA NA 4 Hartigan-Wong # 4: nstart ParamInt 1 Inf Inf 1 # 5: trace ParamInt 0 Inf Inf 0 # centers : 聚类数 # iter.max: 迭代次数 # nstart : 随机初始多少组质心 # algorithm : k均值算法 ##(1) 对于nstart、iter.max 建议先确定固定值 ##(2) 对于algorithm、centers可设置多个候选值组合。 search_space = ps( algorithm = p_fct(c(\u0026#34;Hartigan-Wong\u0026#34;, \u0026#34;Lloyd\u0026#34;, \u0026#34;MacQueen\u0026#34;)), centers = p_int(lower=3,upper=8), iter.max = p_int(lower=100,upper=100), nstart = p_int(lower=5,upper=5) ) design = expand.grid(algorithm = c(\u0026#34;Hartigan-Wong\u0026#34;, \u0026#34;Lloyd\u0026#34;, \u0026#34;MacQueen\u0026#34;), centers = 3:8, iter.max = 100, nstart = 5, stringsAsFactors = FALSE) %\u0026gt;% as.data.table() ## 交叉验证与评价指标 resampling = rsmp(\u0026#34;cv\u0026#34;) grep(\u0026#34;clust\u0026#34;,mlr_measures$keys(), value = T) # [1] \u0026#34;clust.ch\u0026#34; \u0026#34;clust.db\u0026#34; \u0026#34;clust.dunn\u0026#34; \u0026#34;clust.silhouette\u0026#34; \u0026#34;clust.wss\u0026#34; measure = msr(\u0026#34;clust.silhouette\u0026#34;) 2.3 优化超参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 ##创建实例 instance = TuningInstanceSingleCrit$new( task = task_clust, learner = learner, resampling = resampling, measure = measure, terminator = trm(\u0026#34;none\u0026#34;), search_space = search_space ) tuner = tnr(\u0026#34;design_points\u0026#34;, design = design) tuner$optimize(instance) as.data.table(instance$archive)[,1:5] %\u0026gt;% head() # algorithm centers iter.max nstart clust.silhouette # 1: Hartigan-Wong 3 100 5 0.4529947 # 2: Lloyd 3 100 5 0.4678896 # 3: MacQueen 3 100 5 0.4680556 # 4: Hartigan-Wong 4 100 5 0.4944346 # 5: Lloyd 4 100 5 0.4943383 # 6: MacQueen 4 100 5 0.4944346 instance$result_learner_param_vals #最佳超参数 # $centers # [1] 4 # $algorithm # [1] \u0026#34;Hartigan-Wong\u0026#34; # $iter.max # [1] 100 # $nstart # [1] 5 instance$result_y #最佳超参数的CV结果 # clust.silhouette # 0.4944346 2.4 确定模型 1 2 3 learner$param_set$values = instance$result_learner_param_vals learner$train(task_clust) learner$model ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/113%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr314--%E8%81%9A%E7%B1%BB-k%E5%9D%87%E5%80%BC/","summary":"\u003ch1 id=\"1算法简介\"\u003e1、算法简介\u003c/h1\u003e\n\u003ch2 id=\"11-不同种k均值算法\"\u003e1.1 不同种K均值算法\u003c/h2\u003e\n\u003cp\u003ek均值是常用的聚类算法之一。\u003c/p\u003e\n\u003cp\u003e（1）首先需要预先定义样本集中存在多少种聚类（假设为k），即数据集中处在K个真正意义上的质心。\u003c/p\u003e\n\u003cp\u003e（2）然后随机初始化k个质心，每个质心具有与样本数据相同维度的变量值。\u003c/p\u003e","title":"机器学习基于R包mlr3(14)--聚类-k均值"},{"content":"1、层次聚类简介 1.1 计算步骤 层次聚类hierarchical clustering常用的是自下而上的聚合法(Agglomerative)。与之相对的是自顶而下的分裂法(Division)。\n以聚合法为例：最初将数据集中每个单独样本视为一个聚类\n（1）计算所有聚类两两之间的距离，通常为欧几里得距离。\n（2）将最相似(距离最近)的两个聚类合并成一个聚类。\n（3）重复上述步骤1、2，直至所有的所有样本都位于单个聚类中。\n1.2 聚类距离 计算聚类之间的距离，有如下方式可供选择\n质心链接：两聚类质心之间的距离； 单链接：两聚类最近样本之间的距离； 全链接：两聚类最远样本之间的距离； 均链接：两聚类所有样本之间距离的平均值； Ward方法： 首先计算每个聚类的类内距离平方和（类内方差） 然后对于所有聚类两两组合中，类内方差增加最少的组合方式。 1.3 树状图切割聚类 对于层次聚类的结果通常以树状图(dendrogram)的方式展示。如下左图表示原始样本的分布情况；右图表示层次聚类的结果\n水平线表示相应的两个聚类被合并在一起，而这两个聚类之间的距离对应水平线的高度。 层次聚类的优势在于保留了样本之间的层次结构，即样本与哪些样本更相似性，而又与哪些样本的关系比较远。\n如下示例，从层次聚类结果来看，样本C更接近DEF，与AB较远 基于层次聚类结果，确定样本聚类的划定方式就是在树状图使用水平线切割，有如下两种思路\n给定指定的距离进行切割； 给定指定的聚类数进行切割。 如上的聚类确定方式需要对数据集有预期的把握。如不确定，可比较不同的聚类结果的性能(上一节K均值算法中提到的聚类性能评价指标)，选择最优的聚类结果。\n2、代码实操 (1) 原始数据归一化 1 2 3 4 5 6 7 8 9 10 11 data(GvHD, package = \u0026#34;mclust\u0026#34;) gvhdTib \u0026lt;- GvHD.control # CD4 CD8b CD3 CD8 # 1 199 420 132 226 # 2 294 311 241 164 # 3 85 79 14 218 gvhdScaled \u0026lt;- gvhdTib %\u0026gt;% scale() # CD4 CD8b CD3 CD8 # 1 -0.4373389 0.8752503 -0.2166459 0.1832758 # 2 0.2595066 0.1289858 0.5752226 -0.3543201 # 3 -1.2735535 -1.4593936 -1.0738981 0.1139086 (2) 计算样本两两间距离 1 2 3 4 5 gvhdDist \u0026lt;- dist(gvhdScaled, method = \u0026#34;euclidean\u0026#34;) dim(gvhdDist) # [1] 6809 6809 # dist_mt = as.matrix(gvhdDist) # dist_mt[1:4,1:4] (3) 层次聚类 1 2 3 4 gvhdHclust \u0026lt;- hclust(gvhdDist, method = \u0026#34;ward.D2\u0026#34;) #可视化 plot(as.dendrogram(gvhdHclust), leaflab = \u0026#34;none\u0026#34;) (4) 确定聚类 1 2 3 4 5 6 7 8 gvhdCut \u0026lt;- cutree(gvhdHclust, k = 4) #也可使用 h= 参数指定切割的高度 gvhdTib \u0026lt;- mutate(gvhdTib, gvhdCut = as.factor(gvhdCut)) head(gvhdTib) table(gvhdTib$gvhdCut) # 1 2 3 4 # 4235 1339 580 655 rect.hclust(gvhdHclust, k = 4) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/114%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr315--%E8%81%9A%E7%B1%BB-%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB/","summary":"\u003ch1 id=\"1层次聚类简介\"\u003e1、层次聚类简介\u003c/h1\u003e\n\u003ch2 id=\"11-计算步骤\"\u003e1.1 计算步骤\u003c/h2\u003e\n\u003cp\u003e层次聚类hierarchical clustering常用的是自下而上的聚合法(Agglomerative)。与之相对的是自顶而下的分裂法(Division)。\u003c/p\u003e","title":"机器学习基于R包mlr3(15)--聚类-层次聚类"},{"content":"1、算法与工具简介 1.1 EM算法 EM， Expectation-Maximization 期望最大化算法\n混合分布：来自两种或两种以上概率分布(高斯分布最典型)的随机数据组成的一组混合数据所形成的分布。\n混合模型聚类：识别混合分布中，样本的原始分布，从而进行聚类(一种原始分布对应一个聚类)，属于软聚类。\n假设一组混合分布的30个数据，虚线为混合分布的概率密度。混合模型聚类的目的就是找到其中哪些样本属于红色分布类，哪些样本属于绿色分布类。\n（已知：其中10个来自红色正态分布，20个来自绿色正态分布。在计算时是不知道这一信息）\n后验概率(posterior probability)：样本属于某种特定分布的概率\n似然概率(likelihood probability)：在某种特定分布中观察到样本的概率\n先验概率(prior probability)：在混合样本中，属于某种特定分布的样本数目\n全概率：在混合样本中的概率密度\n根据贝叶斯公式 $$ 后验概率 = \\frac{似然概率×先验概率}{全概率} $$\n某一样本的全概率等于：红色正态分布中出现该样本的概率加上绿色正态分布中出现该样本的概率。 $$ x_i = p(x_i|k_红)×p(k_红) + p(x_i|k_绿)×p(k_绿) $$\n样本属于红色正态分布的概率 $$ p(k_{红}|x_i) = \\frac{p(x_i|k_红)×p(k_红)}{x_i} $$\n样本属于绿色正态分布的概率 $$ p(k_{绿}|x_i) = \\frac{p(x_i|k_绿)×p(k_绿)}{x_i} $$\n（1）首先假定混合分布中样本来自几种原始正态分布，这里假设为2。\n（2）初始化每种正态分布的特征参数(均值、方差)与先验概率(属于两种分布的样本比例)。\n（3）根据每种分布当前的特征参数，计算两种分布对于每个样本的似然概率。\n（4）参考贝叶斯公式计算出每个样本对于每种分布的后验概率。\n（5）根据每个样本属于每种分布的后验概率\n更新每种分布的参数(均值与方差)，以提高似然概率值； 简单来说将样本的后验概率作为权重，使得更新后的分布更接近“属于”(higher posterior probability)它的样本特征。 更新先验概率 如果有很多的样本对于特征分布有较高的后验概率，将具有较高的先验概率。 （6）重复步骤（3），如果总体似然概率的增幅小于预设的阈值(收敛)，则结束；否则继续执行步骤4、5、6，不断更新高斯分布，提高似然概率(最大化)。\n参考下图，EM算法主要分为两步：Expectation Step(对应上述步骤3、4)；Maximization Step(对应上述步骤5)\n1.2 mclust包 mclust包是基于EM算法实现混合分布聚类的常用R包，现在已经更新的5.4.10。\n官方示例教程：https://cran.r-project.org/web/packages/mclust/vignettes/mclust.html\n（1）在具体计算中，每一种Mclust模型结果由聚类数量与混合类型两个参数决定。其中混合类型表示：对于不同类型混合的高斯分布，使用3个字母组合表示14种特征的混合高斯分布。\n第一个字母：（1）E表示等体积，V表示不同体积； 第二个字母：（1）E表示等长径比，V表示不同长径比，I表示球形； 第三个字母：（1）I表示与轴方向正交，E表示不正交，V表示每个分布方向不同。 （2）对于不同Mclust模型的结果，可通过BIC(贝叶斯信息准则)指标进行比较。在模型的似然概率结果的基础上，进一步考虑模型的参数。如果模型中包含太多的参数，BIC就会对模型进行惩罚。\n简单来说在Mclust()结果中，特定模型的BIC指标越小，表示该模型性能越好。 2、R实操 2.1 多变量数据 （1）基础操作 示例数据：100张真钞与100张假钞的特征数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 library(mclust) data(banknote, package = \u0026#34;mclust\u0026#34;) table(banknote$Status) # counterfeit genuine # 100 100 swissTib \u0026lt;- select(banknote, -Status) #仅保留特征数据 dim(swissTib) # [1] 200 6 head(swissTib) # Length Left Right Bottom Top Diagonal # 1 214.8 131.0 131.1 9.0 9.7 141.0 # 2 214.6 129.7 129.7 8.1 9.5 141.7 # 3 214.8 129.7 129.7 8.7 9.6 142.2 # 4 214.8 129.7 129.6 7.5 10.4 142.0 # 5 215.0 129.6 129.7 10.4 7.7 141.8 # 6 215.7 130.8 130.5 9.0 10.1 141.4 在不设置其它参数的情况下，Mclust()默认计算1至9种聚类的14种混合类型的BIC指标结果； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 swissMclust \u0026lt;- Mclust(swissTib) ##(1) 结果概况 summary(swissMclust) # ---------------------------------------------------- # Gaussian finite mixture model fitted by EM algorithm # ---------------------------------------------------- # # Mclust VVE (ellipsoidal, equal orientation) model with 3 components: # # log-likelihood n df BIC ICL # -663.3814 200 53 -1607.574 -1607.71 # # Clustering table: # 1 2 3 # 18 98 84 #具体展示每种分布模型的分布特征 summary(swissMclust, parameters = TRUE) ##(2) 所有模型的BIC结果 dim(swissMclust$BIC) # [1] 9 14 ##(3) 最优模型的特征 swissMclust$G # [1] 3 swissMclust$modelName # [1] \u0026#34;VVE\u0026#34; ##(4) 模型计算结果可视化 #所有模型组合的BIC指标 plot(swissMclust, what = \u0026#34;BIC\u0026#34;) # plot(swissMclust, what = \u0026#34;classification\u0026#34;) # plot(swissMclust, what = \u0026#34;uncertainty\u0026#34;) # plot(swissMclust, what = \u0026#34;density\u0026#34;) （2）相关参数设置 限定聚类数量或者混合类型 1 2 3 4 5 6 7 8 9 10 11 12 swissMclust2 \u0026lt;- Mclust(swissTib, G=1:3, modelNames = \u0026#34;VVE\u0026#34;) summary(swissMclust2) swissMclust2$BIC # Bayesian Information Criterion (BIC): # VVE # 1 -1978.941 # 2 -1721.311 # 3 -1607.574 # # Top 3 models based on the BIC criterion: # VVE,3 VVE,2 VVE,1 # -1607.574 -1721.311 -1978.941 初始化设置 1 2 3 4 5 6 hc1 \u0026lt;- hc(swissTib, modelName = \u0026#34;VVV\u0026#34;, use = \u0026#34;SVD\u0026#34;) # hc2 \u0026lt;- hc(swissTib, modelName = \u0026#34;VVV\u0026#34;, use = \u0026#34;VARS\u0026#34;) # hc3 \u0026lt;- hc(swissTib, modelName = \u0026#34;EEE\u0026#34;, use = \u0026#34;SVD\u0026#34;) # swissMclust \u0026lt;- Mclust(swissTib, initialization = list(hcPairs = hc1)) #default swissMclust \u0026lt;- Mclust(swissTib, initialization = list(hcPairs = hc2)) summary(swissMclust) （3）Bootstrap法验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 bootClust \u0026lt;- MclustBootstrap(swissMclust) summary(bootClust, what = \u0026#34;ci\u0026#34;) # summary(bootClust, what = \u0026#34;se\u0026#34;) # plot(bootClust, what = \u0026#34;mean\u0026#34;) # plot(bootClust, what = \u0026#34;pro\u0026#34;) # ---------------------------------------------------------- # Resampling confidence intervals # ---------------------------------------------------------- # Model = VVE # Num. of mixture components = 3 # Replications = 999 # Type = nonparametric bootstrap # Confidence level = 0.95 # # Mixing probabilities: # 1 2 3 # 2.5% 0.05396204 0.4200456 0.3549896 # 97.5% 0.13491555 0.5550405 0.4852951 # .... 2.2 单变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 data(acidity) str(acidity) # num [1:155] 2.93 3.91 3.73 3.69 3.82 ... acidityMclust \u0026lt;- Mclust(acidity) summary(acidityMclust, parameters = TRUE) # ---------------------------------------------------- # Gaussian finite mixture model fitted by EM algorithm # ---------------------------------------------------- # # Mclust E (univariate, equal variance) model with 2 components: # # log-likelihood n df BIC ICL # -185.9493 155 4 -392.0723 -398.5554 # # Clustering table: # 1 2 # 98 57 # # Mixing probabilities: # 1 2 # 0.6233595 0.3766405 # # Means: # 1 2 # 4.370946 6.320153 # # Variances: # 1 2 # 0.1863702 0.1863702 table(acidityMclust$classification) # 1 2 # 98 57 plot(acidityMclust, what = \u0026#34;density\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/115%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Er%E5%8C%85mlr316--%E8%81%9A%E7%B1%BB-em%E6%B7%B7%E5%90%88%E5%88%86%E5%B8%83/","summary":"\u003ch1 id=\"1算法与工具简介\"\u003e1、算法与工具简介\u003c/h1\u003e\n\u003ch2 id=\"11-em算法\"\u003e1.1 EM算法\u003c/h2\u003e\n\u003cp\u003eEM， Expectation-Maximization 期望最大化算法\u003c/p\u003e\n\u003cp\u003e混合分布：来自两种或两种以上概率分布(高斯分布最典型)的随机数据组成的一组混合数据所形成的分布。\u003c/p\u003e\n\u003cp\u003e混合模型聚类：识别混合分布中，样本的原始分布，从而进行聚类(一种原始分布对应一个聚类)，属于\u003cstrong\u003e软聚类\u003c/strong\u003e。\u003c/p\u003e","title":"机器学习基于R包mlr3(16)--聚类-EM混合分布"},{"content":"一、数据预处理 1. 数据拆分 sklearn.model_selection.train_test_split() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from sklearn.datasets import load_wine from sklearn.model_selection import train_test_split import pandas as pd wine = load_wine() # 字典 feats = wine[\u0026#34;data\u0026#34;] feats_name = wine[\u0026#34;feature_names\u0026#34;] feats_df = pd.DataFrame(feats, columns=feats_name) targets = wine[\u0026#34;target\u0026#34;].reshape((-1,1)) #train_test_split()第一个参数是一个数据集或者多个数据集(行数相同) #数据集类型可以是pandas表格，numpy数组，甚至list列表 train_X, test_X = train_test_split(feats_df, test_size=0.2, random_state=42) train_X.shape, test_X.shape # ((142, 13), (36, 13)) train_X, test_X, train_y, test_y = train_test_split(feats_df, targets, test_size=0.2, random_state=42) train_X.shape, test_X.shape, train_y.shape, test_y.shape # (142, 13), (36, 13), (142, 1), (36, 1)) ##设置stratify参数，对某一分类文本列进行分层拆分数据集 train_X, test_X, train_y, test_y = train_test_split(feats_df, targets, test_size=0.2, random_state=42, stratify =targets) pd.DataFrame(train_y).value_counts(normalize=True) pd.DataFrame(test_y).value_counts(normalize=True) 2. 数据转换 fit\u0026ndash;transform流程，一般返回数组\n2.1 数值变量标准化 1 feats_df_num = feats_df.loc[:,feats_df.dtypes==\u0026#34;float\u0026#34;] 均值为0，方差为1的标准化 1 2 3 4 5 from sklearn.preprocessing import StandardScaler scale = StandardScaler() scale.fit_transform(feats_df_num) StandardScaler().fit_transform(feats_df_num) [0,1]的归一化 1 2 from sklearn.preprocessing import MinMaxScaler MinMaxScaler().fit_transform(feats_df_num) 2.2 分类变量编码 1 2 3 cate_df = pd.DataFrame({\u0026#34;feat-1\u0026#34;:[\u0026#34;A\u0026#34;,\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;], \u0026#34;feat-2\u0026#34;:[\u0026#34;Red\u0026#34;,\u0026#34;Blue\u0026#34;,\u0026#34;Pink\u0026#34;,\u0026#34;Black\u0026#34;]}) target_df = pd.DataFrame({\u0026#34;target\u0026#34;:[\u0026#34;survive\u0026#34;,\u0026#34;dead\u0026#34;,\u0026#34;dead\u0026#34;,\u0026#34;survive\u0026#34;,\u0026#34;unknown\u0026#34;]}) 标签编码 OrdinalEncoder针对二维数组，所以常用于特征编码\n1 2 3 4 5 6 from sklearn.preprocessing import OrdinalEncoder OrdinalEncoder().fit_transform(cate_df) # array([[0., 3.], # [0., 1.], # [1., 2.], # [2., 0.]]) LabelEncoder针对一维数组，所以常用于目标编码\n1 2 3 4 5 6 7 8 9 10 from sklearn.preprocessing import LabelEncoder LabelEncoder().fit_transform(target_df.values.ravel()) # array([1, 0, 0, 1, 2]) ##将标签返回原始类别 X = LabelEncoder().fit(target_df.values.ravel()) Xlabel = X.transform(target_df.values.ravel()) # 还原 X.inverse_transform(Xlabel) # array([\u0026#39;survive\u0026#39;, \u0026#39;dead\u0026#39;, \u0026#39;dead\u0026#39;, \u0026#39;survive\u0026#39;, \u0026#39;unknown\u0026#39;], dtype=object) 独热编码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from sklearn.preprocessing import OneHotEncoder OneHotEncoder().fit_transform(cate_df).toarray() # pd.get_dummies(cate_df) OneHotEncoder().fit_transform(target_df).toarray() # array([[0., 1., 0.], # [1., 0., 0.], # [1., 0., 0.], # [0., 1., 0.], # [0., 0., 1.]]) X = OneHotEncoder().fit(target_df) Xlabel = X.transform(target_df).toarray() # 还原 X.inverse_transform(Xlabel) # array([[\u0026#39;survive\u0026#39;], # [\u0026#39;dead\u0026#39;], # [\u0026#39;dead\u0026#39;], # [\u0026#39;survive\u0026#39;], # [\u0026#39;unknown\u0026#39;]], dtype=object) 2.3 NA值处理 1 2 3 4 5 6 7 8 9 feats_df_num = feats_df.loc[:,feats_df.dtypes==\u0026#34;float\u0026#34;] from sklearn.impute import SimpleImputer imputer = SimpleImputer(strategy=\u0026#34;median\u0026#34;) # \u0026#34;mean\u0026#34;, \u0026#34;median\u0026#34;, \u0026#34;most_frequent\u0026#34;, \u0026#34;constant\u0026#34; imputer.fit(feats_df_num) imputer.statistics_ imputer.transform(feats_df_num) #返回数组 # 一步到位 imputer.fit_transform(feats_df_num) 二、建模基础 如下以红酒数据集进行决策树分类预测为例，演示建模的一些基础操作。（树相关的决策树算法不需要数据预处理。）\n1 2 3 4 5 6 7 8 import pandas as pd from sklearn.datasets import load_wine from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split from sklearn.model_selection import cross_val_score from sklearn.model_selection import cross_validate from sklearn.model_selection import KFold from sklearn.model_selection import GridSearchCV 1. 加载、拆分数据 1 2 3 4 5 6 7 8 9 10 wine = load_wine() # 字典 feats = wine[\u0026#34;data\u0026#34;] feats_name = wine[\u0026#34;feature_names\u0026#34;] feats_df = pd.DataFrame(feats, columns=feats_name) targets = wine[\u0026#34;target\u0026#34;].reshape((-1,1)) feats_df.shape, targets.shape train_X, test_X, train_y, test_y = train_test_split(feats_df, targets, test_size=0.2, random_state=42) train_X.shape, test_X.shape, train_y.shape, test_y.shape 2. fit\u0026ndash;predict\u0026ndash;score三步走 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from sklearn.tree import DecisionTreeClassifier tree_classif = DecisionTreeClassifier() #模型实例化 #当前模型的参数 tree_classif.get_params() #模型拟合 tree_classif.fit(train_X, train_y) #模型预测 tree_classif.predict(train_X) #模型评价 tree_classif.score(train_X, train_y) from sklearn.metrics import f1_score predicts = tree_classif.predict(train_X) f1_score(y_test, predicts) #模型保存与加载 import joblib joblib.dump(tree_classif, \u0026#34;test_model.pkl\u0026#34;) my_model = joblib.load(\u0026#34;test_model.pkl\u0026#34;) 三、 关于二分类 机器学习可分为有监督与无监督两大类，而有监督又可分为回归与分类问题。\n其中分类问题又可以细分为二分类与多分类问题。\n一方面：二分类问题的评价指标更加多样，例如召回率、AUC值等\nhttps://scikit-learn.org/stable/modules/model_evaluation.html#function-for-prediction-error-metrics\n另一方面：有些分类器仅可以处理二分类问题(SVM、朴素贝叶斯等)，但可通过OvO或者OvR策略间接处理多分类问题。\n所以理论上sklearn分类器模型均可以处理二分类/多分类模型\n3.1 二分类示例 1 2 3 4 5 6 7 8 9 10 11 12 13 from sklearn.datasets import load_breast_cancer from collections import Counter from sklearn.model_selection import train_test_split bc_set = load_breast_cancer() Counter(bc_set.target) # Counter({0: 212, 1: 357}) X_train, X_test, y_train, y_test = train_test_split(bc_set.data, bc_set.target, test_size=0.2, random_state=42) from sklearn.linear_model import SGDClassifier sgd_clf.fit(X_train, y_train) y_test_predict = sgd_clf.predict(X_test) （1）二分类评价指标 相关二分类评价指标含义：https://lishensuo.github.io/posts/basic/005%E7%BB%9F%E8%AE%A1%E5%AD%A6%E5%9F%BA%E7%A1%80\u0026ndash;%E4%BA%8C%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_score, roc_auc_score, average_precision_score confusion_matrix(y_test, y_test_predict) precision_score(y_test, y_test_predict) recall_score(y_test, y_test_predict) f1_score(y_test, y_test_predict) roc_auc_score(y_test, y_test_predict) average_precision_score(y_test, y_test_predict) #绘制ROC、AUPR曲线 from sklearn.metrics import plot_roc_curve, plot_precision_recall_curve plot_roc_curve(sgd_clf, X_test, y_test) plot_precision_recall_curve(sgd_clf, X_test, y_test) （2）类别不均衡 例如在数据集中阳性标签样本数远远低于阴性标签数，此时可以提高阳性样本的权重，降低阴性样本的权重\n1 2 3 4 5 6 #方法1:在实例化模型时，为每个类别赋予权重 sgd_clf = SGDClassifier(class_weight=\u0026#34;balanced\u0026#34;) #方法2：在训练模型时，为每个样本赋予权重 sgd_clf = SGDClassifier() sgd_clf.fit(X_train, y_train, sample_weight=np.ones((len(y_train),))) 3.2 多分类问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from sklearn.datasets import load_iris iris_set = load_iris() Counter(iris_set.target) # Counter({0: 50, 1: 50, 2: 50}) from sklearn.svm import SVC svm_clf = SVC() # 参数 decision_function_shape : {\u0026#39;ovo\u0026#39;, \u0026#39;ovr\u0026#39;}, default=\u0026#39;ovr\u0026#39; svm_clf.fit(X_train, y_train) svm_clf.score(X_train, y_train) svm_clf.predict(X_test) # from sklearn.multiclass import OneVsOneClassifier # svm_clf = OneVsOneClassifier(SVC()) 3. 交叉验证 https://scikit-learn.org/stable/modules/model_evaluation.html#function-for-prediction-error-metrics\n1 2 3 4 5 6 7 8 9 scores = cross_val_score(tree_classif, train_X, train_y, scoring=\u0026#34;accuracy\u0026#34;, cv=10) scores.mean(), scores.std() # (0.8857142857142858, 0.09689042833036099) ## cross_validate用法基本同cross_val_score，优势在于可以指定多个评价指标 from sklearn.model_selection import cross_validate ## KFold可以自动生成k份互斥的训练集与测试集，并可以通过参数设置是否打乱。用以手动的交叉验证 from sklearn.model_selection import KFold 超参数优化 1 2 3 4 5 6 7 8 9 10 11 12 13 param_grid = {\u0026#34;max_depth\u0026#34;: [3, 5, 10], \u0026#34;min_samples_split\u0026#34;: [2, 4], \u0026#34;min_samples_leaf\u0026#34;: [1, 3]} grid_search = GridSearchCV(tree_classif, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;) grid_search.fit(train_X, train_y) grid_search.best_params_ grid_search.best_score_ grid_search.cv_results_[\u0026#34;mean_test_score\u0026#34;] best_tree_classif = grid_search.best_estimator_ best_tree_classif.score(test_X, test_y) 保存、加载模型 1 2 3 4 5 # 保存、加载模型 import joblib joblib.dump(best_tree_classif, \u0026#34;test_model.pkl\u0026#34;) my_model = joblib.load(\u0026#34;test_model.pkl\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/116%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Esklearn1--sklearn%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"一数据预处理\"\u003e一、数据预处理\u003c/h1\u003e\n\u003ch2 id=\"1-数据拆分\"\u003e1. 数据拆分\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003esklearn.model_selection.train_test_split()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.datasets \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e load_wine\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e train_test_split\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewine = load_wine() \u003cspan style=\"color:#007f7f\"\u003e# 字典\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efeats = wine[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efeats_name = wine[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;feature_names\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efeats_df = pd.DataFrame(feats, columns=feats_name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etargets = wine[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;target\u0026#34;\u003c/span\u003e].reshape((-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#train_test_split()第一个参数是一个数据集或者多个数据集(行数相同)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#数据集类型可以是pandas表格，numpy数组，甚至list列表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X, test_X = train_test_split(feats_df, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t\t\t   test_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e, random_state=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X.shape, test_X.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ((142, 13), (36, 13))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X, test_X, train_y, test_y = train_test_split(feats_df, targets, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t\t\t\t\t\t\t\ttest_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e, random_state=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X.shape, test_X.shape, train_y.shape, test_y.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (142, 13), (36, 13), (142, 1), (36, 1))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##设置stratify参数，对某一分类文本列进行分层拆分数据集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X, test_X, train_y, test_y = train_test_split(feats_df, targets, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t\t\t\t\t\t\t\ttest_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e, random_state=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t\t\t\t\t\t\t\tstratify =targets)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epd.DataFrame(train_y).value_counts(normalize=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epd.DataFrame(test_y).value_counts(normalize=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2-数据转换\"\u003e2. 数据转换\u003c/h2\u003e\n\u003cp\u003efit\u0026ndash;transform流程，一般返回数组\u003c/p\u003e","title":"机器学习基于sklearn(1)--sklearn基础"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import pandas as pd from sklearn.datasets import load_wine from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier tree_classif = DecisionTreeClassifier() wine = load_wine() # 字典 feats = wine[\u0026#34;data\u0026#34;] feats_name = wine[\u0026#34;feature_names\u0026#34;] feats_df = pd.DataFrame(feats, columns=feats_name) targets = wine[\u0026#34;target\u0026#34;].reshape((-1,1)) #feats_df.shape, targets.shape train_X, test_X, train_y, test_y = train_test_split(feats_df, targets, test_size=0.2, random_state=42) train_X.shape, test_X.shape, train_y.shape, test_y.shape # ((142, 13), (36, 13), (142, 1), (36, 1)) 一、交叉验证 https://scikit-learn.org/stable/modules/cross_validation.html\nhttps://scikit-learn.org/stable/modules/model_evaluation.html#scoring-parameter\n1.1 自动进行交叉验证 cross_val_score : 返回一维数组，记录每一折对应的单指标结果 1 2 3 4 5 6 from sklearn.model_selection import cross_val_score scores = cross_val_score(tree_classif, train_X, train_y, scoring=\u0026#34;accuracy\u0026#34;, cv=10) # array([0.93333333, 1. , 0.85714286, 0.85714286, 0.71428571, # 0.92857143, 0.78571429, 0.92857143, 1. , 0.85714286]) cross_validate : 返回一个字典，包括训练时间与计算指标两类结果。可以计算多个指标 1 2 3 4 5 from sklearn.model_selection import cross_validate scores = cross_validate(tree_classif, train_X, train_y, scoring=[\u0026#34;accuracy\u0026#34;,\u0026#34;f1_micro\u0026#34;], cv=10) scores.keys() # dict_keys([\u0026#39;fit_time\u0026#39;, \u0026#39;score_time\u0026#39;, \u0026#39;test_accuracy\u0026#39;, \u0026#39;test_f1_micro\u0026#39;]) 关于cv参数\n（1）如果不指定，默认为5折交叉验证。对于分类任务，使用StratifiedKFold；对于回归任务，使用KFold。\n（2）如果填写某一整数，则指定为K折交叉验证\n（3）可以是sklearn交叉验证索引生成器，参考下面1.2 KFold示例\n（4）自定义一个交叉验证索引迭代器， 参考下面1.2 KFold示例中的方式2\n1.2 生成训练集与验证集索引 KFold : 生成k折的互斥训练集与验证集索引 1 2 3 4 5 6 7 from sklearn.model_selection import KFold kf = KFold(n_splits=3, shuffle=True, random_state=42) for train_idx, test_idx in kf.split(train_X): print(f\u0026#34;train={len(train_idx)}, valid={len(test_idx)}\u0026#34;) # train=94, valid=48 # train=95, valid=47 # train=95, valid=47 与上述自动交叉验证相结合，等价于自定义交叉验证方式。\n在后面的超参数优化中，同样可以使用类似方式。\n1 2 3 4 5 6 ##方式1 cross_val_score(tree_classif, train_X, train_y, scoring=\u0026#34;accuracy\u0026#34;, cv=kf) ##方式2 cross_val_score(tree_classif, train_X, train_y, scoring=\u0026#34;accuracy\u0026#34;, cv=kf.split(train_X)) RepeatedKFold : 重复多次生成k折的互斥训练集与验证集索引 1 2 3 4 5 6 7 8 9 10 from sklearn.model_selection import RepeatedKFold rkf = RepeatedKFold(n_splits=3, n_repeats=2, random_state=42) for train_idx, test_idx in rkf.split(train_X): print(f\u0026#34;train={len(train_idx)}, valid={len(test_idx)}\u0026#34;) # train=94, valid=48 # train=95, valid=47 # train=95, valid=47 # train=94, valid=48 # train=95, valid=47 # train=95, valid=47 StratifiedKFold : 基于分层抽样原则，生成k折的互斥训练集与验证集索引 1 2 3 4 from sklearn.model_selection import StratifiedKFold skf = StratifiedKFold(n_splits=3, shuffle=True, random_state=42) for train_idx, test_idx in skf.split(train_X, train_y): #多一个参数，交代分层标准 print(f\u0026#34;train={len(train_idx)}, valid={len(test_idx)}\u0026#34;) GroupKFold：样本设计时已经分为若干组，在划分训练集与验证集时，确保同一组的样本位于同一类集合内。 1 2 3 4 5 6 from sklearn.model_selection import GroupKFold ##如下表示分组信息：假设每两个样本为一组 group = np.tile(np.array(range(int(train_X.shape[0]/2))), 2).reshape((-1,1)) gkf = GroupKFold(n_splits=5) for train_idx, test_idx in gkf.split(train_X, groups = group): #多一个参数，交代分组标准 print(f\u0026#34;train={len(train_idx)}, valid={len(test_idx)}\u0026#34;) 二、超参数优化 https://scikit-learn.org/stable/modules/grid_search.html\n2.1 网格搜索 GridSearchCV网格/暴力搜索，遍历所有参数组合 以字典形式设置超参数候选范围 cv设置交叉验证，scoring模型评价指标，可以有多个 refit设置是否使用最佳超参数直接拟合模型；默认为True；当有多个评价指标时，需指定其中一个为组合比较标准 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from sklearn.model_selection import GridSearchCV param_grid = {\u0026#34;max_depth\u0026#34;: [3, 5, 10], \u0026#34;min_samples_split\u0026#34;: [2, 4], \u0026#34;min_samples_leaf\u0026#34;: [1, 3]} grid_search = GridSearchCV(tree_classif, param_grid, cv=3, scoring=\u0026#34;accuracy\u0026#34;, refit=True, n_jobs=1) grid_search = GridSearchCV(tree_classif, param_grid, cv=3, scoring=[\u0026#34;accuracy\u0026#34;,\u0026#34;f1_micro\u0026#34;], #计算多个指标 refit=\u0026#34;accuracy\u0026#34;, #使用`accuracy`比较不同组超参数 n_jobs=-1) #使用全部可用线程 #遍历超参数拟合 grid_search.fit(train_X, train_y) #所有超参数的计算结果 pd.DataFrame(grid_search.cv_results_) #最优超参数的值与得分 grid_search.best_params_ grid_search.best_score_ #最优超参数模型 best_tree_classif = grid_search.best_estimator_ best_tree_classif.score(test_X, test_y) grid_search_cv_df = pd.DataFrame(grid_search.cv_results_) grid_search_cv_df.loc[:,[x.startswith((\u0026#34;mean\u0026#34;,\u0026#34;rank\u0026#34;,\u0026#34;params\u0026#34;)) for x in grid_search_cv_df.columns]] 2.2 随机搜索 RandomizedSearchCV ：除n_iter参数设置随机搜索的次数外，其余参数与上述相同 1 2 3 4 5 from sklearn.model_selection import RandomizedSearchCV random_search = RandomizedSearchCV(tree_classif, param_grid, n_iter = 10, cv=3, scoring=[\u0026#34;accuracy\u0026#34;,\u0026#34;f1_micro\u0026#34;], refit=\u0026#34;accuracy\u0026#34;, n_jobs=-1) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/117%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Esklearn2--%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E4%B8%8E%E8%B6%85%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.datasets \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e load_wine\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.preprocessing \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e StandardScaler\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e train_test_split\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.tree \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e DecisionTreeClassifier\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etree_classif = DecisionTreeClassifier()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewine = load_wine() \u003cspan style=\"color:#007f7f\"\u003e# 字典\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efeats = wine[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efeats_name = wine[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;feature_names\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efeats_df = pd.DataFrame(feats, columns=feats_name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etargets = wine[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;target\u0026#34;\u003c/span\u003e].reshape((-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#feats_df.shape, targets.shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X, test_X, train_y, test_y = train_test_split(feats_df, targets, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t\t\t\t\t\t\t\ttest_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e, random_state=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e42\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X.shape, test_X.shape, train_y.shape, test_y.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ((142, 13), (36, 13), (142, 1), (36, 1))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"一交叉验证\"\u003e一、交叉验证\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://scikit-learn.org/stable/modules/cross_validation.html\"\u003ehttps://scikit-learn.org/stable/modules/cross_validation.html\u003c/a\u003e\u003c/p\u003e","title":"机器学习基于sklearn(2)--交叉验证与超参数优化"},{"content":" 目的：演示常见几种分类器的使用方法，对其超参数调优候选超参数的选择\n0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.model_selection import cross_val_score from sklearn.model_selection import GridSearchCV iris = datasets.load_iris() iris_X, iris_y = iris.data, iris.target iris_X = StandardScaler().fit_transform(iris_X) train_X, test_X, train_y, test_y = train_test_split(iris_X, iris_y, test_size=0.3) train_X.shape, test_X.shape, train_y.shape, test_y.shape # ((105, 4), (45, 4), (105,), (45,)) 1、K近邻 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from sklearn.neighbors import KNeighborsClassifier model_knn = KNeighborsClassifier() param_grid = {\u0026#34;n_neighbors\u0026#34;: [3, 5, 7, 10, 20], \u0026#34;p\u0026#34;: [1, 2], \u0026#34;weights\u0026#34;: [\u0026#34;uniform\u0026#34;, \u0026#34;distance\u0026#34;]} grid_search = GridSearchCV(model_knn, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;, n_jobs=-1) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) knn_grid_search = grid_search # {\u0026#39;n_neighbors\u0026#39;: 10, \u0026#39;p\u0026#39;: 2, \u0026#39;weights\u0026#39;: \u0026#39;uniform\u0026#39;} # 0.9714285714285715 2、逻辑回归 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from sklearn.linear_model import LogisticRegression model_logistic = LogisticRegression() param_grid = [ {\u0026#39;penalty\u0026#39; : [\u0026#39;l1\u0026#39;, \u0026#39;l2\u0026#39;, \u0026#39;elasticnet\u0026#39;, \u0026#39;none\u0026#39;], \u0026#39;C\u0026#39; : [0.01, 0.1, 1, 10, 100], \u0026#39;solver\u0026#39; : [\u0026#39;lbfgs\u0026#39;,\u0026#39;newton-cg\u0026#39;,\u0026#39;liblinear\u0026#39;,\u0026#39;sag\u0026#39;,\u0026#39;saga\u0026#39;], \u0026#39;max_iter\u0026#39; : [1000] } ] grid_search = GridSearchCV(model_logistic, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;, n_jobs=1) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) logistic_grid_search = grid_search # {\u0026#39;C\u0026#39;: 10, \u0026#39;max_iter\u0026#39;: 1000, \u0026#39;penalty\u0026#39;: \u0026#39;l1\u0026#39;, \u0026#39;solver\u0026#39;: \u0026#39;saga\u0026#39;} # 0.980952380952381 3、贝叶斯算法 1 2 3 4 5 6 from sklearn.naive_bayes import GaussianNB model_bayes = GaussianNB() scores = cross_val_score(model_bayes, train_X, train_y, scoring=\u0026#34;accuracy\u0026#34;, cv=10) print(scores.mean()) # 0.96 bayes_cv = scores 4、支持向量机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from sklearn.svm import SVC model_svm = SVC() param_grid = [ {\u0026#39;C\u0026#39; : [0.01, 0.1, 1, 10, 100], \u0026#39;kernel\u0026#39; : [\u0026#39;linear\u0026#39;, \u0026#39;poly\u0026#39;, \u0026#39;rbf\u0026#39;, \u0026#39;sigmoid\u0026#39;], \u0026#39;gamma\u0026#39; : [\u0026#39;scale\u0026#39;,\u0026#39;auto\u0026#39;] } ] grid_search = GridSearchCV(model_svm, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;, n_jobs=1) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) svm_grid_search = grid_search # {\u0026#39;C\u0026#39;: 100, \u0026#39;gamma\u0026#39;: \u0026#39;scale\u0026#39;, \u0026#39;kernel\u0026#39;: \u0026#39;linear\u0026#39;} # 0.980952380952381 5、随机森林 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from sklearn.ensemble import RandomForestClassifier model_rf = RandomForestClassifier() param_grid = [ {\u0026#39;n_estimators\u0026#39; : [100, 200, 300, 500, 1000], \u0026#39;criterion\u0026#39; : [\u0026#39;gini\u0026#39;, \u0026#39;entropy\u0026#39;], \u0026#39;max_depth\u0026#39; : [4, 8, 16, 32], \u0026#39;max_features\u0026#39; : [\u0026#34;sqrt\u0026#34;, \u0026#34;log2\u0026#34;] } ] grid_search = GridSearchCV(model_rf, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;, n_jobs=10) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) rf_grid_search = grid_search # {\u0026#39;criterion\u0026#39;: \u0026#39;gini\u0026#39;, \u0026#39;max_depth\u0026#39;: 8, \u0026#39;max_features\u0026#39;: \u0026#39;sqrt\u0026#39;, \u0026#39;n_estimators\u0026#39;: 500} # 0.9523809523809523 6、梯度增加机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from sklearn.ensemble import GradientBoostingClassifier model_gbm = GradientBoostingClassifier() param_grid = [ {\u0026#39;learning_rate\u0026#39; : [0.001, 0.01, 0.1], \u0026#39;n_estimators\u0026#39; : [100, 200, 300, 500, 1000], \u0026#39;subsample\u0026#39; : [0.5, 0.7, 1], \u0026#39;criterion\u0026#39; : [\u0026#34;friedman_mse\u0026#34;, \u0026#34;squared_error\u0026#34;] } ] grid_search = GridSearchCV(model_gbm, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;, n_jobs=10) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) gbm_grid_search = grid_search # {\u0026#39;colsample_bytree\u0026#39;: 0.5, \u0026#39;learning_rate\u0026#39;: 0.01, \u0026#39;n_estimators\u0026#39;: 10, \u0026#39;subsample\u0026#39;: 0.5} # 0.9619047619047618 7、XGBoost 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from xgboost import XGBClassifier model_xgb = XGBClassifier() param_grid = [ {\u0026#39;n_estimators\u0026#39; : [10, 30, 50], \u0026#39;learning_rate\u0026#39; : [0.01, 0.1], \u0026#39;subsample\u0026#39; : [0.5, 0.7, 1], \u0026#39;colsample_bytree\u0026#39; : [0.5, 0.7, 1] } ] grid_search = GridSearchCV(model_xgb, param_grid, cv=5, scoring=\u0026#34;accuracy\u0026#34;, n_jobs=10) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) xgb_grid_search = grid_search # {\u0026#39;colsample_bytree\u0026#39;: 1, \u0026#39;learning_rate\u0026#39;: 0.01, \u0026#39;n_estimators\u0026#39;: 10, \u0026#39;subsample\u0026#39;: 0.5} # 0.9619047619047618 简单比较 1 2 3 4 5 6 7 8 9 10 import pandas as pd pd.DataFrame({ \u0026#34;KNN\u0026#34; : knn_grid_search.best_score_, \u0026#34;Logistic\u0026#34; : logistic_grid_search.best_score_, \u0026#34;Bayes\u0026#34; : bayes_cv.mean(), \u0026#34;SVM\u0026#34; : svm_grid_search.best_score_, \u0026#34;RF\u0026#34; : rf_grid_search.best_score_, \u0026#34;GBM\u0026#34; : gbm_grid_search.best_score_, \u0026#34;XGB\u0026#34; : xgb_grid_search.best_score_ }, index=[\u0026#34;score\u0026#34;]).T.plot.line() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/118%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Esklearn3--%E5%B8%B8%E8%A7%81%E5%88%86%E7%B1%BB%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e目的：演示常见几种分类器的使用方法，对其超参数调优候选超参数的选择\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"0示例数据\"\u003e0、示例数据\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e datasets\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e train_test_split\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.preprocessing \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e StandardScaler\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e cross_val_score\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e GridSearchCV\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eiris = datasets.load_iris()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eiris_X, iris_y = iris.data, iris.target\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eiris_X = StandardScaler().fit_transform(iris_X)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X, test_X, train_y, test_y = train_test_split(iris_X, iris_y, test_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X.shape, test_X.shape, train_y.shape, test_y.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ((105, 4), (45, 4), (105,), (45,))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1k近邻\"\u003e1、K近邻\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.neighbors \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e KNeighborsClassifier\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_knn = KNeighborsClassifier()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;n_neighbors\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;p\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;weights\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;uniform\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;distance\u0026#34;\u003c/span\u003e]}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_knn, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, n_jobs=-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eknn_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;n_neighbors\u0026#39;: 10, \u0026#39;p\u0026#39;: 2, \u0026#39;weights\u0026#39;: \u0026#39;uniform\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.9714285714285715\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2逻辑回归\"\u003e2、逻辑回归\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.linear_model \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e LogisticRegression\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_logistic = LogisticRegression()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;penalty\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;l1\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;l2\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;elasticnet\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;solver\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;lbfgs\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;newton-cg\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;liblinear\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;sag\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;saga\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;max_iter\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_logistic, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)          \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogistic_grid_search = grid_search \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;C\u0026#39;: 10, \u0026#39;max_iter\u0026#39;: 1000, \u0026#39;penalty\u0026#39;: \u0026#39;l1\u0026#39;, \u0026#39;solver\u0026#39;: \u0026#39;saga\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.980952380952381\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3贝叶斯算法\"\u003e3、贝叶斯算法\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.naive_bayes \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e GaussianNB\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_bayes = GaussianNB()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escores = cross_val_score(model_bayes, train_X, train_y, scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(scores.mean())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.96\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebayes_cv = scores\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"4支持向量机\"\u003e4、支持向量机\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.svm \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e SVC\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_svm = SVC()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;kernel\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;linear\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;poly\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;rbf\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;sigmoid\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;gamma\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;scale\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;auto\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_svm, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)      \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esvm_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;C\u0026#39;: 100, \u0026#39;gamma\u0026#39;: \u0026#39;scale\u0026#39;, \u0026#39;kernel\u0026#39;: \u0026#39;linear\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.980952380952381\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"5随机森林\"\u003e5、随机森林\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.ensemble \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e RandomForestClassifier\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_rf = RandomForestClassifier()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;n_estimators\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e300\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e500\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;criterion\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;gini\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;entropy\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;max_depth\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e16\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e32\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;max_features\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;sqrt\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;log2\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_rf, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)   \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erf_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;criterion\u0026#39;: \u0026#39;gini\u0026#39;, \u0026#39;max_depth\u0026#39;: 8, \u0026#39;max_features\u0026#39;: \u0026#39;sqrt\u0026#39;, \u0026#39;n_estimators\u0026#39;: 500}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.9523809523809523\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"6梯度增加机\"\u003e6、梯度增加机\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.ensemble \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e GradientBoostingClassifier\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_gbm = GradientBoostingClassifier()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;learning_rate\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.001\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;n_estimators\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e300\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e500\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;subsample\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;criterion\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;friedman_mse\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;squared_error\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_gbm, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)      \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egbm_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;colsample_bytree\u0026#39;: 0.5, \u0026#39;learning_rate\u0026#39;: 0.01, \u0026#39;n_estimators\u0026#39;: 10, \u0026#39;subsample\u0026#39;: 0.5}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.9619047619047618\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"7xgboost\"\u003e7、XGBoost\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e xgboost \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e XGBClassifier\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_xgb = XGBClassifier()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;n_estimators\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e50\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;learning_rate\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;subsample\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;colsample_bytree\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_xgb, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;accuracy\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)           \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003exgb_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;colsample_bytree\u0026#39;: 1, \u0026#39;learning_rate\u0026#39;: 0.01, \u0026#39;n_estimators\u0026#39;: 10, \u0026#39;subsample\u0026#39;: 0.5}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.9619047619047618\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"简单比较\"\u003e简单比较\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epd.DataFrame({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;KNN\u0026#34;\u003c/span\u003e : knn_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Logistic\u0026#34;\u003c/span\u003e : logistic_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Bayes\u0026#34;\u003c/span\u003e : bayes_cv.mean(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SVM\u0026#34;\u003c/span\u003e : svm_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RF\u0026#34;\u003c/span\u003e : rf_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GBM\u0026#34;\u003c/span\u003e : gbm_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;XGB\u0026#34;\u003c/span\u003e : xgb_grid_search.best_score_\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}, index=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;score\u0026#34;\u003c/span\u003e]).T.plot.line()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220904170954206.png\" alt=\"image-20220904170954206\"  /\u003e\r\n\u003c/p\u003e","title":"机器学习基于sklearn(3)--常见分类任务学习器"},{"content":" 目的：演示常见几种回归器的使用方法，对其超参数调优候选超参数的选择\n0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.model_selection import cross_val_score from sklearn.model_selection import GridSearchCV diabetes = datasets.load_diabetes() diabetes_X, diabetes_y = diabetes.data, diabetes.target diabetes_X = StandardScaler().fit_transform(diabetes_X) train_X, test_X, train_y, test_y = train_test_split(diabetes_X, diabetes_y, test_size=0.3) train_X.shape, test_X.shape, train_y.shape, test_y.shape # ((309, 10), (133, 10), (309,), (133,)) 1、K近邻 1 2 3 4 5 6 7 8 9 10 11 12 13 from sklearn.neighbors import KNeighborsRegressor model_knn = KNeighborsRegressor() param_grid = {\u0026#34;n_neighbors\u0026#34;: [3, 5, 7, 10, 20], \u0026#34;p\u0026#34;: [1, 2], \u0026#34;weights\u0026#34;: [\u0026#34;uniform\u0026#34;, \u0026#34;distance\u0026#34;]} grid_search = GridSearchCV(model_knn, param_grid, cv=5, scoring=\u0026#34;neg_root_mean_squared_error\u0026#34;, n_jobs=-1) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) knn_grid_search = grid_search # {\u0026#39;n_neighbors\u0026#39;: 10, \u0026#39;p\u0026#39;: 2, \u0026#39;weights\u0026#39;: \u0026#39;distance\u0026#39;} # -58.18148180421127 2、线性回归 1 2 3 4 5 6 7 from sklearn.linear_model import LinearRegression model_linear = LinearRegression() scores = cross_val_score(model_linear, train_X, train_y, scoring=\u0026#34;neg_root_mean_squared_error\u0026#34;, cv=10) print(scores.mean()) linear_cv = scores # -56.297486183914245 3、支持向量机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from sklearn.svm import SVR model_svm = SVR() param_grid = [ {\u0026#39;C\u0026#39; : [0.01, 0.1, 1, 10, 100], \u0026#39;kernel\u0026#39; : [\u0026#39;linear\u0026#39;, \u0026#39;poly\u0026#39;, \u0026#39;rbf\u0026#39;, \u0026#39;sigmoid\u0026#39;], \u0026#39;gamma\u0026#39; : [\u0026#39;scale\u0026#39;,\u0026#39;auto\u0026#39;] } ] grid_search = GridSearchCV(model_svm, param_grid, cv=5, scoring=\u0026#34;neg_root_mean_squared_error\u0026#34;, n_jobs=1) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) svm_grid_search = grid_search # {\u0026#39;C\u0026#39;: 1, \u0026#39;gamma\u0026#39;: \u0026#39;scale\u0026#39;, \u0026#39;kernel\u0026#39;: \u0026#39;linear\u0026#39;} # -56.48299266830155 4、随机森林 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 随机森林 from sklearn.ensemble import RandomForestRegressor model_rf = RandomForestRegressor() param_grid = [ {\u0026#39;n_estimators\u0026#39; : [100, 200, 300, 500, 1000], \u0026#39;criterion\u0026#39; : [\u0026#34;squared_error\u0026#34;, \u0026#34;absolute_error\u0026#34;], #与分类任务有变化 \u0026#39;max_depth\u0026#39; : [4, 8, 16, 32], \u0026#39;max_features\u0026#39; : [\u0026#34;sqrt\u0026#34;, \u0026#34;log2\u0026#34;] } ] grid_search = GridSearchCV(model_rf, param_grid, cv=5, scoring=\u0026#34;neg_root_mean_squared_error\u0026#34;, n_jobs=10) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) rf_grid_search = grid_search # {\u0026#39;criterion\u0026#39;: \u0026#39;squared_error\u0026#39;, \u0026#39;max_depth\u0026#39;: 4, \u0026#39;max_features\u0026#39;: \u0026#39;sqrt\u0026#39;, \u0026#39;n_estimators\u0026#39;: 500} # -56.98892728898064 5、梯度增加机 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from sklearn.ensemble import GradientBoostingRegressor model_gbm = GradientBoostingRegressor() param_grid = [ {\u0026#39;loss\u0026#39; : [\u0026#39;squared_error\u0026#39;, \u0026#39;absolute_error\u0026#39;, \u0026#39;huber\u0026#39;, \u0026#39;quantile\u0026#39;], #与分类任务有变化 \u0026#39;learning_rate\u0026#39; : [0.001, 0.01, 0.1], \u0026#39;n_estimators\u0026#39; : [100, 200, 300, 500], \u0026#39;subsample\u0026#39; : [0.5, 0.7, 1] } ] grid_search = GridSearchCV(model_gbm, param_grid, cv=5, scoring=\u0026#34;neg_root_mean_squared_error\u0026#34;, n_jobs=10) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) gbm_grid_search = grid_search # {\u0026#39;learning_rate\u0026#39;: 0.01, \u0026#39;loss\u0026#39;: \u0026#39;absolute_error\u0026#39;, \u0026#39;n_estimators\u0026#39;: 500, \u0026#39;subsample\u0026#39;: 0.5} # -57.07526918837941 6、XGBoost 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from xgboost import XGBRegressor model_xgb = XGBRegressor() param_grid = [ {\u0026#39;n_estimators\u0026#39; : [10, 30, 50], \u0026#39;learning_rate\u0026#39; : [0.01, 0.1], \u0026#39;subsample\u0026#39; : [0.5, 0.7, 1], \u0026#39;colsample_bytree\u0026#39; : [0.5, 0.7, 1] } ] grid_search = GridSearchCV(model_xgb, param_grid, cv=5, scoring=\u0026#34;neg_root_mean_squared_error\u0026#34;, n_jobs=10) grid_search.fit(train_X, train_y) print(grid_search.best_params_) print(grid_search.best_score_) xgb_grid_search = grid_search # {\u0026#39;colsample_bytree\u0026#39;: 0.5, \u0026#39;learning_rate\u0026#39;: 0.1, \u0026#39;n_estimators\u0026#39;: 50, \u0026#39;subsample\u0026#39;: 0.5} # -58.57262307535045 简单比较 1 2 3 4 5 6 7 8 9 import pandas as pd pd.DataFrame({ \u0026#34;KNN\u0026#34; : knn_grid_search.best_score_, \u0026#34;Linear\u0026#34; : linear_cv.mean(), \u0026#34;SVM\u0026#34; : svm_grid_search.best_score_, \u0026#34;RF\u0026#34; : rf_grid_search.best_score_, \u0026#34;GBM\u0026#34; : gbm_grid_search.best_score_, \u0026#34;XGB\u0026#34; : xgb_grid_search.best_score_ }, index=[\u0026#34;score\u0026#34;]).T.plot.line() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/119%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8Esklearn4--%E5%B8%B8%E8%A7%81%E5%9B%9E%E5%BD%92%E4%BB%BB%E5%8A%A1%E5%AD%A6%E4%B9%A0%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e目的：演示常见几种回归器的使用方法，对其超参数调优候选超参数的选择\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"0示例数据\"\u003e0、示例数据\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e datasets\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e train_test_split\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.preprocessing \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e StandardScaler\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e cross_val_score\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.model_selection \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e GridSearchCV\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ediabetes = datasets.load_diabetes()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ediabetes_X, diabetes_y = diabetes.data, diabetes.target\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ediabetes_X = StandardScaler().fit_transform(diabetes_X)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X, test_X, train_y, test_y = train_test_split(diabetes_X, diabetes_y, test_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_X.shape, test_X.shape, train_y.shape, test_y.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ((309, 10), (133, 10), (309,), (133,))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1k近邻\"\u003e1、K近邻\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.neighbors \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e KNeighborsRegressor\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_knn = KNeighborsRegressor()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;n_neighbors\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;p\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;weights\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;uniform\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;distance\u0026#34;\u003c/span\u003e]}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_knn, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;neg_root_mean_squared_error\u0026#34;\u003c/span\u003e, n_jobs=-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eknn_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;n_neighbors\u0026#39;: 10, \u0026#39;p\u0026#39;: 2, \u0026#39;weights\u0026#39;: \u0026#39;distance\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -58.18148180421127\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2线性回归\"\u003e2、线性回归\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.linear_model \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e LinearRegression\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_linear = LinearRegression()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escores = cross_val_score(model_linear, train_X, train_y, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\t\t scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;neg_root_mean_squared_error\u0026#34;\u003c/span\u003e, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(scores.mean())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elinear_cv = scores\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -56.297486183914245\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3支持向量机\"\u003e3、支持向量机\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.svm \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e SVR\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_svm = SVR()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;C\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;kernel\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;linear\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;poly\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;rbf\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;sigmoid\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;gamma\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;scale\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;auto\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_svm, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;neg_root_mean_squared_error\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)              \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esvm_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;C\u0026#39;: 1, \u0026#39;gamma\u0026#39;: \u0026#39;scale\u0026#39;, \u0026#39;kernel\u0026#39;: \u0026#39;linear\u0026#39;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -56.48299266830155\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"4随机森林\"\u003e4、随机森林\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 随机森林\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.ensemble \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e RandomForestRegressor\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_rf = RandomForestRegressor()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;n_estimators\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e300\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e500\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;criterion\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;squared_error\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;absolute_error\u0026#34;\u003c/span\u003e],  \u003cspan style=\"color:#007f7f\"\u003e#与分类任务有变化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;max_depth\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e16\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e32\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;max_features\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;sqrt\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;log2\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_rf, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;neg_root_mean_squared_error\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)              \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erf_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;criterion\u0026#39;: \u0026#39;squared_error\u0026#39;, \u0026#39;max_depth\u0026#39;: 4, \u0026#39;max_features\u0026#39;: \u0026#39;sqrt\u0026#39;, \u0026#39;n_estimators\u0026#39;: 500}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -56.98892728898064\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"5梯度增加机\"\u003e5、梯度增加机\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e sklearn.ensemble \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e GradientBoostingRegressor\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_gbm = GradientBoostingRegressor()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;loss\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;squared_error\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;absolute_error\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;huber\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;quantile\u0026#39;\u003c/span\u003e], \u003cspan style=\"color:#007f7f\"\u003e#与分类任务有变化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;learning_rate\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.001\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;n_estimators\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e300\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e500\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;subsample\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_gbm, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;neg_root_mean_squared_error\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)              \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egbm_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;learning_rate\u0026#39;: 0.01, \u0026#39;loss\u0026#39;: \u0026#39;absolute_error\u0026#39;, \u0026#39;n_estimators\u0026#39;: 500, \u0026#39;subsample\u0026#39;: 0.5}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -57.07526918837941\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"6xgboost\"\u003e6、XGBoost\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e xgboost \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e XGBRegressor\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel_xgb = XGBRegressor()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam_grid = [    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;n_estimators\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e50\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;learning_rate\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;subsample\u0026#39;\u003c/span\u003e  : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e     \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;colsample_bytree\u0026#39;\u003c/span\u003e : [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search = GridSearchCV(model_xgb, param_grid, cv=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                           scoring=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;neg_root_mean_squared_error\u0026#34;\u003c/span\u003e, n_jobs=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_search.fit(train_X, train_y)              \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_params_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(grid_search.best_score_)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003exgb_grid_search = grid_search\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;colsample_bytree\u0026#39;: 0.5, \u0026#39;learning_rate\u0026#39;: 0.1, \u0026#39;n_estimators\u0026#39;: 50, \u0026#39;subsample\u0026#39;: 0.5}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -58.57262307535045\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"简单比较\"\u003e简单比较\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epd.DataFrame({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;KNN\u0026#34;\u003c/span\u003e : knn_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Linear\u0026#34;\u003c/span\u003e : linear_cv.mean(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SVM\u0026#34;\u003c/span\u003e : svm_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RF\u0026#34;\u003c/span\u003e : rf_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GBM\u0026#34;\u003c/span\u003e : gbm_grid_search.best_score_,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;XGB\u0026#34;\u003c/span\u003e : xgb_grid_search.best_score_\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}, index=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;score\u0026#34;\u003c/span\u003e]).T.plot.line()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220904181725895.png\" alt=\"image-20220904181725895\"  /\u003e\r\n\u003c/p\u003e","title":"机器学习基于sklearn(4)--常见回归任务学习器"},{"content":" A network approach reveals driver genes associated with survival of patients with triple-negative breast cancer\nApril 19, 2021; IF=5.4\nhttps://doi.org/10.1016/j.isci.2021.102451\n1、WGCNA分析 （1）对773个来自TCGA的BRCA(包括92个TNBC)的31338个基因表达数据进行WGCNA网络共表达分析\n计算邻接矩阵的相关性指标选择 bicor(biweight midcorrelation) 得到22个模块，计算模块相关的ME与kME ME：每个样本对于每个模块的特征值 kME：每个基因对于每个模块的相关性 （2）使用方差分析，根据WGCNA鉴定的样本模块ME特征值与BRCA样本的subtype，发现与亚型分型最相关的12个模块\n前期根据每个模块的基因组成进行富集分析，注释每个模块的相关通路(GO BP) 其中M12模块与TNBC分析最正相关(bicor = 0.69)；M2模块与TNBC最负相关(bicor = -0.69) （3）对模块进行聚类分析，发现22个模块可以分为3类；其中的两类与TNBC相关，但相反(anti-correlated)\n对于每个模块的样本ME值与样本TRAIT数据进行相关性分析，其中重点关注与样本的TNBC二分类以及生存时间的相关性。目标是希望找到与TNBC二分类正相关与生存时间负相关的模块。 发现M12为代表的一类模块（M7，M21，M17，M8）与TNBC正相关，生存时间负相关，统称为M12-like module 发现M2为代表的一类模块（M11，M5，M19）与TNBC负相关，与生存时间正相关，统称为M2-like module 综上找到与TNBC分型相关的两大类模块，包括9个模块 与TNBC正相关表明，模块特征值越大，越符合TNBC；与TNBC正相关表明，模块特征值越小，越符合TNBC。\n2、差异分析与生存分析 （1）差异分析：使用T检验，分析TNBC分别与其它三种BRCA subtype的差异基因 BH FDR校正\n取三次差异分析结果中具有相同方向的显著TNBC DEG，共1518个。 （2）模块ME生存分析：基于TCGA的773样本的RFS状态进行生存分析\n首先分析每个模块的ME高低分组与生存的相关性：分为M12-like与M2-like两类模块讨论，总体来说M2-like模块低表达组(lower ME)的样本更容易复发；M12-like模块与之相反。 （3）单基因生存分析：基于GEO的1234个样本的RFS状态进行生存分析\n根据之前的差异分析结果，标记M12 TNBC top20(相对Luminal A)的上调基因；标记M2 TNBC top20(相对Luminal A)的下调基因。进行单基因生存分析。 结果发现M12模块的PSAT1、ART3等5个基因；M2模块的TFF1、SCUBE2等6个基因具有生存显著相关性。 3、GIANT分析 （1）挑选出M2-like、M12-like的hub基因（Top10，kME\u0026gt;0.6）\n（2）使用GIANT数据库(http://giant-v2.princeton.edu/)搜索在乳腺组织中，与这些hub gene高相关的基因。\n对于M2、M12模块也加入哪些虽然不是hub，但是生存高相关的基因。 （3）结果发现M7，M21，M17，M8，M12，M2这6个模块，具有较高的连接度关系\nM12模块的hub基因，PSAT1，YBX1，MTHFD1L具有最高的连接度。 M2模块中整体连接度比较高，hub基因ESR1，TFF1，SCUBE2等基因比较特殊。 4、预后模型 基于GEO的1234个BRCA样本的RFS状态，训练基因组合模型，使用ROC曲线评价模型对于BRCA以及TNBC的预测性能。\n如下式，定义一个score：分子来自与TNBC负相关的M2-like module的基因；分母来自与TNBC正相关的M12-like module的基因。\n分子与分母的基因数保持相同，即基因数比（1:1,2:2,3:3）；每个基因的权重设置为1。\n若M2相关基因的表达值越低、同时M12相关基因的表达越高；则score值就越低→越符合TNBC。\n$$ score = \\frac{M2-like ,gene(s)}{M12-like ,gene(s)} $$\n4.1 第一轮ROC 选用来自第二步中挑选的11个来自M2(5)、M12(6)，与生存相关的TNBC差异基因。\n共有381种模型组合可能； 对BRCA预测最佳模型的基因组合为（ERBB4 + SCUBE2 + TFF1/ART3 + FZD9 + PSAT1），但是在TNBC中表现不佳。 ERBB4/FZD9组合在TNBC的5年生存率预测中效果最佳 4.2 第二轮ROC 扩大基因的选择范围，考虑更多的module 差异基因或者hub基因\n分子包括ERBB4、SCUBE2等24个来自M2-like 模块；分母包括ART3, FZD9,PSAT1等34个来自M12-like 模块；\n共有11385种组合可能（包括1:1, 2:2, 3:3）；\n针对TNBC的Top最佳模型在TNBC中性能明显优于上一轮，但在BRCA数据中预测性能最低；\n最佳基因组合为(BIK +GPRC5C+ SPTLC2/CEBPB + DUSP4 + TPO)，而且大些基因大多出现在Top100 TNBC模型中。\n4.3 第三轮ROC 在第二轮的最佳TNBC模型6基因的基础上，手动根据文献添加补充候选基因； 最终敲定最优的9基因模型对TNBC具有良好的特异性，对BRCA性能一般。 最后在TCGA的BRCA数据上取得了验证。 小结：这篇文章目的是找到一个特异性针对TNBC的预后模型的基因组合。首先使用WGCNA找到与TNBC分型相关的模块，然后结合差异分析、生存分析以及组织间基因相互作用分析从关键模块定位到关键基因。关于模型基因组合，第一次见到本文的计算（类似于传统riskscore）方式，觉得比较新奇；结合三轮ROC分析，不断增加候选基因，筛选了1W+的基因组合，最终获得了一个理想的模型。\n","permalink":"https://lishensuo.github.io/en/posts/basic/120%E6%96%87%E7%8C%AE--%E7%BB%BC%E5%90%88%E5%A4%9A%E7%A7%8D%E5%88%86%E6%9E%90%E5%BB%BA%E7%AB%8Btnbc%E9%A2%84%E5%90%8E%E6%A8%A1%E5%9E%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003eA network approach reveals driver genes associated with survival of patients with triple-negative breast cancer\u003c/p\u003e\n\u003cp\u003eApril 19, 2021; IF=5.4\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://doi.org/10.1016/j.isci.2021.102451\"\u003ehttps://doi.org/10.1016/j.isci.2021.102451\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220505144346626.png\" alt=\"image-20220505144346626\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220505144446718.png\" alt=\"image-20220505144446718\" style=\"zoom: 33%;\" /\u003e\r\n\u003ch1 id=\"1wgcna分析\"\u003e1、WGCNA分析\u003c/h1\u003e\n\u003cp\u003e（1）对\u003cstrong\u003e773\u003c/strong\u003e个来自TCGA的BRCA(包括92个TNBC)的31338个基因表达数据进行WGCNA网络共表达分析\u003c/p\u003e","title":"文献--综合多种分析建立TNBC预后模型"},{"content":" 最先在李沐大神在B站的分享中了解到autogluon，它是一个自动机器学习工具，可用于文本图片识别、表格任务等。据说效果非常不错\u0026ndash;号称3行代码打败99%的机器学习模型，甚至说标志着手动调参的时代已经结束。\n关于它的原理暂且不深入了解了，简单记录下在传统表格任务上的用法，可以作为对数据的初步探索。\n安装方式：https://auto.gluon.ai/stable/index.html 官方教程：https://auto.gluon.ai/stable/tutorials/tabular_prediction/tabular-quickstart.html 1 from autogluon.tabular import TabularDataset, TabularPredictor 1、准备数据 （1）(多列)特征与(1列)target合并在一个表格中，转为autogluon的TabularDataset对象；\n（2）每行代表一个样本，须分为训练集与测试集。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ## (1) 方式1： 从csv文件读取 train_data = TabularDataset(\u0026#39;https://autogluon.s3.amazonaws.com/datasets/Inc/train.csv\u0026#39;) subsample_size = 500 # 仅为演示、节省时间 train_data = train_data.sample(n=subsample_size, random_state=0) test_data = TabularDataset(\u0026#39;https://autogluon.s3.amazonaws.com/datasets/Inc/test.csv\u0026#39;) type(train_data) # autogluon.core.dataset.TabularDataset ## (2) 方式2：可由pd.Dataframe对象转换 import pandas as pd train_df = pd.read_csv(\u0026#34;https://autogluon.s3.amazonaws.com/datasets/Inc/train.csv\u0026#34;) train_data = TabularDataset(train_df) 2、模型训练 （1）autogluon可自动根据target列的内容决定是回归还是分类任务；\n（2）对于特征列数据，autogluon可自动完成缺失值处理、数据标准化等，无需手动清洗数据。\n2.1 基础流程 （1）训练模型 1 2 3 4 5 6 7 8 #指定target列 label = \u0026#39;class\u0026#39; #指定模型保存位置 save_path = \u0026#39;tmp\u0026#39; #开始训练 predictor = TabularPredictor(label=label, path=save_path).fit(train_data) # predictor = TabularPredictor.load(save_path) 加载模型 （2）查看训练结果相关信息 1 2 3 4 5 predictor.problem_type #训练任务类型 print(predictor.feature_metadata) #所判断的特征列数据类型 #不同类型模型的训练结果验证集指标排名 predictor.fit_summary() （3）测试集预测 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 不同模型在测试集的指标排名 predictor.leaderboard(test_data, silent=True) # 最优模型在测试集的多种结果指标 predictor.evaluate(test_data) ##等价于如下步骤 y_test = test_data[label] #真实值 test_data_nolab = test_data.drop(columns=[label]) test_data_nolab.head() y_pred = predictor.predict(test_data_nolab) #预测值 predictor.evaluate_predictions(y_true=y_test, y_pred=y_pred, auxiliary_metrics=True) predictor.predict_proba(test_data_nolab) #预测概率 # 使用指定模型预测 predictor.predict(test_data, model=\u0026#39;LightGBM\u0026#39;) 2.2 多种指标 autogluon对于分类任务，默认使用accuracy指标；对于回归任务，默认使用RMSE指标\n其它可选指标包括\n（1）分类：\n1 2 3 [\u0026#39;accuracy\u0026#39;, \u0026#39;balanced_accuracy\u0026#39;, \u0026#39;f1\u0026#39;, \u0026#39;f1_macro\u0026#39;, \u0026#39;f1_micro\u0026#39;, \u0026#39;f1_weighted\u0026#39;, \u0026#39;roc_auc\u0026#39;, \u0026#39;roc_auc_ovo_macro\u0026#39;, \u0026#39;average_precision\u0026#39;, \u0026#39;precision\u0026#39;, \u0026#39;precision_macro\u0026#39;, \u0026#39;precision_micro\u0026#39;, \u0026#39;precision_weighted\u0026#39;, \u0026#39;recall\u0026#39;, \u0026#39;recall_macro\u0026#39;, \u0026#39;recall_micro\u0026#39;, \u0026#39;recall_weighted\u0026#39;, \u0026#39;log_loss\u0026#39;, \u0026#39;pac_score\u0026#39;] （2）回归\n1 2 [\u0026#39;root_mean_squared_error\u0026#39;, \u0026#39;mean_squared_error\u0026#39;, \u0026#39;mean_absolute_error\u0026#39;, \u0026#39;median_absolute_error\u0026#39;, \u0026#39;mean_absolute_percentage_error\u0026#39;, \u0026#39;r2\u0026#39;] 如需更多评价指标可参考https://auto.gluon.ai/stable/tutorials/tabular_prediction/tabular-custom-metric.html#sec-tabularcustommetric\n用于训练时的模型优化：选择一个指标，用于模型优化以及比较 1 2 3 metric = \u0026#39;roc_auc\u0026#39; predictor = TabularPredictor(label=label, path=save_path, eval_metric=metric).fit(train_data) predictor.fit_summary() 用于训练后的模型不同角度的性能比较：可选择多个指标 1 2 metrics = [\u0026#39;roc_auc\u0026#39;, \u0026#34;f1\u0026#34;, \u0026#34;recall\u0026#34;, \u0026#34;recall\u0026#34;] predictor.leaderboard(test_data, extra_metrics = metrics, silent=True) 2.3 不同模式 主要针对 TabularPredictor().fit(train_data, presets=)的presets参数\n默认为\u0026quot;medium_quality\u0026quot;，其余依次为\u0026quot;good_quality\u0026quot;, \u0026ldquo;high_quality\u0026rdquo;, \u0026ldquo;best_quality\u0026rdquo;\n从左到右，代表了训练时间/成本与训练结果性能之间的取舍。\n官方教程建议先按默认的medium_quality训练，对模型有初步的了解后，在尝试best_quality\n此外fit()函数还包括一个time_limit=参数，单位为秒，直接指定训练的时长。如不指定默认训练完全部可能的模型。\n报错记录 1、在best_quality/high_quality训练模式下会可能会出现如下报错： 1 2 3 4 5 6 7 8 9 10 11 12 13 OpenBLAS : Program is Terminated. Because you tried to allocate too many memory regions. This library was built to support a maximum of 128 threads - either rebuild OpenBLAS with a larger NUM_THREADS value or set the environment variable OPENBLAS_NUM_THREADS to a sufficiently small number. This error typically occurs when the software that relies on OpenBLAS calls BLAS functions from many threads in parallel, or when your computer has more cpu cores than what OpenBLAS was configured to handle. OpenBLAS : Program is Terminated. Because you tried to allocate too many memory regions. This library was built to support a maximum of 128 threadPC: @ 0x7ff3b109952c (unknown) dgemm_incopy_SKYLAKEX @ 0x7ff3b95f0630 (unknown) (unknown) [2023-05-27 15:40:36,365 E 90917 106900] logging.cc:361: *** SIGSEGV received at time=1685173236 on cpu 136 *** [2023-05-27 15:40:36,366 E 90917 106900] logging.cc:361: PC: @ 0x7ff3b109952c (unknown) dgemm_incopy_SKYLAKEX [2023-05-27 15:40:36,366 E 90917 106900] logging.cc:361: @ 0x7ff3b95f0630 (unknown) (unknown) Fatal Python error: Segmentation fault 解决方案参考：https://github.com/autogluon/autogluon/issues/1020 主要原因是KNN模型训练时调用了过多线程，导致超过OpenBLAS所支持的上限。\n因此可限制KNN使用的线程数（默认调用机器的全部线程），或者干脆使用KNN模型\n1 predictor = TabularPredictor(label=\u0026#34;label\u0026#34;).fit(zuhe_train_Tab,presets=\u0026#34;high_quality\u0026#34;,excluded_model_types = [\u0026#39;KNN\u0026#39;]) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/130%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0--%E8%87%AA%E5%8A%A8%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7autogluon/","summary":"\u003cblockquote\u003e\n\u003cp\u003e最先在李沐大神在B站的分享中了解到autogluon，它是一个自动机器学习工具，可用于文本图片识别、表格任务等。据说效果非常不错\u0026ndash;号称3行代码打败99%的机器学习模型，甚至说标志着手动调参的时代已经结束。\u003c/p\u003e","title":"机器学习--自动机器学习工具autogluon"},{"content":"1、TTD数据库简介 首先关于靶点的生物学定义是： 生物学靶点（英語：Biological target）是指位于生物体内，能够被其他物质（配体、药物等）识别或结合的结构。常见的药物靶点包括蛋白质、核酸和离子通道等。\u0026mdash;维基百科\n其次关于TTD数据库，官方简介为 TTD是一个提供目前已知或者处于探索阶段的、具有治疗价值的蛋白或核酸靶点的相关信息；包括靶点相关疾病、介导的生物学通路信息、以及作用靶点的药物信息。数据库记载的全部数据均是有参考文献来源的。 2、TTD数据库内容 2.1 靶点 TTD数据库的核心是靶点数据，其余所有信息均是围绕靶点展开的； TTD将收录的靶点分为四类\u0026ndash;如下，可信度又高到低 Successful：基于该靶点，已经有至少一种靶向药物批准； clinical trial：该靶点的药物还处于临床研究阶段； patent-recorded：靶点的靶向化合物具有专利保护； literature-reported：有文献报道的靶点。 如下是目前近些年收录的靶点数目统计 2.2 药物 针对靶点的结合靶向结合药物，TTD分为了Approved、Clinical Trial、Patented以及Experimental四类 2.3 靶点的调控分子 这部分是TTD数据库近些年才收录的，认为靶点表达在生物过程中可能会受到多种生物分子的调控，包括microRNA、Transcription Factor、interaction protein(互作蛋白) 如下对数据库中靶点的调控分子记载的统计情况 2.4 其它 此外，数据库还收载了靶点的表达数据情况、相关的生物通路(pathway)、实验验证数据等 作为TTD的一个特点：它还专门收集了COVID-19靶点以及相关信息 如下图为TTD数据为对于一个靶点的全部信息内容 3、TTD数据库使用 数据库网址：http://db.idrblab.net/ttd//\n下载界面：http://db.idrblab.net/ttd/full-data-download\n进入数据库网站，可以直接搜索靶点，也可以通过药物、疾病搜索相关靶点等等；而且全部数据提供了下载界面，觉得还是很不错的。\n3.1 靶点信息整理 包括靶点的基因名SYMBOL、蛋白UNIPOD id、靶点类型、PDB结构id，蛋白类型。\n此外还包括靶点蛋白序列、涉及通路，对应药物等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 ttd_targets = fread(\u0026#34;P1-01-TTD_target_download.txt\u0026#34;,skip = 40) head(ttd_targets) target_UNIPROID = ttd_targets %\u0026gt;% dplyr::filter(V2==\u0026#34;UNIPROID\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(TargetID=V1,UNIPROID=V3) head(target_UNIPROID) target_GENENAME = ttd_targets %\u0026gt;% dplyr::filter(V2==\u0026#34;GENENAME\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(TargetID=V1,GENENAME=V3) head(target_GENENAME) target_TARGTYPE = ttd_targets %\u0026gt;% dplyr::filter(V2==\u0026#34;TARGTYPE\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(TargetID=V1,TARGTYPE=V3) head(target_TARGTYPE) target_PDBSTRUC = ttd_targets %\u0026gt;% dplyr::filter(V2==\u0026#34;PDBSTRUC\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(TargetID=V1,PDBSTRUC=V3) head(target_PDBSTRUC) target_BIOCLASS = ttd_targets %\u0026gt;% dplyr::filter(V2==\u0026#34;BIOCLASS\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(TargetID=V1,BIOCLASS=V3) head(target_BIOCLASS) target_info = target_UNIPROID %\u0026gt;% dplyr::full_join(target_GENENAME) %\u0026gt;% dplyr::full_join(target_TARGTYPE) %\u0026gt;% dplyr::full_join(target_PDBSTRUC) %\u0026gt;% dplyr::full_join(target_BIOCLASS) head(target_info) write.csv(target_info, file = \u0026#34;TTD_target_info_v8101.csv\u0026#34;) 3.2 药物信息整理 （1）药物信息 包括药物的研究阶段、所属类别、结构描述符、以及对应其它数据库ID等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 ttd_drug = fread(\u0026#34;P1-02-TTD_drug_download.txt\u0026#34;, skip = 29, header = F) head(ttd_drug) drug_DRUGCLAS = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;DRUGCLAS\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,DRUGCLAS=V3) head(drug_DRUGCLAS) table(drug_DRUGCLAS$DRUGCLAS) drug_THERCLAS = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;THERCLAS\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,THERCLAS=V3) head(drug_THERCLAS) drug_DRUGTYPE = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;DRUGTYPE\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,DRUGTYPE=V3) head(drug_DRUGTYPE) drug_DRUGINCH = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;DRUGINCH\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,DRUGINCH=V3) head(drug_DRUGINCH) drug_DRUGINKE = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;DRUGINKE\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,DRUGINKE=V3) head(drug_DRUGINKE) drug_DRUGSMIL = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;DRUGSMIL\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,DRUGSMIL=V3) head(drug_DRUGSMIL) drug_HIGHSTAT = ttd_drug %\u0026gt;% dplyr::filter(V2==\u0026#34;HIGHSTAT\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,HIGHSTAT=V3) head(drug_HIGHSTAT) drug_info = drug_DRUGCLAS %\u0026gt;% dplyr::full_join(drug_THERCLAS) %\u0026gt;% dplyr::full_join(drug_DRUGTYPE) %\u0026gt;% dplyr::full_join(drug_DRUGINCH) %\u0026gt;% dplyr::full_join(drug_DRUGINKE) %\u0026gt;% dplyr::full_join(drug_DRUGSMIL) %\u0026gt;% dplyr::full_join(drug_HIGHSTAT) drug_supp = fread(\u0026#34;P1-03-TTD_crossmatching.txt\u0026#34;, skip = 27, header = F) head(drug_supp) drug_DRUGNAME = drug_supp %\u0026gt;% dplyr::filter(V2==\u0026#34;DRUGNAME\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,DRUGNAME=V3) head(drug_DRUGNAME) drug_CASNUMBE = drug_supp %\u0026gt;% dplyr::filter(V2==\u0026#34;CASNUMBE\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,CASNUMBE=V3) %\u0026gt;% dplyr::mutate(CASNUMBE=sub(\u0026#34;CAS \u0026#34;,\u0026#34;\u0026#34;,CASNUMBE)) head(drug_CASNUMBE) drug_D_FOMULA = drug_supp %\u0026gt;% dplyr::filter(V2==\u0026#34;D_FOMULA\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,D_FOMULA=V3) head(drug_D_FOMULA) drug_PUBCHCID = drug_supp %\u0026gt;% dplyr::filter(V2==\u0026#34;PUBCHCID\u0026#34;) %\u0026gt;% dplyr::select(V1, V3) %\u0026gt;% dplyr::rename(DrugID=V1,PUBCHCID=V3) head(drug_PUBCHCID) drug_info = drug_info %\u0026gt;% dplyr::full_join(drug_DRUGNAME) %\u0026gt;% dplyr::full_join(drug_CASNUMBE) %\u0026gt;% dplyr::full_join(drug_D_FOMULA) %\u0026gt;% dplyr::full_join(drug_PUBCHCID) head(drug_info) write.csv(drug_info, file = \u0026#34;TTD_drug_info_v8101.csv\u0026#34;) （2）药物对应疾病信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 drug2disease=fread(\u0026#34;P1-05-Drug_disease.txt\u0026#34;, skip = 22, header = F) head(drug2disease) index1=which(drug2disease$V1==\u0026#34;TTDDRUID\u0026#34;) index2=c(which(drug2disease$V1==\u0026#34;\u0026#34;),nrow(drug2disease)+1) drugs = drug2disease$V2[index1] times = index2 - index1 drugs_times = rep(drugs, times) drug2disease = drug2disease %\u0026gt;% dplyr::filter(V2 != \u0026#34;\u0026#34;) %\u0026gt;% dplyr::mutate(TTDDRUID=drugs_times) %\u0026gt;% dplyr::select(TTDDRUID, dplyr::everything()) head(drug2disease) d2d_INDICATI = drug2disease %\u0026gt;% dplyr::filter(V1==\u0026#34;INDICATI\u0026#34;) %\u0026gt;% dplyr::mutate(DiseaseName=str_match(V2,\u0026#39;(.*) \\\\[ICD-11: (.*)\\\\] (.*)\u0026#39;)[,2]) %\u0026gt;% dplyr::mutate(`ICD-11`=str_match(V2,\u0026#39;(.*) \\\\[ICD-11: (.*)\\\\] (.*)\u0026#39;)[,3]) %\u0026gt;% dplyr::mutate(Clinical_Status=str_match(V2,\u0026#39;(.*) \\\\[ICD-11: (.*)\\\\] (.*)\u0026#39;)[,4]) %\u0026gt;% dplyr::select(-V1, -V2) write.csv(d2d_INDICATI, file = \u0026#34;TTD_drug2disease_v8101.csv\u0026#34;) （3）药物对应靶点信息 1 2 3 4 5 6 7 8 drug2target = readxl::read_xlsx(\u0026#34;P1-07-Drug-TargetMapping.xlsx\u0026#34;) head(drug2target) drug_info = read.csv(\u0026#34;TTD_drug_info_v8101.csv\u0026#34;) target_info = read.csv(\u0026#34;TTD_target_info_v8101.csv\u0026#34;) drug2target=drug2target %\u0026gt;% dplyr::left_join(drug_info[,c(\u0026#34;DrugID\u0026#34;,\u0026#34;DRUGNAME\u0026#34;)]) %\u0026gt;% dplyr::left_join(target_info[,c(\u0026#34;TargetID\u0026#34;,\u0026#34;GENENAME\u0026#34;)]) write.csv(drug2target, file = \u0026#34;TTD_drug2target_v8101.csv\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/150%E6%95%B0%E6%8D%AE%E5%BA%93--%E8%8D%AF%E7%89%A9%E4%B8%8E%E8%8D%AF%E7%89%A9%E9%9D%B6%E7%82%B9ttd/","summary":"\u003ch2 id=\"1ttd数据库简介\"\u003e1、TTD数据库简介\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e首先关于靶点的生物学定义是：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e生物学靶点\u003c/strong\u003e（英語：Biological target）是指位于生物体内，能够被其他物质（配体、药物等）识别或结合的结构。常见的药物靶点包括蛋白质、核酸和离子通道等。\u0026mdash;维基百科\u003c/p\u003e","title":"数据库--药物与药物靶点TTD"},{"content":" Network Pharmacology-Based Analysis on the Potential Biological Mechanisms of Sinisan Against Non-Alcoholic Fatty Liver Disease（四逆散\u0026ndash;非酒精性脂肪肝）\n27 August 2021\nFront Pharmacol, IF=5.8\nDOI: 10.3389/fphar.2021.693701\n分析思路 文章的流程图 1、数据收集 1.1 TCM数据 四味中药：柴胡、白芍、枳实、甘草\nTCMSP数据库，筛选条件：OB ≥ 30% ; DL ≥ 0.18。\nOB: systemic bioavailability after oral absorption and distribution;\nDL: structural similarity between compounds and clinically used drugs in the DrugBank database\n对于筛选的结果，进行文献和其它数据库验证。未明确说哪些数据库，但从上述流程图可知有ETCM，SymMap\n最后得到137个活性成分，155个作用靶点\n1.2 疾病数据 DisGeNET 数据库 搜索关键词：\u0026ldquo;Non-alcoholic Fatty Liver Disease\u0026rdquo;, \u0026ldquo;Nonalcoholic Steatohepatitis\u0026rdquo;, and \u0026ldquo;Fibrosis, Liver\u0026rdquo; 过滤掉 BEFREE text mining genes 结果 得到306个NAFLD基因 1.3 PPI数据 文章基于两个数据库建立了两个PPI网络\n（1）dataset constructed by Professor Barabasi’s team 15 commonly used databases with experimental evidence and the inhouse conﬁrmed data without inferred information. https://ccsb.dana-farber.org/interactome-data.html http://www.interactome-atlas.org/download 共得到16677个蛋白的243603条互作关系，简记为Bnet （2）STRING Homo sapiens； conﬁdence score ≥0.9 共得到9941个蛋白的227186条互作关系，简记为Snet 2、通路富集分析 ClusterProfiler包\nTCM与Disease各自的靶点分别进行GO(BP/CC/MF)、KEGG富集分析，比较是否富集到相同的通路。\nTCM与Disease的交集靶点富集到哪些通路。\n3、网络分析 3.1 网络接近度计算 如下公式，计算在Bnet中TCM靶点群与Disease靶点群的距离。其中V表示Disease靶点群，T表示TCM靶点群；计算对于TCM靶点群的所有靶点能到Disease靶点群(的任一靶点)的最短距离的均值。 $$ d_c(V,T) = \\frac{1}{||T||}\\sum_{t\\in T}min_{v\\in V}d(v,t) $$\n为了衡量TCM靶点群到Disease靶点群的距离相对远近，进行Z值标准化。 具体做法是大量模拟任意与TCM靶点群相同数量的蛋白群，同上公式计算其与Disease靶点群的距离；计算均值与方差，再按下公式计算出Z值。 $$ Z_{d_{c}} = \\frac{d_c-\\mu_{d_{c}(V,T)}}{\\sigma_{d_{c}(V,T)}} $$\n结果 d=1.05，Z=-9.51，显著低于随机分布；表明TCM靶点群到Disease靶点群距离近，具有显著意义 3.2 RWR算法计算hub基因 从全部的PPI数据(Bnet)，提取出仅包含TCM与Disease靶点的 sub-PPI，sub-Bnet。根据PPI关系，计算出Disease靶点群中的哪些靶点最容易收到TCM靶点群的影响。 算法为RWR重启随机游走算法。使用RandomWalkRestartMH包计算，将TCM靶点群视为种子节点，重启概率设为0.75。笔记链接\u0026ndash; $$ p_{t+1}^T = (1-r)Mp_t^T + rP_{0}^T $$\n得到最易受到影响的Top10节点：STAT3, CTNNB1, MAPK1, MAPK3, AGT, NQO1, TOP2A, FDFT1, ALDH4A1, and KCNH2 3.3 亚群鉴定分析 从全部的PPI数据(Snet)，提取出仅包含TCM与Disease靶点的 sub-PPI，sub-Snet；包含1425条互作关系\n使用Cytoscape软件的 ClusterMaker 2插件鉴定6个包含TCM与Disease靶点的subcluster；并通过KEGG富集找到每个subcluster最相关的通路。\n","permalink":"https://lishensuo.github.io/en/posts/basic/150%E6%96%87%E7%8C%AE--%E5%9B%9B%E9%80%86%E6%95%A3%E4%B8%8E%E9%9D%9E%E9%85%92%E7%B2%BE%E6%80%A7%E8%84%82%E8%82%AA%E8%82%9D%E7%BD%91%E8%8D%AF%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eNetwork Pharmacology-Based Analysis on the Potential Biological Mechanisms of Sinisan Against Non-Alcoholic Fatty Liver Disease（四逆散\u0026ndash;非酒精性脂肪肝）\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e27 August 2021\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eFront Pharmacol, IF=5.8\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eDOI: \u003ca href=\"https://doi.org/10.3389/fphar.2021.693701\"\u003e10.3389/fphar.2021.693701\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220423122209873.png\" alt=\"image-20220423122209873\" style=\"zoom:50%;\" /\u003e\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e分析思路\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220422154843335.png\" alt=\"image-20220422154843335\" style=\"zoom: 67%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e文章的流程图\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220422155113821.png\" alt=\"image-20220422155113821\" style=\"zoom: 33%;\" /\u003e\r\n\u003ch2 id=\"1数据收集\"\u003e1、数据收集\u003c/h2\u003e\n\u003ch3 id=\"11-tcm数据\"\u003e1.1 TCM数据\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e四味中药：柴胡、白芍、枳实、甘草\u003c/p\u003e","title":"文献--四逆散与非酒精性脂肪肝网药分析"},{"content":" Network-based prediction of drug combinations\nNature communication 2019 / 03 IF=15\nhttps://doi.org/10.1038/s41467-019-09186-x\n文章使用数据 1、PPI high-quality protein-protein interactions (PPIs)\n原文说有243,603 PPIs connecting 16,677 unique proteins ，但是根据文章附件链接只有217160 PPIs, 涉及15970个蛋白质\nhttps://static-content.springer.com/esm/art%3A10.1038%2Fs41467-019-09186-x/MediaObjects/41467_2019_9186_MOESM3_ESM.xlsx\n2、药物数据 （1）药物组方：DCDB\n1,363 clinically reported drug combinations for 904 distinctive components\nhttp://public.synergylab.cn/dcdb/index.jsf\n在本文，作者仅关注 pairwise drug combinations ：681 combinations connnecting 362 drugs\n（2）TTD数据库\nhttp://db.idrblab.net/ttd/\ndrug, target, and drug-target pathway information\n3、疾病靶点 （1）OMIM：The OMIM database (Online Mendelian Inheritance in Man)\nhttp://www.omim.org/\nliterature-curated human disease genes with various high-quality experimental evidences.\n（2）CTD：The Comparative Toxicogenomics Database\nhttp://ctdbase.org/\nonly manually curated gene-disease interactions from the literatures were used.\n（3）ClinVar：relationships among sequence variation and various human phenotypes\nhttps://www.ncbi.nlm.nih.gov/clinvar/\ncardiovascular[Disease/Phenotype]\n（4）GWAS\nhttps://www.ebi.ac.uk/gwas/\nunbiased SNP-disease associations with genome-wide significance\np \u0026lt;5.0×10 -8\n（5）GWASdb\nhttp://jjwanglab.org/gwasdb NOT USED\nSNP-trait associations from GWAS for PubMed and other resource\np \u0026lt;1.0×10 -3\n（6）PheWAS Catalog\nhttps://phewascatalog.org/phewas\nphewas.mc.vanderbilt.edu\nSNP-trait associations identified by the phenome-wide association study (PheWAS) paradigm within electronic medical records\np \u0026lt;0.05\n（7）HuGE Navigator\nhttps://phgkb.cdc.gov/PHGKB/phgHome.action?action=home\nan integrated disease candidate gene database based on the core data from PubMed abstracts using text mining algorithms\nliterature-reported disease-gene annotation data with known PubMed IDs\n（8）DisGeNET\n16,000 genes and 13,000 diseases\nonly expert-curated data\n附件上传的数据\nThe publicly available human protein–protein interactome (Supplementary Data 1)\nexperimentally validated drug–target interactions (Supplementary Data 2)\nexperimentally validated drug combinations (Supplementary Data 3)\n分析思路 1、药物靶点群与疾病群距离 假设：Disease proteins are not scattered randomly in the interactome, but tend to form localized neighborhoods, known as disease modules\n计算药物与疾病的Network-based proximity\n$$ d(X,Y) = \\frac{1}{||Y||}\\sum_{y\\in{Y}}min_{x\\in{X}}d(x,y) $$\n计算相同数量size与连接度degree的靶点群与疾病靶点群的距离，拟合高斯分布，进行Z值转换。由此判断药物距离与疾病距离是否足够近(z\u0026lt;0)。 $$ z = \\frac{d-\\mu}{\\sigma} $$ 2、计算药物靶点群与药物靶点群的距离 药物靶点的数目通常比较少（FDA批准的1978个药物中，平均靶点为3。由上公式计算的药物与药物间距离的随机化不符合正态分布。 进一步改进计算公式，考虑两个药物的影响范围。同第一点，进行Z值转换。 $$ s_{AB} = d_{AB} - \\frac{d_{AA} + d_{BB}}{2} $$\n通过药物组合实验数据、药物性质以及药物距离的关系\n（1）两个药物靶模块之间的拓扑关系也反映了生物和药理学关系。\n（2）FDA批准的两两药物组合之间的距离比较近。如下图A\n3、药物-药物-靶点群关系 文章分为6种药物-药物-靶点群关系 结合已知药物组合数据发现：only drug pairs that have Complementary Exposure relationship to the disease module(下图B) show a statistically significant efficacy for drug combination therapies 最后文章利用Complementary Exposure relationship，预测、筛选具有抗高血压的药物组合。发现预测显著的结果有相应的研究数据支持，表明这种药物组合发现模式的准确性。 前期准备好数据很重要。不仅仅是用于预测的数据，还要有支持验证的数据。\n","permalink":"https://lishensuo.github.io/en/posts/basic/151%E6%96%87%E7%8C%AE--%E5%9F%BA%E4%BA%8Eppi%E7%BD%91%E7%BB%9C%E7%9A%84%E9%9D%B6%E7%82%B9%E7%BE%A4%E8%B7%9D%E7%A6%BB%E9%A2%84%E6%B5%8B%E8%8D%AF%E7%89%A9%E7%BB%84%E5%90%88/","summary":"\u003cblockquote\u003e\n\u003cp\u003eNetwork-based prediction of drug combinations\u003c/p\u003e\n\u003cp\u003eNature communication   2019 / 03  IF=15\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://doi.org/10.1038/s41467-019-09186-x\"\u003ehttps://doi.org/10.1038/s41467-019-09186-x\u003c/a\u003e\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220429151826294.png\" alt=\"image-20220429151826294\" style=\"zoom: 50%;\" /\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"文章使用数据\"\u003e文章使用数据\u003c/h1\u003e\n\u003ch2 id=\"1ppi\"\u003e1、PPI\u003c/h2\u003e\n\u003cp\u003ehigh-quality protein-protein interactions (PPIs)\u003c/p\u003e\n\u003cp\u003e原文说有\u003cstrong\u003e243,603\u003c/strong\u003e PPIs connecting \u003cstrong\u003e16,677\u003c/strong\u003e unique proteins ，但是根据文章附件链接只有217160 PPIs, 涉及15970个蛋白质\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://static-content.springer.com/esm/art%3A10.1038%2Fs41467-019-09186-x/MediaObjects/41467_2019_9186_MOESM3_ESM.xlsx\"\u003ehttps://static-content.springer.com/esm/art%3A10.1038%2Fs41467-019-09186-x/MediaObjects/41467_2019_9186_MOESM3_ESM.xlsx\u003c/a\u003e\u003c/p\u003e\n\u003ch2 id=\"2药物数据\"\u003e2、药物数据\u003c/h2\u003e\n\u003cp\u003e（1）药物组方：DCDB\u003c/p\u003e","title":"基于PPI网络的靶点群距离预测药物组合"},{"content":" Cmap LINCS计划采用L1000技术进行大规模的细胞系干扰实验测序，得到差异基因。具体可分为Phase-1，Phase-2两个阶段。数据已整理、上传至阿里云盘。本片笔记整理下数据的操作、使用方法。\n一、CMap https://clue.io/data/CMap2020#LINCS2020\nCompound类型 ~4w 化合物作用于240个细胞系的72w+ 次干扰试验 1、差异表达矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ###根据行列id序号提取指定的差异表达矩阵 ###行名表示基因名；列名表示实验id名 gctx_demo = parse_gctx(\u0026#34;gctx/level5_beta_trt_cp_n720216x12328.gctx\u0026#34;, cid=1:2, rid=1:2) gctx_demo@mat # ABY001_A375_XH:BRD-A61304759:0.625:24 ABY001_A375_XH:BRD-A61304759:0.625:3 # 10 -0.02435 0.2960798 # 100 0.70715 -0.8559232 gctx_demo@rdesc # id # 1 10 # 2 100 gctx_demo@cdesc # id # 1 ABY001_A375_XH:BRD-A61304759:0.625:24 # 2 ABY001_A375_XH:BRD-A61304759:0.625:3 2、meta注释信息 2.1 实验（行）注释\u0026ndash;基本+质量信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 sig_info = data.table::fread(\u0026#34;siginfo_beta.txt\u0026#34;,data.table=FALSE) col_meta \u0026lt;- read_gctx_meta(\u0026#34;gctx/level5_beta_trt_cp_n720216x12328.gctx\u0026#34;, dim=\u0026#34;col\u0026#34;) table(col_meta[,\u0026#34;id\u0026#34;] %in% sig_info[,\u0026#34;sig_id\u0026#34;]) # TRUE #720216 sig_sub = subset(sig_info, sig_id %in% col_meta[,\u0026#34;id\u0026#34;]) t(sig_sub[1,]) # bead_batch \u0026#34;b17\u0026#34; # nearest_dose NA # pert_dose \u0026#34;100\u0026#34; # pert_dose_unit \u0026#34;ug/ml\u0026#34; # pert_idose \u0026#34;100 ug/ml\u0026#34; # pert_itime \u0026#34;336 h\u0026#34; # pert_time \u0026#34;336\u0026#34; # pert_time_unit \u0026#34;h\u0026#34; # cell_mfc_name \u0026#34;N8\u0026#34; # pert_mfc_id \u0026#34;BRD-U44432129\u0026#34; # nsample \u0026#34;4\u0026#34; # cc_q75 \u0026#34;0.6164\u0026#34; # ss_ngene \u0026#34;446\u0026#34; # tas \u0026#34;0.530187\u0026#34; # pct_self_rank_q25 \u0026#34;0\u0026#34; # wt \u0026#34;0.26,0.26,0.22,0.26\u0026#34; # median_recall_rank_spearman \u0026#34;0.925926\u0026#34; # median_recall_rank_wtcs_50 \u0026#34;1.15741\u0026#34; # median_recall_score_spearman \u0026#34;0.548655\u0026#34; # median_recall_score_wtcs_50 \u0026#34;0.705263\u0026#34; # batch_effect_tstat \u0026#34;-2.31\u0026#34; # batch_effect_tstat_pct \u0026#34;0.488085\u0026#34; # is_hiq \u0026#34;1\u0026#34; # qc_pass \u0026#34;1\u0026#34; # pert_id \u0026#34;BRD-U44432129\u0026#34; # sig_id \u0026#34;MET001_N8_XH:BRD-U44432129:100:336\u0026#34; # pert_type \u0026#34;trt_cp\u0026#34; # cell_iname \u0026#34;NAMEC8\u0026#34; # det_wells \u0026#34;H05|H06|H07|H08\u0026#34; # det_plates \u0026#34;MET001_N8_XH_X1_B17\u0026#34; # distil_ids \u0026#34;MET001_N8_XH_X1_B17:H05|MET001_N8_XH_X1_B17:H06|MET001_N8_XH_X1_B17:H07|MET001_N8_XH_X1_B17:H08\u0026#34; # build_name NA # project_code \u0026#34;MET\u0026#34; # cmap_name \u0026#34;BRD-U44432129\u0026#34; # is_exemplar_sig \u0026#34;0\u0026#34; # is_ncs_sig \u0026#34;0\u0026#34; # is_null_sig \u0026#34;0\u0026#34; 2.2 实验（行）注释\u0026ndash;化合物与细胞系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 cp_meta = data.table::fread(\u0026#34;compoundinfo_beta.txt\u0026#34;) t(cp_meta[1,]) # [,1] # pert_id \u0026#34;BRD-A08715367\u0026#34; # cmap_name \u0026#34;L-theanine\u0026#34; # target \u0026#34;\u0026#34; # moa \u0026#34;\u0026#34; # canonical_smiles \u0026#34;CCNC(=O)CCC(N)C(O)=O\u0026#34; # inchi_key \u0026#34;DATAGRPVKZEWHA-UHFFFAOYSA-N\u0026#34; # compound_aliases \u0026#34;l-theanine\u0026#34; cell_meta = data.table::fread(\u0026#34;cellinfo_beta.txt\u0026#34;) t(cell_meta[1,]) # [,1] # cell_iname \u0026#34;1HAE\u0026#34; # cellosaurus_id \u0026#34;\u0026#34; # donor_age \u0026#34;\u0026#34; # donor_age_death NA # donor_disease_age_onset NA # doubling_time \u0026#34;\u0026#34; # growth_medium \u0026#34;\u0026#34; # provider_catalog_id \u0026#34;\u0026#34; # feature_id \u0026#34;\u0026#34; # cell_type \u0026#34;normal\u0026#34; # donor_ethnicity \u0026#34;Unknown\u0026#34; # donor_sex \u0026#34;Unknown\u0026#34; # donor_tumor_phase \u0026#34;Unknown\u0026#34; # cell_lineage \u0026#34;unknown\u0026#34; # primary_disease \u0026#34;unknown\u0026#34; # subtype \u0026#34;normal fibroblast sample\u0026#34; # provider_name \u0026#34;\u0026#34; # growth_pattern \u0026#34;unknown\u0026#34; # ccle_name \u0026#34;\u0026#34; # cell_alias \u0026#34;\u0026#34; 2.3 实验（列）注释\u0026ndash;基因信息 1 2 3 4 5 6 7 8 9 10 gene_meta = data.table::fread(\u0026#34;geneinfo_beta.txt\u0026#34;) t(gene_meta[1,]) # [,1] # gene_id \u0026#34;750\u0026#34; # gene_symbol \u0026#34;GAS8-AS1\u0026#34; # ensembl_id \u0026#34;ENSG00000221819\u0026#34; # gene_title \u0026#34;GAS8 antisense RNA 1\u0026#34; # gene_type \u0026#34;ncRNA\u0026#34; # src \u0026#34;NCBI\u0026#34; # feature_space \u0026#34;inferred\u0026#34; shRNA类型 1、差异表达矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 gctx_demo = parse_gctx(\u0026#34;gctx/level5_beta_trt_sh_n238351x12328.gctx\u0026#34;, cid=1:2, rid=1:2) gctx_demo@mat # CGS001_A375_96H:A2M:1 CGS001_A375_96H:AARS:1 # 10 -0.3014087 -0.17930678 # 100 0.2917795 0.05233869 gctx_demo@rdesc # id # 1 10 # 2 100 gctx_demo@cdesc # id # 1 CGS001_A375_96H:A2M:1 # 2 CGS001_A375_96H:AARS:1 2、meta注释信息 2.1 实验（行）注释\u0026ndash;基本+质量信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 sig_info = data.table::fread(\u0026#34;siginfo_beta.txt\u0026#34;,data.table=FALSE) col_meta \u0026lt;- read_gctx_meta(\u0026#34;gctx/level5_beta_trt_sh_n238351x12328.gctx\u0026#34;, dim=\u0026#34;col\u0026#34;) table(col_meta[,\u0026#34;id\u0026#34;] %in% sig_info[,\u0026#34;sig_id\u0026#34;]) # TRUE # 238351 t(sig_sub[1,]) # 373 # bead_batch \u0026#34;b7\u0026#34; # nearest_dose NA # pert_dose NA # pert_dose_unit \u0026#34;\u0026#34; # pert_idose \u0026#34;\u0026#34; # pert_itime \u0026#34;96 h\u0026#34; # pert_time \u0026#34;96\u0026#34; # pert_time_unit \u0026#34;h\u0026#34; # cell_mfc_name \u0026#34;PC3\u0026#34; # pert_mfc_id \u0026#34;TRCN0000350275\u0026#34; # nsample \u0026#34;2\u0026#34; # cc_q75 \u0026#34;0.43\u0026#34; # ss_ngene \u0026#34;74\u0026#34; # tas \u0026#34;0.180377\u0026#34; # pct_self_rank_q25 \u0026#34;0.134953\u0026#34; # wt \u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\\\u0026#34;\u0026#34; # median_recall_rank_spearman \u0026#34;0\u0026#34; # median_recall_rank_wtcs_50 \u0026#34;0\u0026#34; # median_recall_score_spearman \u0026#34;0.426979\u0026#34; # median_recall_score_wtcs_50 \u0026#34;0.697757\u0026#34; # batch_effect_tstat \u0026#34;11.81\u0026#34; # batch_effect_tstat_pct \u0026#34;51.0192\u0026#34; # is_hiq \u0026#34;1\u0026#34; # qc_pass \u0026#34;1\u0026#34; # pert_id \u0026#34;TRCN0000350275\u0026#34; # sig_id \u0026#34;TAK001_PC3_96H:TRCN0000350275:-666\u0026#34; # pert_type \u0026#34;trt_sh\u0026#34; # cell_iname \u0026#34;PC3\u0026#34; # det_wells \u0026#34;P11\u0026#34; # det_plates \u0026#34;TAK001_PC3_96H_X1_B7_DUO52HI53LO|TAK001_PC3_96H_X2_B7_DUO52HI53LO\u0026#34; # distil_ids \u0026#34;TAK001_PC3_96H_X1_B7_DUO52HI53LO:P11|TAK001_PC3_96H_X2_B7_DUO52HI53LO:P11\u0026#34; # build_name NA # project_code \u0026#34;TAK\u0026#34; # cmap_name \u0026#34;PIK3CA\u0026#34; #作用对象基因 # is_exemplar_sig \u0026#34;1\u0026#34; # is_ncs_sig \u0026#34;1\u0026#34; # is_null_sig \u0026#34;0\u0026#34; （1）其余注释同上\n（2）此外还有其它类型干扰(over-expression、CRISPR等)；操作基本同上，不再叙述。\n二、LINCS Phase-1(GSE92742) 1、差异表达矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ###根据行列id序号提取指定的差异表达矩阵 ###行名表示基因名；列名表示实验id名 gctx_demo = parse_gctx(\u0026#34;phase1/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, cid=1:2, rid=1:2) gctx_demo@mat # CPC005_A375_6H:BRD-A85280935-003-01-7:10 # 5720 0.7737690 # 466 -0.8184680 # CPC005_A375_6H:BRD-A07824748-001-02-6:10 # 5720 -0.6455861 # 466 -0.8107487 ###gctx文件里没有更多的注释信息 gctx_demo@rdesc # id #1 5720 #2 466 gctx_demo@cdesc # id #1 CPC005_A375_6H:BRD-A85280935-003-01-7:10 #2 CPC005_A375_6H:BRD-A07824748-001-02-6:10 由于gctx文件太大，可根据下面的注释信息，仅仅提取部分感兴趣的差异表达矩阵。\n2、meta注释信息 2.1 实验（行）注释\u0026ndash;基本信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 sig_info = data.table::fread(\u0026#34;phase1/Fine_phase1_sig_info_473647.csv\u0026#34;, data.table = F) col_meta = read_gctx_meta(\u0026#34;phase1/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, dim=\u0026#34;col\u0026#34;) identical(col_meta$id, sig_info$sig_id) # [1] TRUE t(sig_info[1,]) # [,1] # sig_id \u0026#34;CPC005_A375_6H:BRD-A85280935-003-01-7:10\u0026#34; ##实验ID # pert_id \u0026#34;BRD-A85280935\u0026#34; ##干扰方法ID # pert_iname \u0026#34;quinpirole\u0026#34; ##干扰物命名(化合物或者基因名) # pert_type \u0026#34;trt_cp\u0026#34; ##干扰类型(化合物/基因敲除、过表达) # cell_id \u0026#34;A375\u0026#34; ##细胞系名 # pert_dose \u0026#34;10.0\u0026#34; ##剂量 # pert_dose_unit \u0026#34;µM\u0026#34; ##剂量 # pert_idose \u0026#34;10 µM\u0026#34; ##剂量 # pert_time \u0026#34;6\u0026#34; ##干扰时间 # pert_time_unit \u0026#34;h\u0026#34; ##干扰时间 # pert_itime \u0026#34;6 h\u0026#34; ##干扰时间 # distil_id \u0026#34;CPC005_A375_6H_X1_B3_DUO52HI53LO:K06|CPC005_A375_6H_X2_B3_DUO52HI53LO:K06|CPC005_A375_6H_X3_B3_DUO52HI53LO:K06\u0026#34; table(sig_info$pert_type) # ctl_untrt ctl_untrt.cns ctl_vector ctl_vector.cns ctl_vehicle # 588 30 6826 137 14423 #ctl_vehicle.cns trt_cp trt_lig trt_oe trt_oe.mut # 61 205034 8256 22205 6 # trt_sh trt_sh.cgs trt_sh.css # 154993 36720 24368 2.2 实验（行）注释\u0026ndash;实验质量信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sig_metrics = data.table::fread(\u0026#34;phase1/phase1_sig_metrcs.csv\u0026#34;, data.table = F) col_meta = read_gctx_meta(\u0026#34;phase1/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, dim=\u0026#34;col\u0026#34;) sig_metrics = sig_metrics[match(col_meta$id, sig_metrics$sig_id),] identical(col_meta$id, sig_metrics$sig_id) # [1] TRUE t(sig_metrics[1,]) # 53349 # sig_id \u0026#34;CPC005_A375_6H:BRD-A85280935-003-01-7:10\u0026#34; # pert_id \u0026#34;BRD-A85280935\u0026#34; # pert_iname \u0026#34;quinpirole\u0026#34; # pert_type \u0026#34;trt_cp\u0026#34; # distil_cc_q75 \u0026#34;0.11\u0026#34; # 重复相同实验的结果相似度指标 # distil_ss \u0026#34;2.84895\u0026#34; # 干扰影响强度指标 # ngenes_modulated_up_lm \u0026#34;18\u0026#34; # ngenes_modulated_dn_lm \u0026#34;15\u0026#34; # tas \u0026#34;0.101169\u0026#34; # 综合cc_q75与ss的评价指标结果 # pct_self_rank_q25 \u0026#34;7.6087\u0026#34; # is_exemplar \u0026#34;0\u0026#34; # distil_nsample \u0026#34;3\u0026#34; 2.3 实验（行）注释\u0026ndash;干扰物与细胞系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ###通过pert_id与前面的信息相关联 #(1)干扰物注释：主要针对化合物类干扰实验，提供化合物的CID等信息 pert_info = data.table::fread(\u0026#34;phase1/phase1_pert_info.csv\u0026#34;) t(pert_info[1,]) # [,1] # V1 \u0026#34;1\u0026#34; # pert_id \u0026#34;56582\u0026#34; # pert_iname \u0026#34;AKT2\u0026#34; # pert_type \u0026#34;trt_oe\u0026#34; # is_touchstone \u0026#34;0\u0026#34; # inchi_key_prefix \u0026#34;-666\u0026#34; # inchi_key \u0026#34;-666\u0026#34; # canonical_smiles \u0026#34;-666\u0026#34; # pubchem_cid \u0026#34;-666\u0026#34; #(2)细胞系注释：例如是否为肿瘤细胞系，源自那个部位等 cell_info = data.table::fread(\u0026#34;phase1/phase1_cell_info.csv\u0026#34;) t(cell_info[1,]) # [,1] # cell_id \u0026#34;A375\u0026#34; # cell_type \u0026#34;cell line\u0026#34; # base_cell_id \u0026#34;A375\u0026#34; # precursor_cell_id \u0026#34;-666\u0026#34; # modification \u0026#34;-666\u0026#34; # sample_type \u0026#34;tumor\u0026#34; # primary_site \u0026#34;skin\u0026#34; # subtype \u0026#34;malignant melanoma\u0026#34; # original_growth_pattern \u0026#34;adherent\u0026#34; # provider_catalog_id \u0026#34;CRL-1619\u0026#34; # original_source_vendor \u0026#34;ATCC\u0026#34; # donor_age \u0026#34;54\u0026#34; # donor_sex \u0026#34;F\u0026#34; # donor_ethnicity \u0026#34;-666\u0026#34; 2.4 实验（列）注释\u0026ndash;基因信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 gene_info = data.table::fread(\u0026#34;phase1/Fine_phase1_gene_info_12328.csv\u0026#34;, data.table = F) row_meta \u0026lt;- read_gctx_meta(\u0026#34;phase1/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, dim=\u0026#34;row\u0026#34;) identical(as.integer(row_meta$id), gene_info$pr_gene_id) # [1] TRUE dim(gene_info) # [1] 12328 5 t(gene_info[1,]) # 1 # pr_gene_id \u0026#34;5720\u0026#34; # pr_gene_symbol \u0026#34;PSME1\u0026#34; # pr_gene_title \u0026#34;proteasome activator subunit 1\u0026#34; # pr_is_lm \u0026#34;1\u0026#34; # landmark 978 # pr_is_bing \u0026#34;1\u0026#34; # landmark + best inferred gene 10174 Phase-2(GSE70138) 1、差异表达矩阵 1 2 3 4 5 6 7 8 ###根据行列id序号提取指定的差异表达矩阵 ###行名表示基因名；列名表示实验id名 gctx_demo = parse_gctx(\u0026#34;phase2/GSE70138_Broad_LINCS_Level5_COMPZ_n118050x12328_2017-03-06.gctx\u0026#34;, cid=1:2, rid=1:2) gctx_demo@mat # REP.A001_A375_24H:A03 REP.A001_A375_24H:A04 #780 4.2641425 -0.3822108 #7849 0.0572492 0.3043132 2、meta注释信息 2.1 实验（行）注释\u0026ndash;基本信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 sig_info = data.table::fread(\u0026#34;phase2/Fine_phase2_sig_info_118050.csv\u0026#34;, data.table = F) col_meta = read_gctx_meta(\u0026#34;phase2/GSE70138_Broad_LINCS_Level5_COMPZ_n118050x12328_2017-03-06.gctx\u0026#34;, dim=\u0026#34;col\u0026#34;) identical(col_meta$id, sig_info$sig_id) # [1] TRUE t(sig_info[1,]) # 1 # sig_id \u0026#34;REP.A001_A375_24H:A03\u0026#34; # pert_id \u0026#34;DMSO\u0026#34; # pert_iname \u0026#34;DMSO\u0026#34; # pert_type \u0026#34;ctl_vehicle\u0026#34; # cell_id \u0026#34;A375\u0026#34; # pert_idose \u0026#34;-666\u0026#34; # pert_itime \u0026#34;24 h\u0026#34; # distil_id \u0026#34;REP.A001_A375_24H_X1_B22:A03|REP.A001_A375_24H_X2_B22:A03|REP.A001_A375_24H_X3_B22:A03\u0026#34; table(sig_info$pert_type) # ctl_untrt ctl_vector ctl_vehicle trt_cp trt_xpr # 88 209 6467 107404 3882 2.2 实验（行）注释\u0026ndash;实验质量信息 1 2 3 4 5 6 7 8 sig_metrics = data.table::fread(\u0026#34;phase2/phase2_sig_metrics.csv\u0026#34;, data.table = F) col_meta = read_gctx_meta(\u0026#34;phase1/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, dim=\u0026#34;col\u0026#34;) sig_metrics = sig_metrics[match(col_meta$id, sig_metrics$sig_id),] identical(col_meta$id, sig_metrics$sig_id) # [1] TRUE t(sig_metrics[1,]) 2.3 实验（行）注释\u0026ndash;干扰物与细胞系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ###通过pert_id与前面的信息相关联 #(1)干扰物注释：主要针对化合物类干扰实验，提供化合物的CID等信息 pert_info = data.table::fread(\u0026#34;phase2/phase2_pert_info.csv\u0026#34;) t(pert_info[1,]) # [,1] # pert_id \u0026#34;BRD-K70792160\u0026#34; # canonical_smiles \u0026#34;CCN(CC)CCCCN1c2ccccc2Oc2ccc(Cl)cc12\u0026#34; # inchi_key \u0026#34;GYBXAGDWMCJZJK-UHFFFAOYSA-N\u0026#34; # pert_iname \u0026#34;10-DEBC\u0026#34; # pert_type \u0026#34;trt_cp\u0026#34; # pubchem_id \u0026#34;10521421\u0026#34; #(2)细胞系注释：例如是否为肿瘤细胞系，源自那个部位等 cell_info = data.table::fread(\u0026#34;phase2/phase2_cell_info.csv\u0026#34;) t(cell_info[1,]) # [,1] # cell_id \u0026#34;A375\u0026#34; # cell_type \u0026#34;cell line\u0026#34; # base_cell_id \u0026#34;A375\u0026#34; # precursor_cell_id \u0026#34;-666\u0026#34; # modification \u0026#34;-666\u0026#34; # sample_type \u0026#34;tumor\u0026#34; # primary_site \u0026#34;skin\u0026#34; # subtype \u0026#34;malignant melanoma\u0026#34; # original_growth_pattern \u0026#34;adherent\u0026#34; # provider_catalog_id \u0026#34;CRL-1619\u0026#34; # original_source_vendor \u0026#34;ATCC\u0026#34; # donor_age \u0026#34;54\u0026#34; # donor_sex \u0026#34;F\u0026#34; # donor_ethnicity \u0026#34;-666\u0026#34; 2.4 实验（列）注释\u0026ndash;基因信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 gene_info = data.table::fread(\u0026#34;phase2/Fine_phase1_gene_info_12328.csv\u0026#34;, data.table = F) row_meta \u0026lt;- read_gctx_meta(\u0026#34;phase2/GSE92742_Broad_LINCS_Level5_COMPZ.MODZ_n473647x12328.gctx\u0026#34;, dim=\u0026#34;row\u0026#34;) identical(as.integer(row_meta$id), gene_info$pr_gene_id) # [1] TRUE dim(gene_info) # [1] 12328 5 t(gene_info[1,]) # 1 # pr_gene_id \u0026#34;5720\u0026#34; # pr_gene_symbol \u0026#34;PSME1\u0026#34; # pr_gene_title \u0026#34;proteasome activator subunit 1\u0026#34; # pr_is_lm \u0026#34;1\u0026#34; # landmark 978 # pr_is_bing \u0026#34;1\u0026#34; # landmark + best inferred gene 10174 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/151%E6%95%B0%E6%8D%AE%E5%BA%93--%E8%8D%AF%E7%89%A9%E5%B9%B2%E6%89%B0%E8%BD%AC%E5%BD%95%E7%BB%84cmap/","summary":"\u003cblockquote\u003e\n\u003cp\u003eCmap LINCS计划采用L1000技术进行大规模的细胞系干扰实验测序，得到差异基因。具体可分为Phase-1，Phase-2两个阶段。数据已整理、上传至阿里云盘。本片笔记整理下数据的操作、使用方法。\u003c/p\u003e","title":"CMap数据库整理与使用方法"},{"content":"本次的两篇文章属于同一团队，第一篇文章侧重提出计算方法；第二篇文章侧重于应用方法，发现生物学规律\nPaper1：提出方法 SIGN: similarity identification in gene expression\nBioinformatics 2019 / 2 IF = 7\n1.1 TSC score 文章根据2009年学者提出的modified RV coefficient，使用transcriptional similarity coefficient(TSC)分数，用以表征两个矩阵的相似性。计算公式如下：其中P1矩阵与P2矩阵的纵轴(Gene Row)需要保持一致，而两个矩阵的样本数(Sample Column)没有要求。 $$ TSC(P_1,P_2) = \\frac{\\sum_{i}(P_{10}×P_{20}){ij}} {{\\sqrt{\\sum{ij}(P_{10}){ij}^2}}× {\\sqrt{\\sum{ij}(P_{20})_{ij}^2}}} $$\n其中Pm0的计算公式如下。 P'表示原始P矩阵的转置矩阵，Diagonal()方法仅保存原始矩阵的主对角线值，其余值标记为0。 $$ P_{m0} = P_m × P\u0026rsquo;_m - Diagonal(P_m × P\u0026rsquo;_m) $$\n计算的TSC score范围在[-1, 1]之间，值越高表明两个样本(群)具有相同的基因表达模式。\n根据RV coefficient，符合以下特征规律：\n举例计算，实现需要了解矩阵乘法的原理。\n1.2 简单应用 1.2.1 乳腺癌分型 文章根据一个乳腺癌数据集表达矩阵，计算其中两两样本间分别关于ESR1、ERBB2相关基因集的相似性。基于此计算样本间的欧几里得距离(详见原文代码)，用于层次聚类。\n根据样本已知注释评价聚类结果，如下图所示具有较好的一致性。\n1.2.2 生存分析 同样的数据集，根据不同给药处理分为四组，每组单独分析。在每组中，找到生存最好、最差的10%样本作为标准，计算其余每一样本分别与之的相似性，进行比较，得出Delta结果。 $$ Delta = (similarity,to,good,survival,cohort) - (similarity,to,poor,survival,cohort) $$ 如果Delta\u0026gt;0, 表示该样本与生存良好的样本集更接近；反之Delta\u0026lt;0, 表示与生存较差的样本集更接近。\n然后根据Delta正负性对每组样本进行分组生存分析，用以评价Delta的生存预后价值。\n1.3 数据分享 1.3.1 SIGN包 文章编写了一个R包 SIGN(Similarity Identiﬁcation in Gene expressioN)用于计算两个基因表达矩阵的相似性，已经上传到CRAN。\n其核心代码如下\n1 2 3 4 5 6 7 8 TSC \u0026lt;- function(PathwayExp1, PathwayExp2){ AA \u0026lt;- PathwayExp1%*%t(PathwayExp1) BB \u0026lt;- PathwayExp2%*%t(PathwayExp2) AA0 \u0026lt;- AA - diag(diag(AA)) BB0 \u0026lt;- BB - diag(diag(BB)) TSC \u0026lt;- sum(diag(AA0%*%BB0))/sum(AA0^2)^.5/sum(BB0^2)^.5 return(TSC) } 1.3.2 codeocean 文章已将绘制Fig2的代码、数据上传到 CodeOcean，可通过http://bit.ly/2PMwegY访问，进行复现分析。\nPaper2：应用发现 Pathway-Based Drug Response Prediction Using Similarity Identification in Gene Expression\nFrontiers in Genetics 2020 / 09 IF=4.6\n2.1 应用思路 拉帕替尼(Lapatinib)和曲妥珠单抗(trastuzumab)是针对HER2+型乳腺癌的药物，但并非所有HER2+型乳腺癌患者均有效(40%)。\n因此文章想鉴定出根据患者的基因表达情况可以预测HER2+型乳腺癌患者对上述药物是否响应的biomaker。\n一方面考虑单基因作为biomarker的区分效果，另一方面使用上面提及的TSC score方法评价通路作为biomarker的预测效果。\n2.2 研究步骤 2.2.1 数据与方法 使用来自NeoALTTO clinical trial数据集，根据治疗方式分为Lapatinib、Trastuzumab，以及联用组。并进一步根据ER状态分为阴性组与阳性组。\nRelying on the common knowledge on ER being one of the main drivers in breast cancer development and progression (Fuqua,1997), we stratified our analyses based on the ER status.\n根据Rate of pathological complete response (pCR)，将患者分为Responders，与Non-responders。相当于贴标签。\n使用C-index(concordance index)值用于评价gene/pathway的预测分类性能\n2.2.2 单基因biomarker分析 根据患者的基因表达与响应状态关系，计算C-index。使用置换检验评价结果的显著性。\n结果发现最好的单基因C-index值为0.68，即使是marker基因ERBB2的C-index值仅为0.59。\n2.2.3 通路biomaker分析 通路选择：GO term中基因数10~30之前的通路\nTSC预测：对于每一组来说，选择其中一个病人进行预测。分别计算其与剩余所有Responder与Non-responders 的相似度。\n将该样本定位为距离相距较近的一组。对所有样本逐一按此法预测。\n留一法交叉验证：选择一个病人，分别计算其与剩余样本中任意5个Responder的通路相似度，以及任意5个Non-Responder的通路相似度，比较二者结果的中位数，贴标签；重复100次取众数。计算C-index。\n结果发现，每组的Top通路的C-index可达到0.8，优于其它机器学习的预测结果。 ","permalink":"https://lishensuo.github.io/en/posts/basic/152%E6%96%87%E7%8C%AE--%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E6%80%A7%E8%AE%A1%E7%AE%97%E6%A0%B7%E6%9C%AC%E9%80%9A%E8%B7%AF%E4%B8%80%E8%87%B4%E6%80%A7/","summary":"\u003cp\u003e本次的两篇文章属于同一团队，第一篇文章侧重提出计算方法；第二篇文章侧重于应用方法，发现生物学规律\u003c/p\u003e\n\u003ch1 id=\"paper1提出方法\"\u003ePaper1：提出方法\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eSIGN: similarity identification in gene expression\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eBioinformatics  2019 / 2  IF = 7\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220513150043152.png\" alt=\"image-20220513150043152\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"11-tsc-score\"\u003e1.1 TSC score\u003c/h2\u003e\n\u003cp\u003e文章根据2009年学者提出的\u003ca href=\"https://pubmed.ncbi.nlm.nih.gov/19073588/\"\u003emodified RV coefficient\u003c/a\u003e，使用transcriptional similarity coefficient(TSC)分数，用以表征两个矩阵的相似性。计算公式如下：其中P1矩阵与P2矩阵的纵轴(Gene Row)需要保持一致，而两个矩阵的样本数(Sample Column)没有要求。\n$$\nTSC(P_1,P_2) = \\frac{\\sum_{i}(P_{10}×P_{20})\u003cem\u003e{ij}} {{\\sqrt{\\sum\u003c/em\u003e{ij}(P_{10})\u003cem\u003e{ij}^2}}× {\\sqrt{\\sum\u003c/em\u003e{ij}(P_{20})_{ij}^2}}}\n$$\u003c/p\u003e","title":"矩阵相似性计算样本通路一致性"},{"content":" 官方介绍：https://www.gsea-msigdb.org/gsea/msigdb/\n下载界面：http://www.gsea-msigdb.org/gsea/downloads.jsp\n通路词条示例：https://www.gsea-msigdb.org/gsea/msigdb/cards/CORONEL_RFX7_DIRECT_TARGETS_UP.html，记录通路的描述信息以及出处。\n1、hallmark gene sets 50条代表性通路，涵盖了涉及发育、免疫、信号通路等明确定义的基因集，具体见文末。\n基于C1-C6的4000多条通路整理而成，整合思路可参考文章。\n可以作为探索富集通路的分析起点\n1 2 3 4 5 6 7 8 9 10 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/h.all.v7.5.1.symbols.gmt\u0026#34;) length(unique(gset$term)) # head(gset) # term gene # 1 HALLMARK_TNFA_SIGNALING_VIA_NFKB JUNB # 2 HALLMARK_TNFA_SIGNALING_VIA_NFKB CXCL2 # 3 HALLMARK_TNFA_SIGNALING_VIA_NFKB ATF3 # 4 HALLMARK_TNFA_SIGNALING_VIA_NFKB NFKBIA # 5 HALLMARK_TNFA_SIGNALING_VIA_NFKB TNFAIP3 # 6 HALLMARK_TNFA_SIGNALING_VIA_NFKB PTGS2 2、C1 : positional gene sets 记录每个染色体区段的基因； 可用于识别与染色体缺失/扩增，表观遗传沉默等相关的效应 1 2 3 4 5 6 7 8 9 10 11 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c1.all.v7.5.1.symbols.gmt\u0026#34;) length(unique(gset$gene)) # 40721 head(gset) # term gene # 1 chr1p11 RPL22P6 # 2 chr1p11 NBPF8 # 3 chr1p11 LINC02798 # 4 chr1p11 H3P4 # 5 chr1p11 MTIF2P1 # 6 chr1p11 SRGAP2C 3、C2：curated gene sets 3.1 CGP: Chemical and genetic perturbations 化合物/基因/信号通路干扰的差异表达基因集，一般分为UP/DN两类。收集的signature数据主要来自于文献。 1 2 3 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c2.cgp.v7.5.1.symbols.gmt\u0026#34;) head(gset) head(unique(gset$term)) 3.2 CP: Canonical pathways 各种通路数据库中收集而来，比如KEGG、Reactome、WikiPathways等 1 2 3 4 5 6 7 8 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c2.cp.kegg.v7.5.1.symbols.gmt\u0026#34;) length(unique(gset$term)) #186 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c2.cp.reactome.v7.5.1.symbols.gmt\u0026#34;) length(unique(gset$term)) #1615 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c2.cp.wikipathways.v7.5.1.symbols.gmt\u0026#34;) length(unique(gset$term)) #664 4、C3：regulatory target gene sets 4.1 MIR: microRNA targets microRNA所调控的靶点基因，主要收集自miRDB v6.0 (mirdb.org, Chen and Wang, 2020) 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c3.mir.v7.5.1.entrez.gmt\u0026#34;) head(gset) # term gene # 1 MIR153_5P 4232 # 2 MIR153_5P 11163 # 3 MIR153_5P 3267 # 4 MIR153_5P 3843 # 5 MIR153_5P 25926 # 6 MIR153_5P 63976 4.2 TFT: Transcription factor targets 转录因子所调控的靶点，主要收集自the Gene Transcription Regulation Database (GTRD, gtrd.biouml.org) 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c3.tft.v7.5.1.symbols.gmt\u0026#34;) head(gset) # term gene # 1 METHYLCYTOSINE_DIOXYGENASE_TET_UNIPROT_A0A023HHK9_UNREVIEWED_TARGET_GENES PPP1R12A # 2 METHYLCYTOSINE_DIOXYGENASE_TET_UNIPROT_A0A023HHK9_UNREVIEWED_TARGET_GENES SPHK2 # 3 METHYLCYTOSINE_DIOXYGENASE_TET_UNIPROT_A0A023HHK9_UNREVIEWED_TARGET_GENES HAGH # 4 METHYLCYTOSINE_DIOXYGENASE_TET_UNIPROT_A0A023HHK9_UNREVIEWED_TARGET_GENES RBL1 # 5 METHYLCYTOSINE_DIOXYGENASE_TET_UNIPROT_A0A023HHK9_UNREVIEWED_TARGET_GENES GEMIN5 # 6 METHYLCYTOSINE_DIOXYGENASE_TET_UNIPROT_A0A023HHK9_UNREVIEWED_TARGET_GENES TMED2 5、C4：computational gene sets 5.1 CGN: Cancer gene neighborhoods 癌症相关的表型或者特征相关的基因集，收集自4个数据库GNF2: Human tissue compendium (Novartis)、CAR: Novartis carcinoma compendium (Novartis)、GCM: Global Cancer Map (Broad Institute)、MORF: An unpublished compendium of gene expression data sets。 1 2 3 4 5 6 7 8 9 10 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c4.cgn.v7.5.1.symbols.gmt\u0026#34;) head(gset) unique(gset$term) # term gene # 1 MORF_ATRX ADCY3 # 2 MORF_ATRX SEC31A # 3 MORF_ATRX BTD # 4 MORF_ATRX LTBP4 # 5 MORF_ATRX UTRN # 6 MORF_ATRX FIG4 5.2 CM: Cancer modules 456 such modules as significantly changed in a variety of cancer conditions 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c4.cm.v7.5.1.symbols.gmt\u0026#34;) head(gset) # term gene # 1 MODULE_9 SLC16A4 # 2 MODULE_9 ACTN1 # 3 MODULE_9 PER1 # 4 MODULE_9 VWF # 5 MODULE_9 DHRS3 # 6 MODULE_9 ID2B 6、C5：ontology gene sets 6.1 GO: Gene Ontology biological process (BP), cellular component (CC), or molecular function (MF) respectively. 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c5.go.v7.5.1.symbols.gmt\u0026#34;) head(gset) # term gene # 1 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE AKT3 # 2 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE PPARGC1A # 3 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE POLG2 # 4 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE PARP1 # 5 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE DNA2 # 6 GOBP_MITOCHONDRIAL_GENOME_MAINTENANCE TYMP 6.2 Human Phenotype Ontology 疾病表型相关的基因集 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c5.hpo.v7.5.1.symbols.gmt\u0026#34;) head(gset) # term gene # 1 HP_MULTICYSTIC_KIDNEY_DYSPLASIA TMEM107 # 2 HP_MULTICYSTIC_KIDNEY_DYSPLASIA LZTFL1 # 3 HP_MULTICYSTIC_KIDNEY_DYSPLASIA PEX6 # 4 HP_MULTICYSTIC_KIDNEY_DYSPLASIA GPC4 # 5 HP_MULTICYSTIC_KIDNEY_DYSPLASIA TFAP2A # 6 HP_MULTICYSTIC_KIDNEY_DYSPLASIA SIX1 7、C6：oncogenic signature gene sets 癌症细胞系中相关癌基因异常表达的上下调基因集 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c6.all.v7.5.1.symbols.gmt\u0026#34;) head(gset) # term gene # 1 GLI1_UP.V1_DN CACUL1 # 2 GLI1_UP.V1_DN CCNL2 # 3 GLI1_UP.V1_DN YIPF1 # 4 GLI1_UP.V1_DN GTDC1 # 5 GLI1_UP.V1_DN OPN3 # 6 GLI1_UP.V1_DN SLC22A1 8、C7：immunologic signature gene sets 8.1：ImmuneSigDB 主要收集自GEO，有关免疫系统异常状态差异分析的上下调基因集 1 2 3 4 5 6 7 8 9 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c7.immunesigdb.v7.5.1.symbols.gmt\u0026#34;) head(gset) # term gene # 1 KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP RFLNB # 2 KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP AMPD3 # 3 KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP NSG2 # 4 KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP DUSP6 # 5 KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP ADCY6 # 6 KAECH_NAIVE_VS_DAY8_EFF_CD8_TCELL_UP TEC 8.2：VAX: vaccine response gene sets 疫苗反应的基因集 9、C8：cell type signature gene sets 不同细胞类型的marker基因；主要收集自文献 1 2 gset = clusterProfiler::read.gmt(\u0026#34;msigdb_v7.5.1_GMTs/c8.all.v7.5.1.symbols.gmt\u0026#34;) length(unique(gset$term)) #700 附 Hallmark name Process category Description 释义 Number of founder sets Number of genes 1 APICAL_JUNCTION cellular component Apical junction complex consisting of adherens and tight junctions 顶端连接复合体，影响细胞-细胞粘附和细胞间通讯 37 200 2 APICAL_SURFACE cellular component Membrane proteins in the apical domain 顶端结构域的膜蛋白 12 44 3 PEROXISOME cellular component Peroxisomes 过氧化物酶体，一种细胞器 28 107 4 ADIPOGENESIS development Adipocyte development 脂肪细胞的发育 36 200 5 ANGIOGENESIS development Blood vessel formation 血管的形成 14 36 6 EPITHELIAL_MESENCHYMAL_TRANSITION development Epithelial mesenchymal transition 上皮间充质转化，在胚胎发育、慢性炎症、组织重建、癌症转移和多种纤维化疾病中发挥了重要作用 107 200 7 MYOGENESIS development Muscle differentiation 肌肉发育分化 64 200 8 SPERMATOGENESIS development Sperm development and male fertility 精子发育和男性生育能力 24 135 9 PANCREAS_BETA_CELL development Genes specific to pancreatic beta cells 胰腺细胞 24 40 10 DNA_REPAIR DNA damage DNA repair DNA修复 44 150 11 UV_RESPONSE_DOWN DNA damage UV response: down-regulated genes 紫外反应\u0026ndash;下调基因 17 144 12 UV_RESPONSE_UP DNA damage UV response: up-regulated genes 紫外反应\u0026ndash;上调基因 16 158 13 ALLOGRAFT_REJECTION immune Allograft rejection 同种异体移植物排斥 190 200 14 COAGULATION immune Coagulation cascade 凝血级联，身体形成血凝块以防止过多失血的过程 71 138 15 COMPLEMENT immune Complement cascade 补体级联反应 71 200 16 INTERFERON_ALPHA_RESPONSE immune Interferon alpha response 干扰素 α 82 97 17 INTERFERON_GAMMA_RESPONSE immune Interferon gamma response 干扰素 γ 82 200 18 IL6_JAK_STAT3_SIGNALING immune IL6 STAT3 signaling during acute phase response IL6 细胞因子受体 24 87 19 INFLAMMATORY_RESPONSE immune Inflammation 炎症 120 200 20 BILE_ACID_METABOLISM metabolic Biosynthesis of bile acids 胆汁酸生物合成 28 112 21 CHOLESTEROL_HOMEOSTASIS metabolic Cholesterol homeostasis 胆固醇平衡 28 74 22 FATTY_ACID_METABOLISM metabolic Fatty acid metabolism 脂肪酸代谢 53 158 23 GLYCOLYSIS metabolic Glycolysis and gluconeogenesis 糖酵解和糖质新生 87 200 24 HEME_METABOLISM metabolic Heme metabolism 血红素代谢 36 200 25 OXIDATIVE_PHOSPHORYLATION metabolic Oxidative phosphorylation and citric acid cycle 氧化磷酸化与柠檬酸循环 93 200 26 XENOBIOTIC_METABOLISM metabolic Metabolism of xenobiotics 外源性物质代谢 124 200 27 APOPTOSIS pathway Programmed cell death; caspase pathway 程序性细胞死亡;半胱天冬酶通路 80 161 28 HYPOXIA pathway Response to hypoxia; HIF1A targets 缺氧；HIF1A:缺氧诱导因子-1α 87 200 29 PROTEIN_SECRETION pathway Protein secretion 蛋白质分泌 74 96 30 UNFOLDED_PROTEIN_RESPONSE pathway Unfolded protein response; ER stress 内质网应激 22 113 31 REACTIVE_OXYGEN_SPECIES_PATHWAY pathway Reactive oxygen species (ROS) pathway 活性氧(ROS)途径 13 49 32 E2F_TARGETS proliferation E2F targets 参与哺乳动物细胞中DNA的细胞周期调控和合成 420 200 33 G2M_CHECKPOINT proliferation Cell cycle G2/M checkpoint 细胞周期G2/M检查点 420 200 34 MYC_TARGETS_V1 proliferation MYC targets variant 1 致癌基因MYC的治疗靶点 404 200 35 MYC_TARGETS_V2 proliferation MYC targets variant 2 致癌基因MYC的治疗靶点 6 58 36 P53_PATHWAY proliferation p53 pathway TP53通路 85 200 37 MITOTIC_SPINDLE proliferation Mitotic spindle assembly 有丝分裂纺锤体组装 108 200 38 ANDROGEN_RESPONSE signaling Androgen response 雄激素反应 8 117 39 ESTROGEN_RESPONSE_EARLY signaling Early estrogen response 雌激素反应 61 200 40 ESTROGEN_RESPONSE_LATE signaling Late estrogen response 雌激素反应 61 200 41 IL2_JAK_STAT5_SIGNALING signaling IL2 STAT5 signaling IL2 STAT5通路 13 200 42 KRAS_SIGNALING_UP signaling KRAS signaling, up-regulated genes KRAS通路 上调基因 14 200 43 KRAS_SIGNALING_DOWN signaling KRAS signaling, down-regulated genes KRAS通路 下调基因 16 200 44 MTORC1_SIGNALING signaling mTORC1 signaling mTOR通路 487 200 45 NOTCH_SIGNALING signaling Notch signaling Notch通路 49 32 46 PI3K_AKT_MTOR_SIGNALING signaling PI3K signaling via AKT to mTORC1 PI3K/AKT/mTOR通路 591 105 47 HEDGEHOG_SIGNALING signaling Hedgehog signaling Hedgehog通路 79 36 48 TGF_BETA_SIGNALING signaling TGF beta signaling TGF-β通路 29 54 49 TNFA_SIGNALING_VIA_NFKB signaling TNFA signaling via NFkB TNF-α/NF-kB通路 132 200 50 WNT_BETA_CATENIN_SIGNALING signaling Cannonical beta catenin pathway 经典Wnt信号通路 49 42 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/152%E6%95%B0%E6%8D%AE%E5%BA%93--%E9%80%9A%E8%B7%AF%E5%9F%BA%E5%9B%A0%E9%9B%86msigdb/","summary":"\u003cblockquote\u003e\n\u003cp\u003e官方介绍：https://www.gsea-msigdb.org/gsea/msigdb/\u003c/p\u003e\n\u003cp\u003e下载界面：http://www.gsea-msigdb.org/gsea/downloads.jsp\u003c/p\u003e","title":"MsigDB基因集数据库"},{"content":"1、算法简介 1.1 关系拆解 通过计算方法( 例如相关性Pearson correlation, 互信息mutual information等)构建的相互关系网络中，节点两两之间的关系通常包括直接关系与间接关系两部分，即如下图所示Total = Direct + Indirect\nPNAS的一篇文章提供了一种从计算网络中鉴定节点之间direct association的新方法\u0026ndash;iDIRECT(Inference of Direct and Indirect Relationships with Effective Copula-based Transitivity)\nDisentangling direct from indirect relationships in association networks\nDOI: 10.1073/pnas.2109995119\nPNAS 2022 Jan 11\n对于Sequential paths(如下图A)，即两个节点之间存在1至多个中间节点连接二者。可通过简单的关系乘法计算这两个节点在这条path的indirect关系。 $$ u \\otimes v = uv $$\n对于parallel paths中(如下图B)，即两个节点之间存在多条path。此时并没有简单的相加，而是采用Archimedean copulas计算 combined probability。从而保证u⊕v ∈ [0,1] for all u,v ∈ [0,1]。其中u、v表示每条path的indirect association $$ u\\oplus v = \\frac{u+v-2uv}{1-uv} $$\n对于存在direct与indirect association的节点对。其中G表示observation association；S表示direct association $$ G_{ij} = S_{ij}\\oplus S_{ik_2}G_{k_2j} \\oplus S_{ik_3}G_{k_3j} \\oplus \u0026hellip; \\oplus S_{ik_d}G_{k_dj} $$\n文章对上式做了进一步的改进：在计算节点i的邻居k(假如为k2)与节点j的关系时，排除self-looping path(k-i-j)后再进行计算k2与j的total association。 $$ G_{ij} = S_{ij}\\oplus S_{ik_2}T_{i,k_2j} \\oplus S_{ik_3}T_{i,k_3j} \\oplus \u0026hellip; \\oplus S_{ik_d}T_{i,k_dj} $$\n1.2 算法对比 文中提到之前已经有人提出相关方法，例如network deconvolution (ND)、global silencing (GS)等\n作者认为以前的方法中存在3点不足\n（1）interaction strength overﬂow：对于parallel path采用简单的相加，可能会存在 over-estimation。\n本文采用了Archimedean copulas方式计算多条path之和（如上图b所示） （2）self-looping：对于indirect association，考虑了包含自身的冗余路径。\n本文提出在计算indirect path时，一种计算transitivity matrix的新思路，用以去冗余。（如上图c所示） （3） ill-conditioning：对于这一点，暂时没有太理解。作者认为ND、GS等方法求解 direct association时借助转置矩阵G-1。但由于关系矩阵一般近奇异，转置操作具有高度不确定性。而本文使用了称为nonlinear solver方法，进行推算迭代、直至稳定。\nSpecifically, ill-conditioning means that the association matrix is close to singular and is highly unreliable to invert.\n2、Python脚本 作者已将代码封装为Python脚本，可直接使用。\nhttps://github.com/nxiao6gt/iDIRECT 为了适应不同python版本，作者提供了对应python版本的脚本文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 git clone https://github.com/nxiao6gt/iDIRECT.git # iDIRECT/ # ├── demo.py # ├── file_handler.pyc # ├── idirect.pyc ##主要分析脚本，默认为3.8版本的 # ├── LICENSE # ├── net_handler.pyc # ├── net_simulator.pyc # ├── __pycache__ # ├── README.md # ├── result # ├── script # └── versions tree iDIRECT/versions/ # iDIRECT/versions/ # ├── 3.5 # │ ├── file_handler.pyc # │ ├── idirect.pyc # │ ├── net_handler.pyc # │ └── net_simulator.pyc # ├── 3.8 # │ ├── file_handler.pyc # │ ├── idirect.pyc # │ ├── net_handler.pyc # │ └── net_simulator.pyc # └── 3.9 # ├── file_handler.pyc # ├── idirect.pyc # ├── net_handler.pyc # └── net_simulator.pyc ##(1) 选择相应版本的python脚本 ls iDIRECT/versions/3.8/*pyc | while read id ; do cp ${id} iDIRECT/; done cd iDIRECT #进入Python环境 import idirect as idir import file_handler as fh import net_handler as nh from time import time t0 = time() ##(2) 准备observable total association matrix G # cat result/demo.txt # N1 N2 0.7 # N2 N3 0.7 # N1 N3 0.5 # 如上是3个节点、3条边的total association matrix # 读取矩阵，以字典的形式存放 G,n = fh.read_file_weighted_edges(\u0026#34;result/demo.txt\u0026#34;, t0) G # {\u0026#39;N1\u0026#39;: {\u0026#39;N2\u0026#39;: 0.7, \u0026#39;N3\u0026#39;: 0.5}, # \u0026#39;N2\u0026#39;: {\u0026#39;N1\u0026#39;: 0.7, \u0026#39;N3\u0026#39;: 0.7}, # \u0026#39;N3\u0026#39;: {\u0026#39;N2\u0026#39;: 0.7, \u0026#39;N1\u0026#39;: 0.5}} ##(3) 计算direct association network S,err = idir.direct_association(G, t0=t0) # {\u0026#39;N1\u0026#39;: {\u0026#39;N2\u0026#39;: 0.6963451220087372, \u0026#39;N3\u0026#39;: 0.055394034573922085}, # \u0026#39;N2\u0026#39;: {\u0026#39;N1\u0026#39;: 0.6963451220087372, \u0026#39;N3\u0026#39;: 0.6963451220087373}, # \u0026#39;N3\u0026#39;: {\u0026#39;N2\u0026#39;: 0.6963451220087373, \u0026#39;N1\u0026#39;: 0.055394034573922085}} ##(4) 保存结果 direct association matrix S S2 = nh.merge(G, S) St = fh.save_sorted_turple(S2, in_file=\u0026#34;result/demo.txt\u0026#34;) fh.save_file_weighted_edges(St, \u0026#34;result/demo_res.txt\u0026#34;) # cat result/demo_res.txt # N1 N2 0.696345122 # N2 N3 0.696345122 # N1 N3 0.055394035 3、应用示例 在文章Result中除了第一部分简单介绍了iDIRECT的算法原理，后续部分都是通过在不同类型/背景网络中的应用（同时对比其它算法）说明本方法的优势。\n简单介绍一下在优化基因调控网络关系中的示例：\n3.1 DREAM5 DREAM5有一项重构基因网络挑战项目，其中有一个模拟的基因表达数据(GeneNet-Weaver (GNW) version 3.0)，同时给出了gold-standard 基因调控关系（0/1）。参赛者采用不同的计算方法试图重构网络，然后DREAM5基于gold-standard对预测结果进行评价。\n评价方式是从0到1遍历不同cut-off得到的true-positive rate/false-negative rate得到的AUPR与AUROC。\n然后进行随机1,000 random simulations，得到的AUPR与AUROC分布，作为背景，从而计算上述方法得到的AUPR与AUROC的P值\n原文描述为：\nThose links were then scored based on the true network using the Challenge organizer’s script (details in Mate- rials and Methods), which was just -log(p) of the empirical P-values of the predicted AUPR from 1,000 random simulations.\n3.2 iDIRECT优化 文章对于参赛者已提交的、基于不同算法得到network使用iDIRECT，以期望从中鉴定出direct association； 同时对比ND与GS两种方法的结果； 在结果评价上，同时考虑了AUPR与AUROC两个指标 $$ \\Theta_{PR} = -log_{10}P_{PR} $$\n$$ \\Theta_{ROC} = -log_{10}P_{ROC} $$\n$$ \\Theta_{total} = (\\Theta_{PR} + \\Theta_{ROC})/2 $$\nAUPR represents the average precision when recall (true-positive rate) varies from zero to one;\nAUROC represents the average true positive rate when the false-negative rate varies from zero to one.\n","permalink":"https://lishensuo.github.io/en/posts/basic/153%E6%96%87%E7%8C%AE--%E4%BB%8E%E7%9B%B8%E5%85%B3%E6%80%A7%E7%BD%91%E7%BB%9C%E4%B8%AD%E9%89%B4%E5%AE%9A%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E7%9B%B4%E6%8E%A5%E8%B0%83%E6%8E%A7%E5%85%B3%E7%B3%BB/","summary":"\u003ch1 id=\"1算法简介\"\u003e1、算法简介\u003c/h1\u003e\n\u003ch2 id=\"11-关系拆解\"\u003e1.1 关系拆解\u003c/h2\u003e\n\u003cp\u003e通过计算方法( 例如相关性Pearson correlation, 互信息mutual information等)构建的相互关系网络中，节点两两之间的关系通常包括直接关系与间接关系两部分，即如下图所示\u003ccode\u003eTotal = Direct + Indirect\u003c/code\u003e\u003c/p\u003e","title":"文献--从相关性网络中鉴定节点间的直接调控关系"},{"content":" （1）Computational Drug Repurposing for Alzheimer’s Disease Using Risk Genes From GWAS and Single-Cell RNA Sequencing Studies\nhttps://www.frontiersin.org/articles/10.3389/fphar.2021.617537/full\nFront Pharmacol， 2021/06， IF 5.81\n（2）gene2drug: a computational tool for pathway-based rational drug repositioning\nhttps://academic.oup.com/bioinformatics/article/34/9/1498/4721786\nBioinformatics，2018/15， IF 6.92\n（3）Drug-set enrichment analysis: a novel tool to investigate drug mode of action\nhttps://academic.oup.com/bioinformatics/article/32/2/235/1743543\nBioinformatics，2016/01， IF 6.92\n一、DSEA与gene2drug Napolitano等人分别于2016年、2018年在Bioinformatics提出了DSEA与gene2drug方法，分别回答了如下两个问题。\n1、功能简介 （1）DSEA：给出特定的几个类似的药物，发现这些药物可以特定作用于哪些通路？ https://dsea.tigem.it/\n（2）gene2drug：给出特定的几个通路，发现这些通路可以被哪些药物所调控？https://gene2drug.tigem.it/\n目前已经提供了gep2pep的bioconductor包同时支持上述的两种分析，分别称为CondSEA与PathSEA。\nhttps://bioconductor.org/packages/release/bioc/vignettes/gep2pep/inst/doc/vignette.html\n2、数据与计算方法 通路数据主要收集在MsigDB的8类基因集(DSEA)，DSEA与gene2drug文章所使用的数据略有差异。 药物干扰数据主要收集自Cmap的1309个 Ranked gene list(First\u0026ndash;most up; Last\u0026ndash;most down)，分别对应1309个compound。\n使用Kolmogorov–Smirnov (KS) test方法(https://github.com/franapoli/signed-ks-test)，计算每个药物对于所有通路的GSEA分析，得到富集分数与P值。富集分数范围在-1~1之间，越接近1表示药物可正向调控这个通路。\n3、两次GSEA分析 如上本质上是将药物\u0026ndash;基因差异表达矩阵转为药物\u0026ndash;通路调控矩阵。\nDSEA与gene2drug方法本质都是基于药物\u0026ndash;通路调控矩阵的再一次GSAE分析。\n对于DSEA，则是通路为主体的ranked list。First 是最正向调控该通路的药物，Last是最负向调控该通路的药物。\n在用户分析时，提供若干感兴趣的药物，发现整体上这些输入药物所正向/负向调控的通路。\n对于gene2drug，则是药物为主体的ranked list。First是该药物最正向调控的通路，Last是最负向调控的通路。\n在用户分析时，提供若干感兴趣的通路，发现整体上能够正向/负向这些输入通路的药物。\n二、基于通路的AD药物重定向 1、收集基因list 1.1 GWAS risk gene GWAS(genome-wide association analyses)全基因组关联分析通过SNP位点与病人表型信息鉴定疾病相关的risk gene\n作者参考Jansen等人2019年的大型AD GWAS研究(https://doi.org/10.1038/s41588-018-0311-9)收集到255个late-onset AD的风险基因【Table S1A】\n1.2 scRNAseq DEG scRNAseq单细胞数据可进行细胞类型水平的差异基因分析。\n作者参考Mathys等人2019年的大型AD单细胞数据研究(https://doi.org/10.1038/s41586-019-1195-2)收集得到717个来自3种细胞类型在AD early与late间的差异基因。【Table S1】\nAsr,astrocytes,星形胶质细胞\u0026ndash;532； Ex,excitatory neuronal,兴奋神经元\u0026ndash;103； Oli,oligodendrocytes,少突胶质细胞\u0026ndash;82 2、预分析 2.1 富集分析 对上述的4个基因list使用Enrichr工具进行富集分析（GO BP）\n2.2 靶点交集分析 根据Cummings等人2019年的AD研发药物综述(https://doi.org/10.1016/j.trci.2019.05.008)总结的处于phase 1, 2, and 3阶段的药物，在TTD、DrugBank、PubChem数据库收集药物的作用靶点。【Table S2】\nPhase Total target genes Unique target genes Total number of pathways (adjusted p-value \u0026lt; 0.05) Phase 3 49 37 33 Phase 2 110 90 67 Phase 1 34 23 21 结合上述3类药物的靶点信息，与之前得到的4个基因list做交集分析。结果发现\nGWAS 基因list与之有5个基因交集（TREM2, CD33, CHRNA2, PRSS8, and ACE） Ex差异基因list与之有3个基因交集（TKT, APP, and GABRA1） 其它两个基因list无交集基因。 The analysis suggests that other drugs targeted these AD-associated risk genes ca potentially be repurposed for AD.\n3、gene2drug分析 4个 如上所述的基因list、8个 通路基因集 使用 gep2pep包计算每个基因list中的基因在每个基因集的相关通路，然后进行PathSEA分析，得到以P值作为排序依据的Ranked Drug list。 每个基因list对于每个通路基因集都得到一个drug list，共32个drug list。 由于CP、MIR、TFT通路基因集得到drug list包含较少的药物结果，所以剔除，保留20个 使用adjusted p-values，将每个基因list的5个drug list合并为一个drug list 挑选出每个drug list的Top5 drug，共20个候选药物 文献验证 PubMed：收集药物的有效性、作用机制研究 PubChem：确定药物的毒性与否 ClinicalTrials：查看药物的临床研究情况 ","permalink":"https://lishensuo.github.io/en/posts/basic/154%E6%96%87%E7%8C%AE--%E5%9F%BA%E4%BA%8E%E9%80%9A%E8%B7%AF%E5%AF%8C%E9%9B%86%E7%9A%84%E8%8D%AF%E7%89%A9%E9%87%8D%E5%AE%9A%E5%90%91%E4%BB%A5ad%E8%8D%AF%E7%89%A9%E4%B8%BA%E4%BE%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003e（1）Computational Drug Repurposing for Alzheimer’s Disease Using Risk Genes From GWAS and Single-Cell RNA Sequencing Studies\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://www.frontiersin.org/articles/10.3389/fphar.2021.617537/full\"\u003ehttps://www.frontiersin.org/articles/10.3389/fphar.2021.617537/full\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eFront Pharmacol， 2021/06， IF 5.81\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cblockquote\u003e\n\u003cp\u003e（2）gene2drug: a computational tool for pathway-based rational drug repositioning\u003c/p\u003e","title":"文献--基于通路富集的药物重定向(以AD药物为例)"},{"content":" Discovery of drug mode of action and drug repositioning from transcriptional responses\nAugust 2, 2010 | PNAS | IF=11.2\n10.1073/pnas.1000138107\n1、合并PRL cMap 1309种化合物作用于5种细胞系的6100个干扰转录组的差异基因结果。对于同一种化合物由于不同浓度，或者作用于不同细胞系会得到多个差异基因列表（下面简称list）。\n为了得到一种化合物的综合差异基因列表，根据如下步骤通过合并多个原始的list(由up到down的降序ranked list)，得到Prototype Ranked List (PRL)。\n（1）计算同一化合物所有list两两间的相似性，文章具体使用的是Spearman’s Footrule系数。\n（2）对于最相似的两个list，使用Borda Merging Method方法合并产生一个新的list，代替原有旧的两个list。\n（3）重复上述步骤（1）、（2）直至只剩下一个list，即为该化合物的PRL。\n对于PRL排名最靠前的基因，表示被化合物显著上调的基因；排名靠后的基因，表示被化合物显著下调的基因。\nRankAggreg包\n2、计算PRL距离 基于富集分析原理，计算两个PRL的距离(相似性)\n如下公式：对于药物d的PRL，p表示排名靠前的Top N个基因，q表示排名靠后的Last N个基因。\n分别计算p与q相对于药物x的PRL富集分数(Enrichment score)\nES\u0026gt;0, 表示富集到PRL的排名靠前部分 ES\u0026lt;0, 表示富集到PRL的排名靠后部分 如果对于p的ES接近1，q的ES接近-1，则TES结果接近0，那么说明药物d的PRL距药物x的PRL较近(相似)。\n如果对于p的ES接近-1，q的ES接近1，则TES结果接近2，那么说明药物d的PRL距药物x的PRL较远(不相似)。 $$ TES_{d,x} = 1-\\frac{ES^p_x-ES^q_x}{2} $$ 同理可计算药物x的PRL距药物d的PRL的远近程度。\n药物d至x的距离不一定等于药物x至d的距离。\n最后有两种方式评价两个药物的综合距离\n（1）平均TES $$ D = \\frac{TES_{A,B}+TES_{B,A}}{2} $$ （2）最近距离 $$ D = \\frac{min(TES_{A,B},TES_{B,A})}{2} $$\n3、构建网络并分群 3.1 构建网络 根据所有化合物间两两距离(1309种化合物的856086个两两距离)，筛选Top5%的距离关系。(Top5%聚类作为threshold) 然后构建有1302个药物作为节点，41047条距离作为权重的边的Drug Network。 3.2 分群鉴定 基于 affinity propagation算法，对Drug Network进行分群，鉴定community以及每个community的exemplar核心节点。 共鉴定得到106个community R包apcluster可实现affinity propagation算法：https://cran.r-project.org/web/packages/apcluster/vignettes/apcluster.pdf\n3.3 分群验证 （1）在同一群的药物是否具有相同的MOA（包括ATC、Target、pathway）以随机分布作为背景，计算odd ratios\n共有77个community具有显著富集的MOA（odd ratios\u0026gt;1） （2）文章进一步说明了具有相同的MOA的化合物是否分到一个community里\n4、小分子MOA预测 4.1 预测流程 在如上建立了drug network并鉴定出具有MOA意义的community之后，可通过此网络预测新的小分子的MOA。\n（1）得到新的小分子干扰实验的PRL\n（2）计算该小分子与网络中所有节点的距离，保留距离低于阈值的边。\n（3）计算该小分子分别与网络中所有community的距离→weighted geometric average of the distances\n如下公式，计算药物x到与community C的距离，|Cx|表示community C的组成节点数。(Π表示累乘符号) $$ \\sqrt[|C_x|]{\\Pi_{d\\in C_x} D(d,x)/|C_x|} $$ 4.2 可行性验证 文章以9个已知MOA的化合物作为输入，用于验证可行性。\n如下图所示，三个测试化合物MMS-Tanespimycin、NMS-E973、NVP-AUY922为已知的HSP90抑制剂。\n根据上述方式计算，相距最近的community为 n.28，该community主要有HSP900抑制剂组成；其次接近的为n40、n104。\n最后也通过WB实验验证了上述预测的预测结果。\n","permalink":"https://lishensuo.github.io/en/posts/basic/155%E6%96%87%E7%8C%AE--%E5%9F%BA%E4%BA%8E%E8%8D%AF%E7%89%A9%E5%B9%B2%E6%89%B0%E8%BD%AC%E5%BD%95%E7%BB%84%E5%BB%BA%E7%AB%8B%E8%B7%9D%E7%A6%BB%E7%BD%91%E7%BB%9C%E7%94%A8%E4%BA%8E%E8%8D%AF%E7%89%A9%E9%87%8D%E5%AE%9A%E5%90%91/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDiscovery of drug mode of action and drug repositioning from transcriptional responses\u003c/p\u003e\n\u003cp\u003eAugust 2, 2010 | PNAS | IF=11.2\u003c/p\u003e\n\u003cp\u003e10.1073/pnas.1000138107\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220618154451159.png\" alt=\"image-20220618154451159\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1合并prl\"\u003e1、合并PRL\u003c/h1\u003e\n\u003cp\u003ecMap 1309种化合物作用于5种细胞系的6100个干扰转录组的差异基因结果。对于同一种化合物由于不同浓度，或者作用于不同细胞系会得到多个差异基因列表（下面简称list）。\u003c/p\u003e","title":"文献--基于药物干扰转录组建立距离网络用于药物重定向"},{"content":" DrugCombDB: a comprehensive database of drug combinations toward the discovery of combinatorial therapy\nNucleic Acids Research | 2020 | IF=17\n1、数据收集 （1）HTS(high-throughput screening)高通量筛选技术可用于快速测得药物作用于癌症细胞系的不同剂量(dose concentrations)下的反应(Response)。其中，反应(Response)的指标常是细胞活力(cell viability)。\n在细胞群体中总有一些因各种原因而死亡的细胞，总细胞中活细胞所占的百分比叫做细胞活力.\n（2）药物组合测试（Combination Test）在应用HTS技术中，多为双药组合测试，用于评价组合效果（synergy协同、additivity叠加或者antagonism拮抗）。在具体实验中，通常设计n×n 剂量-响应矩阵(dose–response matrix)。\n本文收集了大规模HTS assay 药物组合测试（Combination Test）实验结果。包括如下两个主要的来源。\nNIH(National In-stitutes of Health)\n主要收集自NIH下的NCI-ALMANAC (A Large Matrix of Anti- Neoplastic Agent Combinations)计划\n311604个作用于60种肿瘤细胞系的药物组合3×3剂量反应矩阵，共2873514次test\n文献：An unbiasedoncology compound screen to identify novel combination strategies.\n92208个作用于39种肿瘤细胞系的药物组合4×4剂量反应矩阵，共1475328次test 如下图所示，在文章发表时，根据作者说明已收集了 6055 92个combination tests，涉及448 555个双药物组合，2887种药物，以及124种肿瘤细胞系。\n其它来源包括\n文献研究汇总\n其它数据库\nDCDB、DrugCentral均收集自 FDA Orange Book数据 TTD：72种药物协同组合 ASDCD：抗菌药物组合 DrugBank：临床报道具有拮抗效应的antagonistic 文章提到，由于\u0026gt;=3药物组合的研究复杂性，在HTS实验少有涉及。在其它来源的收集中，也会注重区分出这些组合。\n2、组合评价 通过药物组合的剂量-响应矩阵结果，去评价两药物间是否具有协同作用(synergistic)。\n计算思路主要是：根据单药物的剂量-响应结果，得出双药物组合的**预期(expected)**剂量-响应。\n如果实验结果优于预期响应值，则认为在该剂量组合下具有协同作用； 相反，如果低于预期值，则可能二者间具有拮抗(antagonistic)效果。 计算步骤(参考下图)\n（1）首先计算结果(细胞活性viability)为0~1之间的百分数，为方便起见，常取百分值。\n该值越大表明药物可增强细胞活力，反之则表示产生抑制效果。 （2）然后用1减去这些值，转换为药物的效果，结果越大(\u0026gt;0)表明抑制作用越强。\n（3）计算药物组合的预期效果值，不同指标有不同的计算方式。\n本文使用SynergyFinderR包计算了HSA、Bliss、Loewe、ZIP4个指标 如下以HSA、Bliss两个指标为例演示 （4）药物组合实际抑制效果减去预期抑制效果(如下公式)。\nEab表示药物AB特定浓度组合的效果、Ea/Eb表示相同浓度下，单独药物的效果。(注意是百分数)； 计算得到的Score值越大（大于0），表示该药物浓度组合越具有潜在的协同关系。 （5）最后取所有浓度组合的Score均值作为最终评价该药物组合的指标值。\n$$ E_{HSA} = E_{AB} - max(E_A, E_B) $$\n$$ E_{Bliss} = E_{AB} - (E_A + E_B-E_A×E_B) $$\n3、整合数据 （1）对于不同HTS平台来源的药物组合实验结果(cell viability)具有可比性，作者对每个平台数据进行最大-最小归一标准化。 $$ R_{inhibit} = \\frac{max(viability)-viability}{max(viability)-min(viability)} $$ （2）由于可根据Synergy score的正负性，简单判断两药组合是协同还是抑制关系。\n如下图所示，由于整体呈围绕0的正态分布，文章根据每种指标的Top25%，定义为synergistic；Low25%定义为 antagonistic 如果对于每一药物组合的4个指标都认为是协同(Top25)，则认为该组合具有协同关系 最终根据上述过程，定义了85154个具有协同关系的两药组合；155824个具有拮抗关系的两药组合 （3）最后文章将收集整理的数据放到了自建的DrugCombDB网站里，供用户查阅、下载\nhttp://drugcombdb.denglab.org/main http://drugcombdb.denglab.org/tutorial 最后数据库提供的化合物注释难以使用，后根据化合物名字在https://pubchem.ncbi.nlm.nih.gov/idexchange/idexchange.cgi网页进行化合物ID注释。\n4、SynergyFinderR包使用 https://bioconductor.org/packages/release/bioc/vignettes/synergyfinder/inst/doc/User_tutorual_of_the_SynergyFinder_plus.html\n如上所说，文章使用了SynergyFinderR药物组合剂量反应矩阵的四种协同分数。下面简单学习这个包的用法。\n1 2 # BiocManager::install(\u0026#34;synergyfinder\u0026#34;) library(synergyfinder) 4.1 输入数据 输入数据为一个表格，记录药物组合的相关实验信息；\nSynergyFinderR对表格的列名具有严格的要求，具体如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 ##示例数据为2种药物组合 6×6的剂量-反应矩阵 data(\u0026#34;mathews_screening_data\u0026#34;) table(mathews_screening_data$block_id) # 1 2 # 36 36 head(mathews_screening_data) # block_id drug_row drug_col conc_r conc_c response conc_r_unit conc_c_unit # 1 1 ispinesib ibrutinib 2500 50.0000 7.802637 nM nM # 2 1 ispinesib ibrutinib 2500 12.5000 6.831317 nM nM # 3 1 ispinesib ibrutinib 2500 3.1250 15.089589 nM nM # 4 1 ispinesib ibrutinib 2500 0.7812 24.503885 nM nM # 5 1 ispinesib ibrutinib 2500 0.1954 38.043076 nM nM # 6 1 ispinesib ibrutinib 2500 0.0000 45.790634 nM nM 4.2 计算协同分数 (1) 导入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 res \u0026lt;- ReshapeData( data = mathews_screening_data, data_type = \u0026#34;viability\u0026#34;, impute = TRUE, impute_method = NULL, noise = TRUE, seed = 1) ##返回含有两个元素(表格)的列表 res$drug_pairs #每种组合的注释信息 # # A tibble: 2 x 7 # block_id drug1 drug2 conc_unit1 conc_unit2 input_type replicate # \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;lgl\u0026gt; # 1 1 ispinesib ibrutinib nM nM viability FALSE # 2 2 canertinib ibrutinib nM nM viability FALSE head(res$response) #每个剂量药物组合的实验结果： response = 1 - response_origin # # A tibble: 6 x 5 # block_id conc1 conc2 response response_origin # \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 1 2500 50 92.2 7.80 # 2 1 2500 12.5 93.2 6.83 # 3 1 2500 3.12 84.9 15.1 # 4 1 2500 0.781 75.5 24.5 # 5 1 2500 0.195 62.0 38.0 # 6 1 2500 0 54.2 45.8 （2）计算协同分数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 res \u0026lt;- CalculateSynergy( data = res, method = c(\u0026#34;ZIP\u0026#34;, \u0026#34;HSA\u0026#34;, \u0026#34;Bliss\u0026#34;, \u0026#34;Loewe\u0026#34;), Emin = NA, Emax = NA, correct_baseline = \u0026#34;non\u0026#34;) ##在原有list的结果里，添加一个表示协同分数的表格元素 head(res$synergy_scores) ## ***_ref表示药物组合的期望值 ## ***_synergy表示药物组合的score(实际值减去期望值) # # A tibble: 6 x 12 # block_id conc1 conc2 ZIP_fit ZIP_ref ZIP_synergy HSA_ref HSA_synergy Bliss_ref # \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 1 2500 50 93.3 79.4 13.9 71.3 20.9 86.9 # 2 1 2500 12.5 92.3 79.4 12.9 54.2 39.0 78.6 # 3 1 2500 3.12 82.7 67.9 14.8 54.2 30.7 73.1 # 4 1 2500 0.781 75.2 37.2 38.1 54.2 21.3 45.9 # 5 1 2500 0.195 57.3 37.2 20.1 54.2 7.75 52.5 # 6 1 2500 0 54.2 54.2 0 54.2 0 54.2 # # ... with 3 more variables: Bliss_synergy \u0026lt;dbl\u0026gt;, Loewe_ref \u0026lt;dbl\u0026gt;, Loewe_synergy \u0026lt;dbl\u0026gt; 1、对于cell viability的response_origin实验结果，以及response理论上应该在（0,1）范围之间。如果不是，则可能属于异常值，可通过设置correct_baseline参数进行校正。具体可参考原文档。\n2、这个包还可以计算IC50值，就不记录了。具体可参考原文档。\n（3）结果可视化 1 2 3 4 5 6 7 ##(1)单药浓度曲线 PlotDoseResponseCurve( data = res, plot_block = 1, drug_index = 2, plot_new = FALSE, record_plot = FALSE) 1 2 3 4 5 6 7 8 9 ##(2)药物组合二维热图 Plot2DrugHeatmap( data = res, plot_block = 1, drugs = c(1, 2), plot_value = \u0026#34;response\u0026#34;, #可以是其它值，包括上述计算的协同分数 dynamic = FALSE, summary_statistic = c(\u0026#34;mean\u0026#34;, \u0026#34;median\u0026#34;) ) 1 2 3 4 5 6 7 8 ##(3) 上述二者的组图 PlotDoseResponse( data = res, block_ids = c(1, 2), drugs = c(1,2), save_file = TRUE, file_type = \u0026#34;png\u0026#34; ) 1 2 3 4 5 6 7 8 9 ##(3)热图立体化 Plot2DrugSurface( data = res, plot_block = 1, drugs = c(1, 2), plot_value = \u0026#34;response\u0026#34;, dynamic = FALSE, summary_statistic = c(\u0026#34;mean\u0026#34;, \u0026#34;quantile_25\u0026#34;, \u0026#34;median\u0026#34;, \u0026#34;quantile_75\u0026#34;) ) ","permalink":"https://lishensuo.github.io/en/posts/basic/170%E6%96%87%E7%8C%AE--synergyfinder%E5%8C%85%E8%AE%A1%E7%AE%97%E5%8D%8F%E5%90%8C%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDrugCombDB: a comprehensive database of drug combinations toward the discovery of combinatorial therapy\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eNucleic Acids Research  | 2020 | IF=17\u003c/em\u003e\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220527214321528.png\" alt=\"image-20220527214321528\" style=\"zoom:50%;\" /\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1数据收集\"\u003e1、数据收集\u003c/h1\u003e\n\u003cp\u003e（1）HTS(high-throughput screening)高通量筛选技术可用于快速测得药物作用于癌症细胞系的不同剂量(dose concentrations)下的反应(Response)。其中，反应(Response)的指标常是细胞活力(cell viability)。\u003c/p\u003e","title":"文献--synergyfinder包计算协同评价指标"},{"content":" A single-cell analysis of breast cancer cell lines to study tumour heterogeneity and drug response\nNature Communications | 31 March 2022\nDOI: https://doi.org/10.1038/s41467-022-29358-6\n这篇文章对来自32个乳腺癌细胞系的35276个细胞进行了单细胞转录组测序(Drop-seq)，数据已上传到 GSE173634。文章具体内容主要是针对测序结果，从多个角度展开衍生的分析。\nhttps://figshare.com/articles/dataset/Single_Cell_Breast_Cancer_cell-line_Atlas/15022698\n32种细胞系的分型信息如下，其中MCF12A为non-cancer细胞系。\nCCLs ER PR HER2 Subtype 1 AU565 - - + H 2 BT20 - - - TNA 3 BT474 + + + LB 4 BT483 + +/- - LA 5 BT549 - - - TNB 6 CAL51 - - - TNB 7 CAL851 - - - TNB 8 CAMA1 + +/- - LA 9 DU4475 - - - TNA 10 EFM19 + + - LA 11 EVSAT - +/- + H 12 HCC1143 - - - TNA 13 HCC1187 - - - TNA 14 HCC1500 + +/- - LA 15 HCC1937 - - - TNA 16 HCC1954 - - + H 17 HCC38 - - - TNB 18 HCC70 - - - TNA 19 HDQP1 - - - TNB 20 HS578T - - - TNB 21 JIMT1 - - + H 22 KPL1 + - - LA 23 MCF12A - - - Basal-like 24 MCF7 + + - LA 25 MDAMB361 + +/- + LB 26 MDAMB415 + +/- - LA 27 MDAMB436 - - - TNA 28 MDAMB453 - - + H 29 MDAMB468 - - - TNA 30 MX1 - - - TNB 31 T47D + + - LA 32 ZR751 + +/- - LA 1、BC细胞系scRNAseq图谱概况 32种细胞系的35276个单细胞测序结果\n平均每个细胞系1069个细胞 平均每个细胞3248个基因表达信息 （1）如下图，对单细胞数据的降维可视化发现不同亚型的细胞系可基本被分开。\n其中Luminal super-cluster混杂部分Her2亚型 TNBC被分为2个不同的super-cluster(TNA、TNB) （2）不同细胞系对于ESR1、ERBB2、PGR、EGFR以及MKI67等5种经典标志物基因的表达情况\n（3）不同细胞系对于48个基于文献的标志物基因的表达情况。\n2、聚类分群发现新的BC标志物基因 将325276个细胞经聚类、分为22个cluster。\n从每一个cluster中，挑选一个cluster marker gene(例如相较其它cluster最差异表达的)。\n首先经文献查询，这22个marker gene具有研究的价值。 观察TCGA的937病人样本的表达数据中这22个基因的表达情况，并结合病人的BC注释分型信息，分析差异表达(如下图所示)。 最后，文章测试了这个22个基因用于区分TCGA样本亚型的能力，并与PAM50进行比较。 3、根据细胞系结果分析BC病人测序样本的异质性 （1）对于BC病人的scRNAseq测序结果，分析每个细胞与哪种BC细胞系最相似。\n分析过程本质上是分类预测，判断样本的一个细胞属于哪一种乳腺癌细胞系。\nMapping算法大致如下图所示，核心是利用UMAP降维转换以及KNN聚类算法。\n首先基于细胞系数据做测试，分为训练集与验证集，正确率在75%以上 然后从GEO(GSE173634)中获得5个TNBC样本的scRNAseq结果以及BC空间转录组数据进行测试。 （2）对于BC病人的bulk RNAseq测序结果，使用Bisque工具预测样本的细胞系组成比例。\n首先对CCLE中BC细胞系的bulk RNAseq数据进行验证，正确率在40%~80% 然后对TCGA BRCA的表达数据，预测样本的细胞系组成，对比样本本身的亚型注释信息验证准确性。 4、单细胞水平的药物敏感度预测 （1）从CTRPv2数据库收集得到450个药物作用于658个癌症细胞系的药物敏感度数据；\n其值越小，表明细胞系对于该药物越敏感（药物越有效） （2）对于一个药物的658个细胞系的敏感度实验结果与基因在这658个细胞系的表达情况做相关性分析(PCC)。\n如果二者呈负相关，说明细胞系中的该基因表达水平越高，药物该细胞系效果越显著。\n因此对于每一个药物都可以得到一个相关系数为排名依据（由高到低）的基因列表。\n（3）对于一种细胞系中每一个细胞的测序结果，取Top250高表达基因，分别对上述450个drug gene list做GSEA富集分析，如果ES显著小于0，表明该药物可能对这个细胞会有良好的效果。\n因此可以预测出一种细胞系中不同种细胞可能有不同的适应药物。 （4）文章把上述的方法包装为一个工具，为DREEP (DRug Estimation from single-cell Expression Profiles)，详见https://github.com/dibbelab/singlecell_bcatlas\n（5）最后文章以MDA-MB-361细胞系的单细胞数据进行示例分析以及药物实验验证。\n以上是文章的简要整理，其中分析部分还有一大点涉及细胞系的基因表达异质性与动态性，尚未完全理解，因此没有整理。\n关于这篇文章，最重要的还是提供了全面的乳腺癌细胞系的单细胞转录组数据。其次将基因表达与药物敏感性进行关联的药物发现思路值得借鉴与学习。\n","permalink":"https://lishensuo.github.io/en/posts/basic/171%E6%96%87%E7%8C%AE--32%E7%A7%8D%E4%B9%B3%E8%85%BA%E7%99%8C%E7%BB%86%E8%83%9E%E7%B3%BB%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%84%E5%9B%BE%E8%B0%B1/","summary":"\u003cblockquote\u003e\n\u003cp\u003eA single-cell analysis of breast cancer cell lines to study tumour heterogeneity and drug response\u003c/p\u003e\n\u003cp\u003eNature Communications  |   31 March 2022\u003c/p\u003e\n\u003cp\u003eDOI: \u003ca href=\"https://doi.org/10.1038/s41467-022-29358-6\"\u003ehttps://doi.org/10.1038/s41467-022-29358-6\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220706151411925.png\" alt=\"image-20220706151411925\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e这篇文章对来自32个乳腺癌细胞系的35276个细胞进行了单细胞转录组测序(Drop-seq)，数据已上传到 GSE173634。文章具体内容主要是针对测序结果，从多个角度展开衍生的分析。\u003c/p\u003e","title":"文献--32种乳腺癌细胞系单细胞转录组图谱"},{"content":" A single-cell and spatially resolved atlas of human breast cancers\nNatGenet. 2021 September\n1、scRNAseq测序样本 文章对26个乳腺癌样本进行了单细胞测序，包括11 ER+，5 HER2+，10 TNBC。\n对质控得到的130246个细胞根据marker基因注释为8种主要的细胞类型。\n其中对于上皮细胞(epithelial cell)使用inferCNV鉴定出恶性肿瘤细胞与正常上皮细胞。\n2、鉴定乳腺癌亚型 （1）使用下述方法将上述测序样本分别注释为4种亚型之一(LumA, LumB, Her2, Basal)\n首先将每个样本的单细胞表达矩阵合并为pseudo-bulk：\n方法1：应用PAM50分类器自动注释 方法2：与TCGA已注释亚型样本进行层级聚类，基于相似度注释 （2）将标注亚型的样本分为训练集与测试集。在训练集中，基于差异分析鉴定出每种亚型的marker基因，作为“scSubtype” gene signatures(Supplementary Table 4)\nBasal_SC: 89\nHER2E_SC: 102\nLumA_SC: 46\nLumB_SC: 65\n（3）使用上述的signatures对于单细胞表达矩阵对应的样本进行亚型注释\n首先计算每个细胞对于4个signatures的表达分数，取最高的标签注释细胞； 然后取样本中大多数细胞注释标签注释为该样本的亚型。 结合测试集以及Bulk RNA-seq说明有较好的预测效果。\n3、驱动肿瘤异质性的模块基因集 （1）对至少有50个肿瘤细胞的肿瘤样本单细胞表达矩阵进行基因的聚类分析(integrative clustering)得到574个 gene-signatures。\n（2）基于gene-signature之间的Jaccard相似度系数，进一步聚类( Spherical k-means based consensus clustering)得到7个模块，对于模块取出现频率最高的200个基因。\n（3）对于每个模块的组成基因进行通路富集分析；\n（4）对于每个肿瘤细胞，计算对于7个模块的表达分数，再进行层级聚类，可以一定程度解释肿瘤异质性。\n例如GM1 → LumA，GM2 → LumB\n4、免疫微环境研究 这一步主要是对免疫细胞进行亚类分析，包括T细胞与固有免疫细胞(myloid、B、plasmablast)\n此外对其中的4个样本进行CITE-seq测序进行细胞表面蛋白表达分子的辅助验证。\n（1）将淋巴细胞分为了18个亚类，包括4个CD4亚群、5个CD8亚群等\n此外将B细胞分为两个亚类：naive and memory\n（2）将Myeloid细胞分为了13个亚群，包括3个Monocytes亚群、6个Macrophages亚群等。\n（3）Stromal细胞分为3大类：CAFs, perivascular-like cells(PCL), endothelial cells，分别从轨迹分析解读不同发育阶段特征。\n5、空间转录组解释乳腺癌异质性 （1）对于6个乳腺癌样本进行空间转录组测序，其中前4个属于于上述单细胞测序的样本(2 ER+, 2 TNBC)；另外2个来自外部数据(TNBC)。\n（2）使用Stereoscope模型对每个spot进行细胞类型注释，结果与病理切片注释大致相同。\n（3）计算上述得到的7个模块在空间转录组spot表达特征，例如模块与亚型的差异性，模块与模块的相关性等。\n6、发现细胞间相互作用 主要阐述此前研究较少的基质细胞与免疫细胞相互作用情况\n（1）主要计算方式是基于spot中两两细胞类型表达比例的相关性\n例如 iCAF与MyCAF存在负相关性；iCAF/MyCAF与淋巴细胞存在明显的相关性。\n（2）通过计算高表达配(受)体iCAF spot与高表达受(配)体的CD4/CD8 spot在空间转录组上的距离进一步验证这两类细胞所存在的相互作用类型。\n7、定义乳腺癌新的亚型 （1）根据上述的再聚类结果，共得到乳腺癌的45种亚群以及相应的gene signatures。\n（2）对METABRIC的BC bulk RNA-seq队列使用CIBERSOFTx算法，基于上述的signatures计算每个样本的45种细胞亚群的比例。然后进一步聚类得到9类肿瘤亚类。即每一类肿瘤都有相似的细胞类型组成模式。\n（3）结合肿瘤样本的生存资料，进一步分析较好/较差预后肿瘤亚类，以及对应的细胞类型组成特点。\n8、关于数据获取 （1）文章对于数据可视化制作的网页\nhttps://singlecell.broadinstitute.org/single_cell/study/SCP1039/a-single-cell-and-spatially-resolved-atlas-of-human-breast-cancers\n（2）单细胞以及Bulk RNAseq测序数据：\nProcessed：GSE176078 Raw： EGAS00001005173 （3）空间转录组数据\n自测 \u0026ndash; DOI: 10.5281/zenodo.4739739\n外部 \u0026ndash; DOI: 10.5281/zenodo.3957257\n（4）文章分析涉及的代码脚本\nhttps://github.com/Swarbricklab-code/BrCa_cell_atlas\n以上是我自己对于这篇文章中要点所做的简单概述。其中每一点，对应原文都有较详细的阐述，例如特定细胞亚群的特征与作用。\n作为一篇体量较大的资源型文章，在日后涉及乳腺癌特定细胞类型的相关研究时，都可以使用这个数据集进行初步尝试与探索或者补充验证。\n","permalink":"https://lishensuo.github.io/en/posts/basic/172%E6%96%87%E7%8C%AE--%E4%B9%B3%E8%85%BA%E7%99%8C%E5%8D%95%E7%BB%86%E8%83%9E%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84%E5%9B%BE%E8%B0%B1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eA single-cell and spatially resolved atlas of human breast cancers\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003eNatGenet. 2021 September\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220806223653835.png\" alt=\"image-20220806223653835\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1scrnaseq测序样本\"\u003e1、scRNAseq测序样本\u003c/h2\u003e\n\u003cp\u003e文章对26个乳腺癌样本进行了单细胞测序，包括11 ER+，5 HER2+，10 TNBC。\u003c/p\u003e\n\u003cp\u003e对质控得到的130246个细胞根据marker基因注释为8种主要的细胞类型。\u003c/p\u003e","title":"文献--乳腺癌单细胞转录组图谱"},{"content":" Comprehensive analysis of spatial architecture in primary liver cancer\nSci Adv. 2021 Dec 17\nDoi: 10.1126/sciadv.abg3750.\n简单摘要: 这是一篇资源型的文章，应该是第一篇较大规模的肝癌空间转录组测序文献。基于ST的所包含的空间信息，本文进行多种新颖的分析思路，例如leading-edge section区域的特征，空间相邻的细胞通讯分析，肿瘤中心与四周的通路表达差异等。文章分析的角度涉及很多方面，但具体每个角度来说大多以数据分析结果描述为主。\n相关缩写：\nPLCs, primary liver cancers 原发性肝癌\nHCC, hepatocellular carcinoma 肝细胞癌\nICC, intrahepatic cholangiocarcinoma 肝内胆管癌\nTME, tumor microenvironment 肿瘤微环境\nTLSs, tertiary lymphoid structures 三级淋巴结构\n1、测序数据 1.1 21个组织切片 来自7个患者样本的21张组织切片的10x Genomics空间转录组测序，相关数据上传到 https://ngdc.cncb.ac.cn/gsa-human/browse/HRA000437 (试了下，可以正常下载)\n样本类型：5个HCC(HCC1, HCC2, HCC3, HCC4, HCC5), 1个ICC(ICC-1)，以及cHC-1(combined hepatocellular and cholangiocarcinoma)\n组织切片类型：N, nontumor section; L, leading-edge section; T, tumor section; P, the portal vein tumor thrombus\n（1）HCC1, HCC3, HCC4, cHC-1 : N + L + T \u0026mdash;\u0026mdash; 12张\n（2）HCC2：N + L + T + P \u0026mdash;\u0026mdash;- 4张\n（3）ICC：L \u0026mdash;\u0026mdash;\u0026ndash; 1张\n（4）HCC5：对完整的肿瘤组织，分为4个切片 \u0026mdash;\u0026ndash;4张\n测序结果共有84,823个spot\n每个spot直径55μm，包括8-22个细胞；每个切片宽6.5㎜，最多有5000个spot\n1.2 初步探索 以spot为单位，进行UMAP降维；然后以特定细胞类型的signature富集分析注释spot特征；\n可以得出N类型切片的正常干细胞得分较高，L/T/P类型切片的恶性细胞得分较高等初步结论。\n2、PLC的空间异质性 对HCC1, HCC2, HCC3, HCC4, cHC-1的N/L/T/P 组织切片进行分群，共得到8个cluster。\n（1）HCC-1T、3T、4T的cluster空间分布特征较明显；而HCC-2T，cHC-1T的clutser分布较混乱\n（2）基于主成分分析的层级聚类显示不同样本的相同类型(tumor/stromal/normal)区域具有相似的特征(如下左图)\n（3）基于diffusion map算法，分析从正常组织spot到肿瘤组织spot变化时，cluster比例/细胞类型比例的变化情况。(如下右图)\n3、L(leading-edge)区特征 （1）首先定义两个指标，评价组织切片的cluster分布特征\nspatial continuity degree(空间相邻一致性): the consistency of cluster identity between each spot and its neighbors.\ntranscriptome diversity degree(全局转录异质性): the global transcriptomic heterogeneity of tumor regions in each section.\nHCC-1、3、4的L与T切片具有 high spatial continuity and lower transcriptome diversity(如下图A)\n（2）结合切片病理特征，将HCC-1、3、4的L切片定义为complete capsule (CC)组；而将HCC-2L/cHC-1L/ICC-1L定义为non- or discontinuous capsule(NC)组。\n此外，将HCC-1、2、3、4-L，cHC-1L划分为3个区域：normal、transition、tumor region(如下图C)\n（3）先比较不同细胞类型富集比例在不同区、不同组的差异分布(如下图D)\n例如CC组样本中tumor区域的T、B、myleiod细胞类型比例高于normal区域的；而在NC组中无此特征\n（4）从normal区到tumor区，每5个spot宽度划分为一个与transition分界线平行区域，对每个区域分别做hallmark pathways的GSVA通路富集分析。\n其中如下6条与肿瘤相关的通路从normal到tumor区通路活性发生突增。(如下图)\n4、PLC肿瘤内部异质性 （1）两个module\n基于上面第2步的分群结果，分析不同样本的不同tumor cluster对hallmark pathway的表达活性。\n再经层次聚类将这些cluster分为两个module：\nmodule-1与细胞周期、代谢等通路相关； module-2与炎症、EMT等通路相关。 （2）tumor cluster间细胞通讯\n对HCC-1相邻的两个tumor cluster互相接壤的spot进行细胞通讯分析。如下图所示，一边各取2个spot宽度的spot。 HCC-1由3个tumor cluster，考虑配受体方向，即做3×2、共6次细胞通讯分析(如下为部分截图)； 5、肿瘤干细胞龛异质性分析 将高表达肝癌干性的5个marker(CD47, EPCAM, KRT19, PROM1, SOX9)的Top5% tumor spot(L/T/P)定义为相应marker阳性的CSC niches。\n（1）首先分析不同类型组织的所含有的CSC niches比例变化。(如下图A)；\n（2）其次PROM1+ CSC niches 在HCC-2P中拥有最多的spot(如下图B)，以及双阳性最多的spot(如下图C)。\n（3）然后分析5种CSC niches特异的表达通路(图D)与细胞类型(图F)\n6、一个完整肝细胞癌nodule的异质性分析 （1）将一个肿瘤组织(HCC-5)，分为4个section，分别测序。将ST数据合并、分群后，得到6个cluster。根据marker基因表达分为：tumor(1/2/5), stromal cell(3/6), normal(2)\n（2）由于是完整的CSC组织，可以探究从肿瘤中心到四周围，信号通路的活性变化\n先按照径向将每个组织切片分为4个部分，A-1表示组织A的第1部分。 然后按照环形每5个spot做一次分割，即分为18个环形区域。 参下图F，A-1.1表示A-1区域的cluster1，计算通路活性与圆心距的相关性。 7、TLS在肿瘤组织的分布特征 （1）如上，HCC-5的cluster3、6为stromal cell，其中cluster6由于高表达CXCL13, CCL19, CCL21, LTF, LTB, CD79A/B等TLS marker被重新注释为TLS；\n（2）将该cluster的特异高表达的Top50基因作为signature，用于注释其它组织测序spot是否为TLS，主要多分布于L区的非肿瘤区域\n（3）比较HCC-5的stromal与TLS区域的特异相关细胞类型(下图C)\n（4）分析TLS spot的细胞类型比例与肿瘤距离的相关性(下图D)\n（5）TLS区域中心到四周的特定基因表达变化趋势(下图E)\n","permalink":"https://lishensuo.github.io/en/posts/basic/173%E6%96%87%E7%8C%AE--%E8%82%9D%E7%99%8C%E7%A9%BA%E9%97%B4%E8%BD%AC%E5%BD%95%E7%BB%84%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003eComprehensive analysis of spatial architecture in primary liver cancer\u003c/p\u003e\n\u003cp\u003eSci Adv. 2021 Dec 17\u003c/p\u003e\n\u003cp\u003eDoi: 10.1126/sciadv.abg3750.\u003c/p\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20221002154903204.png\" alt=\"image-20221002154903204\" style=\"zoom:50%;\" /\u003e\r\n\u003cp\u003e简单摘要: 这是一篇资源型的文章，应该是第一篇较大规模的肝癌空间转录组测序文献。基于ST的所包含的空间信息，本文进行多种新颖的分析思路，例如leading-edge section区域的特征，空间相邻的细胞通讯分析，肿瘤中心与四周的通路表达差异等。文章分析的角度涉及很多方面，但具体每个角度来说大多以数据分析结果描述为主。\u003c/p\u003e","title":"文献--肝癌空间转录组数据分析"},{"content":"【01】ccRCC与免疫浸润 标题：Landscape of immune cell infiltration in clear cell renal cell carcinoma to aid immunotherapy\n期刊|日期：Cancer Science | 13 March 2021\n1 第一次分亚群 TCGA 525样本（TPM） 29个 imunne signature：16 免疫细胞与13个免疫相关功能 使用ssGSEA方法计算每个样本的signature score 基于signature score，使用ConsensuClusterPlus包分得5个亚群 PCA可视化轮廓 PD-1与PD-L1表达差异 C1+C4与C2+C3+C5间生存差异 2 第二次分亚群 两大组之间（C1+C4与C2+C3+C5）进行差异分析，得到658个差异基因 基于上述差异基因，再次使用ConsensuClusterPlus包重新分成3个亚群 PCA可视化轮廓 PD-1与PD-L1表达差异 三组间生存分析 29种signature score在三组间的分布差异 immune score与stromal score在三组间的分布差异（ESTIMATE） 根据与分组的相关性，将上述差异基因分成signature A/B 通路富集分析 3 TII分数及衍生分析 分别计算signatue A/B的第一主成分之和，然后相减作为每个样本的TII score 根据survmier包计算最佳阈值划分成high与low score两组，并进行一系列后续分析： （1）生存分析\n（2）与之间鉴定亚群的关系\n（3）GSEA分析\n（4）与TMB的独立性分析\n（5）29种signature score在两组间的分布差异\n（6）免疫检查点基因表达在两组间的分布差异\n（7）使用pRRophetic进行药物敏感度分析\n（8）基于两组间的差异基因【high vs low】进行CMAP药物匹配\n（9）TII分组与临床信息的关系（fish exact test）\n外部数据集验证（生存分析） PFS TCGA papillary renal cell carcinoma乳头状肾细胞癌 IMvigor210 cohort（urothelial cancer，尿路上皮癌） 【02】ccRCC与IFN-γ相关基因 标题：Comprehensive Multi-Omics Identification of Interferon-g Response Characteristics Reveals That RBCK1 Regulates the Immunosuppressive Microenvironment of Renal Cell Carcinoma\n期刊|日期：Cancer Science | 02 November 2021\n1、整体批量分析 24个IFN-γ响应相关基因 （1）TCGA：530 ccRCC, 323 pRCC, and 91 chRCC 分别与癌旁组织差异分析 基因高低表达分组与病人癌症阶段(Stage)，生存时间的关系 （2）肿瘤突变数据：SNV，CNV，genetic mutation 基于GSCA网站完成：http:// bioinfo.life.hust.edu.cn/GSCA 2、预后模型筛选基因 分别从ccRCC，RCC的OS与RFS(2×2)的4种组合进行套路分析 LASSO回归建模 计算risk score，以中位数分组 生存分析，AUC分析，免疫浸润相关性分析 基于ccRCC的OS预后模型，对高低风险组差异基因分析，通路富集 分别以OS与PFS为目标的诺模图分析发现RBCK1为关键基因 3、单基因分析 基于单细胞数据集（TISCH database），发现基因高表达的免疫细胞类型 泛癌分析（1）与癌旁组织的差异表达；（2）与免疫检查基因的相关性 基因表达高低分组与TIDE score、免疫检查点基因表达相关性 ICGC验证TIDE score FUSCC数据集验证差异表达，免疫浸润、生存分析 【03】ccRCC的免疫预后基因 标题：Immune-Associated Gene Signatures Serve as a Promising Biomarker of Immunotherapeutic Prognosis for Renal Clear Cell Carcinoma\n期刊|日期：Frontiers in Immunology | 24 May 2022\n1、筛选候选基因 TCGA：539 tumor/72 normal → 9459 DEGs InnateDB+ImmPort数据库 → 2660 immune genes 上述取交集 → 946 个，用于WGCNA鉴定与tumor相关的两个模块，取40 hub genes 2、建立预后模型 40个候选基因经cox回归，筛选得到24个 再经多变量回归，鉴定5基因组成的模型SHC1，WNT5A, NRP1, TGFA, IL4R 计算risk score，根据中位数分组，生存分析具有显著性 使用ICGC的生存数据做进一步验证 3、预后模型衍生分析 risk score与其它临床指标的独立性 risk score分组与通路GSEA的关系 risk score分组与基因突变的关系 risk score分组与免疫浸润的关系 risk score分组与TIDE score的关系 【04】ccRCC与单基因 标题：PIK3C2A is a prognostic biomarker that is linked to immune infiltrates in kidney renal clear cell carcinoma\n期刊|日期：Frontiers in Immunology | 30 March 2023\nPIK3C2A 1、初步表达分析 泛癌分析：差异表达、COX相关性(OS/DFS/PFS) TCGA KIRC分析(下调) + GEO验证 + HPA验证 + WB验证 单细胞分析：高表达数据类型/对照前后差异表达 2、临床预后分析 高低表达分组的生存分析/AUC 高低表达分组的差异临床指标分析 基因与其它临床指标的预后独立性 3、实验siRNA敲除后的影响 4、其它衍生分析 基因表达与免疫浸润的关系 基因表达与免疫细胞相关marker的关系 与PIK3C2A基因表达所有相关的基因-→通路 【05】PCa与巨噬细胞 标题：Multi-omics analysis reveals a macrophage-related marker gene signature for prognostic prediction, immune landscape, genomic heterogeneity, and drug choices in prostate cancer\n期刊 | 日期：Frontiers in Immunology | 14 April 2023\n1、筛选signature gene scRNA-seq macrophage cluster →307 marker genes Consensus分群 → C1 versus C2+C3 生存分析/临床指标/免疫功能/差异基因通路 38个 Cox genes TCGA → 18304 DEGs 21 交集基因，经lasso回归，9个基因 2、基因层面分析 scRNA seq细胞类型表达、RT-qPCR验证差异表达 基因表达与临床表型、CNV/SNP、ICB基因、免疫治疗IPS 3、risk score层面分析 riskscore与临床表型、免疫浸润、肿瘤相关指标评价 根据中位数分为高低组 生存分析/AUC，差异分析/通路 CNV/SNP，药物敏感度分析（分子对接） 构建诺模图及相关分析 GEO数据验证 GSE70768， GSE46602 “inSilicoMerging”包去批次 ","permalink":"https://lishensuo.github.io/en/posts/basic/174%E6%96%87%E7%8C%AE--%E7%94%9F%E4%BF%A1%E5%A5%97%E8%B7%AF%E4%B9%8B%E8%82%BF%E7%98%A4%E9%A2%84%E5%90%8E/","summary":"\u003ch3 id=\"01ccrcc与免疫浸润\"\u003e【01】ccRCC与免疫浸润\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e标题\u003c/strong\u003e：Landscape of immune cell infiltration in clear cell renal cell carcinoma to aid immunotherapy\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊\u003c/strong\u003e|\u003cstrong\u003e日期\u003c/strong\u003e：Cancer Science | 13 March 2021\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch4 id=\"1-第一次分亚群\"\u003e1 第一次分亚群\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003eTCGA 525样本（TPM）\u003c/li\u003e\n\u003cli\u003e29个 imunne signature：16 免疫细胞与13个免疫相关功能\u003c/li\u003e\n\u003cli\u003e使用ssGSEA方法计算每个样本的signature score\u003c/li\u003e\n\u003cli\u003e基于signature score，使用ConsensuClusterPlus包分得5个亚群\n\u003cul\u003e\n\u003cli\u003ePCA可视化轮廓\u003c/li\u003e\n\u003cli\u003ePD-1与PD-L1表达差异\u003c/li\u003e\n\u003cli\u003eC1+C4与C2+C3+C5间生存差异\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230408161538233.png\" alt=\"image-20230408161538233\" style=\"zoom:67%;\" /\u003e\r\n\u003ch4 id=\"2-第二次分亚群\"\u003e2 第二次分亚群\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e两大组之间（C1+C4与C2+C3+C5）进行差异分析，得到658个差异基因\u003c/li\u003e\n\u003cli\u003e基于上述差异基因，再次使用ConsensuClusterPlus包重新分成3个亚群\n\u003cul\u003e\n\u003cli\u003ePCA可视化轮廓\u003c/li\u003e\n\u003cli\u003ePD-1与PD-L1表达差异\u003c/li\u003e\n\u003cli\u003e三组间生存分析\u003c/li\u003e\n\u003cli\u003e29种signature score在三组间的分布差异\u003c/li\u003e\n\u003cli\u003eimmune score与stromal score在三组间的分布差异（ESTIMATE）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e根据与分组的相关性，将上述差异基因分成signature A/B\n\u003cul\u003e\n\u003cli\u003e通路富集分析\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230408162322248.png\" alt=\"image-20230408162322248\" style=\"zoom: 67%;\" /\u003e\r\n\u003ch4 id=\"3-tii分数及衍生分析\"\u003e3 TII分数及衍生分析\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e分别计算signatue A/B的第一主成分之和，然后相减作为每个样本的TII score\u003c/li\u003e\n\u003cli\u003e根据survmier包计算最佳阈值划分成high与low score两组，并进行一系列后续分析：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（1）生存分析\u003c/p\u003e","title":"文献--生信套路之肿瘤预后"},{"content":" 题目：Single-cell analyses of renal cell cancers reveal insights into tumor microenvironment, cell of origin, and therapy response\n期刊 | 日期：PNAS | May 5, 2021\nDOI：https://doi.org/10.1073/pnas.2103240118\n概述：这篇文章来自密歇根大学Arul M. Chinnaiyan的研究团队，该研究对正常肾组织与肾细胞组织进行了单细胞测序，对RCC相关的肿瘤细胞来源、免疫微环境组成以及免疫治疗标志物进行了解读。单细胞数据已上传至GEO（GSE159115：https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159115）\n1、初步概括分析 1.1 癌旁组织 7个样本，6046个细胞 3大类细胞类型 上皮细胞Epithelial，12 subtypes 内皮细胞Endothelial，5 subtypes 基质细胞 Stromal，2 subtypes 免疫细胞 Immune，5 subtypes 上皮细胞中包括3类Proximal tubule (PT) cells：PT-A, PT-B, PT-C 差异特征分析 轨迹分析(Slingshot) 1.2 肿瘤组织 ccRCC：7个样本，20500个细胞 chRCC：1个样本，2500个细胞 3大类细胞类型：Tumor，Immune，Endo/vSMC 2、肿瘤细胞分析 2.1 肿瘤来源细胞预测 使用癌旁组织的12种上皮细胞类型表达数据建立随机森林模型，预测未知样本对于这些细胞类型的可能性； 先使用来自TCGA的已知测序部位的正常癌旁组织数据进行模型验证； 再对RCC的单细胞数据等预测肿瘤细胞的来源细胞类型，结果指向了PT-B 2.2 肿瘤细胞特征分析 对RCC的tumor细胞与癌旁的PT-B与PT-C分别进行差异基因分析 结合通路富集分析，从oxidative phosphorylation氧化磷酸化、免疫/炎症通路进一步说明PT-B与肿瘤的相似性； 通过配受体基因对分析，发现肿瘤细胞类型与其它细胞类型的通讯关系 3、其它细胞类型分析 3.1 髓系免疫细胞 在ccRCC中分成3类髓系细胞：单核细胞Monocyte，树突细胞Dendritic，巨噬细胞Macrophage 在两亚类巨噬细胞中进行差异分析、通路分析以及marker基因生存分析 3.2 内皮细胞 在ccRCC与癌旁中鉴定出6类亚群，并进行差异特征基因分析 文章最后结合了Bulk样本的免疫治疗相关数据，发现了若干与免疫治疗/生存预后相关的基因或者细胞类型(CD8 T)。由于该部分数据以及前文提到的外显子数据目前还未公开，暂不记录。\n","permalink":"https://lishensuo.github.io/en/posts/basic/175%E6%96%87%E7%8C%AE--ccrcc%E5%8D%95%E7%BB%86%E8%83%9E%E8%BD%AC%E5%BD%95%E7%BB%84/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：Single-cell analyses of renal cell cancers reveal insights into tumor microenvironment, cell of origin, and therapy response\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊\u003c/strong\u003e | \u003cstrong\u003e日期\u003c/strong\u003e：PNAS | May 5, 2021\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.1073/pnas.2103240118\u003c/p\u003e","title":"文献--ccRCC单细胞转录组"},{"content":" 题目：Transcriptomic atlas and interaction networks of brain cells in mouse CNS demyelination and remyelination\n期刊|日期：Cell Report | April 2023\nDOI：https://doi.org/10.1016/j.celrep.2023.112293\n简介：髓鞘脱失是MS(多发性硬化症)发生和发展的主要病理生理机制之一。来自美国华盛顿大学医学院的Marco Colonna团队对小鼠髓鞘脱失与再生模型进行单核细胞测序分析，对多种脑内细胞特异的分子特异变化进行了探索与解读。测序数据已上传到 GSE20477。\n1、单核细胞测序整体分析 （1）测序组织分组\n正常小鼠（n=2），简称normal\n髓鞘脱失模型小鼠（n=3），简称Demye\n髓鞘再生模型小鼠（n=3），简称Remye\n（2）测序初步结果\n58079个细胞，19个细胞群，根据marker gene注释为7大类细胞类型\n同一细胞类型在3组的比例变化\n同一细胞类型在3组的两两表的差异基因\n2、Oli少突胶质细胞分析 将Oli分为8个亚群\n分析Demye组与normal比例相差较大的亚群及其对应功能，再分析这些亚群在Remye的变化\n关联外部数据分析\nDemye与Remye内亚群的发育轨迹 与AD的Oli合并分析发现独特与共有的亚型 基于人的MS的Oli差异基因表现部分Remye特征 发现IL-33在不同组的Oli表达变化，及其同源受体ST2在Ast/Micro的表达变化\n3、Ast星形胶质细胞分析 首先分析了Demye， Remye的marker gene及其功能 将Ast进一步分为9个亚群，分析每组相关的亚群及其功能 结合MS相关的Ast marker，分析与Demye， Remye状态下的Ast marker关系 4、其它细胞类型分析 针对其它细胞类型，分析思路与上面类似，概述如下\n（1）Micro小胶质细胞\n将Micro分为9个亚群（下图） 分析每组相关的亚群及其功能 （2）Vasc血管细胞等\n同样进行亚群分析，对于同一亚群进行Demye与 Remye间差异分析 对两个内皮细胞亚群之间的特征分 （3）神经元细胞分析\n分别对兴奋与抑制性神经元进行亚群分析 同一亚群在Demye与 Remye间差异分析 5、NicheNet细胞通讯分析 将Oli作为受体细胞，在normal与Demye差异表达变化下，分析来自其它细胞类型的可能配体 将上述分析也将Ast与Micro作为受体细胞同样做一遍，发现了若干重要的配受体对，进行深入研究 6、TERM2基因敲除的影响 同样对TERM2基因敲除的3组进行单细胞测序，细胞类型注释 分析Demye中每一细胞类型WT与敲除组的差异；对Remye进行同样分析 对Micro进行亚群注释，比较Demye中WT与敲除组的亚群比例差异；对Remye进行同样分析 对Oli同样进行上述分析 ","permalink":"https://lishensuo.github.io/en/posts/basic/176%E6%96%87%E7%8C%AE--%E9%AB%93%E9%9E%98%E8%84%B1%E5%A4%B1%E4%B8%8E%E5%86%8D%E7%94%9F%E6%A8%A1%E5%9E%8B%E5%B0%8F%E9%BC%A0snrnaseq%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：Transcriptomic atlas and interaction networks of brain cells in mouse CNS demyelination and remyelination\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊|日期\u003c/strong\u003e：Cell Report | April 2023\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.1016/j.celrep.2023.112293\u003c/p\u003e","title":"文献--髓鞘脱失与再生模型小鼠snRNAseq数据分析"},{"content":" 题目：Pan-cancer T cell atlas links a cellular stress response state to immunotherapy resistance\n期刊|日期：nature medicine | 26 April 2023\nDOI：https://doi.org/10.1038/s41591-023-02371-y\n简介：来自德克萨斯大学安德森癌症中心的Linghua Wang研究团队收集了16种肿瘤类型的\u0026gt;30W个T细胞表达数据，对多种T细胞亚型及其分子、临床特征展开了深入地分析。值得一提的是文章发现了一种曾被忽视的Tstr亚型，并揭示了其与免疫治疗抵抗的关系。\n1、数据整体概况 （1）数据规模\n27个单细胞数据集(10个为内部测序数据，其余17个来自公共数据)，涉及16种癌症 测序样本根据病理情况可分为healthy, 癌旁的uninvolved, primary以及metastatic tumor （2）初步分析\n经合并、过滤处理(method部分有详细介绍)后，共得到308,048个T细胞表达数据 初步分群注释后共得到6种主要的T细胞类型 CD4+, CD8+, γδ T, NKT, MAIT,以及proliferative T cells 其中CD4+, CD8+占比最多，分别达55.76%与35.78% 2、T细胞亚型注释 （1）CD8+ T细胞亚型分析\n亚群分析得到14个 clusters/states，其中可分为Naive，Effector，Memory， Exhausted以及其它；\n在其它类中的c4_Tstr特异性高表达应激相关的热休克基因（例如HSPA1A和HSPA1B）；\n在拟时序分析中，鉴定出以Naive为发育起点的3条发育轨迹，其中一条的终点是Tstr；\n进一步观察了特定亚型在不同样本病理状态下的比例分布差异。\n（2）CD4+ T细胞亚型分析\n群分析得到12个 clusters/states，其中可分为Naive，Memory，Cytotoxic， Regulatory，Helper以及其它(也包括一类Tstr)； 同样观察了特定亚型在不同样本病理状态下的比例分布差异； 考虑到Treg与Tfh类亚型的异质性，进一步对这二者进行亚群分析，分别得到7、5个cluster。 （3）其它类型T细胞\n最后同样对γδ T, NKT, MAIT,以及proliferative T cells进行亚型注释以及分析。 3、亚型特征相关分析 （1）T细胞亚型间相关性\n使用层次聚类，将上述31种T细胞state可分为4大类； 基于样本水平亚型比例相关性，分析存在正相关或负相关的 state-pairs （2）T细胞亚型与样本表型相关性\n使用特定肿瘤的scRNA-seq数据集，分析特定亚型在normal/primariy/metastase状态下的分布差异； 使用TCGA预后数据以及特定亚型的signature，分析生存相关的亚型； 使用CPI1000数据集，分析与突变、ICB治疗相关的亚型。 4、Tstr亚型临床意义 （1）验证Tstr亚型的存在，而非细胞裂解时的人为刺激因素\n通过黑色素瘤的situ hybridization验证HSPA1B的表达 通过MSCLC的空间分子成像验证HSPA1A，HSPA1B的表达 通过多种癌症的空间转录组学验证HSPA1A，HSPA1B的表达 （2）Tstr亚型与免疫治疗的关系\n另外收集了6个肿瘤scRNA-seq数据，涉及到经anti-PD-1/PD-L1治疗有或者没有响应的样本； 观察发现在Tstr均相对富集在non-response的样本组中，提示其与ICB resistance可能有关。 小结：\n**（1）**文章本身对于肿瘤T细胞方面深入探索的意义是一方面，其对特定细胞类型在肿瘤（其它疾病）中的多角度分析思路也可以给我们提供一些参考价值。\n**（2）**这篇文章在前期的数据收集与前期处理方面下了一番功夫。虽然作者提及将数据整理成了一个网页(https://singlecell.mdanderson.org/TCM/) ，但好像并不提供数据下载。在原文中也仅是提供了公共数据来源(部分还需要申请)，所以想直接使用文章数据有一定门槛；\n**（3）**在method方法部分，文章较为详细交代了数据前期处理的方法（Seurat），可供借鉴。文章提到对harmony与Seurat-rPCA两种批次整合方法进行了比较，结合silhouette score轮廓分数治疗最终选择了后者。\n**（4）**最后作者也在Github上提供了部分绘图R语言代码(https://github.com/Coolgenome/TCM)，如对文章某一张图感兴趣，可以学习一下。例如其在比较细胞亚型在不同分组样本的分布差异时，绘制了一种特殊的DimPlot点图。如下所示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 # 参考Github代码，结合10X示例数据绘制如下 library(TENxPBMCData) library(Seurat) library(patchwork) tenx_pbmc3k \u0026lt;- TENxPBMCData(dataset = \u0026#34;pbmc3k\u0026#34;) counts = as.matrix(assay(tenx_pbmc3k, \u0026#34;counts\u0026#34;)) rownames(counts) = rowData(tenx_pbmc3k)$Symbol_TENx colnames(counts) = paste0(\u0026#34;cell-\u0026#34;,1:ncol(counts)) sce = CreateSeuratObject(counts = counts) sce = sce %\u0026gt;% NormalizeData() %\u0026gt;% FindVariableFeatures(nfeatures = 2000) %\u0026gt;% ScaleData() %\u0026gt;% RunPCA() %\u0026gt;% RunUMAP(dims = 1:30) %\u0026gt;% FindNeighbors(dims = 1:30) %\u0026gt;% FindClusters(resolution = c(0.01, 0.05, 0.1, 0.2, 0.3, 0.5,0.8,1)) Idents(sce) \u0026lt;- sce$seurat_clusters coord = Embeddings(object = sce, reduction = \u0026#34;umap\u0026#34;) coord = coord[,c(1,2)] colnames(coord) = c(\u0026#34;UMAP_1\u0026#34;, \u0026#34;UMAP_2\u0026#34;) coord = data.frame(ID = rownames(coord), coord) meta = sce@meta.data meta = data.frame(ID = rownames(meta), meta,stringsAsFactors = F) meta = left_join(meta, coord, by = \u0026#39;ID\u0026#39;) theme_black \u0026lt;- function(base_size = 12, base_family = \u0026#34;\u0026#34;) { theme_grey(base_size = base_size, base_family = base_family) %+replace% theme( axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), legend.position = \u0026#34;none\u0026#34;, panel.background = element_rect(fill = \u0026#34;black\u0026#34;, color = NA), panel.border = element_blank(), panel.grid = element_blank(), panel.spacing = unit(0, \u0026#34;lines\u0026#34;), strip.background = element_rect(fill = \u0026#34;grey30\u0026#34;, color = \u0026#34;grey10\u0026#34;), strip.text.x = element_text(size = base_size*0.8, color = \u0026#34;white\u0026#34;), strip.text.y = element_text(size = base_size*0.8, color = \u0026#34;white\u0026#34;,angle = -90), plot.background = element_rect(color = \u0026#34;black\u0026#34;, fill = \u0026#34;black\u0026#34;), plot.title = element_text(size = base_size*1.2, color = \u0026#34;white\u0026#34;), plot.margin = unit(rep(0, 4), \u0026#34;lines\u0026#34;) ) } p1 = DimPlot(sce, reduction = \u0026#34;umap\u0026#34;, group.by = \u0026#34;RNA_snn_res.0.5\u0026#34;, label = T, label.size = 5) + theme_void() + theme(legend.position = \u0026#34;none\u0026#34;, plot.title = element_blank()) + theme(panel.border = element_rect(fill=NA,color=\u0026#34;black\u0026#34;)) p2 \u0026lt;- ggplot(data = coord, mapping = aes(x = UMAP_1, y = UMAP_2)) + stat_density_2d(aes(fill = ..density..), geom = \u0026#34;raster\u0026#34;, contour = F) + geom_point(color = \u0026#39;white\u0026#39;, size = .05) + scale_fill_viridis(option=\u0026#34;magma\u0026#34;) + theme_black() p1 + p2 ","permalink":"https://lishensuo.github.io/en/posts/basic/177%E6%96%87%E7%8C%AE--%E5%9F%BA%E4%BA%8E%E6%B3%9B%E7%99%8Cscrnaseq%E7%9A%84t%E7%BB%86%E8%83%9E%E5%9B%BE%E8%B0%B1%E6%95%B4%E5%90%88%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：Pan-cancer T cell atlas links a cellular stress response state to immunotherapy resistance\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊|日期\u003c/strong\u003e：nature medicine | 26 April 2023\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.1038/s41591-023-02371-y\u003c/p\u003e","title":"文献--基于泛癌scRNAseq的T细胞图谱整合分析"},{"content":" 题目：The potential crosstalk between tumor and plasma cells and its association with clinical outcome and immunotherapy response in bladder cancer 期刊|日期：Journal of Translational Medicine | 03 May 2023 DOI：https://doi.org/10.1186/s12967-023-04151-1 这篇文章讨论了浆细胞在膀胱癌免疫微环境的所扮演的作用。相比于传统肿瘤预后类文章，觉得有如下几方面新意：\n（1）除了TCGA数据，引入了独立的免疫治疗相关数据集；在整个分析流程中起到验证作用；\n（2）在单细胞数据的细胞异质性分析中，提供了多角度的衍生分析，充实了数据完整性；\n（3）使用配受体对相关基因作为建模候选基因，理论上可以反应建立在互作水平上的预后意义；\n（4）文章构图很美观，丰富。除了正文部分展示了最重要的7张图，附件中还有10余张附图。\n总体来说是值得借鉴的一篇生信文章，下面简单总结了文章的分析思路。\n1、PCs水平对BC生存分析 对两个BC数据集(TCGA, IMvigor210)使用Xcell算法进行免疫浸润分析； 在TCGA中，class-switched memory B cells/PCs与较好预后相关； 在IMvigor210中， PCs与较好预后相关；且Response组的PCs水平较高。 2、BC单细胞数据分析 根据PRJNA662018单细胞数据集，首先分析PCs与Tumor cell的异质性；然后进行cellchat细胞通讯分析。\n2.1 两个PCs亚群\n首先根据CD79A, MZB1表达将cluster11注释为PCs，并进一步鉴定7个亚群； 然后根据抗体相关基因表达，又可将PCs主要分为两个亚群：IGHG1-, IGHA1-； 对这两个亚群进行特征基因(COSG tool)通路分析分析以及拟时序分析阐释二者生物意义。 2.2 六种肿瘤细胞状态\n根据CNV水平，从上皮细胞中鉴定肿瘤细胞；并使用NMF算法进行降维分析； 基于肿瘤状态基因集打分，定义出处于6种状态下的肿瘤细胞； 对每种状态肿瘤细胞的特征基因(COSG tool)进行通路分析， 生存分析。 2.3 PCs与Tumor通讯分析\n在总体细胞通讯水平中，PCs主要是基质细胞的receiver；是T细胞与MDCs的sender； 在PCs与肿瘤细胞的通讯分析中， 对一些特征通路，配受体对展开深入的分析，例如MIF通路，APP/CD74配受体； 在其中58个显著配受体对涉及基因中，33个基因在TCGA tumor/normal差异表达；16个基因在IMvigor210 response/nonresponse差异表达； 结合空间转录组数据集(GSE171351)对上述中的两个配受体共表达进行了验证。 3、预后模型系列分析 3.1 构建预后模型\n基于上述58个配受体对相关基因，采用逐步回归法(My.stepwise R package)，鉴定出由13个基因组成signature； signature衍生的riskscore与TCGA较差预后相关，且预测性能优于其它临床指标； 在IMvigor210数据集中发现riskscore与较差预后相同，同时也与免疫治疗效果负相关。 3.2 模型相关性分析\nriskscore与Hallmark pathway打分的相关性；\nriskscore与免疫细胞浸润(Xcell)，评分(ESITIMATE)的相关性；\nriskscore与TIDE系列打分(https://github.com/jingxinfu/TIDEpy), IPS等的相关性；\n高低风险分组与不同BC亚型、药物敏感度、基因突变的相关性分析。\n","permalink":"https://lishensuo.github.io/en/posts/basic/178%E6%96%87%E7%8C%AE--%E6%B5%86%E7%BB%86%E8%83%9Eplasma-cells%E5%9C%A8%E8%86%80%E8%83%B1%E7%99%8Cbladder-cancer%E4%B8%AD%E7%9A%84%E9%A2%84%E5%90%8E%E5%88%86%E6%9E%90/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e题目\u003c/strong\u003e：The potential crosstalk between tumor and plasma cells and its association with clinical outcome and immunotherapy response in bladder cancer\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e期刊|日期\u003c/strong\u003e：Journal of Translational Medicine | 03 May 2023\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.1186/s12967-023-04151-1\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这篇文章讨论了浆细胞在膀胱癌免疫微环境的所扮演的作用。相比于传统肿瘤预后类文章，觉得有如下几方面新意：\u003c/p\u003e","title":"文献--浆细胞(Plasma cells)在膀胱癌(Bladder cancer)中的预后分析"},{"content":" 题目：In Silico Prediction and Insights Into the Structural Basis of Drug Induced Nephrotoxicity\n期刊 | 日期：05 January 2022\nDOI: 10.3389/fphar.2021.793332\n简括：建立机器学习模型的经典流程，值得注意的是包括化合物特征提取，模型建立/评价都是在online chemical database and modeling environment (OCHEM)平台完成的。文章建立的模型也上传到该平台中：https://ochem.eu/article/140251\n1、收集数据 1.1 标签数据 如下，最终收集到565个药物(287, 278)\n（1）阳性数据，即肾毒性药物，收集自SIDER数据库：drugs with nephrotoxicity related ADRs with frequency ≥0.1%；\n（2）阴性数据，即无肾毒性药物参考2019年Zhang等预测模型所使用的阴性药物；\n（3）筛选不合适的药物：去重、混合物主要成分、salt → parent form\n1.2 特征数据 基于OCHEM平台，计算8种分子描述符(molecular descriptors)\nChemaxon descriptors (Chemaxon, 499 descriptors) Fragmentor GSFrag descriptors (GSFrag, 1,138 descriptors) MORDRED descriptors (MORDRED, 1826 descriptors), PyDescriptor (1,624 descriptors), QNPR descriptors (QNPR) RDKit descriptors (RDKit) alvaDesc descriptors (5,666 descriptors) 对于深度学习模型，直接使用SMILES字符串作为每个化合物输入\n2、训练模型 2.1 模型算法 （1）5种机器学习模型\nassociative neural network (ASNN) support vector machine (SVM) C4.5 decision tree random forest (RFR) extreme gradient boosting (XGBoost) （2）5种深度学习模型\nconvolutional neural network fingerprint (CNF) transformer convolutional neural network (TRANSNN) TEXTCNN algorithm available from DeepChem (TEXTCNN) Graph Isomorphism Network (GIN) edge attention based multirelational graph convolutional networks (EAGCNG) 2.3 评价指标 AUC\ntotal accuracy(Q)\nsensitivity(SE)\nspecificity(SP)\nenrichment factor(EF)\nMatthews correlation coefficient(MCC)\n2.2 数据集划分 （1）如下划分出训练集与验证集：\n（2）经降维分析，发现两组数据分布均匀。\n2.3 训练模型 使用训练集，经5折交叉验证训练出40个机器学习模型(5×8)与5个深度学习模型 基于Q\u0026gt;0.7, AUC\u0026gt;0.8发现3个最优模型：2个ML(XGBoost_QNPR, RFR_QNPR)与1个DL(CNF) 使用上述3个Top模型进行consensus modeling，即3个模型预测结果的均值，性能有较大提示。 2.4 验证模型 对上述3个Top模型以及consensus模型进行测试集验证，发现还是consensus模型较优。 ","permalink":"https://lishensuo.github.io/en/posts/basic/200%E6%96%87%E7%8C%AE--%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E8%8D%AF%E7%89%A9%E8%82%BE%E6%AF%92%E6%80%A7-1/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e题目\u003c/strong\u003e：In Silico Prediction and Insights Into the Structural Basis of Drug Induced Nephrotoxicity\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊\u003c/strong\u003e | 日期：05 January 2022\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e: 10.3389/fphar.2021.793332\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e简括\u003c/strong\u003e：建立机器学习模型的经典流程，值得注意的是包括化合物特征提取，模型建立/评价都是在online chemical database and modeling environment (OCHEM)平台完成的。文章建立的模型也上传到该平台中：https://ochem.eu/article/140251\u003c/p\u003e","title":"文献--机器学习模型预测药物肾毒性-1"},{"content":"1、R镜像设置 （1）临时设置，重启R之后会重置\n1 2 3 4 options(BioC_mirror=\u0026#34;http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\u0026#34;) options(\u0026#34;repos\u0026#34; = c(CRAN=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/\u0026#34;)) options()$repos options()$BioC_mirror （2）通过设置.Rprofile文件永久设置\nlinux 1 2 3 4 5 6 7 #进入家目录 cd ~ vi ~/.Rprofile #输入下面两行代码 options(repos=structure(c(CRAN=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/\u0026#34;))) options(BioC_mirror=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/bioconductor\u0026#34;) #保存退出 window 第①步：打开记事本或者其他文本编辑软件； 第②步：输入默认设置（内容同上述linux案例）； 第③步：保存文件到 “此电脑\u0026gt;文档” /.Rprofile； 第④步：重新进入R/RStudio即可。\n.Rprofile文件为启动R时自动加载的文件，可以继续添加其它命令，例如管道符号library(magrittr)\n","permalink":"https://lishensuo.github.io/en/posts/program/200r%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/","summary":"\u003ch1 id=\"1r镜像设置\"\u003e1、R镜像设置\u003c/h1\u003e\n\u003cp\u003e（1）临时设置，重启R之后会重置\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions(BioC_mirror=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;repos\u0026#34;\u003c/span\u003e = c(CRAN=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions()$repos \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions()$BioC_mirror\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e（2）通过设置\u003ccode\u003e.Rprofile\u003c/code\u003e文件永久设置\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elinux\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#进入家目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ecd\u003c/span\u003e ~\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003evi ~/.Rprofile\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#输入下面两行代码\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions(repos=structure(c(CRAN=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/\u0026#34;\u003c/span\u003e))) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions(BioC_mirror=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/bioconductor\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#保存退出\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003ewindow\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e第①步\u003c/strong\u003e：打开记事本或者其他文本编辑软件；\n\u003cstrong\u003e第②步\u003c/strong\u003e：输入默认设置（内容同上述linux案例）；\n\u003cstrong\u003e第③步\u003c/strong\u003e：保存文件到 “此电脑\u0026gt;文档” /.Rprofile；\n\u003cstrong\u003e第④步\u003c/strong\u003e：重新进入R/RStudio即可。\u003c/p\u003e","title":"R基础配置"},{"content":"1、创建与查看igraph对象 1.1 示例数据 igraph包提供了很多创建igraph对象的函数与思路。这里采用常用的基于data.frame的格式创建。 示例数据来自STRINGdb的PPI蛋白互作数据以及对应基因的上下调信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 library(STRINGdb) library(tidyverse) string_db \u0026lt;- STRINGdb$new(version=\u0026#34;11\u0026#34;, species=9606, score_threshold=200, input_directory=\u0026#34;\u0026#34;) data(diff_exp_example1) genes = rbind(head(diff_exp_example1,30), tail(diff_exp_example1,30)) head(genes) genes_mapped \u0026lt;- string_db$map(genes, \u0026#34;gene\u0026#34; ) head(genes_mapped) ppi = string_db$get_interactions(genes_mapped$STRING_id) %\u0026gt;% distinct() edges = ppi %\u0026gt;% dplyr::left_join(genes_mapped[,c(1,4)], by=c(\u0026#39;from\u0026#39;=\u0026#39;STRING_id\u0026#39;)) %\u0026gt;% dplyr::rename(Gene1=gene) %\u0026gt;% dplyr::left_join(genes_mapped[,c(1,4)], by=c(\u0026#39;to\u0026#39;=\u0026#39;STRING_id\u0026#39;)) %\u0026gt;% dplyr::rename(Gene2=gene) %\u0026gt;% dplyr::select(Gene1, Gene2, combined_score) nodes = genes_mapped %\u0026gt;% dplyr::filter(gene %in% c(edges$Gene1, edges$Gene2)) %\u0026gt;% dplyr::mutate(log10P = -log10(pvalue), direction = ifelse(logFC\u0026gt;0,\u0026#34;Up\u0026#34;,\u0026#34;Down\u0026#34;)) %\u0026gt;% dplyr::select(gene, log10P, logFC, direction) ###边信息 head(edges) # Gene1 Gene2 combined_score # 1 UPK3B PTS 244 # 2 GSTM5 ACOT12 204 # 3 GRHL3 IGDCC4 238 # 4 TNNC1 ATP13A1 222 # 5 NNAT VSTM2L 281 # 6 EZH2 RBBP7 996 ###节点信息 head(nodes) # gene log10P logFC direction # 1 VSTM2L 3.992252 3.333461 Up # 2 TNNC1 3.534468 2.932060 Up # 3 MGAM 3.515558 2.369738 Up # 4 IGDCC4 3.290137 2.409806 Up # 5 UPK3B 3.248490 2.073072 Up # 6 SLC52A1 3.227019 3.214998 Up 1.2 创建对象 使用graph_from_data_frame()函数创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 library(igraph) library(tidyverse) g1 = graph_from_data_frame(d = edges, #交代边信息 vertices = nodes, #交代点信息 directed = FALSE) g1 # IGRAPH 3eb2403 UN-- 19 15 -- # + attr: name (v/c), log10P (v/n), logFC (v/n), direction (v/c), combined_score # | (e/n) # + edges from 3eb2403 (vertex names): # [1] UPK3B --PTS GSTM5 --ACOT12 IGDCC4 --GRHL3 TNNC1 --ATP13A1 VSTM2L --NNAT # [6] EZH2 --RBBP7 PTTG1 --EZH2 GRHL3 --PARN SLC52A1--ATP13A1 SETD1B --EZH2 # [11] SETD1B --RBBP7 SLC52A1--SLC5A8 MGAM --PTS MGAM --NPB MGAM --PARN 第一行的UN--的4个占位符：（1）D/U, 表示是否为有向图；（2）N，表示节点node是否有name属性；（3）W，表示边edge是否有weight属性；（4）B，表示节点node是否有type属性。\n后面紧接着的两个数字（19 15）分别表示节点总数与边总数\n第二行则表示点v/边e/图g目前由哪些属性；后面的第二个字母则表示属性字符类型：n:numeric; c:character;l:logical\n1.3 查看对象 基本统计 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ###(1)边信息 E(g1) # + 15/15 edges from 3eb2403 (vertex names): # [1] UPK3B --PTS GSTM5 --ACOT12 IGDCC4 --GRHL3 TNNC1 --ATP13A1 VSTM2L --NNAT # ... as_ids(E(g1)) %\u0026gt;% str() # chr [1:15] \u0026#34;UPK3B|PTS\u0026#34; \u0026#34;GSTM5|ACOT12\u0026#34; \u0026#34;IGDCC4|GRHL3\u0026#34; \u0026#34;TNNC1|ATP13A1\u0026#34; ... ###多少条边 ecount(g1) # [1] 15 ###(2)节点信息 V(g1) # + 19/19 vertices, named, from 3eb2403: # [1] VSTM2L TNNC1 MGAM IGDCC4 UPK3B SLC52A1 GRHL3 SLC5A8 GSTM5 NNAT as_ids(V(g1)) %\u0026gt;% str() # chr [1:19] \u0026#34;VSTM2L\u0026#34; \u0026#34;TNNC1\u0026#34; \u0026#34;MGAM\u0026#34; \u0026#34;IGDCC4\u0026#34; \u0026#34;UPK3B\u0026#34; \u0026#34;SLC52A1\u0026#34; \u0026#34;GRHL3\u0026#34; ... ###多少个点 vcount(g1) # [1] 19 节点的邻居 1 2 3 4 5 6 7 8 9 10 11 12 13 ###节点邻居（下面三个命令结果一样） V(g1)[nei(\u0026#34;GRHL3\u0026#34;)] neighbors(g1,\u0026#34;GRHL3\u0026#34;) g1[[\u0026#34;GRHL3\u0026#34;]] ##包含节点的有哪些 g1[[\u0026#34;GRHL3\u0026#34;,edges=TRUE]] ###针对有向图 g1[[\u0026#34;GRHL3\u0026#34;,]] #以GRHL3为起始点的邻居节点 g1[[,\u0026#34;GRHL3\u0026#34;]] #以GRHL3为终点的邻居节点 g1[[\u0026#34;GRHL3\u0026#34;,,edges=TRUE]] #以GRHL3为起始点的边 节点之间的距离 1 2 3 4 5 6 7 ##计算两节点之间的距离 ##如果存在边权重，可计算权重距离和 ##如果两个节点没有公共节点，则计算距离为0 distances(g1, v=c(\u0026#34;PTS\u0026#34;,\u0026#34;NPB\u0026#34;), to=c(\u0026#34;IGDCC4\u0026#34;,\u0026#34;UPK3B\u0026#34;,\u0026#34;NPB\u0026#34;)) # IGDCC4 UPK3B NPB # PTS 4 1 2 # NPB 4 3 0 1.4 igraph对象转为data.frame 1 2 3 4 5 6 7 8 9 #单独保存边信息 as_data_frame(g1, what = \u0026#34;edges\u0026#34;) %\u0026gt;% head() #单独保存点信息 as_data_frame(g1, what = \u0026#34;vertices\u0026#34;) %\u0026gt;% head() #同时保存点和边的信息 as_data_frame(g1, what = \u0026#34;both\u0026#34;) %\u0026gt;% head() #为包含两个表格的list对象 2、edge与vertex属性 2.1 edge边属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 edge_attr(g1) %\u0026gt;% names() # edge_attr_names(g1) #[1] \u0026#34;combined_score\u0026#34; edge_attr(g1)$combined_score # E(g1)$combined_score # [1] 244 204 238 222 281 996 598 225 226 291 415 294 210 237 266 #增加边属性 edge_attr(g1)$weight = edge_attr(g1)$combined_score edge_attr(g1)$type = ifelse(edge_attr(g1)$combined_score\u0026gt;500, \u0026#34;strong\u0026#34;,\u0026#34;weak\u0026#34;) #删除边属性 g1 \u0026lt;- delete_edge_attr(g1, \u0026#34;type\u0026#34;) edge_attr(g1) %\u0026gt;% names() # [1] \u0026#34;combined_score\u0026#34; \u0026#34;weight\u0026#34; 2.2 vertex点属性 1 2 3 4 5 6 7 vertex_attr(g1) %\u0026gt;% names() #[1] \u0026#34;name\u0026#34; \u0026#34;log10P\u0026#34; \u0026#34;logFC\u0026#34; \u0026#34;direction\u0026#34; vertex_attr(g1)$name #V(g1)$name # [1] \u0026#34;VSTM2L\u0026#34; \u0026#34;TNNC1\u0026#34; \u0026#34;MGAM\u0026#34; \u0026#34;IGDCC4\u0026#34; \u0026#34;UPK3B\u0026#34; \u0026#34;SLC52A1\u0026#34; \u0026#34;GRHL3\u0026#34; \u0026#34;SLC5A8\u0026#34; # ... 2.3 graph图属性 1 2 3 4 g1 \u0026lt;- set_graph_attr(g1, \u0026#34;name\u0026#34;, \u0026#34;PPI network\u0026#34;) graph_attr(g1) # $name # [1] \u0026#34;PPI network\u0026#34; 2.4 增删点与边 增加点 1 2 3 4 5 6 7 8 9 vertex_attr(g1) %\u0026gt;% names() # [1] \u0026#34;name\u0026#34; \u0026#34;log10P\u0026#34; \u0026#34;logFC\u0026#34; \u0026#34;direction\u0026#34; #增加两个节点 g1 %\u0026gt;% add_vertices(nv = 2, attr = list(name=c(\u0026#34;TP53\u0026#34;,\u0026#34;APC\u0026#34;), log10P=c(3,2), logFC=c(2,1), direction=c(\u0026#34;Up\u0026#34;,\u0026#34;Down\u0026#34;))) 增加边 1 2 3 4 5 6 edge_attr(g1) %\u0026gt;% names() # [1] \u0026#34;combined_score\u0026#34; \u0026#34;weight\u0026#34; #增加两条边 g1 %\u0026gt;% add_edges(c(\u0026#34;PTTG1\u0026#34;,\u0026#34;NPB\u0026#34;,\u0026#34;ACOT12\u0026#34;,\u0026#34;SLC5A8\u0026#34;), attr = list(combined_score = c(500,500), weight = c(300,300))) 删除点 1 2 3 V(g1) g1 %\u0026gt;% delete_vertices(, c(1,5)) %\u0026gt;% #根据序号下标 delete_vertices(\u0026#34;GSTM5\u0026#34;) #直接根据名字 删除边 1 2 3 E(g1) g1 %\u0026gt;% delete_edges(1) %\u0026gt;% #根据序号下标 delete_edges(\u0026#34;NPB|MGAM\u0026#34;) #直接边的节点组成 3、节点重要性网络分析 3.1 点度中心性degree 与目标节点直接相连的节点数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # mode参数主要考虑有向图的可能 degree(g1, mode=\u0026#34;all\u0026#34;) # VSTM2L TNNC1 MGAM IGDCC4 UPK3B SLC52A1 GRHL3 SLC5A8 GSTM5 NNAT PTTG1 # 1 1 3 1 1 2 2 1 1 1 1 # ATP13A1 ACOT12 SETD1B NPB EZH2 PARN PTS RBBP7 # 2 1 2 1 3 2 2 2 # normalized = T表示相对点度中心性 # 即divided by n-1, where n is the number of vertices in the graph. degree(g1, mode=\u0026#34;all\u0026#34;, normalized = T) # VSTM2L TNNC1 MGAM IGDCC4 UPK3B SLC52A1 GRHL3 SLC5A8 # 0.05555556 0.05555556 0.16666667 0.05555556 0.05555556 0.11111111 0.11111111 0.05555556 # GSTM5 NNAT PTTG1 ATP13A1 ACOT12 SETD1B NPB EZH2 # 0.05555556 0.05555556 0.05555556 0.11111111 0.05555556 0.11111111 0.05555556 0.16666667 # PARN PTS RBBP7 # 0.11111111 0.11111111 0.11111111 3.2 紧密度中间性closeness 目标节点到其余所有节点的最短（权重）距离均值的倒数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 closeness(g1, mode=\u0026#34;all\u0026#34;, weights=NA) # 参数weights表示计算最短距离时是否考虑边的权重 # VSTM2L TNNC1 MGAM IGDCC4 UPK3B SLC52A1 GRHL3 # 0.003086420 0.003436426 0.004201681 0.004048583 0.004065041 0.003460208 0.004132231 # SLC5A8 GSTM5 NNAT PTTG1 ATP13A1 ACOT12 SETD1B # 0.003436426 0.003086420 0.003086420 0.003448276 0.003460208 0.003086420 0.003460208 # NPB EZH2 PARN PTS RBBP7 # 0.004115226 0.003472222 0.004184100 0.004149378 0.003460208 # Warning message: # In closeness(g1, mode = \u0026#34;all\u0026#34;, weights = NA) : # At centrality.c:2874 :closeness centrality is not well-defined for disconnected graphs #同样可设置normalized参数是否进行标准化 由于提供的PPI网络存在断连的情况，所以会出现上面的warning\n3.3 介数中间性betweenness 除目标节点外所有节点间的最短(权重)距离是否经过目标节点（的次数） 1 2 3 4 5 6 7 betweenness(g1, directed = FALSE, weights=NA) # VSTM2L TNNC1 MGAM IGDCC4 UPK3B SLC52A1 GRHL3 SLC5A8 GSTM5 NNAT PTTG1 # 0 0 11 0 0 2 5 0 0 0 0 # ATP13A1 ACOT12 SETD1B NPB EZH2 PARN PTS RBBP7 # 2 0 0 0 2 8 5 0 #同样可设置normalized参数是否进行标准化 4、网络可视化 1 plot(g1) 图形的调整参数涉及如下三个方面\n（1）节点与节点的标签；\n（2）边\n（3）其它\n例如，设置节点的颜色与差异基因上下调相关，节点大小与上下调程度相关，边的宽度与蛋白互作程度相关\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #设置节点颜色--上下调方向 vcol=vertex_attr(g1)$direction vcol[vcol==\u0026#34;Up\u0026#34;]=\u0026#34;tomato\u0026#34; vcol[vcol==\u0026#34;Down\u0026#34;]=\u0026#34;gold\u0026#34; V(g1)$color=vcol # 设置节点大小--上下调程度 vsize=vertex_attr(g1)$logFC %\u0026gt;% abs() %\u0026gt;% round(1) V(g1)$size=vsize+10 # 设置线的宽度(相对值) E(g1)$width=edge_attr(g1)$combined_score/500 set.seed(123) plot(g1, vertex.label.color=\u0026#34;black\u0026#34;, vertex.label.cex=1, vertex.label.dist=1, edge.curved=0.2, layout=layout_with_fr, #layout=layout.auto(g1), frame = TRUE, main=\u0026#34;PPI network of DEGs\u0026#34;) legend(\u0026#34;right\u0026#34;, legend = c(\u0026#34;Up\u0026#34;,\u0026#34;Down\u0026#34;), pch=21, col=c(\u0026#34;tomato\u0026#34;,\u0026#34;gold\u0026#34;), pt.bg=c(\u0026#34;tomato\u0026#34;,\u0026#34;gold\u0026#34;), pt.cex=1, cex=.8, bty=\u0026#34;n\u0026#34;, ncol=1) 关于layout参数，layout.auto()函数可根据网络组成，选择较为合适的布局：（1）connected and vcount\u0026lt;=100: kk； （2）vcount\u0026lt;=1000:fr； （3）else: drl\nggraph包建立在ggplot2绘图框架上，可用于可视化igraph对象，具体用法以后有机会再学。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/200%E4%BD%BF%E7%94%A8igraph%E5%8C%85%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90%E4%B8%8E%E5%8F%AF%E8%A7%86%E5%8C%96/","summary":"\u003ch2 id=\"1创建与查看igraph对象\"\u003e1、创建与查看igraph对象\u003c/h2\u003e\n\u003ch4 id=\"11-示例数据\"\u003e1.1 示例数据\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eigraph\u003c/code\u003e包提供了很多创建igraph对象的函数与思路。这里采用常用的基于data.frame的格式创建。\u003c/li\u003e\n\u003cli\u003e示例数据来自\u003ccode\u003eSTRINGdb\u003c/code\u003e的PPI蛋白互作数据以及对应基因的上下调信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e45\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(STRINGdb)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estring_db \u0026lt;- STRINGdb$new(version=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;11\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          species=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9606\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          score_threshold=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          input_directory=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(diff_exp_example1)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes = rbind(head(diff_exp_example1,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              tail(diff_exp_example1,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(genes)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes_mapped \u0026lt;- string_db$map(genes, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;gene\u0026#34;\u003c/span\u003e )\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(genes_mapped)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eppi = string_db$get_interactions(genes_mapped$STRING_id) %\u0026gt;% distinct()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eedges = ppi %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::left_join(genes_mapped[,c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)], by=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;from\u0026#39;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;STRING_id\u0026#39;\u003c/span\u003e)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::rename(Gene1=gene) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::left_join(genes_mapped[,c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)], by=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;to\u0026#39;\u003c/span\u003e=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;STRING_id\u0026#39;\u003c/span\u003e)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::rename(Gene2=gene) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(Gene1, Gene2, combined_score)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enodes = genes_mapped %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::filter(gene %in% c(edges$Gene1, edges$Gene2)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::mutate(log10P = -log10(pvalue),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                direction = ifelse(logFC\u0026gt;\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Up\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Down\u0026#34;\u003c/span\u003e)) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::select(gene, log10P, logFC, direction)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###边信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(edges)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Gene1   Gene2 combined_score\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 UPK3B     PTS            244\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 GSTM5  ACOT12            204\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 GRHL3  IGDCC4            238\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4 TNNC1 ATP13A1            222\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5  NNAT  VSTM2L            281\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6  EZH2   RBBP7            996\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e###节点信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(nodes)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      gene   log10P    logFC direction\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  VSTM2L 3.992252 3.333461        Up\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2   TNNC1 3.534468 2.932060        Up\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3    MGAM 3.515558 2.369738        Up\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4  IGDCC4 3.290137 2.409806        Up\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5   UPK3B 3.248490 2.073072        Up\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 SLC52A1 3.227019 3.214998        Up\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch4 id=\"12-创建对象\"\u003e1.2 创建对象\u003c/h4\u003e\n\u003cp\u003e使用\u003ccode\u003egraph_from_data_frame()\u003c/code\u003e函数创建\u003c/p\u003e","title":"使用igraph包进行网络结构分析与可视化"},{"content":" 题目：In silico prediction of potential drug-induced nephrotoxicity with machine learning methods\n期刊 | 日期 ： Journal of Applied Toxicology | 11 April 2022\n简介：标准的机器学习模型分析流程，从数据收集到数据整理，从训练模型到评价模型。\n1、数据收集 1.1 标签数据 （1）从SIDER、DrugBank、ChEMBL以及TCM@taiwan等4个数据库收集了1366个标签化合物\n（2）使用PubChem获得每个化合物的PubCID与canonical SMILE；\n（3）使用Pipeline Pilot(https://www.accelrys.com) 筛选无效的化合物\n无机和有机金属化合物 将salt forms转为parent form 去重 （4）经上一部筛选保留777个化合物\n125 天然化合物 652 化药化合物 （5）基于文献与最新更新数据，收集70个外部数据集\n基于文献：29个天然化合物、11个化药化合物 2021FDA最新批准药物：11个。 1.2 特征数据 使用Padel Descriptor software(https://github.com/ecrl/padelpy)软件,计算每个化合物的9种分子指纹。\nAtom Pair 2D fingerprint (AP2DFP, 780 bits) Estate fingerprint (EstateFP, 79 bits) CDK extended fingerprint (ExtFP, 1024 bits) CDK fingerprint (FP, 1024 bits) CDK graph only fingerprint (GraphFP, 1024 bits) Klekota–Roth fingerprint (KRFP, 4860 bits) MACCS fingerprint (MACCSFP, 166 bits) PubChem fingerprint (PubChemFP, 881 bits) substructure fingerprint (SubFP, 307 bits) 2 训练模型 2.1 机器学习算法 （1）使用scikit-learn包提供的8种算法建立机器学习分类模型。\n（2）结合上面的8种指纹特征，共建立得到72个机器学习模型。\nArtificial neural network (ANN) LightGBM Random forest (RF) SVM C4.5 decision tree (DT) KNN naïve Bayes (NB) scalable end-to-end tree boosting system (XGBoost) 2.2 数据集划分 （1）将777个标签数据按照9:1比例，划分成训练集(train)与内部验证集(internal validation)\n（2）结合上面提及的70个标签化合物(external validation)，共有3份数据集。\n（3）检验所有化合物之间特征分布无不平衡情况\n比较3类数据集的Molecular/AlogP特征分布（左）； 计算化合物两两相似性Tanimoto similarity coefficient（右） 2.3 模型训练 （1）在训练集中，使用10次的10折交叉验证方式优化参数(grid search)\n（2）使用下述多个指标对模型预测结果进行评价\nAUC ：overall predictive performance ACC ：prediction of the overall sample data. SE(sensitivity)：positive sample data SP(specificity)：negative sample data. F1：harmonic mean of recall and precision. MCC(for external validation) 4、模型评价 （1）对于每个优化好的模型(72个)在internal validation set中作第一次验证，优选综合评价最好的6个模型。\n（2）使用这6个模型在external validation set中作第二次验证，分3个角度进行(单独天然药、单独化药、混合数据)。\n5、衍生 模型的适用域applicability domain (AD)\n分析警示结构 structural alerts（SARpy工具）\n","permalink":"https://lishensuo.github.io/en/posts/basic/201%E6%96%87%E7%8C%AE--%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E8%8D%AF%E7%89%A9%E8%82%BE%E6%AF%92%E6%80%A7-2/","summary":"\u003cblockquote\u003e\n\u003cp\u003e题目：In silico prediction of potential drug-induced nephrotoxicity with machine learning methods\u003c/p\u003e\n\u003cp\u003e期刊 | 日期 ： Journal of Applied Toxicology | 11 April 2022\u003c/p\u003e\n\u003cp\u003e简介：标准的机器学习模型分析流程，从数据收集到数据整理，从训练模型到评价模型。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"1数据收集\"\u003e1、数据收集\u003c/h2\u003e\n\u003ch3 id=\"11-标签数据\"\u003e1.1 标签数据\u003c/h3\u003e\n\u003cp\u003e（1）从SIDER、DrugBank、ChEMBL以及TCM@taiwan等4个数据库收集了1366个标签化合物\u003c/p\u003e","title":"文献--机器学习模型预测药物肾毒性-2"},{"content":" 在遇到R里的大量循环操作时，可以考虑多线程处理方式，提高分析速度。具体使用方法针对window与linux/mac平台有所区别。相关笔记如下\n1 2 #查看系统平台 Windows/Linux Sys.info()[\u0026#39;sysname\u0026#39;] 一、Linux/Mac平台 1 2 3 library(parallel) # 检测系统的CPU数 detectCores() 1、lapply 多线程 mclapply()函数，关键是mc.cores参数设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(parallel) ##并行4个线程 res = mclapply(1:10, function(x){ \u0026lt;code\u0026gt; \u0026lt;code\u0026gt; }, mc.cores = 4) ##并行处理不影响顺序 res = mclapply(1:1000, function(x){ print(x) x2 = x*x Sys.sleep(0.1) return(c(x, x2)) }, mc.cores = 10) res_df = do.call(rbind, res) head(res_df,3) # [,1] [,2] # [1,] 1 1 # [2,] 2 4 # [3,] 3 9 tail(res_df,3) # [,1] [,2] # [998,] 998 996004 # [999,] 999 998001 # [1000,] 1000 1000000 2、for循环 多线程 配合foreach包。可通过调整参数，设置结果返回的形式，详见相关笔记，或者该包的帮助文档。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 library(foreach) library(doParallel) cl=makeCluster(4) registerDoParallel(cl) #专门加载所需要的分析包 clusterEvalQ(cl, library(package1)) clusterEvalQ(cl, library(package1)) res = foreach(i = 1:10) %dopar% { \u0026lt;code\u0026gt; \u0026lt;code\u0026gt; } stopCluster(cl) 二、window平台 个人觉得window平台的笔记本电脑可能还是不太适合多线程的使用 1 2 3 library(parallel) # 检测系统的CPU数 detectCores() 1、lapply 多线程 parLapply()函数 1 2 3 4 5 6 7 8 cl \u0026lt;- makeCluster(4) #专门加载所需要的分析包 clusterExport(cl, library(packages)) res=parLapply(cl, 1:10, function(x){ \u0026lt;code\u0026gt; \u0026lt;code\u0026gt; }) stopCluster(cl) #需要显式的释放已加载的线程，比较麻烦 2、for循环的多线程调用同上 参考教程 https://www.biostars.org/p/273107/ ","permalink":"https://lishensuo.github.io/en/posts/program/201r%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在遇到R里的大量循环操作时，可以考虑多线程处理方式，提高分析速度。具体使用方法针对window与linux/mac平台有所区别。相关笔记如下\u003c/p\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#查看系统平台 Windows/Linux\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eSys.info()[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;sysname\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"一linuxmac平台\"\u003e一、Linux/Mac平台\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(parallel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 检测系统的CPU数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edetectCores()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1lapply-多线程\"\u003e1、lapply 多线程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emclapply()\u003c/code\u003e函数，关键是\u003ccode\u003emc.cores\u003c/code\u003e参数设置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(parallel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##并行4个线程\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres = mclapply(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(x){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u0026lt;code\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u0026lt;code\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}, mc.cores = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##并行处理不影响顺序\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres = mclapply(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(x){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(x)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    x2 = x*x  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Sys.sleep(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e(c(x, x2))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}, mc.cores = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres_df = do.call(rbind, res)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(res_df,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      [,1] [,2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1,]    1    1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [2,]    2    4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [3,]    3    9\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etail(res_df,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         [,1]    [,2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [998,]  998  996004\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [999,]  999  998001\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1000,] 1000 1000000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2for循环-多线程\"\u003e2、for循环 多线程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e配合\u003ccode\u003eforeach\u003c/code\u003e包。可通过调整参数，设置结果返回的形式，详见\u003ca href=\"https://www.zsccy.xyz/md/2018-04-08-r%E8%AF%AD%E8%A8%80%E5%B9%B6%E8%A1%8C%E5%8C%96%E8%AE%A1%E7%AE%97%E4%B9%8Bforeach%E5%8C%85/\"\u003e相关笔记\u003c/a\u003e，或者该包的帮助文档。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(foreach)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(doParallel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecl=makeCluster(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eregisterDoParallel(cl) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#专门加载所需要的分析包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclusterEvalQ(cl, library(package1))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclusterEvalQ(cl, library(package1)) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres = foreach(i = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e) %dopar% {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u0026lt;code\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u0026lt;code\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estopCluster(cl)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"二window平台\"\u003e二、window平台\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e个人觉得window平台的笔记本电脑可能还是不太适合多线程的使用\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(parallel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 检测系统的CPU数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edetectCores()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1lapply-多线程-1\"\u003e1、lapply 多线程\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eparLapply()\u003c/code\u003e函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecl \u0026lt;- makeCluster(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#专门加载所需要的分析包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclusterExport(cl, library(packages))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eres=parLapply(cl, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(x){\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u0026lt;code\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u0026lt;code\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estopCluster(cl) \u003cspan style=\"color:#007f7f\"\u003e#需要显式的释放已加载的线程，比较麻烦\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2for循环的多线程调用同上\"\u003e2、for循环的多线程调用同上\u003c/h3\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e参考教程\n\u003ca href=\"https://www.biostars.org/p/273107/\"\u003ehttps://www.biostars.org/p/273107/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","title":"R语言的多线程循环语句"},{"content":"1、关于RWR 1.1 算法简介 Random Walk with Restart，RWR重启随机游走算法\n在给定的一个由节点和边组成的网络结构中（下面均已PPI蛋白相互作用网络为例），选择其中一个或者一组基因。我们想知道其余的哪些基因与我们先前所选择的一个或者一组基因最相关。此时可以用到RWR，简单原理如下：\nRWR的公式如下。其中1-c表示重启概率，e表示起始节点，W表示网络邻接矩阵 $$ \\vec{r_i} = cW*\\vec{r_i} + (1-c) \\vec{e_i} $$\n如下例图所示，假设对于有12个蛋白互作关系组成PPI网络。我们想知道蛋白4与网络中其它蛋白的相关性排名如何。\n（1）选取蛋白4作为起始节点，随机向邻居节点走一步(蛋白1、3、5)。但是在每一次走向邻居节点时，都有一定概率返回到起始节点(蛋白4)。\n（2）假设走到了节点1，然后继续向邻居节点走一步(蛋白2,3)，也仍然有一定概率返回起始节点。\n（3）如此往复循环，最终从蛋白4走到网络其余每个蛋白的节点概率趋于收敛，作为与蛋白4的相关性度量指标。\n1.2 RandomWalkRestartMH包简介 RandomWalkRestartMH R包2018年最初发表，可用于多种复杂生物网中应用RWR算法，下面的笔记主要参考自官方文档。\n按照文档中的定义，有三种类型的网络\u0026ndash;\nMonoplex Network：只有一种类型节点，一个类型边。例如常规的PPI网络：节点为蛋白，边为互作关系。 Heterogeneous Network：本质上是两个网络（例如PPI网路与疾病相似性网络），节点类型不相同（前者为蛋白，后者为疾病）。依靠两类节点的关系（某疾病与某蛋白功能异常密切相关）合并而成。 Multiplex Network：本质上也是两个网络，但节点类型相同。例如PPI网络与通路网络 1 2 3 4 5 6 7 #安装，建议从github安装 #BiocManager::install(\u0026#34;RandomWalkRestartMH\u0026#34;) devtools::install_github(\u0026#34;alberto-valdeolivas/RandomWalkRestartMH\u0026#34;) packageVersion(\u0026#34;RandomWalkRestartMH\u0026#34;) # [1] ‘1.13.1’ #检查包的版本与官文示例文档的版本要一致 #该包要求为igraph定义的网络结构，也需要安装。 2、分析实例 2.1 Monoplex Network 在给定PPI网络中，寻找与指定基因（集）最相关的基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 library(RandomWalkRestartMH) library(igraph) ##(1) 加载数据：PPI网络的igraph对象 #使用RandomWalkRestartMH的示例数据，下同 data(PPI_Network) PPI_Network #包含4317个蛋白的18062条互作关系 # IGRAPH 3bec0a4 UN-- 4317 18062 -- # 这个PPI网络不包含互作强度 edge_attr(PPI_Network) # named list() ##(2) 创建Multiplex对象，计算出邻接矩阵 PPI_MultiplexObject \u0026lt;- create.multiplex(list(PPI=PPI_Network)) PPI_MultiplexObject AdjMatrix_PPI \u0026lt;- compute.adjacency.matrix(PPI_MultiplexObject) #稀疏矩阵，1表示对应行和列的蛋白存在互作 colSums(AdjMatrix_PPI[,1:4]) # A2M_1 AAGAB_1 AAMDC_1 AAMP_1 # 45 2 2 4 AdjMatrixNorm_PPI \u0026lt;- normalize.multiplex.adjacency(AdjMatrix_PPI) #标准化，使蛋白到所有邻居蛋白的概率和=1 ##(3) 确定起始节点，应用RWR算法，计算相关节点分数 SeedGene \u0026lt;- c(\u0026#34;PIK3R1\u0026#34;) RWR_PPI_Results \u0026lt;- Random.Walk.Restart.Multiplex(AdjMatrixNorm_PPI, PPI_MultiplexObject,SeedGene) # Top 10 ranked Nodes: # NodeNames Score # 1 GRB2 0.006845881 # 2 EGFR 0.006169129 # 3 CRK 0.005674261 # 4 ABL1 0.005617041 # 5 FYN 0.005611086 # 6 CDC42 0.005594680 # 7 SHC1 0.005577900 # 8 CRKL 0.005509182 # 9 KHDRBS1 0.005443541 # 10 TYRO3 0.005441887 # # Seed Nodes used: # [1] \u0026#34;PIK3R1\u0026#34; 有权重的Monoplex Network 基本步骤相同，只需要给igraph对象添加边的权重weight信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #STRING蛋白相互作用数据可使用STRINGdb包下载 #这里就参考文档，随机模拟 ##(1) library(RandomWalkRestartMH) library(igraph) data(PPI_Network) #随机模拟PPI互作强度，设置igraph edge的weight属性 PPI_Network \u0026lt;- set_edge_attr(PPI_Network,\u0026#34;weight\u0026#34;,E(PPI_Network), value = runif(ecount(PPI_Network))) edge_attr(PPI_Network) %\u0026gt;% names() # weight ##(2) 创建Multiplex对象，计算出邻接矩阵 PPI_MultiplexObject \u0026lt;- create.multiplex(list(PPI=PPI_Network)) PPI_MultiplexObject AdjMatrix_PPI \u0026lt;- compute.adjacency.matrix(PPI_MultiplexObject) colSums(AdjMatrix_PPI[,1:4]) # A2M_1 AAGAB_1 AAMDC_1 AAMP_1 #22.4898374 0.4895032 1.4202684 1.2030568 AdjMatrixNorm_PPI \u0026lt;- normalize.multiplex.adjacency(AdjMatrix_PPI) ##(3) 确定起始节点，应用RWR算法，计算相关节点分数 SeedGene \u0026lt;- c(\u0026#34;PIK3R1\u0026#34;) RWR_PPI_Results \u0026lt;- Random.Walk.Restart.Multiplex(AdjMatrixNorm_PPI, PPI_MultiplexObject,SeedGene) # Top 10 ranked Nodes: # NodeNames Score # 1 EGFR 0.010790996 # 2 CRKL 0.010145105 # 3 GSPT1 0.009818236 # 4 AXL 0.009428844 # 5 NFKBIA 0.009418182 # 6 ITSN1 0.009385254 # 7 ZDHHC17 0.009369438 # 8 GAB2 0.009291153 # 9 CXCL2 0.009027423 # 10 STAT3 0.008956187 # # Seed Nodes used: # [1] \u0026#34;PIK3R1\u0026#34; 2.2 Heterogeneous Network 已知疾病SHORT综合征(OMIM的id为269880)的关键基因为PIK3R1。据此发现与之最相关的疾病、基因 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 library(RandomWalkRestartMH) library(igraph) ##(1) 构建两个网络 #构建PPI网络 data(PPI_Network) PPI_MultiplexObject \u0026lt;- create.multiplex(list(PPI=PPI_Network)) #构建疾病相似度网络 data(Disease_Network) Disease_MultiplexObject \u0026lt;- create.multiplex(list(Disease=Disease_Network)) ##(2) 疾病与蛋白的关系数据 data(GeneDiseaseRelations) head(GeneDiseaseRelations) # hgnc_symbol mim_morbid # 3 A2M 614036 # 4 A2M 104300 # 6 A4GALT 111400 # 根据两个网络，进一步筛选 GeneDiseaseRelations_PPI \u0026lt;- GeneDiseaseRelations[which(GeneDiseaseRelations$hgnc_symbol %in% PPI_MultiplexObject$Pool_of_Nodes),] GeneDiseaseRelations_PPI \u0026lt;- GeneDiseaseRelations_PPI[which(GeneDiseaseRelations_PPI$mim_morbid %in% Disease_MultiplexObject$Pool_of_Nodes),] dim(GeneDiseaseRelations_PPI) # [1] 1330 2 ##(3) 创建Multiplex对象，计算出邻接矩阵 PPI_Disease_Net \u0026lt;- create.multiplexHet(PPI_MultiplexObject, Disease_MultiplexObject, GeneDiseaseRelations_PPI) PPI_Disease_Net PPIHetTranMatrix \u0026lt;- compute.transition.matrix(PPI_Disease_Net) dim(PPIHetTranMatrix) # [1] 11264 11264 ##(4) 每一层确定一个起始节点，应用RWR算法，计算相关节点分数 SeedGene \u0026lt;- c(\u0026#34;PIK3R1\u0026#34;) SeedDisease \u0026lt;- c(\u0026#34;269880\u0026#34;) RWRH_PPI_Disease_Results \u0026lt;- Random.Walk.Restart.MultiplexHet(PPIHetTranMatrix, PPI_Disease_Net, Multiplex1_Seeds = SeedGene, Multiplex2_Seeds = SeedDisease) # RWRH_PPI_Disease_Results # Top 10 ranked global nodes: # NodeNames Score # 1 PIK3R1 0.414259752 # 2 269880 0.372567325 # 3 615214 0.020817435 # 4 616005 0.020785895 # 5 194050 0.005868407 # 6 309000 0.005687206 # 7 262500 0.005681162 # 8 138920 0.005655559 # 9 223370 0.005655117 # 10 608612 0.005649291 # # Top 10 ranked nodes from the first Multiplex: # NodeNames Score # 1479 GRB2 0.001965500 # 1081 EGFR 0.001754048 # 797 CRK 0.001636329 # 603 CDC42 0.001630575 # 19 ABL1 0.001623304 # 798 CRKL 0.001605543 # 1360 FYN 0.001598567 # 3405 SHC1 0.001597720 # 2583 PDGFRB 0.001596830 # 4027 TYRO3 0.001589911 # # Top 10 ranked nodes from the second Multiplex: # NodeNames Score # 6352 615214 0.020817435 # 6705 616005 0.020785895 # 1699 194050 0.005868407 # 3625 309000 0.005687206 # 2901 262500 0.005681162 # 686 138920 0.005655559 # 2150 223370 0.005655117 # 4770 608612 0.005649291 # 4464 606176 0.005641777 # 1411 180500 0.005639919 # # Seeds used: # [1] \u0026#34;PIK3R1\u0026#34; \u0026#34;269880\u0026#34; ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/201%E9%87%8D%E5%90%AF%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0%E7%AE%97%E6%B3%95%E4%B8%8Erandomwalkrestartmh%E5%8C%85/","summary":"\u003ch2 id=\"1关于rwr\"\u003e1、关于RWR\u003c/h2\u003e\n\u003ch3 id=\"11-算法简介\"\u003e1.1 算法简介\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eRandom Walk with Restart，RWR重启随机游走算法\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在给定的一个由节点和边组成的网络结构中（下面均已PPI蛋白相互作用网络为例），选择其中一个或者一组基因。我们想知道其余的哪些基因与我们先前所选择的一个或者一组基因最相关。此时可以用到RWR，简单原理如下：\u003c/p\u003e","title":"重启随机游走算法与RandomWalkRestartMH包"},{"content":" 学习Genecompass时，了解参考到可以基因调控网络信息（Gene pair），计算Gene的嵌入表示（Embedding）\nhttps://github.com/jingcheng-du/Gene2vec 关键是要在python=3.7环境下，安装genesim=3.4.0 关于Genesim是NLP领域受欢迎的工具：https://github.com/jingcheng-du/Gene2vec\ngensim.models 是 gensim 库中提供的一组模型工具，主要用于不同类型的模型和算法。\nWord2Vec 是 gensim 中非常常用的模型之一 如下是参考Gene2vec修改后的简化脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 # Stage-1: Definition of loading embeddings import numpy as np from gensim.models.keyedvectors import KeyedVectors #convert binary gene2vec to matrix txt def load_embeddings(file_name): model = KeyedVectors.load(file_name) wordVector = model.wv vocabulary, wv = zip(*[[word, wordVector[word]] for word, vocab_obj in wordVector.vocab.items()]) return np.asarray(wv), vocabulary def outputTxt (embeddings_file): embeddings_file = embeddings_file # gene2vec file address wv, vocabulary = load_embeddings(embeddings_file) index = 0 matrix_txt_file = embeddings_file+\u0026#34;.txt\u0026#34; # gene2vec matrix txt file address with open(matrix_txt_file, \u0026#39;w\u0026#39;) as out: for ele in wv[:]: out.write(str(vocabulary[index]) + \u0026#34;\\t\u0026#34;) index = index + 1 for elee in ele: out.write(str(elee) + \u0026#34; \u0026#34;) out.write(\u0026#34;\\n\u0026#34;) out.close() # Stage-2: Gene2vec training import gensim, logging import os import random import datetime import argparse parser = argparse.ArgumentParser(description=\u0026#39;Please specify data directory, embedding output directory and data file ending pattern\u0026#39;) parser.add_argument(\u0026#39;fileAddress\u0026#39;, metavar=\u0026#39;N\u0026#39;, type=str, nargs=\u0026#39;+\u0026#39;, help=\u0026#39;python gene2vec.py data_directory output_directory txt\u0026#39;) args = parser.parse_args() sourceDir = args.fileAddress[0] # source directory of the files export_dir = args.fileAddress[1] ending_pattern = args.fileAddress[2] n_dims = args.fileAddress[3] logging.basicConfig(format=\u0026#39;%(asctime)s : %(levelname)s : %(message)s\u0026#39;, level=logging.INFO) print(\u0026#34;start!\u0026#34;) # sourceDir = \u0026#34;../data\u0026#34; # training file format: # TOX4 ZNF146 # TP53BP2 USP12 # TP53BP2 YRDC num_db = 0 files = os.listdir(sourceDir) size = len(files) gene_pairs = list() random.shuffle(files) #load all the data for fname in files: if not fname.endswith(ending_pattern): continue num_db = num_db + 1 now = datetime.datetime.now() print(now) print(\u0026#34;current file \u0026#34;+ fname + \u0026#34; num: \u0026#34; + str(num_db) + \u0026#34; total files \u0026#34; + str(size)) f = open(os.path.join(sourceDir, fname), \u0026#39;r\u0026#39;, encoding=\u0026#39;windows-1252\u0026#39;) for line in f: gene_pair = line.strip().split() gene_pairs.append(gene_pair) f.close() current_time = datetime.datetime.now() print(current_time) print(\u0026#34;shuffle start \u0026#34; + str(len(gene_pairs))) random.shuffle(gene_pairs) current_time = datetime.datetime.now() print(current_time) print(\u0026#34;shuffle done \u0026#34; + str(len(gene_pairs))) ####training parameters######## # dimension = 100 # dimension of the embedding dimension = int(n_dims) # dimension of the embedding num_workers = 32 # number of worker threads sg = 1 # sg =1, skip-gram, sg =0, CBOW max_iter = 10 # number of iterations window_size = 1 # The maximum distance between the gene and predicted gene within a gene list # (由于是基因对，所以设置为1) txtOutput = True # export_dir = \u0026#34;../emb\u0026#34; for current_iter in range(1,max_iter+1): # 第一轮时，初始化模型，再训练 if current_iter == 1: print(\u0026#34;gene2vec dimension \u0026#34;+ str(dimension) +\u0026#34; iteration \u0026#34;+ str(current_iter)+ \u0026#34; start\u0026#34;) model = gensim.models.Word2Vec(gene_pairs, size=dimension, window=window_size, min_count=1, workers=num_workers, iter=1, sg=sg) # 保存模型 model.save(export_dir+\u0026#34;/gene2vec_dim_\u0026#34;+str(dimension)+\u0026#34;_iter_\u0026#34;+str(current_iter)) if txtOutput: outputTxt(export_dir+\u0026#34;/gene2vec_dim_\u0026#34;+str(dimension)+\u0026#34;_iter_\u0026#34;+str(current_iter)) print(\u0026#34;gene2vec dimension \u0026#34;+ str(dimension) +\u0026#34; iteration \u0026#34;+ str(current_iter)+ \u0026#34; done\u0026#34;) del model else: current_time = datetime.datetime.now() print(current_time) print(\u0026#34;shuffle start \u0026#34; + str(len(gene_pairs))) # 打乱行数据 random.shuffle(gene_pairs) current_time = datetime.datetime.now() print(current_time) print(\u0026#34;shuffle done \u0026#34; + str(len(gene_pairs))) print(\u0026#34;gene2vec dimension \u0026#34; + str(dimension) + \u0026#34; iteration \u0026#34; + str(current_iter) + \u0026#34; start\u0026#34;) # 加载上一步模型 model = gensim.models.Word2Vec.load(export_dir+\u0026#34;/gene2vec_dim_\u0026#34;+str(dimension)+\u0026#34;_iter_\u0026#34;+str(current_iter-1)) model.train(gene_pairs,total_examples=model.corpus_count,epochs=model.iter) model.save(export_dir+\u0026#34;/gene2vec_dim_\u0026#34;+str(dimension)+\u0026#34;_iter_\u0026#34;+str(current_iter)) if txtOutput: outputTxt(export_dir+\u0026#34;/gene2vec_dim_\u0026#34;+str(dimension)+\u0026#34;_iter_\u0026#34;+str(current_iter)) print(\u0026#34;gene2vec dimension \u0026#34; + str(dimension) + \u0026#34; iteration \u0026#34; + str(current_iter) + \u0026#34; done\u0026#34;) del model 示例运行代码，demo数据参考 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 python ./gene2vec.py data out txt 100 # 参数 ## data: 输入基因对文件所在文件夹（支持多个文件） ## out: 输出文件夹 ## txt: 输入基因对文件的后缀名 ## 100: Embedding的嵌入维度 ls out # gene2vec_dim_100_iter_1 gene2vec_dim_100_iter_3.txt gene2vec_dim_100_iter_7 # gene2vec_dim_100_iter_10 gene2vec_dim_100_iter_4 gene2vec_dim_100_iter_7.txt # gene2vec_dim_100_iter_10.txt gene2vec_dim_100_iter_4.txt gene2vec_dim_100_iter_8 # gene2vec_dim_100_iter_1.txt gene2vec_dim_100_iter_5 gene2vec_dim_100_iter_8.txt # gene2vec_dim_100_iter_2 gene2vec_dim_100_iter_5.txt gene2vec_dim_100_iter_9 # gene2vec_dim_100_iter_2.txt gene2vec_dim_100_iter_6 gene2vec_dim_100_iter_9.txt # gene2vec_dim_100_iter_3 gene2vec_dim_100_iter_6.txt ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/202gene2vec%E7%AE%97%E6%B3%95%E6%A0%B9%E6%8D%AE%E5%9F%BA%E5%9B%A0%E5%AF%B9%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%9B%A0%E8%A1%A8%E7%A4%BA/","summary":"\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e学习Genecompass时，了解参考到可以基因调控网络信息（Gene pair），计算Gene的嵌入表示（Embedding）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/jingcheng-du/Gene2vec\"\u003ehttps://github.com/jingcheng-du/Gene2vec\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e关键是要在python=3.7环境下，安装genesim=3.4.0\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e关于Genesim是NLP领域受欢迎的工具：https://github.com/jingcheng-du/Gene2vec\u003c/p\u003e","title":"Gene2vec算法根据基因对计算基因表示"},{"content":" 文献： scGPT: toward building a foundation model for single-cell multi-omics using generative AI\n时间：2024 Feb. (Published)\n期刊：Nature Method\nDOI：https://doi.org/10.1038/s41592-024-02201-0\nGithub：https://github.com/bowang-lab/scGPT\n1. 简介 1.1 关于作者 通讯作者：Bo Wang，多伦多大学\nhttps://wanglab.ai/ https://github.com/bowang-lab/ https://scholar.google.com/citations?hl=en\u0026user=37FDILIAAAAJ 1.2 文献概述 受启发于GPT等基于transformer的大模型，Wang团队基于大量单细胞转录组数据，构建了scGPT foundation model，可用于多种常见的单细胞下游分析任务，性能优于其它已有的分析工具。\n核心假设：\n在NLP领域中，一个句子由多个单词组成。经过预训练的自监督学习，foundation model可以提取输入句子中每个单词(或者句子整体)的高级表示(Embedding)； 而在scRNA-seq中，一个细胞可以认为由所有基因的不同程度表达定义。经过预训练的自监督学习，foundation model可以提取输入单细胞表达数据的每个基因(或者细胞整体)的高级表示(Embedding)。 在Pre-trained foundation models基础上，将提取的基因/细胞Embedding在具体的单细胞下游分析任务中进行二次微调(fine-tune)，发挥大数据生成的强大优势。\n2. Pretrain预训练 Pre-train foundation model的核心功能就是以一个单细胞的数据为输入，将提取的Gene/Cell Embedding为输出。\n2.0 数据规模 文章从CELLxGENE网站收集了33M个正常细胞的scRNA-seq数据用于训练Foundation model 其中来自Brain、Blood等器官的细胞数最多 2.1 初始化输入 scGPT的原始输入数据通常为N个细胞，G个基因的Count表达矩阵。此时，需要对每个细胞的基因数据进行初始化处理，作为scGPT的标准输入； 概括来说，分别从每个基因的三个角度进行D维嵌入编码 (1×D)，然后再进行矩阵加法（仍为1×D），最终将所有基因合并得到（M×D）的细胞特征矩阵。 因为细胞的基因会根据情况进行选择，并且考虑到\u0026lt;cls\u0026gt;等特殊词元，所以这里并不是G×D\n（1）Gene token\n所有基因(词元)构成的词表中，每个基因都有一个对应的整数标识符（Integer Identifier） 此外还有其它特殊的词元，例如\u0026lt;cls\u0026gt;, \u0026lt;pad\u0026gt;等 \u0026lt;cls\u0026gt;词元通常放在细胞M个词元中的第一个，不表示特定基因，而用于cell representation \u0026lt;pad\u0026gt;词元用于补长至固定长度M(e.g. 有些情况不考虑表达值为0的基因时) 采用PyTorch embedding layer将投射成D维的Embedding （2）Gene expression\n单细胞的count表达值在不同测序背景的条件下，不具有可比性。 scGPT采用bin分段处理，将单个细胞i的非零基因表达值，分为k个bins，分数分别是1..k。 例如，若基因bin打分为k，表示其表达值处于最高的bin范围内； 每个细胞分bin的阈值标准都会不尽相同。 采用MLP，转换为D维的Embedding （3）Condition token\n记录基因额外的Condition token，例如是否为perturbated genes 采用PyTorch embedding layer将投射成D维的Embedding 综上，一个细胞(i)的初始化输入h (M × D)的计算方式如下图所示。其中第一列通常表示为\u0026lt;cls\u0026gt;作为Cell representation；其它列（除\u0026lt;pad\u0026gt;等特殊字符外，均表示Gene Embedding。\n2.2 自监督训练 （1）Transformer块\nFoundation model主要由 12 (l)个Transformer块组成，每个块则均采用了多头（8）自注意力机制； 由于这里的M通常较大，即一个细胞考虑数千上万个基因（可以理解为特别长的句子），scGPT采用了FlashAttention算法用以加速自注意力计算。\n此外，对于每个细胞，只有表达值非0的基因参与预训练过程，以提高速度。\n作者也推荐了其它高效计算的Transformer变体，包括linear complexity (Linformer)，Kernelized Self-Attention (KSA)。\n（2）自监督任务\nscGPT自监督任务的核心是预测掩码(masked)基因的表达值水平，采用MSE损失函数。 具体分为如下两个子任务： Gene-prompt：基于已知表达值的Gene Embedding，预测未知表达值Gene的expression value； Cell-prompt：基于\u0026lt;cls\u0026gt; cell representation预测全基因的expression value。 然后，将上述两种模式的损失loss相加后，再计算梯度并更新模型参数。 （3）Masked Attention\n自注意计算过程为：将masked gene Embedding( without expression) 作为query，计算与其它known gene Embedding（也包括自己）的注意力权重后，再进行加权运算得到输出； 与GPT模型所处理的文本句不同之处在于：the non-sequential nature of the genes in one cell. 为此作者设计了masked attention注意力计算方式； 如上公式，在不考虑Amask的情况下，为标准的自注意力计算方式。而Amask可参考如下公式，以及下图左A（行表示query，列表示key）理解。每一个query（i）计算与其他词元注意力（包括与它自己）时： 若key （j）不是unknown expression gene，则为0； 若i = j时，且j是unknown expression gene，则为0（自己与自己的注意力计算） 其它情况下，则为负无穷（对应图中的深蓝色单元格） 每一行(i)表示一个query词元与该细胞所有词元的注意力计算。 a = 0表示不产生任何影响，a = -inf表示将query(i)对于key(j)的注意力置换为-inf，经softmax转换后则变为0。 The rule of thumb for scGPT attention masking is to only allow attention computation between embeddings of the ‘known genes’ and the query gene itself.\n在一个cell的全部masked gene表达值预测的过程中，采用多轮（k）迭代预测的思路（如上图右，类比GPT的自回归训练） 在第一轮中，对于所有masked token的预测，将其中1/k个high prediction confidence的token标注为known genes。 然后在新一轮迭代中，重复上一步骤，直至预测出所有的masked token。 值得注意的是，文章并没有说明prediction confidence是如何计算的。个人理解本质还是基于与真实表达值之间的误差。 In each generation iteration, scGPT predicts the gene expression values of a new set of genes, and these genes in turn become the ‘known genes’ in the next iteration for attention computation.\n2.3 多批次与多模态表示 在多批次、多组学合并下游任务中，需要额外的token Embedding以表示必要的批次和组学信息，供模型学习； 但是scGPT在Transformer的pre-train过程中，并未加入相关信息。而是在foundation model的输出结果中再进行拼接操作，即模型在Pre-train后，Fine-tune前引入批次和模态信息，以希望在微调过程中学习到相关信息。 这样做的主要原因是：如果批次和模态信息在输入阶段被引入，Transformer的自注意力机制可能会过度关注同一模态或批次内的特征，导致模型忽略跨模态或批次的重要关联。 This is to prevent the transformer from amplifying the attention within features of the same modalities while underestimating those of different modalities.\nmodality tokens (tm)：表示词元对应的feature是Gene/Protein/Peak中的哪一种； batch tokens (tb)：表示token是否来自一个批次，通常对于细胞来说的。因此一个细胞的batch token都是一样的。 如下公式，表示同时存在多批次以及多组学的情况 如下公式，表示同种组学，存在多批次的情况 3. Fine-tune微调 3.1 细胞类型注释 （1）Method\n对于Foundation model提取的每个细胞Cell Embedding (\u0026lt;cls\u0026gt;) 构建一个MLP分类器，用以预测细胞的类别，并使用交叉熵作为损失函数。\n首先使用一个标注细胞类型的数据集（reference set）进行Fine-tune，然后再使用一个Held-out数据集验证\n输入数据前的预处理：\ncommon set between foundation model and the input data Gene expression: normalization → log1 → bin All gene as input (include zero expression) （2）Result\n在Human pancreas (胰腺) dataset\n对于每种细胞的预测Precision都达到0.8以上 (预测为该细胞类型中，实际为该细胞类型的比例) 以Human immune cells进行fine-tune，预测多发性硬化症(MS)的细胞类型\n平均准确率Accuracy可以达到0.85左右 使用6种肿瘤细胞类型作为fine-tune，预测3种其它肿瘤的细胞类型\n在肿瘤微环境细胞类型预测同样表现良好 与TOSICA、scBERT模型进行了比较，均表现出一定的优势\n此外，作者还提出了Reference mapping注释方法：在Zero/Fine-tune模型时，获得标签细胞类型的Cell Embedding。然后再计算出Query cells的Embedding。最后据此，计算出每个Query cell最相近的Reference cells，从而注释其细胞类型（KNN）。\n3.2 基因扰动预测 （1）Method\n对于Foundation model提取的每个细胞的Gene Embedding，将一部分基因的表达值掩码，从而进行Fine-tune微调训练，并以MSE作为损失函数； 在Perturbation prediction task： Input: Gene expression为Control cell expression, Condition token标注相应位置Gene是否被Perturbate Output: Post-perturbation expression 输入数据前的预处理： only select HVGs for training Log1p expression instead of binned values （output相同） （2）Result\n分别基于三个单细胞CRISPR数据集，比较了scGPT与Linear、GEARS模型的性能表现 Adamson: 87 one-gene perturbations； Replogle: 2823 one-gene perturbations； Norman: 131 two-gene and 105 one-gene perturbations 对于每个数据集，使用一部分的扰动数据进行fine-tune，再对其余unseen gene的扰动数据作为test 评价指标为计算预测与真实的post-perturbation expression的相关性 (基于全部基因，或者是前20个影响最显著的基因) 结果发现scGPT模型相比于其它两种模型，提高了5–20% （3）In silicon reverse perturbation prediction\n简单理解，根据perturbation expression的结果反向预测是最有可能哪个基因被扰动； 参考作者在Github issue （https://github.com/bowang-lab/scGPT/issues/87）的解答： 其Fine-tune步骤其实与上面Perturbation prediction task基本一致； 使用数据集的一部分进行微调后，再预测所有相关基因扰动的表达结果； 最后使用真实的Query perturbation上述的预测结果进行KNN关联分析。 The model was fine-tuned in the same way as in the \u0026ldquo;forward\u0026rdquo; perturbation prediction. It used a subset of the dataset as we illustrated in Figure 3F. The reverse perturbation task utilized the model in a different way. To summarize, the result cell states of all possible perturbations were predicted by the fine-tuned model, and then an actual sequenced cell state can query all the predicted cell states in a nearest neighbor search manner, so that the retrieved neighbors indicate the possible origin perturbations.\n3.3 多批次/组学整合 （1）Method（Multi-batch）\n核心目标：对于多批次的scRNA-seq数据，优化不同批次中每个细胞的cell representation\ncorrect batch effects while preserving biological variance 输入数据的预处理\nCommon set between foundation model and the input data\nGene expression: normalization\u0026ndash;log1\u0026ndash;bin\nAll genes as input (include zero expression)\n如2.3中所述，在微调前，还需要在Foundation model的输出结果中，补充细胞的批次信息。\n具体在Fine-tune训练中，设计了对多个目标函数进行损失计算，以共同用于模型优化\n1）GEP：基因表达预测，参考3.2；\n2）GEPC, Gene expression prediction for cell modeling，即为了优化Cell Embedding(hc)，而预测基因表达。\n3）ECS, Elastic cell similarity：基于一个mini-batch的两个细胞的相似度计算损失函数。使得高于某个阈值的两个细胞更相似，低于的则更远离。\n4）Domain adaptation via reverse back propagation：主要作用是使得生成的cell representation表示经过MLP分类器无法预测其正确的batch信息（类似于GAN 对抗神经网络）。本质上还是建立MLP预测Batch的分类器，但是计算梯度后，进行反向更新参数。\n（2）Result\n基于三个数据集，比较了scGPT与scVI，Seurat，Harmony三个工具去批次的效果\nCOVID-19: 18 batches\nPBMC-10K: 2 batches\nPerirhinal cortex: 2 batches\n评价指标：基于三个指标（NMI/ARI/ASW）的AvgBIO，值越高表明去批次效果越好。\nscGPT均优于其它三种工具的效果。 （3）Multi-omics integration\nMethod\n目标是使得相同细胞类型的不同组学数据能够有相似的Cell Embedding，从而在聚类时比较接近。 scGPT主要考虑了3种组学，分别是scRNA-seq、scATAC-seq，Single-cell proteomics。对此，有两种数据形式： paired setting：一群细胞同时测多种组学 mosaic setting：一群细胞测一种组学，另一群测另一组。 对于scRNA-seq可以直接继承第2节训练的Foundation model，对于其它两组需要重头训练。 在Pre-train之后，如2.3小节需要拼接表示多模态的token（如果涉及多批次，也要添加batch token） Fine-tune 目标函数包括GEP，GEPC（如果涉及多批次，还需要添加DAR） Result\n对于Multiome PBMC (paired)数据集，与scGLUE，Seurat进行了比较，如下图所示\nRNA-seq、ATAC 对于Bone marrow mononuclear cells (paired)数据集，与Seurat进行了比较\nRNA-seq、Protein 9w个细胞，12个donor(multiple batches)，48种细胞类型 对于ASAP human PBMC (mosaic)数据集，与scMoMat进行了比较\n4个批次，3种组学 3.4 基因调控网络构建 （1）Method\n本质上是基于Foundation model或者Fine-tune model提取的Gene Embedding计算两两基因间的相关性，用来构建gene similarity network。\nZero-shot setting模式下，直接使用Foundation model输出的Gene Embedding计算；\nFine-tuned setting模式下，使用特定数据集微调后输出的Gene Embedding计算\n使用integration task进行微调，以学习特定数据集相关的Gene Embedding （下同）\n基于注意力机制的target gene鉴定：Attention map可以反映出基因之间的相互影响。其中，每一列(column)，表示这个gene（列名）对所有query gene的influence。\n使用perturbation datasets可以帮助推测perturbating gene的target，如下图所示\n首先，基于control cell得到的attention map； 然后，基于perturbation expression得到的attention map； 计算上述二者对的差值，可以推测特定基因干扰前后，影响最大的gene （2）Result\n文章首先对zero-shot模式进行了探索，然后在对一个human immune dataset进行了Fine-tune后构建GRN，均发现了具有生物学意义的调控网络以及Gene cluster (Leiden)，并进行了通路富集分析等。 接下来，作者基于Pre-train scGPT blood model，使用了Adamson CRISPR数据集(87 CRISPR inference on leukemia cells)进行了微调。 例如下图，通过比较DDIT3扰动前后的difference attention score, 鉴定了其影响最大的的Top20/100个基因。 4. 模型影响因素 综上，scGPT Foundation model在处理下游分析任务时，相比于其它已有的单细胞工具均表现出明显的优势； 最后，文章讨论了两个可能影响Pre-train model性能表现的因素。 4.1 训练样本量 首先，文章研究了训练样本量对于预训练模型的影响； 如下图，结果发现数据量最多时（从30K到33M），模型在多种下游任务中的表现越好； As larger and more diverse datasets become available, we can anticipate further improvements in model performance, advancing our understanding of cellular processes. 4.2 训练样本类型 文章进一步研究了细胞来源对于模型的影响； 在COVID-19数据集的多批次合并任务中，结果发现： 使用全部33M数据与仅使用Blood数据的Foundation model的性能比较接近； Lung来源的细胞量尽管只有2.1M，远少于Brain细胞量(13.2M)，但前者性能明显表现更优。 This emphasizes the importance of aligning the cellular context in pretraining with the target dataset for superior results in downstream tasks. 后续将参考scGPT工具的教程手册及源代码，学习其构建细节与数据处理方式等。\n","permalink":"https://lishensuo.github.io/en/posts/basic/202%E6%96%87%E7%8C%AE--%E5%8D%95%E7%BB%86%E8%83%9E%E7%BB%84%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B9%8Bscgpt/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e文献\u003c/strong\u003e： scGPT: toward building a foundation model for single-cell multi-omics using generative AI\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e时间\u003c/strong\u003e：2024 Feb. (Published)\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊\u003c/strong\u003e：Nature Method\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.1038/s41592-024-02201-0\u003c/p\u003e","title":"文献--单细胞组学大模型之scGPT"},{"content":"标题: scBERT as a large-scale pretrained deep language model for cell type annotation of single-cell RNA-seq data\n期刊|日期：nature machine intelligence, 2022/09\nDOI：https://doi.org/10.1038/s42256-022-00534-z\n作者：腾讯AI Lab 研究团队\n1. 背景 （1）目前在scRNA-seq研究中，有三种常见的细胞类型注释方法。作者认为都存在一定的缺点。\n基于Marker基因的手动注释：较为主观，marker基因缺少或不准确等 基于Atlas图谱的相关性注释：容易受到批次效应影响 基于有监督学习模型的预测：大部分使用HVG等部分基因建模，忽略全局角度 （2）受NLP领域的BERT模型启发，文章建立了scBERT模型专门用于单细胞数据的细胞类型注释任务。\n预训练：基于数百万单细胞数据得到的预训练模型学习基因间相互作用； 微调：基于参考数据集，学习标注细胞类型相关的基因嵌入表示 2. 建模过程 2.1 输入数据\n表达矩阵预处理包括标准化，log转换，过滤表达基因小于200的细胞。\n一个样本序列是一个细胞1.6w个基因表达情况，采用如下两种方式进行嵌入表示\nExpression embed： 将每个基因的表达值分bin处理为整型后，使用nn.Embedding()提取表示 Gene embed：基于gene2vec工具提取每个基因的高维表示 最后将上述每个基因的上述两种表示相加，得到每个基因最终的200维向量表示\nTips: 上面的Exp embed中相当于把离散化的表达值作为token处理。这与scGPT等将Gene id词汇表作为token处理方式不同。\n2.2 自监督训练\n对每个细胞的15%的非零表达基因进行掩码，然后自监督输出的目的是重构掩码基因的表达。 预训练数据来自Panglao数据库， 包括209个数据集，74个组织，1M个细胞。 scBERT采用了Performer用以高效计算针对长序列的注意力。这里处理的序列长度（Genes）是1.6w。(例如BERT模型处理的序列长度才是512) 10 heads each block， 6 block 尽管如此，文章提供实现的batch size也不大，只有3。\n2.3 微调任务\n基于参考数据集（有标注细胞类型）进行微调，根据细胞基因表达输入，预测其细胞类型。 框架简单来说（参看那边）： 首先引用卷积层将基因的200维特征提取为1维 然后使用MLP将细胞的1.6维基因特征映射为单个值 最后应用softmax分类器，计算交叉熵损失 3. Benchmark 接下来，文章基于获得的预训练模型进行了大量的benchmark工作，说明scBERT模型的优势。\n对比的方法包括如下——\nmarker based : SCINA, Garnett, scSorter correlation based : Seurat, SingleR, CellID, scmap supervised classification : scNym, Scibet 对比的角度包括：\n（1） Intra-dataset：在单个数据集内部进行5折交叉验证。\n（2） Inter-dataset：跨多个相似数据集的应用。例如4个数据集中，数据集为单位的CV。\n（3）其它方面：包括允许对未知细胞类型的预测，以及注意力矩阵的可解释性分析等\n","permalink":"https://lishensuo.github.io/en/posts/basic/203%E6%96%87%E7%8C%AE--%E5%8D%95%E7%BB%86%E8%83%9E%E7%BB%84%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B9%8Bscbert/","summary":"\u003cp\u003e\u003cstrong\u003e标题\u003c/strong\u003e: scBERT as a large-scale pretrained deep language model for cell type annotation of single-cell RNA-seq data\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e期刊|日期\u003c/strong\u003e：nature machine intelligence, 2022/09\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eDOI\u003c/strong\u003e：https://doi.org/10.1038/s42256-022-00534-z\u003c/p\u003e","title":"文献--单细胞组学大模型之scBERT"},{"content":" 标题 CELLPLM: PRE-TRAINING OF CELL LANGUAGE MODEL BEYOND SINGLE CELLS https://openreview.net/forum?id=BKXvPDekud\n发表 ICLR (The International Conference on Learning Representations) 2024\n通讯 Jiliang Tang | Computer science and engineering department | Michigan State University | https://www.cse.msu.edu/~tangjili/\n1. 简介 （1）scRNA-seq data与natural language的区别\nNot sequential → Bag-of-genes (refer to bag-words) Cell-cell communication在细胞状态和发育过程中的重要性 单细胞数据的Quantity与Quality较差 （2）CellPLM模型特点 (single-Cell Pre-trained Language Model)\nCell language model to account for cell-cell relations 预训练过程使用了spatially-resolved transcriptomic (SRT) 空间转录组数据 使用高斯混合分布模型学习细胞的潜在分布空间 To the best of our knowledge, the proposed CellPLM is the first pre-trained transformer framework that encodes inter-cell relations, leverages spatially-resolved transcriptomic data, and adopts a reasonable prior distribution.\n（3）CellPLM模型的核心假设\n对于N个细胞，k个基因的单细胞表达矩阵X ∈ [N, k]\n如下式1，O(i)代表细胞i的 unobserved (masked) genes, U(i) 代表细胞i的 known (unmasked) genes 即细胞i的某一基因表达的条件概率分布(conditional probability distribution)可由同一细胞内其它已知表达的基因推测得到。 Gene tokens → 这在许多现有的单细胞Transformer模型常用（e.g. scBERT, scGPT） 如下式2，M表示unobserved genes from many cells, Mc表示表达矩阵X的补集。 即即预测细胞i的某一基因表达可以同一组织内多个细胞的known genes推测得到 Cell tokens → 这是CellPLM模型的核心假设 2. 预训练 预训练模型分为4个组成部分\n（1）Gene expression embedder (cell level)\n参考词袋模型，将基因信息整合至细胞水平。\n首先对gene token计算初始化的embedding表示 → (gene, embedding)\n然后以细胞的基因表达(cell, gene)分别为系数计算加权和，作为初始化的Cell Expression Embedding (N, d)\n表格矩阵基于Seurat进行了标准的library size normalization and log1p transformation处理。\n一个批次的cells作为一个样本 (N, k)，dataloader一次只迭代一个批次（batch_size = 1）\n（2）Transformer encoder\n首先Transformer的input cell embedding由两部分组成（Cat/Add）。除了上面的Expression Embed，还有Position Embed\n对于SRT数据，position embed由一个FOV (fields of view) 内的细胞二维坐标生成。 对于普通scRNA-seq数据，由于没有相关信息，则通过随机生成进行表示。 然后将上述的合并 Cell embedding输入到Transformer层中\n采用了具有线性复杂度的Flowformer计算注意力。 输出为(N, d) （3）Gaussian mixture latent space\n对注意力编码层的细胞表示(N, d)，使用高斯混合分布模型学习其潜在分布空间 z\n一方面学习得到潜在分布空间(N, z) 另一方面得到的变分重构损失（Latent loss）作为预训练损失的一部分 （4）Batch-aware decoder\n预训练的最终输出是基因表达矩阵(N, k)。在输入到MLP预测前，需要进一步考虑其它因素(Covariates)对于表达量的影响。\nCellPLM考虑的协变量因素包括批次效应/测序平台/数据集 Loss\n最后将细胞的潜在分布空间(z)以及协变量表示(b)合并后，输入到MLP网络，再经自然指数转换后，得到最终输出 (N, k)\n使用NB负二项分布计算对于掩码基因的预测值与真实值之间的差异损失(Target loss)\n最终预训练损失由两部分组成：Latent loss + Target loss，进行反向传播，更新模型。\n预训练模型包含82M参数，对11M细胞数据进行训练，\u0026lt;24 hours via 8 v100 GPUs\nscRNA-seq HTCA (human tumor cell atlas)：4.7M HCA (human cell atlas)：1.4M GEO：2.6M SRT：2.7M 3. 微调训练 基于预训练模型，文章采用了多角度的微调任务，并与其它已有模型做对比，表明CellPLM的优势。\n对于每个微调任务，文章基本都从Downstream Task Datasets，Evaluation Metrics，Baselines，Fine-tuning展开。\nCell-level tasks\nZero shot：直接使用预训练模型，计算细胞的嵌入表示h (可用于聚类分群等) Cell Type Annotation：基于Latent输出的cell embed，连接MLP层预测细胞类型 通过查看仓库代码，上述两种微调任务都是直接使用的Latent layer输出的细胞嵌入表示执行相应任务。\nGene-level tasks\nscRNA-seq denoising：将一部分非零表达基因置换为0后，训练模型预测其原有表达值。\nSpatial Transcriptomic imputation：本质上，也是将一部分基因置换为0， 训练模型预测原有表达值。训练过程中，需要联合scRNA-seq作为Reference数据，帮助训练。\nGenetic perturbation prediction：预测扰动基因表达，关键是如何在输入数据中标记出被扰动的基因\nFor one perturbation, we set the input of perturbed genes to be −100 to mimic the gene perturbation action. 4. 其它方面 （1）消融实验\n通过三个角度的消融实验，说明CellPLM模型component所发挥的作用\n是否采用Mixture of Gaussian 是否采用Latent distribution layers 是否采用Transformer encoder （2）代码借鉴学习\n由于单细胞表达矩阵的稀疏性，torch支持相关高效的处理方式 例如 torch.sparse_csr_tensor，torch.sparse.mm等 通过from abc import ABC, abstractmethod，使得更加容易地实现同一类型，不同变体的模型component 例如 不同的微调 Pipeline 每个模型component都由一个文件夹组成，通过其中__init__.py文件发挥关键作用。 Transformer，VAE等经典模型的实现方式 ","permalink":"https://lishensuo.github.io/en/posts/basic/204%E6%96%87%E7%8C%AE--%E5%8D%95%E7%BB%86%E8%83%9E%E7%BB%84%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B9%8Bcellplm/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e标题\u003c/strong\u003e CELLPLM: PRE-TRAINING OF CELL LANGUAGE MODEL BEYOND SINGLE CELLS \u003ca href=\"https://openreview.net/forum?id=BKXvPDekud\"\u003ehttps://openreview.net/forum?id=BKXvPDekud\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e发表\u003c/strong\u003e ICLR (The International Conference on Learning Representations) 2024\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e通讯\u003c/strong\u003e Jiliang Tang | Computer science and engineering department | Michigan State University | \u003ca href=\"https://www.cse.msu.edu/~tangjili/\"\u003ehttps://www.cse.msu.edu/~tangjili/\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1-简介\"\u003e1. 简介\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e（1）scRNA-seq data与natural language的区别\u003c/strong\u003e\u003c/p\u003e","title":"文献--单细胞组学大模型之CellPLM"},{"content":" Transfer learning enables predictions in network biology | Nature https://doi.org/10.1038/s41586-023-06139-9 Received: March 2022 / Accepted: 27 April 2023 Data \u0026amp; Code: https://huggingface.co/ctheodoris 通讯作者：Patrick T. Ellinor, M.D., Ph.D.\nhttps://www.ellinorlab.org/team/ 1. 预训练模型 1.1 scRNA-seq数据 数据收集：Genecorpus-30M\n561 datasets; 29.9 M cells 数据集详细信息见SP Table-1 数据质控：\nExclude cells with high TMB Exclude cells via total read counts/线粒体 read counts Exclude cells with at least 7 features (7 * 0.15% = 1) Exclude possible doublets and/or damaged cells Select protein coding genes + miRNA Finally：~ 2.5w features of 27.4 M cells 表达值RANK encoding\n先对每个细胞所有基因进行标准化 （10000 library size）；\n再对每个基因在所有细胞进行标准化 （scale factor : non-zero median value）；\n主要原因是不同基因在细胞中 基础表达水平的不同 统计发现 House keeping genes 有较高的scale factor，即标准化后值变小 而Genes like TFs 有较低的scale factor，即标准化后值变大 最后在每个细胞中，将基因按表达由高到低排序RANK。\n1.2 模型架构 Transformer模型直接继承于Hugging face的BertForMaskedLM模型\nConfig参数\n6 layers with each 4 heads gene embedding 256 (ffn: 512) max cell sentence length 2048 (dynamic padding)，masked feature ratio: 15% 训练参数\nlr 0.001， linear warmup 10k steps Relu，Dropout 0.2， Adam with 0.001 weight decay Batch size 12， Epoch 3 12 V100 GPU (from 3 nodes), DeepSpeed 分布式训练，3 Days 1.3 预训练效果 在具体介绍微调任务前，文章首先论述了其预训练模型的可应用性\nGene embedding\nNot affect by common batch-dependent technical artefacts 同一基因在不同Batch因素的Cosine相似度高 Context awareness 人为地将Fibroblast的OSKM基因Rank提高 (In silico activation)，使得其它基因的Embedding向iPSC状态变化。 iPSC, induced Pluripotent Stem Cells: 已经分化的体细胞通过导入特定的转录因子重新编程而成的一种细胞类型\nOSKM: 四个关键的基因重编程因子: Oct4 , Sox2 , Klf4 , c-Myc\nCell embedding (Cell embedding取每个细胞所有基因的Embedding的均值)\nBatch integration: cell cluster by cell type, not sample or platform 细胞类型注释微调任务：对比了两种已发表方法：CasTLe (XGBoost), scDeepSort 2. 微调任务 多为Gene classification/Cell classification任务，（详见SP Table2， 每个fine-tune task会freeze diff number of layers） AUC， F1 score 5折交叉验证 所有微调任务都使用相同的超参数组合，以说明预训练模型的性能。 lr 0.00005，linear warmup 500，Adamw weight decay 0.001 batch size 12，epoch 1 to avoid overfitting It should be noted that hyperparameter tuning (超参数调优) for deep learning applications can generally significantly enhance learning effect. 但是文章中并没有这么做，表明后面微调模型性能都是underestimate。\n2.1 Gene dosage sensitivity 基因对剂量的变化的高敏感性，即其少量表达变化可能引发显著的细胞或生物学后果。\n目的：预测基因(TF)是否为剂量敏感性的TF 数据：一方面收集来自已报道的阴性或阳性标签数据，另一方面，使用30M中随机的10K的细胞作为训练数据。 结果：交叉验证的AUC 0.91，并在一个基于CNV的外部测试集数据也表现很好（微调数据与标签来源数据越接近，则效果越好）。 In silico deleting(knockout): 在预训练模型中，模拟敲除心肌细胞的一个心脏疾病相关基因，使得cell Embedding发生较大改变（与敲除前的cell embedding similarity） 发现并验证了一个靶点 TEAD4 相关Genelist做通路富集分析 Smaller cosine similarity indicates more deleterious effect\n2.2 Chromatin dynamics 同一个基因的启动子区域能同时携带 H3K4me3 活跃信号 和 H3K27me3抑制信号 的修饰，这种情况被称为“双价域”（bivalent domains），常见于胚胎干细胞(ESC)中。\n目的：鉴别基因是否为双价修饰基因 or 非甲基化启动子基因或仅带有 H3K4me3 的基因 数据：一方面收集56个保守区域的标签数据，一方面取15K个 ESC作为训练数据 结果：AUC可以达到0.93 (bivalent vs unmethylated gene), 0.88 (bivalent vs H3K4me3-only) 衍生任务：预测long- versus short-range transcription factors 2.3 Network dynamics predictions NOTCH1 是一个跨膜受体，在多种细胞类型中起关键作用，特别是在细胞命运决定、分化、增殖和凋亡等过程中。先前研究表明NOTCH1(N1)调控网络在心脏瓣膜疾病发挥重要作用。\n目的：区分N1基因网络中的核心基因与外周基因 数据：标签数据来自先前研究报道，使用30K心脏内皮细胞作为微调数据 结果：AUC = 0.81 衍生分析：探索出最少需要多少微调训练数据（细胞量）可以达到良好的预测效果（884） 3. 模型深入分析 3.1 Network Hierarchy 即对于预训练Transformer，Attention weight的注意力权重分析。\n6 layers, each 4 heads 都纳入考虑，每个预训练细胞的基因都有unique attention map \u0026gt; 20% heads ，TF genes have higher attention Genes with high rank have higher attention Early / Late layers also show diff patterns 3.2 TF Gene Network 方法类似2.1的In silico deletion，不过这里是为了发现转录因子（GATA4）的靶基因。\n即计算GATA4删除后，其余基因的Embedding与未删除前的Embedding的相似度。越低表明被该TF影响的可能越高。\n结果发现，先前报道具有高置信度的GATA4靶点，确实表现出更低的Cosine similarity。\n衍生分析发现也可以同时删除两个TF genes\n3.3 Therapeutic Target hypertrophic cardiomyopathy, HCM: 肥厚型心肌病；\ndilated cardiomyopathy, DCM: 扩张型心肌病\n首先，微调两个模型，分别区分来自正常心脏和上述两种心肌病的心肌细胞。\n“Normal”→“Disease”：Genes whose deletion or activation in normal status make cell embedding shift towards HCM/DCM.\n**Disease genes **\u0026ndash; 通路富集分析 “Disease”→“Normal”：Genes whose deletion or activation in disease status make cell embedding shift towards normal cells.\nTherapeutic targets \u0026ndash; 通路富集分析 最后，对部分靶点进行实验验证 In silico deletion: remove the gene from the rank value of one cell\nIn silico activation: move the gene to the front of the rank value of one cell\n","permalink":"https://lishensuo.github.io/en/posts/basic/205%E6%96%87%E7%8C%AE--%E5%8D%95%E7%BB%86%E8%83%9E%E7%BB%84%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B9%8Bgeneformer/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cem\u003eTransfer learning enables predictions in network biology\u003c/em\u003e | Nature\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://doi.org/10.1038/s41586-023-06139-9\"\u003ehttps://doi.org/10.1038/s41586-023-06139-9\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eReceived: March 2022 / Accepted: 27 April 2023\u003c/li\u003e\n\u003cli\u003eData \u0026amp; Code: \u003ca href=\"https://huggingface.co/ctheodoris\"\u003ehttps://huggingface.co/ctheodoris\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e通讯作者\u003c/strong\u003e：Patrick T. Ellinor, M.D., Ph.D.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.ellinorlab.org/team/\"\u003ehttps://www.ellinorlab.org/team/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20241215164105420.png\" alt=\"image-20241215164105420\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"1-预训练模型\"\u003e1. 预训练模型\u003c/h1\u003e\n\u003ch2 id=\"11-scrna-seq数据\"\u003e1.1 scRNA-seq数据\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e数据收集\u003c/strong\u003e：Genecorpus-30M\u003c/p\u003e","title":"文献--单细胞组学大模型之Geneformer"},{"content":" GeneCompass: deciphering universal gene regulatory mechanisms with a knowledge-informed cross-species foundation model\nCell research | 2024.10\nhttps://doi.org/10.1038/s41422-024-01034-y\nhttps://github.com/xCompass-AI/GeneCompass\n(最后)通讯作者 Xin Li\n0. 模型预训练 0.1 数据规模 初始收集126M，经QC后，101M细胞用于训练(53M 人源 / 48M鼠源) [详见原文/Table S1， PS: 觉得其中一个描述有点问题]\n包括了正常细胞以及disease cells/cancer cells/immortalize cell lines\n词汇表包括36092个基因，其中17465个为人/鼠同源基因，其余species-specific基因使用Ensembl ID\n0.2 模型框架\n输入数据：每个细胞样本由2048个基因（Token）组成 Token Embedding：将Gene ID，Expression Value，以及四种基因先验知识(promoter/GRN/gene family/co-expression)拼接在一起，再投射到768维 Position Embedding表示每个基因的RANK位置，与上述进行矩阵加法 一个特殊的token，用于标记物种类型[推测应该是指cls标记] 存疑：Method并没有提到基因表达的标准化方式。Gene value与Position rank某种程度上是不是信息重复了\nTransformer\nL =12; H = 12; D = 768 （参数量\u0026gt;100M） 两个自监督任务：预测掩码基因的Expression（MSE loss）与ID (Cross-entropy loss) Train config\nBatch=10 LR = 0.00005, Warm-up=10000 3 Epochs (直至loss不再降低|并没有设置验证集，Geneformer也没有) Cost 9 days using 4×8 A800 GPUs 小规模的消融实验\n数据：human cells (55M) 模型： L = 6; H = 4; D = 256 比较是否加入先验知识对模型的下游任务影响 1. Gene embedding 初步探索 跨物种的同源基因的相似度较高（相比同物种的不同基因）； 贡献：Attention \u0026gt; Prior knowledge 模拟基因(GATA4/TBX5)敲除会显著影响其直接靶基因的状态。 模拟敲除转录因子，观察其靶基因 不同物种观察到相似的结果 In silico perturbation refer to scGPT(基于注意力) 2. Cell embedding 细胞注释 下游的细胞注释效果越好 预训练细胞量越多； 结合跨物种数据由于单物种数据 12注意力层优于6注意力 优于其它类型模型 GeneCompass without pretraining TOSICA Geneformer 作为CAME（一个图神经网络，用于跨物种细胞类型注释）的初始输入，可以增强其最终的预测效果 ​\n3. 基于Gene Embedding的衍生任务 3.1 GRN推断 根据Gene Embedding的相似度得到邻接矩阵，作为DeepSEM模型的输入 效果优于来自Geneformer、scGPT的Gene Embedding，以及vanilla DeepSEM 3.2 Drug Response预测 预测基因在不同种类和浓度扰动条件下的表达情况 分别用GeneCompass，Geneformer，scGPT计算的Gene Embedding替换CPA(单基因预测/drug dose response prediction)、DeepCE(全基因预测/gene expression profiling)的初始输入。Genecompass均能取得较好的结果。[药物扰动] 3.3 Dosage-Sensitive Gene预测 基于Gene Embdding的二分类微调任务 效果优于Geneformer，以及没有预训练的Genecompass 4. 基因扰动预测 预测特定基因突变条件下，其余基因表达的变化情况 基于GEARS框架，将Genecompass的Gene Embedding替换GEARS原有的基于共表达的Gene Embedding表示，观察到性能有明显提升。 5. ISP (In silico perturbation) 验证性分析\n过表达OSKM使得成纤维细胞向iPSC状态变化 敲除维持干性的转录因子(Zbtb11, Zfp131)，使得鼠源胚胎干细胞向内胚层变化。 筛选应用\n逐一过表达ESC细胞的基因，筛选可以将ESC向Progenitor (前体细胞)或者更加成熟的Leydig (激素分泌细胞)状态变化的调控因子。取二者的交集，最终发现了5个。 通过湿实验/测序，证实了其中NR5A1与GATA4的效果 ","permalink":"https://lishensuo.github.io/en/posts/basic/206%E6%96%87%E7%8C%AE--%E5%8D%95%E7%BB%86%E8%83%9E%E7%BB%84%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B9%8Bgenecompass/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eGeneCompass: deciphering universal gene regulatory mechanisms with a knowledge-informed cross-species foundation model\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cem\u003eCell research | 2024.10\u003c/em\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href=\"https://doi.org/10.1038/s41422-024-01034-y\"\u003ehttps://doi.org/10.1038/s41422-024-01034-y\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/xCompass-AI/GeneCompass\"\u003ehttps://github.com/xCompass-AI/GeneCompass\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e(最后)通讯作者\u003c/strong\u003e Xin Li\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20250112124344122.png\" alt=\"image-20250112124344122\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20250112123919615.png\" alt=\"image-20250112123919615\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"0-模型预训练\"\u003e0. 模型预训练\u003c/h1\u003e\n\u003ch2 id=\"01-数据规模\"\u003e0.1 数据规模\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e初始收集126M，经QC后，101M细胞用于训练(53M 人源 / 48M鼠源) [详见原文/Table S1， PS: 觉得其中一个描述有点问题]\u003c/p\u003e","title":"文献--单细胞组学大模型之Genecompass"},{"content":" Quantized multi-task learning for context-specific representations of gene network dynamics 2024.8.19, bioRxiv 【预印本】 https://doi.org/10.1101/2024.08.16.608180 通讯作者：Christina Theodoris （2021 Geneformer的一作，现在应该是独立的PI了）\nhttps://gladstone.org/people/christina-theodoris\n背景知识 算法角度\nMulti-task learning 多任务学习 设置多个任务，每个任务会计算一个独立的损失函数，总损失函数则是所有任务损失的加权和。 训练过程中，共享预训练模型参数，微调模型参数各不相同。 multi-task learning enables context-specific disease modeling that can yield contextual predictions of candidate therapeutic targets for human disease. Continual learning 持续学习 机器学习模型在不断接收新任务或新数据时，能够持续学习和更新其知识。分为三类：Class/Task/Domain incremental continual learning 挑战：catastrophic forgetting https://neptune.ai/blog/continual-learning-methods-and-application 性能角度- QLoRA: Quantization | Low-Rank Adapters\nModel Quantization 模型量化 ：4-bit字节压缩预训练模型 https://huggingface.co/docs/transformers/main_classes/quantization https://huggingface.co/blog/4bit-transformers-bitsandbytes Low-Rank Adapters 低秩适配器 微调部分的参数层通过LoRA低秩矩阵分解降低需要更新参数量 微调/推理过程 Resource-efficient 1. 第一次预训练 数据量：~103M human scRNA-seq\n经质控筛选(e.g. 去除肿瘤细胞)后，保留95M 词汇表：20275 (1) 20271 protein coding genes; (2) 4 special tokens (PAD, MASK, CLS, EOS ) 模型框架（gf-12L-95M-i4096）\n最大序列长度：4096，此外在有效序列的前后增加了CLS与EOS 注意力层：12 | Embedding size: 512 | Heads: 8 Masked ratio: 15% | 最大学习率：5e-4 (warmup steps 5000) | Batch: 1 (梯度累计：4) 44 hours, 8 H100 GPUs 还有4个版本：GF-6L-30M-I2048, GF-12L-30M-I2048, GF-12L-95M-I2048, GF-20L95M-I4096 Zero-shot性能：基于上述预训练模型获得cell/gene的zero-shot Embedding（不更新模型参数），相比Geneformer v1在多个微调任务中表现具有优势。\n值得一提的是：这里的cell embedding是来自倒数第二层的CLS Embedding，后面的MTL以及ISP，都是来自最后一层的CLS Embedding 在Geneformer V1版本中， Cell Embedding是所有基因Embedding的均值。 微调性能结果是基于25次超参数寻参得到的（例如不同的学习率等） 模型量化：使用量化模型（e.g. 4-bit, rank16）可以使得微调任务性能影响不大的情况下，显著降低了成本（时间，内存）。 full fine-tuning：超参数包括被冻结的层数，top 0/7/14 layers quantized fine-tuning：同上 zero-shot (指上面的结果) 2. 多任务微调学习 背景：疾病的发生过程可能与多个角度相关（例如cell type, tissue, developmental stage..）。基于单任务学习（例如Geneformer v1基于细胞类型）得到的cell/gene表示，缺少全面性，尤其是应用在ISP 数据量：~43M annotated cells from CELLxGENE， 71 cell types，38 tissues，68 diseases， 3 developmental stages MTL设计：5个细胞分类微调任务的损失之和作为总损失更新模型 cell types/tissue/disease types/disease vs normal/developmental stage 在每个任务的类别存在不平衡时，采用多种采样策略【详见method】 最终发现在5个任务中均表现良好，此时得到的cell Embedding更具有代表性（用于后续的ISP） 基于微调后的MTL模型，采用量化技术得到的cell embedding信息没有丢失，同时推理成本较低。 在ISP方面，量化模型的基因模拟敲除所发生的shift趋势相同，同样成本降低 3. 第二次预训练及对应微调 Domain-specific continual learning：肿瘤单细胞特征 数据量： ~14M cells from cancer studies 包括1%的第一阶段训练数据，以避免 \u0026ldquo;catastrophic forgetting\u0026rdquo; 训练方式与第一阶段相同，采用15% masked gene的自监督学习。其中包括三种学习率的设置方式。 如下图b，左侧绿线表示第一次预训练的学习率变；而右侧三条线便是3种学习率设置方案的continual learning 结合图c，发现其中最优的一种方案（是与第一次的预训练最大学习率相同） 接下来继续对上述预训练模型，设计一个MTL细胞分类微调任务： 在结直肠癌单细胞数据下的3个任务：MMR status/cell type/cell subtype 发现在cell subtype存在上皮细胞的亚型注释时，二次预训练模型表现更好 4. 基于TME的ISP实验 基于上述的微调模型，进行了两次结直肠癌相关的ISP实验\nTASK-1：\nIn silico overexpression from epithelial cancer cells to normal epithelial (下图的e-f) TASK-2：\nIn silico overexpression from quiescent T cell to activated T cell state 与已报道的CRISPR结果相一致 ","permalink":"https://lishensuo.github.io/en/posts/basic/207%E6%96%87%E7%8C%AE--%E5%8D%95%E7%BB%86%E8%83%9E%E7%BB%84%E5%AD%A6%E5%A4%A7%E6%A8%A1%E5%9E%8B%E4%B9%8Bgeneformer-v2%E9%A2%84%E5%8D%B0%E6%9C%AC/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003eQuantized multi-task learning for context-specific representations of gene network dynamics\u003c/li\u003e\n\u003cli\u003e2024.8.19, bioRxiv 【预印本】\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://doi.org/10.1101/2024.08.16.608180\"\u003ehttps://doi.org/10.1101/2024.08.16.608180\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e通讯作者\u003c/strong\u003e：Christina Theodoris （2021 Geneformer的一作，现在应该是独立的PI了）\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://gladstone.org/people/christina-theodoris\"\u003ehttps://gladstone.org/people/christina-theodoris\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20250118123335727.png\" alt=\"image-20250118123335727\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"背景知识\"\u003e背景知识\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e算法角度\u003c/strong\u003e\u003c/p\u003e","title":"文献--单细胞组学大模型之Geneformer V2[预印本]"},{"content":" 1 2 3 4 5 6 7 8 9 library(tidyverse) # -- Attaching packages ----------------------------------------------------- tidyverse 1.3.1 -- # √ ggplot2 3.3.5 √ purrr 0.3.4 # √ tibble 3.1.2 √ dplyr 1.0.7 # √ tidyr 1.1.3 √ stringr 1.4.0 # √ readr 2.0.0 √ forcats 0.5.1 # -- Conflicts -------------------------------------------------------- tidyverse_conflicts() -- # x dplyr::filter() masks stats::filter() # x dplyr::lag() masks stats::lag() 1、表格筛选 1.1 select 筛选列 col1:col3 选取起止范围的列；\n!c(col1, col2) 删除列；\neverything() 取所有列；\nlast_col() 获取最后一行；\nstarts_with()、ends_with()、contains()、matches 匹配具有特征列名的列；\nall_of、any_of、where 匹配具有特征列值的列。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 data(mtcars) mtcars=mtcars[1:6,] # mpg cyl disp hp drat wt qsec vs am gear carb # Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 # Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 # Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 # Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 # Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 # Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 mtcars %\u0026gt;% select(mpg) #单列 mtcars %\u0026gt;% select(\u0026#34;mpg\u0026#34;) #字符串列名(非必要) mtcars %\u0026gt;% select(mpg:hp) #多列 mtcars %\u0026gt;% select(last_col(1)) #倒数第二列 mtcars %\u0026gt;% select(!c(mpg, am)) #反选 mtcars %\u0026gt;% select(starts_with(\u0026#34;c\u0026#34;)) #列名以p开头的 mtcars %\u0026gt;% select(where(is.numeric)) #数值列 mtcars %\u0026gt;% select(where(function(x) max(x)\u0026gt;100)) #最大值大于200的列 mtcars %\u0026gt;% select(hp, everything()) #把指定列放在第一列 1.2 选择行 1.2.1 filter定义条件筛选行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##(1)全局筛选 data(mtcars) mtcars %\u0026gt;% filter(gear == 3) mtcars %\u0026gt;% filter(gear == 3 \u0026amp; disp \u0026gt; 200) #与 mtcars %\u0026gt;% filter(gear == 3 | disp \u0026gt; 200) #或 ##当使用变量名代替列名时 test=\u0026#34;gear\u0026#34; mtcars %\u0026gt;% filter(.data[[test]] == 3) ##(2)分组筛选：搭配group_by() mtcars %\u0026gt;% group_by(vs) %\u0026gt;% filter(disp == max(disp)) #筛选按 vs 分组里，disp的最大值 mtcars %\u0026gt;% group_by(vs) %\u0026gt;% filter(disp \u0026gt; mean(disp)) #筛选按 vs 分组里，disp 里的大于均值水平的。 1.2.2 slice系列方法选择行 slice() 按行索引取\nslice_min(), slice_max() 按列值大小取最值行\nslice_sample() 随机抽取行\n1 2 3 4 5 6 7 8 9 10 11 mtcars mtcars %\u0026gt;% slice(1) mtcars %\u0026gt;% slice(30:n()) mtcars %\u0026gt;% slice_max(mpg, n=5) mtcars %\u0026gt;% slice_max(mpg, prop = 0.2) mtcars %\u0026gt;% slice_sample(n = 5) mtcars %\u0026gt;% slice_sample(n = 5, weight_by = wt) ##同样可以搭配group_by()分组操作 1.2.3 distinct去重复行 1 2 3 4 5 6 7 8 9 #共有2列10行，列内容均由1、2、3组成 df \u0026lt;- tibble( x = sample(3, 10, rep = TRUE), y = sample(3, 10, rep = TRUE) ) df %\u0026gt;% distinct() #去除完全相同行 distinct(df, x, .keep_all=T) #将某一列去重复 df %\u0026gt;% group_by(x) %\u0026gt;% distinct(y, .keep_all=T) #分组去重 1.2.4 count统计频数 1 2 3 4 5 data(mtcars) data(mtcars) mtcars %\u0026gt;% count(cyl) #返回cyl频数表 mtcars %\u0026gt;% count(cyl, vs) #两个分组变量组合频数 mtcars %\u0026gt;% add_count(cyl) #在原有表格基础上增添一列，为相应level的counts总数 2、summarise表格统计 mean(),median\nsd(),mad()\nmin(),max(),quantile()\nn、n_distinct 分别表示统计行数，与非重复行数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ##(1)全局统计 mtcars %\u0026gt;% summarise(mean_disp = mean(disp)) mtcars %\u0026gt;% summarise(mean_disp = min(disp), n = n(), n_gear = n_distinct(gear), test = sd(.data[[\u0026#34;mpg\u0026#34;]])) #字符串变量名 ##(2)分组统计:搭配group_by() mtcars %\u0026gt;% group_by(cyl) %\u0026gt;% summarise(mean = mean(disp), n = n()) ##(3)分组多列统计:搭配group_by()、across() mtcars %\u0026gt;% group_by(cyl) %\u0026gt;% summarise(across(c(wt,qsec,mpg), median, .names = \u0026#34;median_{.col}\u0026#34;)) 3、mutate修改/创建列 mutate()会在原有表格基础上修改/新增列\ntransmute()仅返回修改或者新增的列\n3.1 修改列 1 2 3 4 5 data(mtcars) mtcars=mtcars[1:6,] mtcars %\u0026gt;% mutate(wt = wt+10) #指定单列运算 mtcars %\u0026gt;% mutate(across(c(mpg,disp), ~ (.x)^2)) #指定多列运算 mtcars %\u0026gt;% mutate(across(where(is.numeric), as.integer)) #所有数值列改为整数 3.2 新增列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data(mtcars) mtcars=mtcars[1:6,] mtcars %\u0026gt;% mutate(wt_new = wt+10) mtcars %\u0026gt;% mutate(wt_new = wt+10, .before = 1) #新增的列在第1列 mtcars %\u0026gt;% mutate(wt_new = wt+10, .after = wt) #新增的列放在wt列的后面 ##使用动态变量名命名新建的列 test=\u0026#34;new\u0026#34; mtcars %\u0026gt;% mutate(\u0026#39;{test}\u0026#39; := 1) ##(1) 根据数值列新增rank列 x \u0026lt;- c(1,2,2,3,4) rank(x) #相同数取平均秩 # [1] 1.0 2.5 2.5 4.0 5.0 row_number(x) #相同数，排在前面的排名高 # [1] 1 2 3 4 5 min_rank(x) #有相同排名，会有gap的情况 # [1] 1 2 2 4 5 dense_rank(x) #有相同排名，没有gap的情况 # 1] 1 2 2 3 4 mtcars %\u0026gt;% mutate(mpg_rank = min_rank(mpg)) mtcars %\u0026gt;% mutate(mpg_rank = min_rank(-1*mpg)) ##(2)case_when新增层级编码列 mtcars %\u0026gt;% mutate(mpg_grade = case_when(mpg \u0026lt;= 20 ~ \u0026#34;C\u0026#34;, mpg \u0026lt;= 22 ~ \u0026#34;B\u0026#34;, TRUE ~ \u0026#34;A\u0026#34;)) 4、arrange表格排序 1 2 3 4 5 6 7 8 mtcars %\u0026gt;% arrange(disp) #desc升序排列 mtcars %\u0026gt;% arrange(desc(disp)) #desc降序排列 arrange(mtcars, carb, disp) #先按carb升序排列，再按disp升序排列 ##分组排序 mtcars %\u0026gt;% group_by(cyl) %\u0026gt;% arrange(mpg) 5、关于表格的列名/行名 rename: 修改列名 1 2 3 4 5 6 #修改列名 mtcars %\u0026gt;% rename(mpg_new=mpg, cyl_new=cyl) #使用变量修改列名 test=\u0026#34;new\u0026#34; mtcars %\u0026gt;% rename(\u0026#39;{test}\u0026#39;:=mpg) rownames_to_column、column_to_rownames行名与列的转换 1 2 3 4 5 6 7 8 9 mtcars %\u0026gt;% head #行名变为列 rownames_to_column(mtcars, var = \u0026#34;car\u0026#34;) %\u0026gt;% head mtcars %\u0026gt;% rownames_to_column(var = \u0026#34;car\u0026#34;) %\u0026gt;% head mtcars %\u0026gt;% rownames_to_column(var = \u0026#34;car\u0026#34;) %\u0026gt;% #指定列变为行名 column_to_rownames(var = \u0026#34;car\u0026#34;) %\u0026gt;% head 6、两个表格合并 示例表格数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 df1 \u0026lt;- data.frame(x1 = c(1, 2, 3, 4, 5, 6), y1 = c(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;)) # x1 y1 # 1 1 a # 2 2 b # 3 3 c # 4 4 d # 5 5 e # 6 6 f df2 \u0026lt;- data.frame(x2 = c(1, 2, 3, 4, 5, 6), y2 = c(\u0026#34;q\u0026#34;, \u0026#34;w\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;r\u0026#34;,\u0026#34;t\u0026#34;,\u0026#34;y\u0026#34;)) # x2 y2 # 1 1 q # 2 2 w # 3 3 e # 4 4 r # 5 5 t # 6 6 y df3 \u0026lt;- data.frame(x3 = c( 2, 4, 5, 6), y3 = c( \u0026#34;a\u0026#34;, \u0026#34;s\u0026#34;, \u0026#34;d\u0026#34;,\u0026#34;f\u0026#34;)) # x3 y3 # 1 2 a # 2 4 s # 3 5 d # 4 6 f 根据不同的分析目的，有多种合并方法~\n6.1 inner_join 取交集，即保留同时在两个表中的观测 1 2 3 4 5 6 # merge(df1, df3, by.x = \u0026#34;y1\u0026#34;, by.y = \u0026#34;y3\u0026#34;) inner_join(df1, df3, by=c(\u0026#34;y1\u0026#34;=\u0026#34;y3\u0026#34;)) # x1 y1 x3 # 1 1 a 2 # 2 4 d 5 # 3 6 f 6 注意：如果这两个列的名相同，合并时直接交代行名即可，例如inner_join(df1_1, df3_1, by=\u0026quot;y\u0026quot;)，merge(df1_1, df3_1, by = \u0026quot;y\u0026quot;),下同~\n6.2 left_join 左连接\u0026ndash;保留左边表格的所有观测，缺失值用NA值代替 1 2 3 4 5 6 7 8 9 # merge(df1, df3, by.x = \u0026#34;y1\u0026#34;, by.y = \u0026#34;y3\u0026#34;, all.x = T) left_join(df1, df3, by=c(\u0026#34;y1\u0026#34;=\u0026#34;y3\u0026#34;)) # x1 y1 x3 # 1 1 a 2 # 2 2 b NA # 3 3 c NA # 4 4 d 5 # 5 5 e NA # 6 6 f 6 6.3 right_join 右连接\u0026ndash;保留右边表格的所有观测，缺失值用NA值代替 1 2 3 4 5 6 7 8 9 # merge(df1, df2, by.x = \u0026#34;y1\u0026#34;, by.y = \u0026#34;y2\u0026#34;, all.y = T) right_join(df1, df2, by=c(\u0026#34;y1\u0026#34;=\u0026#34;y2\u0026#34;)) # x1 y1 x2 # 1 5 e 3 # 2 NA q 1 # 3 NA w 2 # 4 NA r 4 # 5 NA t 5 # 6 NA y 6 6.4 full_join 外连接\u0026ndash;保留两个表格里的所有观测，缺失值用NA值代替 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # merge(df1, df2, by.x = \u0026#34;y1\u0026#34;, by.y = \u0026#34;y2\u0026#34;, all.x = T, all.y = T) full_join(df1, df2, by=c(\u0026#34;y1\u0026#34;=\u0026#34;y2\u0026#34;)) # x1 y1 x2 # 1 1 a NA # 2 2 b NA # 3 3 c NA # 4 4 d NA # 5 5 e 3 # 6 6 f NA # 7 NA q 1 # 8 NA w 2 # 9 NA r 4 # 10 NA t 5 # 11 NA y 6 补充tidyr separate_rows: 将一行的内容按特定分隔符拆分为多行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 df \u0026lt;- data.frame( x = 1:3, y = c(\u0026#34;a\u0026#34;, \u0026#34;d,e,f\u0026#34;, \u0026#34;g,h\u0026#34;) ) # x y # 1 1 a # 2 2 d,e,f # 3 3 g,h df %\u0026gt;% tidyr::separate_rows(y, sep = \u0026#34;,\u0026#34;) # x y # \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; # 1 1 a # 2 2 d # 3 2 e # 4 2 f # 5 3 g # 6 3 h ","permalink":"https://lishensuo.github.io/en/posts/program/210r-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-dplyr%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -- Attaching packages ----------------------------------------------------- tidyverse 1.3.1 --\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# √ ggplot2 3.3.5     √ purrr   0.3.4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# √ tibble  3.1.2     √ dplyr   1.0.7\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# √ tidyr   1.1.3     √ stringr 1.4.0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# √ readr   2.0.0     √ forcats 0.5.1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -- Conflicts -------------------------------------------------------- tidyverse_conflicts() --\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# x dplyr::filter() masks stats::filter()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# x dplyr::lag()    masks stats::lag()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1表格筛选\"\u003e1、表格筛选\u003c/h1\u003e\n\u003ch2 id=\"11-select-筛选列\"\u003e1.1 select 筛选列\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ecol1:col3\u003c/code\u003e  选取起止范围的列；\u003c/p\u003e","title":"R-数据分析-dplyr表格操作"},{"content":"\r1 2 library(tidyverse) library(reshape2) 1、matrix 1 2 3 4 5 6 7 8 9 10 11 12 set.seed(123) scores_mt = matrix(round(rnorm(40, mean = 80, sd=10)), nrow = 10, ncol = 4, dimnames = list(paste0(\u0026#34;Stu\u0026#34;,1:10), paste0(\u0026#34;Subject-\u0026#34;,LETTERS[1:4]))) class(scores_mt) # [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34; head(scores_mt) # Subject-A Subject-B Subject-C Subject-D # Stu1 74 92 69 84 # Stu2 78 84 78 77 # Stu3 96 84 70 89 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##(1) 宽变长 reshaped = melt(scores, value.name = \u0026#34;Score\u0026#34;) head(reshaped) # Var1 Var2 Score # 1 Stu1 Subject-A 74 # 2 Stu2 Subject-A 78 # 3 Stu3 Subject-A 96 ## Var1 --- rownames ## Var2 --- colnames ##(2) 长变宽（还原） reshaped %\u0026gt;% dcast(Var1 ~ Var2) %\u0026gt;% head() # Var1 Subject-A Subject-B Subject-C Subject-D # 1 Stu1 74 92 69 84 # 2 Stu2 78 84 78 77 # 3 Stu3 96 84 70 89 2、data.frame 2.1 简单 1 2 3 4 5 6 7 8 9 10 scores_df = scores_mt %\u0026gt;% as.data.frame() %\u0026gt;% tibble::rownames_to_column(\u0026#34;Name\u0026#34;) class(scores_df) # [1] \u0026#34;data.frame\u0026#34; head(scores_df) # Name Subject-A Subject-B Subject-C Subject-D # 1 Stu1 74 92 69 84 # 2 Stu2 78 84 78 77 # 3 Stu3 96 84 70 89 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ##(1) 宽变长 reshaped = scores_df %\u0026gt;% melt(id=\u0026#34;Name\u0026#34;, variable.name=\u0026#34;Subject\u0026#34;, value.name = \u0026#34;Score\u0026#34;) head(reshaped) # Name Subject Score # 1 Stu1 Subject-A 74 # 2 Stu2 Subject-A 78 # 3 Stu3 Subject-A 96 ##(2) 长变宽（还原） reshaped %\u0026gt;% dcast(Name ~ Subject, value.var = \u0026#34;Score\u0026#34;) %\u0026gt;% head() # Name Subject-A Subject-B Subject-C Subject-D # 1 Stu1 74 92 69 84 # 2 Stu10 76 75 93 76 # 3 Stu2 78 84 78 77 2.2 复杂 1 2 3 4 5 6 7 8 scores_df_Anno = scores_df %\u0026gt;% dplyr::mutate(Class=paste0(\u0026#34;Class\u0026#34;,rep(c(\u0026#34;01\u0026#34;,\u0026#34;02\u0026#34;), 5)), Age=round(rnorm(10, 20, 1)), .before=2) head(scores_df_Anno) # Name Class Age Subject-A Subject-B Subject-C Subject-D # 1 Stu1 Class01 20 74 92 69 84 # 2 Stu2 Class02 20 78 84 78 77 # 3 Stu3 Class01 20 96 84 70 89 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##(1) 宽变长 reshaped = scores_df_Anno %\u0026gt;% melt(id=c(\u0026#34;Name\u0026#34;,\u0026#34;Class\u0026#34;,\u0026#34;Age\u0026#34;), variable.name=\u0026#34;Subject\u0026#34;, value.name = \u0026#34;Score\u0026#34;) head(reshaped) # Name Class Age Subject Score # 1 Stu1 Class01 20 Subject-A 74 # 2 Stu2 Class02 20 Subject-A 78 # 3 Stu3 Class01 20 Subject-A 96 ##(2) 长变宽（还原） reshaped %\u0026gt;% dcast(Name + Class + Age ~ Subject, value.var = \u0026#34;Score\u0026#34;) %\u0026gt;% head() # Name Class Age Subject-A Subject-B Subject-C Subject-D # 1 Stu1 Class01 20 74 92 69 84 # 2 Stu10 Class02 21 76 75 93 76 # 3 Stu2 Class02 20 78 84 78 77 3、list 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 scores_list = list(Stu1=c(1,2), Stu2=c(3,4), Stu3=c(5,6)) # $Stu1 # [1] 1 2 # # $Stu2 # [1] 3 4 # # $Stu3 # [1] 5 6 melt(scores_list) # value L1 # 1 1 Stu1 # 2 2 Stu1 # 3 3 Stu2 # 4 4 Stu2 # 5 5 Stu3 # 6 6 Stu3 ","permalink":"https://lishensuo.github.io/en/posts/program/211r-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-reshape2%E8%A1%A8%E6%A0%BC%E9%95%BF%E7%9F%AD%E8%BD%AC%E6%8D%A2/","summary":"\u003cimg src=\"https://andeekaplan.com/images/blog/01142014widevstall.png\" alt=\"Andee Kaplan\" style=\"zoom: 50%;\" /\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(reshape2)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1matrix\"\u003e1、matrix\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e123\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escores_mt = matrix(round(rnorm(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e40\u003c/span\u003e, mean = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e80\u003c/span\u003e, sd=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                nrow = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, ncol = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                dimnames = list(paste0(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Stu\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                paste0(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Subject-\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#fff;font-weight:bold\"\u003eLETTERS\u003c/span\u003e[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e])))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(scores_mt)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;matrix\u0026#34; \u0026#34;array\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(scores_mt)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      Subject-A Subject-B Subject-C Subject-D\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Stu1        74        92        69        84\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Stu2        78        84        78        77\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Stu3        96        84        70        89\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) 宽变长\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereshaped = melt(scores,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                value.name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Score\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(reshaped)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Var1      Var2 Score\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 Stu1 Subject-A    74\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu2 Subject-A    78\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 Stu3 Subject-A    96\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## Var1 --- rownames\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## Var2 --- colnames\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2) 长变宽（还原）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereshaped %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dcast(Var1 ~ Var2) %\u0026gt;% head()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Var1 Subject-A Subject-B Subject-C Subject-D\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 Stu1        74        92        69        84\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu2        78        84        78        77\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 Stu3        96        84        70        89\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2dataframe\"\u003e2、data.frame\u003c/h1\u003e\n\u003ch2 id=\"21-简单\"\u003e2.1 简单\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escores_df = scores_mt %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  as.data.frame() %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  tibble::rownames_to_column(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(scores_df)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;data.frame\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(scores_df)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Name Subject-A Subject-B Subject-C Subject-D\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 Stu1        74        92        69        84\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu2        78        84        78        77\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 Stu3        96        84        70        89\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) 宽变长\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereshaped = scores_df %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  melt(id=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       variable.name=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Subject\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       value.name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Score\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(reshaped)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Name   Subject Score\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 Stu1 Subject-A    74\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu2 Subject-A    78\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 Stu3 Subject-A    96\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2) 长变宽（还原）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereshaped %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dcast(Name ~ Subject, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        value.var = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Score\u0026#34;\u003c/span\u003e) %\u0026gt;% head()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    Name Subject-A Subject-B Subject-C Subject-D\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  Stu1        74        92        69        84\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu10        76        75        93        76\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3  Stu2        78        84        78        77\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"22-复杂\"\u003e2.2 复杂\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escores_df_Anno = scores_df %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    dplyr::mutate(Class=paste0(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Class\u0026#34;\u003c/span\u003e,rep(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;01\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;02\u0026#34;\u003c/span\u003e), \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e)),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                  Age=round(rnorm(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)), .before=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(scores_df_Anno)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Name   Class Age Subject-A Subject-B Subject-C Subject-D\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 Stu1 Class01  20        74        92        69        84\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu2 Class02  20        78        84        78        77\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 Stu3 Class01  20        96        84        70        89\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(1) 宽变长\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereshaped = scores_df_Anno %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  melt(id=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Name\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Class\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Age\u0026#34;\u003c/span\u003e), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       variable.name=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Subject\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e       value.name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Score\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(reshaped)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   Name   Class Age   Subject Score\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1 Stu1 Class01  20 Subject-A    74\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu2 Class02  20 Subject-A    78\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 Stu3 Class01  20 Subject-A    96\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##(2) 长变宽（还原）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ereshaped %\u0026gt;% dcast(Name + Class + Age ~ Subject,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   value.var = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Score\u0026#34;\u003c/span\u003e) %\u0026gt;% head()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    Name   Class Age Subject-A Subject-B Subject-C Subject-D\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  Stu1 Class01  20        74        92        69        84\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 Stu10 Class02  21        76        75        93        76\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3  Stu2 Class02  20        78        84        78        77\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3list\"\u003e3、list\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escores_list = list(Stu1=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e), Stu2=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e), Stu3=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $Stu1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 1 2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $Stu2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 3 4\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# $Stu3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 5 6\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emelt(scores_list)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   value   L1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1     1 Stu1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2     2 Stu1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3     3 Stu2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4     4 Stu2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5     5 Stu3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6     6 Stu3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"R-数据分析-reshape2表格长短转换"},{"content":" ggplot2包一方面可以实现多种形式的数据可视化、比如箱图、柱状图等；另一方面也可以从多个角度进行美化、修饰。对于前者，之前对ggplot2的柱状图、箱图用法进行了详细的学习。关于其它类型的图，例如密度图、折线图、直方图等，可参考他人的总结，例如下面的sthda网站。\nR-ggplot2-箱图系列（1） basic - 简书 (jianshu.com)\nR-ggplot2-柱状图系列 - 简书 (jianshu.com)\nhttp://www.sthda.com/english/wiki/ggplot2-essentials\n本篇笔记主要是针对我自己在绘制ggplot图片时，常常要修改的细节方面进行了大致的整理，以方便日后的查询。\n1 2 library(tidyverse) library(patchwork) 1、颜色设置 1 2 3 4 ggplot(mpg, aes(x = drv)) + geom_bar(color=\u0026#34;black\u0026#34;, fill=\u0026#34;grey\u0026#34;) #统一颜色 #一般color为边框、点的颜色，fill为填充色 1.1 离散型变量映射 1 2 p = ggplot(mpg, aes(x = drv, fill = drv)) + geom_bar() （1）scale_fill_manual() 1 2 3 4 5 6 p1 = p + scale_fill_manual(values = c(\u0026#34;red\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;)) # https://colorbrewer2.org/ p2 = p + scale_fill_manual(\u0026#34;this is title\u0026#34;, values = c(\u0026#34;4\u0026#34;=\u0026#34;green\u0026#34;, \u0026#34;r\u0026#34;=\u0026#34;red\u0026#34;, \u0026#34;f\u0026#34;=\u0026#34;blue\u0026#34;)) p3 = p + scale_fill_manual(values = c(\u0026#34;red\u0026#34;,\u0026#34;blue\u0026#34;,\u0026#34;green\u0026#34;),guide=\u0026#34;none\u0026#34;) p1 + p2 + p3 （2）scale_fill_brewer() 1 2 3 4 # 关于ColorBrewer的色板：https://www.jianshu.com/p/e0179b0a71d6 p1 = p + scale_fill_brewer(\u0026#34;Set1\u0026#34;, palette = \u0026#34;Set1\u0026#34;) p2 = p + scale_fill_brewer(\u0026#34;Dark2\u0026#34;, palette = \u0026#34;Dark2\u0026#34;) p1 + p2 1 2 3 4 5 6 ## (3) scale_fill_grey() # 0~1 --＞ black~white p + scale_fill_grey(start = 0.1, end = 0.8) ## (4) ggsci包 p + ggsci::scale_fill_aaas() 1.2 连续型变量映射 1 2 3 4 5 6 7 8 9 10 11 p = ggplot(mpg, aes(x = displ, y = hwy, color = cty)) + geom_point() p1 = p + scale_color_gradient(low = \u0026#34;green\u0026#34;, high = \u0026#34;red\u0026#34;) p2 = p + scale_color_gradient2(low = \u0026#34;green\u0026#34;, mid = \u0026#34;grey\u0026#34;, high = \u0026#34;red\u0026#34;, midpoint = mean(mpg$cty)) p3 = p + scale_color_gradient(\u0026#34;this is title\u0026#34;, low = \u0026#34;green\u0026#34;, high = \u0026#34;red\u0026#34;, breaks = c(10,20,30), label = c(\u0026#34;Low\u0026#34;,\u0026#34;Middle\u0026#34;,\u0026#34;High\u0026#34;)) p1 + p2 + p3 1 2 # ggsci包 p + ggsci::scale_color_gsea() 2、文本格式设置 常用参数有如下\nsize：大小\ncolour：颜色\nangle：旋转(rotate)角度\nhjust/vjust：位置\nface：设置粗体\nfamily：设置字体\n1 2 3 4 5 6 7 8 9 10 11 12 p = ggplot(mpg, aes(x = displ, y = hwy, color = cty)) + geom_point() #设置标题 p = p + labs(title = \u0026#34;Big Title\u0026#34;, subtitle = \u0026#34;sub title\u0026#34;, caption = \u0026#34;caption title\u0026#34;, tag = \u0026#34;A\u0026#34;) + xlab(\u0026#34;X title\u0026#34;) + ylab(\u0026#34;Y title\u0026#34;) p1 = p + theme(text = element_text(size = 15, color = \u0026#34;red\u0026#34;)) p + p1 1 2 3 4 5 6 7 8 #标题居中 p1 = p + theme(plot.title = element_text(hjust = 0.5)) #旋转x轴标签文本 p2 = p + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) # p + theme(axis.text.x = element_text(angle = 60, vjust = 1, hjust=1)) p3 = p + theme(axis.text.x = element_text(angle = 45, hjust=1)) p4 = p + theme(axis.text.x = element_text(angle = -30, hjust = 0)) p1 / (p2 + p3 + p4) 3、坐标轴设置 1 2 3 4 5 6 7 8 9 10 p = ggplot(mpg, aes(displ, hwy)) + geom_point() p1 = p + scale_x_continuous(limits = c(3, 6)) #切割 # Warning message: # Removed 105 rows containing missing values (geom_point). p2 = p + coord_cartesian(xlim = c(3, 6)) #放大 p3 = p + scale_x_continuous(breaks = c(3, 5, 7), labels = c(\u0026#34;003\u0026#34;, \u0026#34;005\u0026#34;, \u0026#34;007\u0026#34;)) p1 + p2 + p3 1 2 3 4 5 6 7 8 9 10 11 p = ggplot(mpg, aes(x = drv, fill = drv)) + geom_bar() p1 = p + coord_cartesian(ylim = c(0, 150)) + scale_y_continuous(expand = expansion(0)) #贴边 p2 = p + scale_x_discrete(breaks = c(\u0026#34;4\u0026#34;,\u0026#34;f\u0026#34;,\u0026#34;r\u0026#34;), labels = c(\u0026#34;444\u0026#34;,\u0026#34;fff\u0026#34;,\u0026#34;rrr\u0026#34;), limits = c(\u0026#34;r\u0026#34;,\u0026#34;f\u0026#34;,\u0026#34;4\u0026#34;)) #自定义标签与顺序 p3 = p + coord_flip() #转置 p1 + p2 + p3 4、添加注释 4.1 文本注释 1 2 3 4 5 6 7 8 9 10 11 p = ggplot(mpg, aes(displ, hwy)) + geom_point() p1 = p + annotate(\u0026#34;text\u0026#34;, x = 6, y = 40, label = \u0026#34;annotate() Annotation\u0026#34;) p2 = p + geom_text(x = 6, y = 40, label = \u0026#34;geom_text() Annotation\u0026#34;) p3 = p + annotate(\u0026#34;segment\u0026#34;, x = 4, xend = 2.5, y = 35, yend = 40, colour = \u0026#34;red\u0026#34;, size = 0.5, arrow = arrow(angle = 30, length = unit(0.1, \u0026#34;inches\u0026#34;))) p4 = p + annotate(\u0026#34;rect\u0026#34;, xmin = 6, xmax = 7, ymin = 0, ymax = 50, alpha = .1,fill = \u0026#34;red\u0026#34;) (p1 + p2) / (p3 + p4) 4.2 直线注释 1 2 3 4 5 6 p1 = p + geom_hline(yintercept = 30) p2 = p + geom_vline(xintercept = 4, linetype=\u0026#34;dashed\u0026#34;, color=\u0026#34;red\u0026#34;, size=2) p3 = p + geom_abline(intercept = 20, slope = 1) p1 + p2 + p3 5、分面多图 1 2 3 4 5 6 7 p = ggplot(mpg, aes(displ, hwy)) + geom_point() p1 = p + facet_wrap( ~ class, nrow = 3) p2 = p + facet_grid(drv ~ ., scales = \u0026#34;free_y\u0026#34;) p3 = p + facet_grid(drv ~ cyl, scales = \u0026#34;free\u0026#34;) p1 + p2 + p3 6、图例设置 1 2 3 4 5 6 7 8 9 p = ggplot(mpg, aes(x = drv, fill = drv)) + geom_bar() p1 = p + theme(legend.position = \u0026#34;none\u0026#34;) # \u0026#34;left\u0026#34;, \u0026#34;top\u0026#34;, \u0026#34;right\u0026#34;, \u0026#34;bottom\u0026#34;, \u0026#34;none\u0026#34; p2 = p + theme(legend.position = \u0026#34;bottom\u0026#34;) p3 = p + theme(legend.position = c(0.9,0.8)) p4 = p + guides(fill = guide_legend(title = \u0026#34;\u0026#34;, ncol = 2)) (p1 + p2)/(p3 + p4) ","permalink":"https://lishensuo.github.io/en/posts/program/212r-%E5%8F%AF%E8%A7%86%E5%8C%96-ggplot2%E7%BB%98%E5%9B%BE%E5%9F%BA%E7%A1%80/","summary":"\u003cblockquote\u003e\n\u003cp\u003eggplot2包一方面可以实现多种形式的数据可视化、比如箱图、柱状图等；另一方面也可以从多个角度进行美化、修饰。对于前者，之前对ggplot2的柱状图、箱图用法进行了详细的学习。关于其它类型的图，例如密度图、折线图、直方图等，可参考他人的总结，例如下面的sthda网站。\u003c/p\u003e","title":"R-可视化-ggplot2绘图基础"},{"content":" 参考教程：http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/。\n这里仅摘抄、记录最基本或者这我自己感兴趣的方面，全面参数的用法在对应函数帮助文档中都有详细介绍。\n1 2 library(ggpubr) library(patchwork) 1、点图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 data(\u0026#34;mtcars\u0026#34;) df = mtcars df$cyl = as.factor(df$cyl) df$name \u0026lt;- rownames(df) p1 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;) ##颜色形状 p2 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, color=\u0026#34;cyl\u0026#34;, palette = \u0026#34;jco\u0026#34;, shape = \u0026#34;cyl\u0026#34;, ellipse = TRUE) ##文本注释 p3 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, label = \u0026#34;name\u0026#34;, # 如不设置label.select，则会给所有点添加文本注释 label.select = c(\u0026#34;Toyota Corolla\u0026#34;, \u0026#34;Merc 280\u0026#34;, \u0026#34;Duster 360\u0026#34;), repel = TRUE) ##点的大小 p4 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, size = \u0026#34;qsec\u0026#34;, alpha = 0.5) + scale_size(range = c(0.5, 10)) (p1 | p2)/(p3 | p4) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 p1 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, add = \u0026#34;reg.line\u0026#34;) + stat_cor() p2 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, add = \u0026#34;reg.line\u0026#34;, conf.int = TRUE, add.params = list(color = \u0026#34;blue\u0026#34;, fill = \u0026#34;lightgray\u0026#34;)) + stat_cor() p3 = ggscatter(df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, add = \u0026#34;reg.line\u0026#34;) + stat_cor(method = \u0026#34;pearson\u0026#34;, label.x = 3, label.y = 30, #label.x.npc = 0.3, label.y.npc = 0.3, p.accuracy = 0.001, r.accuracy = 0.01, label.sep = \u0026#39;\\n\u0026#39;) p1 | p2 | p3 2、线图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ##(1)一组样本，每个样本一个点 df \u0026lt;- data.frame(dose=c(\u0026#34;D0.5\u0026#34;, \u0026#34;D1\u0026#34;, \u0026#34;D2\u0026#34;), len=c(4.2, 10, 29.5)) df # dose len # 1 D0.5 4.2 # 2 D1 10.0 # 3 D2 29.5 p1 = ggline(df, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;) #show_line_types() ##(2)两组样本，每个样本一个点 df2 \u0026lt;- data.frame(supp=rep(c(\u0026#34;VC\u0026#34;, \u0026#34;OJ\u0026#34;), each=3), dose=rep(c(\u0026#34;D0.5\u0026#34;, \u0026#34;D1\u0026#34;, \u0026#34;D2\u0026#34;),2), len=c(6.8, 15, 33, 4.2, 10, 29.5)) df2 # supp dose len # 1 VC D0.5 6.8 # 2 VC D1 15.0 # 3 VC D2 33.0 # 4 OJ D0.5 4.2 # 5 OJ D1 10.0 # 6 OJ D2 29.5 p2 = ggline(df2, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, linetype = \u0026#34;supp\u0026#34;, color = \u0026#34;supp\u0026#34;, shape = \u0026#34;supp\u0026#34;) p1 | p2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ##多组样本，每个样本多个点 df3 = ToothGrowth table(df3$supp, df3$dose) # 0.5 1 2 # OJ 10 10 10 # VC 10 10 10 p3 = ggline(df3, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, add = \u0026#34;mean_se\u0026#34;) p4 = ggline(df3, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;supp\u0026#34;, shape = \u0026#34;supp\u0026#34;, linetype = \u0026#34;supp\u0026#34;, add = \u0026#34;mean_se\u0026#34;) p3 | p4 3、柱状图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 data(\u0026#34;mtcars\u0026#34;) dfm \u0026lt;- mtcars dfm$cyl \u0026lt;- as.factor(dfm$cyl) dfm$name \u0026lt;- rownames(dfm) ##整体排序 p1 = ggbarplot(dfm, x = \u0026#34;name\u0026#34;, y = \u0026#34;mpg\u0026#34;, fill = \u0026#34;cyl\u0026#34;, # 填充颜色(映射分组变量) color = \u0026#34;white\u0026#34;, # 边框颜色 sort.val = \u0026#34;desc\u0026#34;, # 降序排列 sort.by.groups = FALSE, # 是否组内排序 x.text.angle = 90) ##分组排序 p2 = ggbarplot(dfm, x = \u0026#34;name\u0026#34;, y = \u0026#34;mpg\u0026#34;, fill = \u0026#34;cyl\u0026#34;, # 填充颜色(映射分组变量) color = \u0026#34;white\u0026#34;, # 边框颜色 sort.val = \u0026#34;asc\u0026#34;, # 升序排列 sort.by.groups = TRUE, # 是否组内排序 x.text.angle = 90) p1 | p2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #对于有正负值的柱状图 p3 = ggbarplot(dfm, x = \u0026#34;name\u0026#34;, y = \u0026#34;mpg_z\u0026#34;, fill = \u0026#34;mpg_grp\u0026#34;, color = \u0026#34;white\u0026#34;, sort.val = \u0026#34;asc\u0026#34;, sort.by.groups = FALSE, x.text.angle = 90) p4 = ggbarplot(dfm, x = \u0026#34;name\u0026#34;, y = \u0026#34;mpg_z\u0026#34;, fill = \u0026#34;mpg_grp\u0026#34;, color = \u0026#34;white\u0026#34;, sort.val = \u0026#34;desc\u0026#34;, sort.by.groups = FALSE, x.text.angle = 90, rotate = TRUE, ggtheme = theme_minimal()) p3 | p4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ##棒棒糖图 p5 = ggdotchart(dfm, x = \u0026#34;name\u0026#34;, y = \u0026#34;mpg\u0026#34;, color = \u0026#34;cyl\u0026#34;, sorting = \u0026#34;ascending\u0026#34;, add = \u0026#34;segments\u0026#34;) ##cleveland p6 = ggdotchart(dfm, x = \u0026#34;name\u0026#34;, y = \u0026#34;mpg\u0026#34;, color = \u0026#34;cyl\u0026#34;, sorting = \u0026#34;descending\u0026#34;, rotate = TRUE, y.text.col = TRUE) + theme_cleveland() p5 | p6 ","permalink":"https://lishensuo.github.io/en/posts/program/213r-%E5%8F%AF%E8%A7%86%E5%8C%96-ggpubr%E5%8C%85%E5%BF%AB%E9%80%9F%E7%BB%98%E5%88%B6%E7%82%B9%E5%9B%BE%E7%BA%BF%E5%9B%BE%E4%B8%8E%E6%9F%B1%E7%8A%B6%E5%9B%BE/","summary":"\u003cblockquote\u003e\n\u003cp\u003e参考教程：http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/。\u003c/p\u003e","title":"R-可视化-ggpubr包快速绘制点图、线图与柱状图"},{"content":"一、ggplot2组图 0、安装包及示例图 1 2 3 4 5 6 7 8 9 10 # #install.packages(\u0026#34;devtools\u0026#34;) # devtools::install_github(\u0026#34;thomasp85/patchwork\u0026#34;) library(ggplot2) library(patchwork) p1 \u0026lt;- ggplot(mtcars) + geom_point(aes(mpg, disp)) p2 \u0026lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear)) p3 \u0026lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl) p4 \u0026lt;- ggplot(mtcars) + geom_bar(aes(carb)) p5 \u0026lt;- ggplot(mtcars) + geom_violin(aes(cyl, mpg, group = cyl)) 1、简单使用 （1）符号连接：+或者| 均表示左右拼接，/表示上下拼接，()可以用于调整优先级 （2）函数调用：wrap_plots()，可通过具体参数设置排列方式\n1 2 p1 + p2 #左右 wrap_plots(p1, p2) 1 2 p1 / p2 #上下 wrap_plots(p1, p2, ncol = 1) 2、复杂排列 符号连接方式中，可使用()调整优先级\n函数调用方式中，可通过design=参数设置\n1 2 3 4 5 6 p1 | (p2 / p3) #先上下再左右 #如上等价于如下 design \u0026lt;- \u0026#34;AB CC\u0026#34; wrap_plots(A = p1, B = p2, C = p3, design = design) 1 2 3 4 5 6 ((p2 + p4) + plot_layout(widths = c(2, 1))) / (p1 + p3 + p5) #如上等价于如下 design \u0026lt;- \u0026#34;AAD BCE\u0026#34; wrap_plots(B = p1, A = p2, C = p3, D = p4, E = p5, design = design) 3、细节调整 plot_layout()调整长宽比例 1 2 3 4 p1 + p2 + plot_layout(widths = c(3,2)) # wrap_plots(p1, p2) + plot_layout(widths = c(3,2)) (((p1 / p2) + plot_layout(heights = c(1,2))) | p3) + plot_layout(widths = c(2,1)) plot_layout()相同legend 1 2 3 4 5 6 7 8 data(Salaries, package=\u0026#34;carData\u0026#34;) p11 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) + geom_bar(position=\u0026#34;stack\u0026#34;) + labs(title=\u0026#39;position=\u0026#34;stack\u0026#34;\u0026#39;) p22 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) + geom_bar(position=\u0026#34;dodge\u0026#34;) + labs(title=\u0026#39;position=\u0026#34;dodge\u0026#34;\u0026#39;) p33 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) + geom_bar(position=\u0026#34;fill\u0026#34;) + labs(title=\u0026#39;position=\u0026#34;fill\u0026#34;\u0026#39;) p11 + p22 + p33 + plot_layout(guides = \u0026#39;collect\u0026#39;) plot_annotation() 设置标题 1 2 3 4 5 (p1 | (p2 / p3)) + plot_annotation( title = \u0026#39;This is main title\u0026#39;, subtitle = \u0026#39;This is subtitle\u0026#39;, caption = \u0026#39;this is just caption\u0026#39;, theme = theme(plot.title = element_text(hjust = 0.5))) plot_annotation() 设置子图tag标签 1 2 3 4 5 6 7 8 9 10 11 12 13 (p1 | (p2 / p3)) + plot_annotation(tag_levels = \u0026#39;A\u0026#39;) # tag_levels : \u0026#39;a\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;i, or \u0026#39;I\u0026#39; # tag标签加前缀 ((p1 | p2) / p3) + plot_annotation(tag_levels = \u0026#39;A\u0026#39;, tag_prefix = \u0026#39;Fig. \u0026#39;) # tag标签加后缀 ((p1 | p2) / p3) + plot_annotation(tag_levels = \u0026#39;A\u0026#39;, tag_suffix = \u0026#39;:\u0026#39;) #单独子图个性化标签 p1 + labs(tag = \u0026#34;any\u0026#34;) 4、ggplot与其它对象的拼图 ggplot2与表格 1 2 df = mtcars[1:10, c(\u0026#39;mpg\u0026#39;, \u0026#39;disp\u0026#39;)] p1 + gridExtra::tableGrob(df) ggplot2与基础绘图 1 p1 + ~plot(mtcars$mpg, mtcars$disp, main = \u0026#39;Plot 2\u0026#39;) 二、R基本绘图组图 仅适用于R基础绘制图形的组图\n1 2 3 4 5 6 7 8 9 10 11 12 13 # (1) 保存原始的默认参数 opar \u0026lt;- par(no.readonly=TRUE) # (2) 声明拼图方案 par(mfcol=c(2,1)) # or # layout(matrix(c(1,1,2,3),2,2,byrow=TRUE)) # (3) 基础绘图函数绘制图形 data(mtcars) plot(mtcars$wt, mtcars$mpg) barplot(mtcars$mpg) # (4) 恢复默认布局参数：一个面板一张图 par(opar) 1、par()方式 mfcol=c(x,y)与mfrow=c(x,y)均是将初始绘图面板平均分割为x行，y列； 二者区别在于前者按列的顺序依次填充、布局；而后者为按行依次填充、布局 1 2 3 4 5 6 7 opar \u0026lt;- par(no.readonly=TRUE) par(mfcol=c(2,1)) #2行1列 #par(mfrow=c(2,1)) data(mtcars) plot(mtcars$wt, mtcars$mpg) #图1 barplot(mtcars$mpg) #图2 par(opar) 2、layout()精细布局 layout()函数的第一个参数为一个矩阵，用于设置组图位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ### 如下表示将三张图拼在一起：第一张图在第一行，第二、三张图在第二行 mt = matrix(c(1,1,2,3), nrow = 2, byrow=TRUE) mt # [,1] [,2] # [1,] 1 1 # [2,] 2 3 ### 如下矩阵表示将四张图拼在一起：第一张图在第一列，第二、三张图在第二列，第四张图在第三列 mt = matrix(c(1,1,2,3,4,4), nrow = 2, byrow=FALSE) mt # [,1] [,2] [,3] # [1,] 1 2 4 # [2,] 1 3 4 widths、heights参数可进一步设置子图间的长宽比例 1 2 3 4 5 6 7 8 9 10 11 12 opar \u0026lt;- par(no.readonly=TRUE) #布局设置 mt = matrix(c(1,1,2,3), nrow = 2,byrow=TRUE) layout(mt, widths=c(3,1), #高度比为 3:1 heights=c(1,2)) #宽度比为 1:2 #绘图 plot(mtcars$wt, mtcars$mpg) barplot(mtcars$mpg) plot(density(mtcars$wt)) par(opar) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 opar \u0026lt;- par(no.readonly=TRUE) mt = matrix(c(1,1,2,3,4,4), nrow = 2, byrow=FALSE) layout(mt, widths = c(2,2,1), heights = c(1,2)) plot(mtcars$wt, mtcars$mpg) barplot(mtcars$mpg) plot(density(mtcars$wt)) hist(mtcars$qsec) par(opar) ","permalink":"https://lishensuo.github.io/en/posts/program/214r-%E5%8F%AF%E8%A7%86%E5%8C%96-%E6%8B%BC%E5%9B%BEpatchwork/","summary":"\u003ch1 id=\"一ggplot2组图\"\u003e一、ggplot2组图\u003c/h1\u003e\n\u003ch2 id=\"0安装包及示例图\"\u003e0、安装包及示例图\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# #install.packages(\u0026#34;devtools\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# devtools::install_github(\u0026#34;thomasp85/patchwork\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggplot2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(patchwork)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 \u0026lt;- ggplot(mtcars) + geom_point(aes(mpg, disp))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 \u0026lt;- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep3 \u0026lt;- ggplot(mtcars) + geom_bar(aes(gear)) + facet_wrap(~cyl)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep4 \u0026lt;- ggplot(mtcars) + geom_bar(aes(carb))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep5 \u0026lt;- ggplot(mtcars) + geom_violin(aes(cyl, mpg, group = cyl))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1简单使用\"\u003e1、简单使用\u003c/h2\u003e\n\u003cp\u003e（1）符号连接：\u003ccode\u003e+\u003c/code\u003e或者\u003ccode\u003e|\u003c/code\u003e 均表示左右拼接，\u003ccode\u003e/\u003c/code\u003e表示上下拼接，\u003ccode\u003e()\u003c/code\u003e可以用于调整优先级\n（2）函数调用：\u003ccode\u003ewrap_plots()\u003c/code\u003e，可通过具体参数设置排列方式\u003c/p\u003e","title":"R-可视化-拼图patchwork"},{"content":"示例数据 3个基因集列表，为list格式\n1 2 3 4 5 genes \u0026lt;- paste0(\u0026#34;gene\u0026#34;,1:1000) set.seed(20210302) gene_list \u0026lt;- list(A = sample(genes,100), B = sample(genes,200), C = sample(genes,300)) 一、VennDiagram VennDiagram包是绘制韦恩图的一个经典包。\n它不是基于ggplot体系，但可以转换为ggplot对象(个人更习惯些)。\n另外每次绘图时，但会生成一个日志log文件，比较麻烦。\n参考教程：https://www.r-graph-gallery.com/14-venn-diagramm.html\n1 基本使用 关键是设置filename 参数；但无论哪一种方法都会生成log文件。\n（1）如果为正常名，则直接保存文件至本地；\n（2）如果设置为NULL值，那么会得到gList图像，可配合grid.draw {grid}在R界面显示\n1 2 3 4 5 6 7 8 9 10 11 12 13 # install.packages(\u0026#34;VennDiagram\u0026#34;) library(VennDiagram) #(1)保存图片至本地 venn.diagram(gene_list, filename = \u0026#34;test.pdf\u0026#34;, height = 3000, width = 3000) #(2)在R界面显示 venn.plot = venn.diagram(gene_list, filename = NULL) grid.draw(venn.plot) file.remove(list.files(pattern = \u0026#34;*log\u0026#34;)) dev.off() 2 细节调整 2.1 类别名 即上图中的A、B、C，包括如下调整方面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #(1) 类别名标签 category.names #(2) 字体大小(相对1) cat.cex = 0.6 #(3) 字体格式 cat.fontface = \u0026#34;bold\u0026#34; #粗体 cat.fontfamily = \u0026#34;sans\u0026#34; #宋体 #(4) 字体颜色 cat.col = c(\u0026#34;#FF0000\u0026#34;, \u0026#34;#00FF00\u0026#34;, \u0026#34;#0000FF\u0026#34;) #(5) 标签围绕图中心的角度位置 cat.pos = c(-27, 27, 135) #0度为12点方向，顺时针旋转 #(6) 类别名距离圆的距离 cat.dist = c(0.055, 0.055, 0.085) #(7) 标签自旋转角度(逆时针) rotation.degree = 60 rotation = 1 #适合3 set的情况 ##示例 venn.plot = venn.diagram(gene_list[1:3], filename = NULL, category.names = LETTERS[1:3], cat.cex = 1.5, cat.fontface = \u0026#34;bold\u0026#34;, cat.pos = c(-20, 20, 180), cat.col = rainbow(3)) grid.draw(venn.plot) 2.2 圆的格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #(1) 填充颜色 fill = rainbow(3) #(2) 边的颜色 col = rainbow(3) #(3) 边的宽度 lwd = 2 #(4) 边的类型 lty = \u0026#39;blank\u0026#39; # dashed dotted ##示例 venn.plot = venn.diagram(gene_list, filename = NULL, fill = RColorBrewer::brewer.pal(4, \u0026#34;Pastel2\u0026#34;), col = RColorBrewer::brewer.pal(4, \u0026#34;Pastel2\u0026#34;), lwd = 2, lty = \u0026#34;dashed\u0026#34;) grid.draw(venn.plot) 我认为VennDiagram与ggVennDiagram包最大的不同就在于圆的填充颜色\n前者为离散的颜色，而后者为连续渐变颜色 2.3 交集数值格式 1 2 3 4 5 venn.plot = venn.diagram(gene_list, cex = 2, #设置大小 fontface = \u0026#34;bold\u0026#34;, #设置格式 filename = NULL) grid.draw(venn.plot) 3 特殊的2 sets 当绘制两个set的交集情况时，圆的面积大小与对应数目成正比； 而且当交集数目过小时，会自动使用引导线注释 1 2 3 4 5 6 7 gene_list2 \u0026lt;- list(A = sample(genes,20), B = sample(genes,100)) venn.plot = venn.diagram(gene_list2, filename = NULL) grid.draw(venn.plot) file.remove(list.files(pattern = \u0026#34;*log\u0026#34;)) dev.off() 可通过ext.系列参数修改这根引导线格式，例如直接取消~ 1 2 3 4 5 6 7 8 9 10 # ext.text = F # ext.percent = 0 重叠数目低于多少百分比，使用线 # ext.pos # ext.line.lwd venn.plot = venn.diagram(gene_list2, ext.text = F, filename = NULL) grid.draw(venn.plot) file.remove(list.files(pattern = \u0026#34;*log\u0026#34;)) dev.off() 如果不想让圆的面积与数值存在这种对应关系，可通过如下方式进行绘制 1 2 3 4 5 6 7 8 9 10 11 12 13 venn.plot \u0026lt;- draw.pairwise.venn( area1 = 50, area2 = 50, cross.area = 20) dev.off() #修改展示标签内容 venn.plot[[5]]$label = length(setdiff(gene_list2[[1]], gene_list2[[2]])) venn.plot[[6]]$label = length(setdiff(gene_list2[[2]], gene_list2[[1]])) venn.plot[[7]]$label = length(intersect(gene_list2[[1]], gene_list2[[2]])) grid.draw(venn.plot) file.remove(list.files(pattern = \u0026#34;*log\u0026#34;)) dev.off() 4 转为ggplot2对象 1 2 3 4 5 library(ggplot2) library(ggplotify) library(cowplot) as.ggplot(plot_grid(grobTree(venn.plot))) + ggtitle(\u0026#34;This is title\u0026#34;) 二、ggVennDiagram ggVennDiagram包是基于ggplot绘图体系的，因此适用于ggplot的语法结构。\n主要参考教程：https://mirror.linux.duke.edu/cran/web/packages/ggVennDiagram/vignettes/using-ggVennDiagram.html\n1 基本使用 1 2 3 4 5 6 7 8 9 # install.packages(\u0026#34;ggVennDiagram\u0026#34;) library(ggVennDiagram) packageVersion(\u0026#34;ggVennDiagram\u0026#34;) # [1] ‘1.2.0’ library(ggplot2) library(patchwork) ggVennDiagram(gene_list) 2 细节调整 2.1 类别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #(1) 类别名标签 category.names = c(\u0026#34;AA\u0026#34;,\u0026#34;BB\u0026#34;,\u0026#34;CC\u0026#34;,\u0026#34;DD\u0026#34;) #(2) 字体大小 set_size = 8 #(3) 字体颜色 set_color = rainbow(4) ##有时名字太长，可能会显示不全，可以通过ggplot2函数拉宽画布 p1=ggVennDiagram(gene_list, category.names = c(\u0026#34;a very long name\u0026#34;,\u0026#34;short name\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;another name\u0026#34;)) p2=ggVennDiagram(gene_list, category.names = c(\u0026#34;a very long name\u0026#34;,\u0026#34;short name\u0026#34;,\u0026#34;name\u0026#34;,\u0026#34;another name\u0026#34;)) + scale_x_continuous(expand = expansion(mult = .2)) p1 / p2 2.2 圆的格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #(1) 填充颜色与数值大小相关，为渐变填充色。 #可通过ggplot的相关函数进行配色 RColorBrewer::display.brewer.all() p1 = ggVennDiagram(gene_list) + scale_fill_distiller(palette = \u0026#34;RdBu\u0026#34;) + ggtitle(\u0026#34;p1\u0026#34;) p2 = ggVennDiagram(gene_list) + scale_fill_distiller(palette = \u0026#34;Reds\u0026#34;, direction = 1) + ggtitle(\u0026#34;p2\u0026#34;) # If -1, the order of colours is reversed. p3 = ggVennDiagram(gene_list) + scale_fill_gradient(low=\u0026#34;blue\u0026#34;,high = \u0026#34;red\u0026#34;) + ggtitle(\u0026#34;p3\u0026#34;) # https://colorbrewer2.org/ p4 = ggVennDiagram(gene_list) + scale_fill_gradient(low=\u0026#34;#ffffb2\u0026#34;,high = \u0026#34;#b10026\u0026#34;) + ggtitle(\u0026#34;p4\u0026#34;) (p1 | p2) / (p3 | p4) 1 2 3 4 5 6 #(2)边的相关设置参数 scale_color_* #设置颜色 edge_size #设置粗细 edge_lty #设置类型 ggVennDiagram(gene_list, edge_lty = \u0026#34;dashed\u0026#34;, edge_size = 1) + scale_color_brewer(palette = \u0026#34;Set1\u0026#34;) 2.3 交集数值格式 参看上图可知，默认为数值加百分比格式，且为白色透明度背景\n1 2 3 4 5 6 7 8 #(1)交集标签内容 label = # c(\u0026#34;both\u0026#34;, \u0026#34;count\u0026#34;, \u0026#34;percent\u0026#34;, \u0026#34;none\u0026#34;) #(2)背景透明度 label_alpha = 0 #(3)标签字体颜色 label_color = \u0026#34;red\u0026#34; #(4)标签字体大小 label_size = 5 三、UpSetR 当可视化多个(\u0026gt;5)集合的交集情况时，传统韦恩图的效果就比较复杂，不够直观。\nUpSetR包可进行相对更加高效的展示，而且用法也很简单。\n参考：https://cran.r-project.org/web/packages/UpSetR/vignettes/\n1、基本使用 1 2 3 4 5 6 # install.packages(\u0026#34;UpSetR\u0026#34;) library(UpSetR) #`upset()`绘图函数默认接受的集合对象为表格； # 如果提供为list，包装在`fromList()`函数内部即可 upset(fromList(gene_list)) 2、细节调整 2.1 左下角柱状图 每一列表示一类集合，柱高表示集合大小。\n1 2 3 4 5 6 #(1) 指定选择哪些set集合纳入分析 sets = names(gene_list) #(2) 设置展示集合的数目默认选择Size Top 5的集合。 nsets = 5 #(2) 集合排列顺序, 默认为 从上到下为size从小到大的顺序 keep.order = TRUE #设置是否按照提供数据的集合顺序展示 2.2 右上角柱状图 nintersects=40 ：默认最多展示40列；设置为NA值则展示所有可能组合\nempty.intersections = \u0026quot;on\u0026quot; ：设置展示为0的交集组合\ncutoff=3 筛选大于一定数量的交集类别\norder.by = \u0026quot;degree\u0026quot; 表示先按照组成集合的类别数排序\norder.by = \u0026quot;freq\u0026quot; 表示仅按照集合大小排序\ndecreasing = T 默认均为降序排列，\n2.3 文本标签设置 1 2 3 4 5 6 7 8 upset(fromList(gene_list), number.angles = 30, point.size = 3.5, #左下角的点 line.size = 2, #左下角的线 mainbar.y.label = \u0026#34;Gene Sets Intersections\u0026#34;, sets.x.label = \u0026#34;Genes Per Set\u0026#34;, mb.ratio = c(0.7, 0.3), text.scale = c(1.5, 1.1, 1.5, 1, 1.2, 1.5)) #见下图箭头) ","permalink":"https://lishensuo.github.io/en/posts/program/215r-%E5%8F%AF%E8%A7%86%E5%8C%96-%E9%9F%A6%E6%81%A9%E5%9B%BEvenn/","summary":"\u003ch1 id=\"示例数据\"\u003e示例数据\u003c/h1\u003e\n\u003cp\u003e3个基因集列表，为list格式\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egenes \u0026lt;- paste0(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;gene\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1000\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20210302\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egene_list \u0026lt;- list(A = sample(genes,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                  B = sample(genes,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                  C = sample(genes,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e300\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"一venndiagram\"\u003e一、VennDiagram\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eVennDiagram包是绘制韦恩图的一个经典包。\u003c/p\u003e","title":"R-可视化-韦恩图venn"},{"content":"\r一、ggplot绘制基础箱图 0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 library(ggplot2) library(patchwork) #组别名最好是字符型；如果是数值类型，最好转为因子化 ToothGrowth$dose = factor(ToothGrowth$dose) summary(ToothGrowth) # len supp dose # Min. : 4.20 OJ:30 0.5:20 # 1st Qu.:13.07 VC:30 1 :20 # Median :19.25 2 :20 # Mean :18.81 # 3rd Qu.:25.27 # Max. :33.90 1、基础绘图 1 2 3 4 5 p1 = ggplot(ToothGrowth, aes(x=dose, y=len, fill=dose)) + geom_boxplot() p2 = ggplot(ToothGrowth, aes(x=dose, y=len, fill=supp)) + geom_boxplot() p1 | p2 2、离群点相关 1 2 3 4 5 6 p1 = ggplot(ToothGrowth, aes(x=dose, y=len)) + geom_boxplot(outlier.color = \u0026#34;red\u0026#34;, outlier.size = 0.5) p2 = ggplot(ToothGrowth, aes(x=dose, y=len)) + geom_boxplot(outlier.alpha = 0) #透明度为0，相当于不绘制离群点 p1 + p2 3、添加随机抖动点/whisker须线 1 2 3 4 5 6 7 ggplot(ToothGrowth, aes(x=dose, y=len)) + geom_boxplot() geom_jitter(color = \u0026#34;black\u0026#34;, size=0.8) ggplot(ToothGrowth, aes(x=dose, y=len)) + stat_boxplot(geom = \u0026#34;errorbar\u0026#34;, width = 0.2) + geom_boxplot() 4、嵌套小提琴图 1 2 3 4 5 6 p1 = ggplot(ToothGrowth, aes(x=dose, y=len, fill=dose)) + geom_violin() p2 = ggplot(ToothGrowth, aes(x=dose, y=len, fill=dose)) + geom_violin() + geom_boxplot(width=0.2, color=\u0026#34;black\u0026#34;, alpha=0.5) p1 | p2 二、ggpubr进行两/多组比较 ggpubr包提供了组间比较的分析函数与可视化函数，主要参考自http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/76-add-p-values-and-significance-levels-to-ggplots/\n0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 library(ggpubr) library(patchwork) #组别名最好是字符型；如果是数值类型，最好转为因子化 ToothGrowth$dose = factor(ToothGrowth$dose) summary(ToothGrowth) # len supp dose # Min. : 4.20 OJ:30 0.5:20 # 1st Qu.:13.07 VC:30 1 :20 # Median :19.25 2 :20 # Mean :18.81 # 3rd Qu.:25.27 # Max. :33.90 1、组间差异检验 1.1 两组间比较 （1）选择有参法还是无参法；（2）能否进行配对比较\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # （1）Wilcoxon compare_means(len ~ supp, data = ToothGrowth) #default # # A tibble: 1 x 8 # .y. group1 group2 p p.adj p.format p.signif method # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 len OJ VC 0.0645 0.064 0.064 ns Wilcoxon # （2）t检验 compare_means(len ~ supp, data = ToothGrowth, method = \u0026#34;t.test\u0026#34;) # 1 len OJ VC 0.0606 0.061 0.061 ns T-test # （3） 修改adjP的计算方法 compare_means(len ~ supp, data = ToothGrowth, p.adjust.method = \u0026#34;BH\u0026#34;) #default \u0026#34;holm\u0026#34; # 1 len OJ VC 0.0645 0.064 0.064 ns Wilcoxon # （4）考虑其它变量的影响 compare_means(len ~ supp, data = ToothGrowth, group.by = \u0026#34;dose\u0026#34;) # # A tibble: 3 x 9 # dose .y. group1 group2 p p.adj p.format p.signif method # \u0026lt;fct\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 0.5 len OJ VC 0.0232 0.046 0.023 * Wilcoxon # 2 1 len OJ VC 0.00403 0.012 0.004 ** Wilcoxon # 3 2 len OJ VC 1 1 1.000 ns Wilcoxon # （5）如果进行配对分析 #那么需要保持每组的样本排列顺序是一致的 compare_means(len ~ supp, data = ToothGrowth, paired = T) # 1 len OJ VC 0.00431 0.0043 0.0043 ** Wilcoxon # （6）修改标签阈值 compare_means(len ~ supp, data = ToothGrowth, symnum.args = list(cutpoints = c(0, 0.01, 0.05, 1), symbols = c(\u0026#34;***\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;not\u0026#34;))) # 1 len OJ VC 0.0645 0.064 0.064 not Wilcoxon 1.2 多分组比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #（1）所有两两间比较 compare_means(len ~ dose, data = ToothGrowth) # .y. group1 group2 p p.adj p.format p.signif method # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 len 0.5 1 0.00000702 0.000014 7.0e-06 **** Wilcoxon # 2 len 0.5 2 0.0000000841 0.00000025 8.4e-08 **** Wilcoxon # 3 len 1 2 0.000177 0.00018 0.00018 *** Wilcoxon # （2）都和0.5的组进行比较 compare_means(len ~ dose, data = ToothGrowth, ref.group = \u0026#34;0.5\u0026#34;) # .y. group1 group2 p p.adj p.format p.signif method # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 len 0.5 1 0.00000702 0.000007 7.0e-06 **** Wilcoxon # 2 len 0.5 2 0.0000000841 0.00000017 8.4e-08 **** Wilcoxon # （3）方差分析-有参 compare_means(len ~ dose, data = ToothGrowth, method = \u0026#34;anova\u0026#34;) #有参 # .y. p p.adj p.format p.signif method # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 len 9.53e-16 9.5e-16 9.5e-16 **** Anova # （4）方差分析-无参 compare_means(len ~ dose, data = ToothGrowth, method = \u0026#34;kruskal.test\u0026#34;) #无参 # .y. p p.adj p.format p.signif method # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 len 0.00000000148 0.0000000015 1.5e-09 **** Kruskal-Wallis 2、绘制箱图 2.1 两组间比较 （1）不同比较方式 1 2 3 4 5 6 7 8 p \u0026lt;- ggboxplot(ToothGrowth, x = \u0026#34;supp\u0026#34;, y = \u0026#34;len\u0026#34;, # 配色方案 ?ggboxplot color = \u0026#34;supp\u0026#34;, palette = \u0026#34;aaas\u0026#34;, add = \u0026#34;jitter\u0026#34;) # Add p-value p1 = p + stat_compare_means() #default Wilcoxon p2 = p + stat_compare_means(method = \u0026#34;t.test\u0026#34;) p1 + p2 （2）标签显示格式 1 2 3 4 5 6 7 8 9 10 11 12 #标签位置 p1 = p + stat_compare_means(label.x.npc = \u0026#34;left\u0026#34;, # label.x = 1.5, label.y = 40 label.y.npc = \u0026#34;top\u0026#34;) #标签内容(数值改为星号) p2 = p + stat_compare_means(aes(label = ..p.signif..)) #自定义阈值 p3 = p + stat_compare_means(aes(label = ..p.signif..), symnum.args = list(cutpoints = c(0, 0.01, 0.05, 1), symbols = c(\u0026#34;***\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;notsig\u0026#34;)), label.x = 1.5, label.y = 40) p1 | p2 | p3 （3）配对分析 1 2 3 4 5 # 要确保相同样本在不同组的排列顺序相同 ggpaired(ToothGrowth, x = \u0026#34;supp\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;supp\u0026#34;, palette = \u0026#34;jco\u0026#34;, line.color = \u0026#34;gray\u0026#34;, line.size = 0.4) + stat_compare_means(paired = TRUE) （4）考虑其它分组变量 1 2 3 4 5 6 7 8 9 10 11 12 13 p \u0026lt;- ggboxplot(ToothGrowth, x = \u0026#34;supp\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;supp\u0026#34;, palette = \u0026#34;jco\u0026#34;, #add = \u0026#34;jitter\u0026#34;, facet.by = \u0026#34;dose\u0026#34;, short.panel.labs = F) p1 = p + stat_compare_means(label = \u0026#34;p.format\u0026#34;) # p + stat_compare_means(label = \u0026#34;p.signif\u0026#34;, label.x = 1.5) p \u0026lt;- ggboxplot(ToothGrowth, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;supp\u0026#34;, palette = \u0026#34;jco\u0026#34;) p2 = p + stat_compare_means(aes(group = supp)) # p + stat_compare_means(aes(group = supp), label = \u0026#34;p.signif\u0026#34;) p1 / p2 2.2 多组间比较 （1）方差分析 1 2 3 4 5 6 7 8 p1 = ggboxplot(ToothGrowth, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;dose\u0026#34;, palette = \u0026#34;jco\u0026#34;)+ stat_compare_means() p2 = ggboxplot(ToothGrowth, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;dose\u0026#34;, palette = \u0026#34;jco\u0026#34;)+ stat_compare_means(method = \u0026#34;anova\u0026#34;) p1 + p2 （2）两两比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 p1 = ggboxplot(ToothGrowth, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;dose\u0026#34;, palette = \u0026#34;jco\u0026#34;)+ stat_compare_means(comparisons = list( c(\u0026#34;0.5\u0026#34;, \u0026#34;1\u0026#34;), c(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;), c(\u0026#34;0.5\u0026#34;, \u0026#34;2\u0026#34;) )) p2 = ggboxplot(ToothGrowth, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;dose\u0026#34;, palette = \u0026#34;jco\u0026#34;)+ stat_compare_means(comparisons = list( c(\u0026#34;0.5\u0026#34;, \u0026#34;1\u0026#34;), c(\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;), c(\u0026#34;0.5\u0026#34;, \u0026#34;2\u0026#34;) ), label.y = c(29, 35, 40))+ #指定标签的高度 stat_compare_means(label.y = 45) #添加方差分析结果 p1 | p2 1 2 3 4 5 6 ## 直接指定一个参考组 ggboxplot(ToothGrowth, x = \u0026#34;dose\u0026#34;, y = \u0026#34;len\u0026#34;, color = \u0026#34;dose\u0026#34;, palette = \u0026#34;jco\u0026#34;)+ stat_compare_means(method = \u0026#34;anova\u0026#34;, label.y = 40)+ # Add global p-value stat_compare_means(label = \u0026#34;p.signif\u0026#34;, method = \u0026#34;t.test\u0026#34;, ref.group = \u0026#34;0.5\u0026#34;) # Pairwise comparison against reference ","permalink":"https://lishensuo.github.io/en/posts/program/216ggplot+ggpubr%E7%BB%98%E5%88%B6%E7%AE%B1%E5%9B%BEboxplot/","summary":"\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-aad1ed8ff0e92e2f.png\" alt=\"https://www.leansigmacorporation.com/box-plot-with-minitab/\" style=\"zoom: 50%;\" /\u003e\r\n\u003ch1 id=\"一ggplot绘制基础箱图\"\u003e一、ggplot绘制基础箱图\u003c/h1\u003e\n\u003ch2 id=\"0示例数据\"\u003e0、示例数据\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggplot2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(patchwork)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#组别名最好是字符型；如果是数值类型，最好转为因子化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eToothGrowth$dose = factor(ToothGrowth$dose)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esummary(ToothGrowth)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#       len        supp     dose   \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Min.   : 4.20   OJ:30   0.5:20  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1st Qu.:13.07   VC:30   1  :20  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Median :19.25           2  :20  \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Mean   :18.81                   \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3rd Qu.:25.27                   \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Max.   :33.90\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1基础绘图\"\u003e1、基础绘图\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = ggplot(ToothGrowth, aes(x=dose, y=len, fill=dose)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_boxplot()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = ggplot(ToothGrowth, aes(x=dose, y=len, fill=supp)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_boxplot()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 | p2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-160c19fae6e5a49b.png\" style=\"zoom: 67%;\" /\u003e\r\n\u003ch2 id=\"2离群点相关\"\u003e2、离群点相关\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = ggplot(ToothGrowth, aes(x=dose, y=len)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_boxplot(outlier.color = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;red\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e               outlier.size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = ggplot(ToothGrowth, aes(x=dose, y=len)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_boxplot(outlier.alpha = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e#透明度为0，相当于不绘制离群点\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 + p2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-584137fd5e864940.png\" alt=\"\"  /\u003e\r\n\u003c/p\u003e","title":"R-可视化-ggplot+ggpubr绘制箱图boxplot"},{"content":"1、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 library(ggplot2) library(patchwork) library(carData) #示例数据 head(Salaries) #教职工资情况 # rank discipline yrs.since.phd yrs.service sex salary # 1 Prof B 19 18 Male 139750 # 2 Prof B 20 16 Male 173200 # 3 AsstProf B 4 3 Male 79750 # 4 Prof B 45 39 Male 115000 # 5 Prof B 40 41 Male 141500 # 6 AssocProf B 6 6 Male 97000 table(Salaries$rank, Salaries$sex) # Female Male # AsstProf 11 56 # AssocProf 10 54 # Prof 18 248 2、基础用法 1 2 3 4 5 6 7 8 9 p1 = ggplot(Salaries, aes(x=rank)) + geom_bar() # 贴近x轴 p2 = ggplot(Salaries, aes(x=rank)) + geom_bar() + scale_y_continuous(expand=c(0,0)) # 映射填充颜色 p3 =ggplot(Salaries, aes(x=rank, fill=rank)) + geom_bar() p1 + p2 + p3 3、position=参数调整分组形式 1 2 3 4 5 6 7 8 # 默认 p1 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) + geom_bar(position=\u0026#34;stack\u0026#34;) + labs(title=\u0026#39;position=\u0026#34;stack\u0026#34;\u0026#39;) p2 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) + geom_bar(position=\u0026#34;dodge\u0026#34;) + labs(title=\u0026#39;position=\u0026#34;dodge\u0026#34;\u0026#39;) p3 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) + geom_bar(position=\u0026#34;fill\u0026#34;) + labs(title=\u0026#39;position=\u0026#34;fill\u0026#34;\u0026#39;) p1 + p2 + p3 + plot_layout(guides = \u0026#39;collect\u0026#39;) 4、stat=参数设置频数统计方式 stat=\u0026quot;count\u0026quot;(default) 表示从给定的数据里，统计每个类别出现的次数； 此时aes()只需要给定x参数即可； stat=\u0026quot;identity\u0026quot;表示直接指定每种类别的频数； 此时aes()除了需要给定x参数交代类别，还需要指定y参数表示频数值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(tidyverse) dat = Salaries %\u0026gt;% group_by(rank) %\u0026gt;% dplyr::summarise(n=n()) %\u0026gt;% as.data.frame() dat # rank n # 1 AsstProf 67 # 2 AssocProf 64 # 3 Prof 266 p1 = ggplot(dat, aes(x=rank, y=n, fill=rank)) + geom_bar(stat = \u0026#34;identity\u0026#34;) dat = Salaries %\u0026gt;% group_by(rank,sex) %\u0026gt;% dplyr::summarise(n=n()) %\u0026gt;% as.data.frame() dat # rank sex n # 1 AsstProf Female 11 # 2 AsstProf Male 56 # 3 AssocProf Female 10 # 4 AssocProf Male 54 # 5 Prof Female 18 # 6 Prof Male 248 p2 = ggplot(dat, aes(x=rank, y=n, fill=sex)) + geom_bar(stat = \u0026#34;identity\u0026#34;) p1 + p2 5、geom_text()添加频数注释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dat = Salaries %\u0026gt;% group_by(rank) %\u0026gt;% dplyr::summarise(n=n()) p1=ggplot(dat, aes(x=rank, y=n)) + geom_bar(stat=\u0026#34;identity\u0026#34;) + geom_text(aes(label=n), vjust = -0.2) # vjust\u0026lt;0,上移；vjust\u0026gt;0,下移 dat = Salaries %\u0026gt;% group_by(rank,sex) %\u0026gt;% dplyr::summarise(n=n()) p2=ggplot(dat, aes(x=rank, y=n, fill=sex)) + geom_bar(stat=\u0026#34;identity\u0026#34;, position = \u0026#34;dodge\u0026#34;) + geom_text(aes(label=n), vjust = -0.2, position=position_dodge(width=0.9)) p1 + p2 6、调整柱子的顺序 如果只有一种分组方式，通过设置类别的因子水平即可。 或者使用scale_x_discrete(c(.....))自定义顺序也可以实现很方便的修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ggplot(Salaries, aes(x=rank)) + geom_bar() + scale_x_discrete(limits=c(\u0026#34;AsstProf\u0026#34;, \u0026#34;AssocProf\u0026#34;, \u0026#34;Prof\u0026#34;)) p1=ggplot(iris, aes(x=Species, y=Sepal.Width)) + geom_boxplot() + ggtitle(\u0026#34;default factor levels\u0026#34;) p2=ggplot(iris, aes(x=fct_reorder(Species, Sepal.Width), y=Sepal.Width)) + geom_boxplot() + ggtitle(\u0026#34;fct_reorder default levels\u0026#34;) p3=ggplot(iris, aes(x=fct_reorder(Species, Sepal.Width, .desc=T), y=Sepal.Width)) + geom_boxplot() + ggtitle(\u0026#34;fct_reorder descent levels\u0026#34;) library(patchwork) p1 | p2 | p3 但如果更复杂的情况\u0026ndash;组内排序。 例：5个学生的三门课程成绩，按照每门学科分组，将5个学生按照成绩从低到高排序(或者从高到低排序)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 grade = data.frame( subject=rep(c(\u0026#34;Chineses\u0026#34;,\u0026#34;Math\u0026#34;,\u0026#34;English\u0026#34;), each=5), name=rep(c(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;),3), score=c(79,65,70,94,82,76,87,80,81,89,88,79,82,95,90)) # 先按学科均分从高到低 # 然后每个学科内,成绩从低到高学生排序 grade$subject=fct_reorder(grade$subject, grade$score, .desc=T) library(tidytext) p1 = ggplot(grade, aes(x=reorder_within(name,score,subject), y=score, fill=name)) + geom_bar(stat = \u0026#34;identity\u0026#34;) + scale_x_reordered() + facet_wrap(subject~. ,scales = \u0026#34;free_x\u0026#34;) # 先按学科均分从低到高 # 然后每个学科内,成绩从高到低学生排序 grade$subject=fct_reorder(grade$subject, grade$score, .desc=F) library(tidytext) p2 = ggplot(grade, aes(x=reorder_within(name,-score,subject), y=score, fill=name)) + geom_bar(stat = \u0026#34;identity\u0026#34;) + scale_x_reordered() + facet_wrap(subject~. ,scales = \u0026#34;free_x\u0026#34;) p1 + p2 + plot_layout(guides = \u0026#39;collect\u0026#39;) 注意reorder_within(个体,值,分组)，还需要设置scale_x_reordered() , facet_wrap(variable~. ,scales = \u0026quot;free_x\u0026quot;)\n7、双向柱状图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dat = Salaries %\u0026gt;% group_by(rank,sex) %\u0026gt;% dplyr::summarise(n=n()) dat_m = dat %\u0026gt;% filter(sex==\u0026#34;Male\u0026#34;) %\u0026gt;% mutate(lab=n) %\u0026gt;% as.data.frame() dat_f = dat %\u0026gt;% filter(sex==\u0026#34;Female\u0026#34;) %\u0026gt;% mutate(lab=-1*n) %\u0026gt;% as.data.frame() #注意要取相反值 ggplot() + geom_bar(data=dat_m, aes(x=rank, y=lab, fill=sex), stat = \u0026#34;identity\u0026#34;, position = \u0026#39;dodge\u0026#39;) + geom_text(data=dat_m, aes(x=rank, y=lab, label=n, vjust=-0.25)) + geom_bar(data=dat_f, aes(x=rank, y=lab, fill=sex), stat = \u0026#34;identity\u0026#34;, position = \u0026#39;dodge\u0026#39;) + geom_text(data=dat_f, aes(x=rank, y=lab, label=n, vjust=1.25)) + scale_y_continuous(breaks=c(200, 100, 0, -20), labels=c(\u0026#34;200\u0026#34;, \u0026#34;100\u0026#34;, \u0026#34;0\u0026#34;,\u0026#34;20\u0026#34;)) + scale_fill_manual(values=c(\u0026#34;#0072B5\u0026#34;,\u0026#34;#BC3C28\u0026#34;)) 8、误差棒error bar 使用上面第6点的示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #首先定义可以计算分组离散变量的均值与sd值的函数 data_summary \u0026lt;- function(data, varname, groupnames){ require(plyr) summary_func \u0026lt;- function(x, col){ c(mean = mean(x[[col]], na.rm=TRUE), sd = sd(x[[col]], na.rm=TRUE)) } data_sum\u0026lt;-ddply(data, groupnames, .fun=summary_func, varname) data_sum \u0026lt;- rename(data_sum, c(\u0026#34;mean\u0026#34; = varname)) return(data_sum) } df1 = data_summary(grade, varname=\u0026#34;score\u0026#34;, groupnames=c(\u0026#34;subject\u0026#34;)) # subject score sd # 1 Chineses 69.2 12.716131 # 2 Math 84.4 8.561542 # 3 English 85.8 5.019960 p1=ggplot(df1, aes(x=subject, y=score)) + geom_bar(stat=\u0026#34;identity\u0026#34;, color=\u0026#34;black\u0026#34;) + geom_errorbar(aes(ymin=score-sd, ymax=score+sd), width=.2) #双向 p2=ggplot(df1, aes(x=subject, y=score)) + geom_bar(stat=\u0026#34;identity\u0026#34;, color=\u0026#34;black\u0026#34;) + geom_errorbar(aes(ymin=score, ymax=score+sd), width=.2) #单向 p1 + p2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 df2 \u0026lt;- data_summary(Salaries, varname=\u0026#34;salary\u0026#34;, groupnames=c(\u0026#34;rank\u0026#34;, \u0026#34;sex\u0026#34;)) # rank sex salary sd # 1 AsstProf Female 78049.91 9371.996 # 2 AsstProf Male 81311.46 7901.343 # 3 AssocProf Female 88512.80 17965.286 # 4 AssocProf Male 94869.70 12890.817 # 5 Prof Female 121967.61 19619.583 # 6 Prof Male 127120.82 28213.808 ggplot(df2, aes(x=rank, y=salary, fill=sex)) + geom_bar(stat=\u0026#34;identity\u0026#34;, color=\u0026#34;black\u0026#34;, position=position_dodge()) + geom_errorbar(aes(ymin=salary-sd, ymax=salary+sd), width=.2, position=position_dodge(0.9)) + theme_classic() + scale_fill_manual(values=c(\u0026#39;#999999\u0026#39;,\u0026#39;#E69F00\u0026#39;)) ","permalink":"https://lishensuo.github.io/en/posts/program/217ggplot%E7%BB%98%E5%88%B6%E5%B8%B8%E8%A7%84%E6%9F%B1%E7%8A%B6%E5%9B%BEbarplot/","summary":"\u003ch2 id=\"1示例数据\"\u003e1、示例数据\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggplot2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(patchwork)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(carData) \u003cspan style=\"color:#007f7f\"\u003e#示例数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(Salaries) \u003cspan style=\"color:#007f7f\"\u003e#教职工资情况\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        rank discipline yrs.since.phd yrs.service  sex salary\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1      Prof          B            19          18 Male 139750\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2      Prof          B            20          16 Male 173200\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3  AsstProf          B             4           3 Male  79750\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4      Prof          B            45          39 Male 115000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5      Prof          B            40          41 Male 141500\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 AssocProf          B             6           6 Male  97000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etable(Salaries$rank, Salaries$sex)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#           Female Male\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# AsstProf      11   56\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# AssocProf     10   54\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Prof          18  248\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2基础用法\"\u003e2、基础用法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = ggplot(Salaries, aes(x=rank)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 贴近x轴\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = ggplot(Salaries, aes(x=rank)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar() + scale_y_continuous(expand=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 映射填充颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep3 =ggplot(Salaries, aes(x=rank, fill=rank)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 + p2 + p3\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-67ebf8365f56dd39.png\" style=\"zoom: 50%;\" /\u003e\r\n\u003ch2 id=\"3position参数调整分组形式\"\u003e3、\u003ccode\u003eposition=\u003c/code\u003e参数调整分组形式\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 默认\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(position=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;stack\u0026#34;\u003c/span\u003e) + labs(title=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;position=\u0026#34;stack\u0026#34;\u0026#39;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(position=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dodge\u0026#34;\u003c/span\u003e) + labs(title=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;position=\u0026#34;dodge\u0026#34;\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep3 \u0026lt;- ggplot(Salaries, aes(x=rank, fill=sex)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(position=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;fill\u0026#34;\u003c/span\u003e) + labs(title=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;position=\u0026#34;fill\u0026#34;\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 + p2 + p3 + plot_layout(guides = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;collect\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-3c933e373420a2e0.png\" style=\"zoom:50%;\" /\u003e\r\n\u003ch2 id=\"4stat参数设置频数统计方式\"\u003e4、\u003ccode\u003estat=\u003c/code\u003e参数设置频数统计方式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003estat=\u0026quot;count\u0026quot;\u003c/code\u003e(default) 表示从给定的数据里，统计每个类别出现的次数；\n\u003cul\u003e\n\u003cli\u003e此时\u003ccode\u003eaes()\u003c/code\u003e只需要给定\u003ccode\u003ex\u003c/code\u003e参数即可；\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003estat=\u0026quot;identity\u0026quot;\u003c/code\u003e表示直接指定每种类别的频数；\n\u003cul\u003e\n\u003cli\u003e此时\u003ccode\u003eaes()\u003c/code\u003e除了需要给定\u003ccode\u003ex\u003c/code\u003e参数交代类别，还需要指定\u003ccode\u003ey\u003c/code\u003e参数表示频数值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edat = Salaries %\u0026gt;% group_by(rank) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::summarise(n=n()) %\u0026gt;% as.data.frame()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edat\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        rank   n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  AsstProf  67\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 AssocProf  64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3      Prof 266\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = ggplot(dat, aes(x=rank, y=n, fill=rank)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edat = Salaries %\u0026gt;% group_by(rank,sex) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::summarise(n=n()) %\u0026gt;% as.data.frame()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edat\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        rank    sex   n\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  AsstProf Female  11\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2  AsstProf   Male  56\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3 AssocProf Female  10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4 AssocProf   Male  54\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5      Prof Female  18\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6      Prof   Male 248\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = ggplot(dat, aes(x=rank, y=n, fill=sex)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 + p2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-1811f2c08d5d4f77.png\" style=\"zoom:50%;\" /\u003e\r\n\u003ch2 id=\"5geom_text添加频数注释\"\u003e5、\u003ccode\u003egeom_text()\u003c/code\u003e添加频数注释\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edat = Salaries %\u0026gt;% group_by(rank) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::summarise(n=n())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1=ggplot(dat, aes(x=rank, y=n)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_text(aes(label=n), vjust = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-0.2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#007f7f\"\u003e# vjust\u0026lt;0,上移；vjust\u0026gt;0,下移\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edat = Salaries %\u0026gt;% group_by(rank,sex) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::summarise(n=n())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2=ggplot(dat, aes(x=rank, y=n, fill=sex)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e, position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dodge\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_text(aes(label=n), vjust = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-0.2\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            position=position_dodge(width=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.9\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 + p2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-ad7f730796c5f32c.png\" style=\"zoom:50%;\" /\u003e\r\n\u003ch2 id=\"6调整柱子的顺序\"\u003e6、调整柱子的顺序\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e如果只有一种分组方式，通过设置类别的因子水平即可。\n\u003cul\u003e\n\u003cli\u003e或者使用\u003ccode\u003escale_x_discrete(c(.....))\u003c/code\u003e自定义顺序也可以实现很方便的修改\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(Salaries, aes(x=rank)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  scale_x_discrete(limits=c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;AsstProf\u0026#34;\u003c/span\u003e,  \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;AssocProf\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Prof\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1=ggplot(iris, aes(x=Species, y=Sepal.Width)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    geom_boxplot() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ggtitle(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;default factor levels\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2=ggplot(iris, aes(x=fct_reorder(Species, Sepal.Width), y=Sepal.Width)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    geom_boxplot() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ggtitle(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;fct_reorder default levels\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep3=ggplot(iris, aes(x=fct_reorder(Species, Sepal.Width, .desc=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eT\u003c/span\u003e), y=Sepal.Width)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    geom_boxplot() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    ggtitle(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;fct_reorder descent levels\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(patchwork)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 | p2 | p3\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e但如果更复杂的情况\u0026ndash;组内排序。\n\u003cul\u003e\n\u003cli\u003e例：5个学生的三门课程成绩，按照每门学科分组，将5个学生按照成绩从低到高排序(或者从高到低排序)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrade = data.frame(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  subject=rep(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Chineses\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Math\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;English\u0026#34;\u003c/span\u003e), each=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  name=rep(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;A\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;B\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;C\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;D\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;E\u0026#34;\u003c/span\u003e),\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  score=c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e79\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e65\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e70\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e94\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e82\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e76\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e87\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e80\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e81\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e89\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e88\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e79\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e82\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e95\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e90\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 先按学科均分从高到低\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 然后每个学科内,成绩从低到高学生排序\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrade$subject=fct_reorder(grade$subject, grade$score, .desc=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eT\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidytext)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = ggplot(grade, aes(x=reorder_within(name,score,subject), y=score, fill=name)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  scale_x_reordered() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  facet_wrap(subject~. ,scales = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;free_x\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 先按学科均分从低到高\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 然后每个学科内,成绩从高到低学生排序\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrade$subject=fct_reorder(grade$subject, grade$score, .desc=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eF\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidytext)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = ggplot(grade, aes(x=reorder_within(name,-score,subject), y=score, fill=name)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(stat = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  scale_x_reordered() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  facet_wrap(subject~. ,scales = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;free_x\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 + p2 + plot_layout(guides = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;collect\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e注意\u003ccode\u003ereorder_within(个体,值,分组)\u003c/code\u003e，还需要设置\u003ccode\u003escale_x_reordered() , facet_wrap(variable~. ,scales = \u0026quot;free_x\u0026quot;)\u003c/code\u003e\u003c/p\u003e","title":"R-可视化-ggplot绘制常规柱状图barplot"},{"content":"1、R中颜色的表示方式 1.1 颜色的名字 R内置了657种颜色的名字可供调用\nhttp://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\n1 2 3 4 5 6 7 8 9 10 11 str(colors()) # chr [1:657] \u0026#34;white\u0026#34; \u0026#34;aliceblue\u0026#34; \u0026#34;antiquewhite\u0026#34; ... head(colors()[1:10]) # [1] \u0026#34;white\u0026#34; \u0026#34;aliceblue\u0026#34; \u0026#34;antiquewhite\u0026#34; # [4] \u0026#34;antiquewhite1\u0026#34; \u0026#34;antiquewhite2\u0026#34; \u0026#34;antiquewhite3\u0026#34; set.seed(111) cols = sample(colors(), 5) numbers = 1:5; names(numbers) = cols barplot(numbers, col=cols) 关于透明色，虽然不在这657个颜色当中，可以通过transparent指定。\n1.2 十六进制颜色代码 16进制的颜色代码是将RGB颜色值的进制转换的表示方式，使用方便，颜色丰富，更加常用 RGB颜色值与十六进制颜色码转换工具：https://www.sioe.cn/yingyong/yanse-rgb-16/ 1 2 3 rainbow(3) # [1] \u0026#34;#FF0000\u0026#34; \u0026#34;#00FF00\u0026#34; \u0026#34;#0000FF\u0026#34; barplot(c(1:7), col=rainbow(7)) 2、色板系列 在理解上述颜色表示方法后，在实际绘图时，一般不会一一手动寻找合适的颜色，而是通过一些R包、网站提供好的，美观的颜色组合，即调色板（palette），可供使用。下面罗列下我目前常用的几种方式。\n2.1 RColorBrewer包 1 2 3 4 5 6 7 8 # install.packages(\u0026#34;RColorBrewer\u0026#34;) library(RColorBrewer) display.brewer.all() #default: type=\u0026#34;all\u0026#34; #仅展示离散类颜色组合 display.brewer.all(type=\u0026#34;qual\u0026#34;) #展示具体某一个组合 display.brewer.pal(n=12, name = \u0026#39;Set3\u0026#39;) 如上图所示，这个包提供了三类色板： （1）sequential【上】：渐变型（生成由浅入深的渐变色，适用于标注数值大小的情况）； （2）qualitative【中】：离散型（生成彼此差异明显的颜色，适用于分类数据）； （3）diverging【下】：发散型（生成深色强调两端、浅色表示中部的颜色，适用于标注数据中的离群点。）\n1 2 3 4 5 6 7 8 9 10 11 ##（1）对于离散类颜色，会自动返回前n个颜色 brewer.pal(n = 9, name = \u0026#34;Set1\u0026#34;) # [1] \u0026#34;#E41A1C\u0026#34; \u0026#34;#377EB8\u0026#34; \u0026#34;#4DAF4A\u0026#34; \u0026#34;#984EA3\u0026#34; \u0026#34;#FF7F00\u0026#34; \u0026#34;#FFFF33\u0026#34; \u0026#34;#A65628\u0026#34; \u0026#34;#F781BF\u0026#34; \u0026#34;#999999\u0026#34; brewer.pal(n = 3, name = \u0026#34;Set1\u0026#34;) # [1] \u0026#34;#E41A1C\u0026#34; \u0026#34;#377EB8\u0026#34; \u0026#34;#4DAF4A\u0026#34; ##（2）对于发散型和渐变型，会考虑整体配色方案，自动返回最合适的n个颜色 brewer.pal(n = 9, name = \u0026#34;Blues\u0026#34;) # [1] \u0026#34;#F7FBFF\u0026#34; \u0026#34;#DEEBF7\u0026#34; \u0026#34;#C6DBEF\u0026#34; \u0026#34;#9ECAE1\u0026#34; \u0026#34;#6BAED6\u0026#34; \u0026#34;#4292C6\u0026#34; \u0026#34;#2171B5\u0026#34; \u0026#34;#08519C\u0026#34; \u0026#34;#08306B\u0026#34; brewer.pal(n = 3, name = \u0026#34;Blues\u0026#34;) # [1] \u0026#34;#DEEBF7\u0026#34; \u0026#34;#9ECAE1\u0026#34; \u0026#34;#3182BD\u0026#34; 2.2 colorbrewer配色网站 https://colorbrewer2.org/ 非常值得安利的一个配色网站，也是大体分为如上三种色板。 其实使用起来很简单，就不总结了。也可以参看别人的笔记：https://zhuanlan.zhihu.com/p/27167989 2.3 ggsci包 自动对接ggplot2包，提供期刊杂志级别的配色方案； 使用十分简单，配合ggplot，只需要选择color还是fill，会自动根据变量类别确认配色； 具体使用方法也不介绍了，安装、加载，配合ggplot绘图即可。可参看官方教程：https://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html 2.4 其它备选方案 （1）viridis包 特点：色盲友好 官方介绍：https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html 中文介绍：https://zhuanlan.zhihu.com/p/81571392\n（2）paletteer包 特点：集成了目前已知所有配色R包的配色方案\n使用网址：https://emilhvitfeldt.github.io/r-color-palettes/discrete.html\n官方介绍：https://github.com/EmilHvitfeldt/paletteer 中文介绍：https://www.yuque.com/xiaojiewanglezenmofenshen/dbwkg1/ilbqqz\n","permalink":"https://lishensuo.github.io/en/posts/program/218%E7%BB%98%E5%9B%BE%E9%A2%9C%E8%89%B2%E4%B8%8E%E7%94%BB%E6%9D%BF%E7%9A%84%E9%80%89%E6%8B%A9/","summary":"\u003ch2 id=\"1r中颜色的表示方式\"\u003e1、R中颜色的表示方式\u003c/h2\u003e\n\u003ch3 id=\"11--颜色的名字\"\u003e1.1  颜色的名字\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eR内置了657种颜色的名字可供调用\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\"\u003ehttp://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estr(colors())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# chr [1:657] \u0026#34;white\u0026#34; \u0026#34;aliceblue\u0026#34; \u0026#34;antiquewhite\u0026#34; ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(colors()[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] \u0026#34;white\u0026#34;         \u0026#34;aliceblue\u0026#34;     \u0026#34;antiquewhite\u0026#34; \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [4] \u0026#34;antiquewhite1\u0026#34; \u0026#34;antiquewhite2\u0026#34; \u0026#34;antiquewhite3\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e111\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecols = sample(colors(), \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enumbers = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e; names(numbers) = cols\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebarplot(numbers, col=cols)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-3d4495bcbec94b10.png\" style=\"zoom:50%;\" /\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003e关于透明色，虽然不在这657个颜色当中，可以通过\u003ccode\u003etransparent\u003c/code\u003e指定。\u003c/p\u003e","title":"R-可视化-绘图颜色与画板的选择"},{"content":" 简单整理两个绘制热图R包的用法，分别是基础的pheatmap包与复杂的ComplexHeatmap包。\npheatmap 1 2 3 4 5 # install.packages(\u0026#34;pheatmap\u0026#34;) library(pheatmap) packageVersion(\u0026#34;pheatmap\u0026#34;) # [1] ‘1.0.12’ 0、 示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 exp = matrix(rnorm(300), nrow = 30, ncol = 10) set.seed(123) exp[1:15, 1:5] = exp[1:15, 1:5] + matrix(rnorm(75,mean = 4), nrow = 15, ncol = 5) set.seed(123) exp[16:30, 6:10] = exp[16:30, 6:10] + matrix(rnorm(75,mean = 3), nrow = 15, ncol = 5) exp = round(exp, 2) colnames(exp) = paste(\u0026#34;Sample\u0026#34;, 1:10, sep = \u0026#34;\u0026#34;) rownames(exp) = paste(\u0026#34;Gene\u0026#34;, 1:30, sep = \u0026#34;\u0026#34;) dim(exp) # [1] 30 10 head(exp) # Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 Sample7 Sample8 Sample9 Sample10 # Gene1 4.47 5.74 5.56 3.18 6.38 0.06 -0.09 0.13 0.70 -1.75 # Gene2 3.49 3.71 2.24 4.23 4.10 -0.70 1.08 0.22 -0.11 0.10 # Gene3 4.34 0.37 5.64 3.05 2.42 -0.72 0.63 1.64 -1.26 -0.57 # Gene4 4.25 4.32 6.79 5.30 2.37 0.88 -0.11 -0.22 1.68 -0.97 # Gene5 3.99 4.45 3.38 4.29 1.74 -1.02 -1.53 0.17 0.91 -0.18 # Gene6 5.72 2.36 5.39 4.04 6.50 1.96 -0.52 1.17 0.24 1.01 ##基础绘图 pheatmap(exp) 1、聚类相关参数 下述均是针对行row的操作，改为col即为针对列的操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## (1) 不聚类 pheatmap(exp, cluster_row = FALSE) ## (2) 聚类但显示聚类树 pheatmap(exp, treeheight_row = 0) ## (3) 距离计算公式 clustering_distance_rows = \u0026#34;euclidean\u0026#34; # \u0026#34;correlation\u0026#34; ## (4) 聚类间距离计算方法 clustering_method = \u0026#34;average\u0026#34; #\u0026#34;ward.D2\u0026#34;, \u0026#34;single\u0026#34;, \u0026#34;complete\u0026#34;等 ## (5) 获取聚类后热图的表达矩阵(改变了行列顺序) ph = pheatmap(exp) ph$tree_row$order ph$tree_col$order ph_exp = exp[ph$tree_row$order, ph$tree_col$order] ph_exp[1:4,1:4] # Sample3 Sample5 Sample2 Sample1 # Gene26 1.05 -0.57 1.44 -0.71 # Gene19 -1.01 -0.52 -0.26 -0.63 # Gene24 0.98 -1.24 -0.96 -0.24 # Gene18 0.33 1.23 -0.49 0.24 2、颜色相关 1 2 3 4 5 6 7 8 9 10 11 #Default colours = colorRampPalette(rev(RColorBrewer::brewer.pal(n = 7, name = \u0026#34;RdYlBu\u0026#34;)))(100) str(colours) # chr [1:100] \u0026#34;#4575B4\u0026#34; \u0026#34;#4979B6\u0026#34; \u0026#34;#4E7DB8\u0026#34; \u0026#34;#5282BB\u0026#34; \u0026#34;#5786BD\u0026#34; \u0026#34;#5C8BBF\u0026#34; \u0026#34;#608FC2\u0026#34; ... # 个性化修改 colours = colorRampPalette(c(\u0026#34;navy\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;firebrick3\u0026#34;))(10) #colours = colorRampPalette(c(\u0026#34;#3288bd\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;#d53e4f\u0026#34;))(10) str(colours) # chr [1:10] \u0026#34;#3288BD\u0026#34; \u0026#34;#5FA2CB\u0026#34; \u0026#34;#8DBCDA\u0026#34; \u0026#34;#BAD7E9\u0026#34; \u0026#34;#E8F1F7\u0026#34; \u0026#34;#FAE9EB\u0026#34; \u0026#34;#F1BEC4\u0026#34; ... pheatmap(exp, color = colours) 3、行列注释 为annotation_col=，annotation_row=参数提供data.frame\n行名与表达矩阵的行名与列名相同； 列的内容为分组信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 构建列注释信息（行名与表达矩阵的列名col保持一致） annotation_col = data.frame( group = rep(c(\u0026#34;Group_A\u0026#34;, \u0026#34;Group_B\u0026#34;), each = 5), row.names = colnames(exp)) head(annotation_col) # 构建行注释信息（行名与表达矩阵的行名row保持一致） annotation_row = data.frame( Type = rep(c(\u0026#34;Up\u0026#34;, \u0026#34;Down\u0026#34;), each = 15), row.names = rownames(exp)) head(annotation_row) pheatmap(exp, annotation_col = annotation_col, annotation_row = annotation_row) 1 2 3 4 5 6 7 8 #修改注释标签的颜色 ann_colors = list( group = c(Group_A = \u0026#34;#e66101\u0026#34;, Group_B = \u0026#34;#5e3c99\u0026#34;), Type = c(Up = \u0026#34;#e7298a\u0026#34;, Down = \u0026#34;#66a61e\u0026#34;)) pheatmap(exp, annotation_col = annotation_col, annotation_row = annotation_row, annotation_colors = ann_colors) 4、热图格子相关 （1）格子边框 格子的边框颜色border_color=；无边框border=F 格子的长宽cellwidth = 15, cellheight = 12 1 2 pheatmap(exp, border_color = \u0026#34;white\u0026#34;, cellwidth = 9, cellheight = 9) （2）文本填充 1 2 3 4 5 6 7 8 9 # 默认使用绘制热图值的矩阵 pheatmap(exp, display_numbers = TRUE, number_color = \u0026#34;blue\u0026#34;, number_format = \u0026#34;%.1e\u0026#34;) #default \u0026#34;%.2f\u0026#34; # 自定义填充内容 pheatmap(exp, display_numbers = matrix(ifelse(exp \u0026gt; 5, exp, \u0026#34;\u0026#34;), nrow(exp))) pheatmap(exp, display_numbers = matrix(ifelse(exp \u0026gt; 5, \u0026#34;*\u0026#34;, \u0026#34;\u0026#34;), nrow(exp))) （3） 切割热图 1 2 3 4 5 6 7 8 9 10 #(1) 根据聚类树，按指定数目进行分割 pheatmap(exp, cutree_cols = 2, cutree_rows = 4) #(2) 指定行/列数进行分割，前提是要取消聚类 pheatmap(exp, cluster_rows = FALSE,cluster_cols = FALSE, gaps_row = c(10, 20), gaps_col = 5) 5、行列名的调整 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # (1) 不显示行名与列名 pheatmap(exp, show_rownames=F, show_colnames=F) # (2) 调整列名的角度，只能是“270”, “0”, “45”, “90”, “315”中的一种。不可调整行名 pheatmap(exp, angle_col = 45) # (3) 字体大小 pheatmap(exp, fontsize_row = 12,fontsize_col = 8) # (4) 仅特定显示部分行名 # 注意：由于聚类的原因，一定要注意对应的顺序 match(c(\u0026#34;Gene1\u0026#34;,\u0026#34;Gene2\u0026#34;,\u0026#34;Gene3\u0026#34;), rownames(exp)[pheatmap(exp)$tree_row$order]) # [1] 19 29 24 labels_row = rep(\u0026#34;\u0026#34;, nrow(exp)) labels_row[c(19, 29, 24)] = c(\u0026#34;Gene1\u0026#34;,\u0026#34;Gene2\u0026#34;,\u0026#34;Gene3\u0026#34;) pheatmap(exp, labels_row = labels_row) 6、其它 （1）按行按列归一化 默认按照原始值可视化。\n可通过scale = c(\u0026quot;row\u0026quot;, \u0026quot;column\u0026quot;)参数设置按照行或者列进行归一化之后的结果绘图\n1 2 3 4 5 6 pheatmap(exp, scale = \u0026#34;row\u0026#34;) # scale_rows = function(x){ # m = apply(x, 1, mean, na.rm = T) # s = apply(x, 1, sd, na.rm = T) # return((x - m) / s) # } （2）转为ggplot2对象 1 2 3 4 library(ggplot2) library(ggplotify) g = as.ggplot(pheatmap(exp)) g + ggtitle(\u0026#34;This is a ggplot object\u0026#34;) ComplexHeatmap ComplexHeatmap包绘制热图的主要函数为Heatmap()；其次也提供了pheatmap()函数可实现上述的所有功能。\nhttps://jokergoo.github.io/ComplexHeatmap-reference/book/\n1、基础 1 2 3 4 5 6 7 8 9 10 # BiocManager::install(\u0026#34;ComplexHeatmap\u0026#34;) library(ComplexHeatmap) Heatmap(exp) Heatmap(exp, name = \u0026#34;Test\u0026#34;) # name= 交代legend title, 同时也是unique identifier for the heatmap hp = Heatmap(exp) grob = grid.grabExpr(draw(hp)) g = ggplotify::as.ggplot(grob) # 转为ggplot2对象，可用于后续的拼图 2、设置颜色 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ##(1) 连续变量 library(circlize) # col_fun = colorRamp2(c(min(exp), 0, max(exp)), c(\u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;red\u0026#34;)) col_fun = colorRamp2(c(-5, 0, 5), c(\u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;red\u0026#34;)) ## 小于-2的均为green、大于2的均为red，如此可避免离群值的影响 ## na_col = \u0026#34;black\u0026#34; 可用于单独设置缺失值颜色 Heatmap(exp, name = \u0026#34;Test\u0026#34;, col = col_fun) ##(2) 离散变量 mat = matrix(sample(LETTERS[1:6], 15, replace = T), nrow = 5, byrow = TRUE, dimnames = list(c(\u0026#34;Row-1\u0026#34;,\u0026#34;Row-2\u0026#34;,\u0026#34;Row-3\u0026#34;,\u0026#34;Row-4\u0026#34;,\u0026#34;Row-5\u0026#34;), c(\u0026#34;Col-1\u0026#34;,\u0026#34;Col-2\u0026#34;,\u0026#34;Col-3\u0026#34;))) colors = RColorBrewer::brewer.pal(n = 6, name = \u0026#34;Set1\u0026#34;) names(colors) = LETTERS[1:6] colors # A B C D E F # \u0026#34;#E41A1C\u0026#34; \u0026#34;#377EB8\u0026#34; \u0026#34;#4DAF4A\u0026#34; \u0026#34;#984EA3\u0026#34; \u0026#34;#FF7F00\u0026#34; \u0026#34;#FFFF33\u0026#34; Heatmap(mat, name = \u0026#34;Test\u0026#34;, col = colors) # rect_gp = gpar(col = \u0026#34;white\u0026#34;, lwd = 1) # 用于设置热图格子内边框颜色、宽度 3、设置行列标题 如下为column的演示，row的参数对应相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 column_title = \u0026#34;This is a column title\u0026#34; #标题内容 column_title_side = c(\u0026#34;top\u0026#34;, \u0026#34;bottom\u0026#34;) #标题位置 #标题格式 column_title_gp = gpar(fontsize = 20, #大小 fontface = \u0026#34;bold\u0026#34;, #字体 col = \u0026#34;white\u0026#34;, #文本颜色 fill = \u0026#34;red\u0026#34;, #填充颜色 border = \u0026#34;blue\u0026#34;) #边框颜色 column_title_rot = 0 #旋转角度，支持水平/垂直 Heatmap(exp, name = \u0026#34;Test\u0026#34;, column_title = \u0026#34;This is a column title\u0026#34;, column_title_side = \u0026#34;top\u0026#34;, column_title_gp = gpar(fontsize = 20)) #当设置填充颜色时，需要预先设置如下参数，使得标题位于中心 # ht_opt$TITLE_PADDING = unit(c(8.5, 8.5), \u0026#34;points\u0026#34;) # ht_opt(RESET = TRUE) 4、设置行名与列名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 show_row_names = FALSE #是否显示 row_names_side = \u0026#34;left\u0026#34; #两边位置 row_names_gp = gpar(fontsize = 20, #大小 col = c(rep(\u0026#34;red\u0026#34;, 10), rep(\u0026#34;blue\u0026#34;, 8))) #颜色 row_names_rot = -45 #旋转角度 row_names_centered = TRUE #是否居中对齐 row_labels = NULL #替换显示的名字 row_labels = paste0(\u0026#34;Row-\u0026#34;,1:30) names(row_labels) = rownames(exp) Heatmap(exp, name = \u0026#34;Test\u0026#34;, row_names_rot = -30, row_labels = row_labels[rownames(exp)]) 5、聚类相关 如下为column的演示，row的参数对应相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 不聚类 cluster_columns = FALSE # 不显示聚类 show_column_dend = FALSE # 聚类树位置 column_dend_side = \u0026#34;bottom\u0026#34; # 树的高度 column_dend_height = unit(4, \u0026#34;cm\u0026#34;) # 聚类算法，可自定义 clustering_distance_columns = \u0026#34;euclidean\u0026#34; #default # 距离计算方式 clustering_method_columns = \u0026#34;complete\u0026#34; #default # 手动设置行列的顺序，此时会自动关闭相应的聚类操作 column_order = 10:1 6、分割热图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # column_split = factor(rep(c(\u0026#34;GroupA\u0026#34;, \u0026#34;GroupB\u0026#34;), each=5), # levels = c(\u0026#34;GroupB\u0026#34;, \u0026#34;GroupA\u0026#34;)) column_split = rep(c(\u0026#34;GroupA\u0026#34;, \u0026#34;GroupB\u0026#34;), each=5) #设置分组字符串变量 column_title = c(\u0026#34;AA\u0026#34;, \u0026#34;BB\u0026#34;) #自定义小组名 column_title = NULL #取消小组名 column_gap = unit(5, \u0026#34;mm\u0026#34;) #设置gap的宽度 ## 默认仍然进行聚类:先在小组中进行聚类；然后再进行组之间的聚类 show_parent_dend_line = FALSE ## 仅在小组内聚类；不进行组之间的聚类 cluster_column_slices = FALSE row_km = 2 #按K均值聚类分割 row_split = 2 #按原始聚类树结果分割 7、其它 （1）文本填充 1 2 3 4 5 6 7 Heatmap(exp, name = \u0026#34;Test\u0026#34;, cell_fun = function(j, i, x, y, width, height, fill) { if(exp[i, j] \u0026gt; 0) #仅显示正值 grid.text(sprintf(\u0026#34;%.1f\u0026#34;, exp[i, j]), #具体填充的文本值 x, y, #填充在热图的位置 gp = gpar(fontsize = 10)) }) （2）图的大小 1 2 3 4 5 6 #整个图的大小 heatmap_width = unit(8, \u0026#34;cm\u0026#34;) heatmap_height = unit(8, \u0026#34;cm\u0026#34;) #热图的大小 width = unit(8, \u0026#34;cm\u0026#34;) height = unit(8, \u0026#34;cm\u0026#34;) （3）从热图对象中获取信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ht = Heatmap(exp) ht2 = draw(ht) row_order(ht2) #[1] 6 1 7 4 14 9 10 8 15 11 2 13 5 12 3 26 24 19 18 21 29 25 30 22 17 16 20 23 28 27 ht = Heatmap(exp, row_km = 3) ht2 = draw(ht) row_order(ht2) # $`3` # [1] 6 1 7 4 14 9 10 8 15 11 2 13 5 12 3 # # $`2` # [1] 29 26 24 19 25 # # $`1` # [1] 18 21 22 17 20 23 28 16 30 27 8、热图注释anno (1) simple_anno 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 set.seed(123) mat = matrix(rnorm(36), 6) rownames(mat) = paste0(\u0026#34;R\u0026#34;, 1:6) colnames(mat) = paste0(\u0026#34;C\u0026#34;, 1:6) library(circlize) col_fun = colorRamp2(c(-1,0,1), c(\u0026#34;blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;red\u0026#34;)) column_ha = HeatmapAnnotation(Anno1 = rnorm(6), Anno2 = rep(c(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;),each=3), # 设定颜色 col = list(Anno1 = col_fun, Anno2 = c(\u0026#34;A\u0026#34; = \u0026#34;red\u0026#34;, \u0026#34;B\u0026#34; = \u0026#34;green\u0026#34;)), # 设定宽度 simple_anno_size = unit(1, \u0026#34;cm\u0026#34;) ) Heatmap(mat, name = \u0026#34;mat\u0026#34;, top_annotation = column_ha) # top_annotation # bottom_annotation # left_annotation # right_annotation 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 set.seed(123) pvalue = 10^(-runif(6, min = 0, max = 3)) pch = rep(\u0026#34;*\u0026#34;, 10) pch[pvalue \u0026gt; 0.01] = NA # [1] \u0026#34;*\u0026#34; NA \u0026#34;*\u0026#34; NA NA \u0026#34;*\u0026#34; \u0026#34;*\u0026#34; NA \u0026#34;*\u0026#34; NA pvalue_col_fun = colorRamp2(c(0, 2, 3), c(\u0026#34;green\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;red\u0026#34;)) column_ha = HeatmapAnnotation(pvalue = anno_simple(-log10(pvalue), col = pvalue_col_fun, pch = pch)) Heatmap(mat, name = \u0026#34;mat\u0026#34;, top_annotation = column_ha) lgd_pvalue = Legend(title = \u0026#34;p-value\u0026#34;, col_fun = pvalue_col_fun, at = c(0, 1, 2, 3), labels = c(\u0026#34;1\u0026#34;, \u0026#34;0.1\u0026#34;, \u0026#34;0.01\u0026#34;, \u0026#34;0.001\u0026#34;)) lgd_sig = Legend(pch = \u0026#34;*\u0026#34;, type = \u0026#34;points\u0026#34;, labels = \u0026#34;\u0026lt; 0.01\u0026#34;) draw(Heatmap(mat, name = \u0026#34;mat\u0026#34;, top_annotation = column_ha, column_split = 2), annotation_legend_list = list(lgd_pvalue, lgd_sig)) (2) anno_block anno_block 在分割热图时，注释每一个分组信息\n1 2 3 4 5 6 7 8 9 10 ha = HeatmapAnnotation( Anno1 = anno_block(gp = gpar(fill = c(\u0026#34;Red\u0026#34;,\u0026#34;Green\u0026#34;)), labels = c(\u0026#34;Group1\u0026#34;, \u0026#34;Group2\u0026#34;), labels_gp = gpar(col = \u0026#34;white\u0026#34;, fontsize = 15)) ) Heatmap(mat, column_split = 2, column_title = NULL, show_column_dend = FALSE, top_annotation = ha) (3) anno_barplot 还有很多其它anno_*系列函数\nhttps://jokergoo.github.io/ComplexHeatmap-reference/book/heatmap-annotations.html\n以anno_barplot()为例\n1 2 3 4 5 6 ?anno_barplot ha = rowAnnotation( Anno1 = anno_barplot(rnorm(6), baseline = 0) ) Heatmap(mat, right_annotation = ha) (4) anno_mark 1 2 3 4 5 6 7 ha = rowAnnotation(foo = anno_mark(at = c(1:4, 20, 29:30), labels = paste0(\u0026#34;Gene\u0026#34;,c(1:4, 20, 29:30)))) Heatmap(exp, name = \u0026#34;mat\u0026#34;, cluster_rows = FALSE, right_annotation = ha, row_names_side = \u0026#34;left\u0026#34;, row_names_gp = gpar(fontsize = 4)) 9、设置legend 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ##(1) 连续变量legend Heatmap(mat, heatmap_legend_param = list( col_fun = col_fun, title = \u0026#34;Test\u0026#34;, at = c(-2, 0, 1.9,2), labels = c(\u0026#34;neg_two\u0026#34;, \u0026#34;zero\u0026#34;, \u0026#34;any_posi(1.9)\u0026#34;,\u0026#34;pos_two\u0026#34;), legend_height = unit(6, \u0026#34;cm\u0026#34;), grid_width = unit(1, \u0026#34;cm\u0026#34;)) ) ##(2) 离散变量legend mat2 = matrix(sample(LETTERS[1:6], 15, replace = T), nrow = 5, byrow = TRUE, dimnames = list(c(\u0026#34;Row-1\u0026#34;,\u0026#34;Row-2\u0026#34;,\u0026#34;Row-3\u0026#34;,\u0026#34;Row-4\u0026#34;,\u0026#34;Row-5\u0026#34;), c(\u0026#34;Col-1\u0026#34;,\u0026#34;Col-2\u0026#34;,\u0026#34;Col-3\u0026#34;))) colors = RColorBrewer::brewer.pal(n = 6, name = \u0026#34;Set1\u0026#34;) names(colors) = LETTERS[1:6] colors Heatmap(mat2, col = colors, heatmap_legend_param = list( title = \u0026#34;AAA\u0026#34;, at = LETTERS[1:6], labels = LETTERS[1:6], ncol = 2, by_row = TRUE, legend_gp = gpar(fill = colors), grid_height = unit(1, \u0026#34;cm\u0026#34;), grid_width = unit(5, \u0026#34;mm\u0026#34;), row_gap = unit(1, \u0026#34;mm\u0026#34;) ) ) ","permalink":"https://lishensuo.github.io/en/posts/program/219r-%E5%8F%AF%E8%A7%86%E5%8C%96--%E7%83%AD%E5%9B%BEheatmap/","summary":"\u003cblockquote\u003e\n\u003cp\u003e简单整理两个绘制热图R包的用法，分别是基础的\u003ccode\u003epheatmap\u003c/code\u003e包与复杂的\u003ccode\u003eComplexHeatmap\u003c/code\u003e包。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"pheatmap\"\u003epheatmap\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# install.packages(\u0026#34;pheatmap\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(pheatmap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epackageVersion(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;pheatmap\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] ‘1.0.12’\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"0-示例数据\"\u003e0、 示例数据\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexp = matrix(rnorm(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e300\u003c/span\u003e), nrow = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, ncol = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e123\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexp[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e] = exp[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e] + matrix(rnorm(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e75\u003c/span\u003e,mean = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e), nrow = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e, ncol = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e123\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexp[16:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e] = exp[16:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e] + matrix(rnorm(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e75\u003c/span\u003e,mean = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e), nrow = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e15\u003c/span\u003e, ncol = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexp = round(exp, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecolnames(exp) = paste(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Sample\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, sep = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erownames(exp) = paste(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Gene\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e, sep = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(exp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 30 10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(exp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#       Sample1 Sample2 Sample3 Sample4 Sample5 Sample6 Sample7 Sample8 Sample9 Sample10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene1    4.47    5.74    5.56    3.18    6.38    0.06   -0.09    0.13    0.70    -1.75\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene2    3.49    3.71    2.24    4.23    4.10   -0.70    1.08    0.22   -0.11     0.10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene3    4.34    0.37    5.64    3.05    2.42   -0.72    0.63    1.64   -1.26    -0.57\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene4    4.25    4.32    6.79    5.30    2.37    0.88   -0.11   -0.22    1.68    -0.97\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene5    3.99    4.45    3.38    4.29    1.74   -1.02   -1.53    0.17    0.91    -0.18\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene6    5.72    2.36    5.39    4.04    6.50    1.96   -0.52    1.17    0.24     1.01\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##基础绘图\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epheatmap(exp)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220612134929311.png\" alt=\"image-20220612134929311\" style=\"zoom:67%;\" /\u003e\r\n\u003ch2 id=\"1聚类相关参数\"\u003e1、聚类相关参数\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e下述均是针对行\u003ccode\u003erow\u003c/code\u003e的操作，改为\u003ccode\u003ecol\u003c/code\u003e即为针对列的操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) 不聚类\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epheatmap(exp, cluster_row = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) 聚类但显示聚类树\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epheatmap(exp, treeheight_row = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (3) 距离计算公式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclustering_distance_rows = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;euclidean\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#007f7f\"\u003e# \u0026#34;correlation\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (4) 聚类间距离计算方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclustering_method = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;average\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#007f7f\"\u003e#\u0026#34;ward.D2\u0026#34;, \u0026#34;single\u0026#34;, \u0026#34;complete\u0026#34;等\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (5) 获取聚类后热图的表达矩阵(改变了行列顺序)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eph = pheatmap(exp)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eph$tree_row$order\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eph$tree_col$order\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eph_exp = exp[ph$tree_row$order, ph$tree_col$order]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eph_exp[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#        Sample3 Sample5 Sample2 Sample1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene26    1.05   -0.57    1.44   -0.71\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene19   -1.01   -0.52   -0.26   -0.63\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene24    0.98   -1.24   -0.96   -0.24\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Gene18    0.33    1.23   -0.49    0.24\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2颜色相关\"\u003e2、颜色相关\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#Default\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecolours = colorRampPalette(rev(RColorBrewer::brewer.pal(n = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e7\u003c/span\u003e, name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RdYlBu\u0026#34;\u003c/span\u003e)))(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estr(colours)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# chr [1:100] \u0026#34;#4575B4\u0026#34; \u0026#34;#4979B6\u0026#34; \u0026#34;#4E7DB8\u0026#34; \u0026#34;#5282BB\u0026#34; \u0026#34;#5786BD\u0026#34; \u0026#34;#5C8BBF\u0026#34; \u0026#34;#608FC2\u0026#34; ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 个性化修改\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecolours = colorRampPalette(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;navy\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;white\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;firebrick3\u0026#34;\u003c/span\u003e))(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#colours = colorRampPalette(c(\u0026#34;#3288bd\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;#d53e4f\u0026#34;))(10)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003estr(colours)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# chr [1:10] \u0026#34;#3288BD\u0026#34; \u0026#34;#5FA2CB\u0026#34; \u0026#34;#8DBCDA\u0026#34; \u0026#34;#BAD7E9\u0026#34; \u0026#34;#E8F1F7\u0026#34; \u0026#34;#FAE9EB\u0026#34; \u0026#34;#F1BEC4\u0026#34; ...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epheatmap(exp, color = colours)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220612135430912.png\" alt=\"image-20220612135430912\"  /\u003e\r\n\u003c/p\u003e","title":"可视化-R--热图heatmap"},{"content":"弦图常用于表示两组或多组成员之间的连接关系。如下简单学习circlize包ChordDiagram()绘制弦图的基础用法\n参考教程：https://jokergoo.github.io/circlize_book/book/the-chorddiagram-function.html 0、数据输入 对于matrix：\n默认row组表示sender，column表示receiver，矩阵值表示link的强度； 对于data.frame\n默认第一列表示sender，第二列表示receiver，第三列表示link的强度 之后的示例学习中主要以matrix的用法为主。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ## (1) matrix set.seed(999) mat = matrix(sample(18, 18), 3, 6) rownames(mat) = paste0(\u0026#34;S\u0026#34;, 1:3) colnames(mat) = paste0(\u0026#34;E\u0026#34;, 1:6) mat # E1 E2 E3 E4 E5 E6 # S1 4 14 13 17 5 2 # S2 7 1 6 8 12 15 # S3 9 10 3 16 11 18 ## (2) data.frame df = data.frame(from = rep(rownames(mat), times = ncol(mat)), to = rep(colnames(mat), each = nrow(mat)), value = as.vector(mat), stringsAsFactors = FALSE) head(df) # from to value # 1 S1 E1 4 # 2 S2 E1 7 # 3 S3 E1 9 # 4 S1 E2 14 # 5 S2 E2 1 # 6 S3 E2 10 1、构图要素 1 2 3 4 5 6 library(circlize) chordDiagram(mat) # title(\u0026#34;Chod Diagram\u0026#34;) # chordDiagram(df) 如上图形，弦图主要由内部表示连接关系的link与外部的3层track构成。tracks由里到外分别是表示组成员的grid/sector、axis、name。后面的参数设置即主要对上述细节进行调整。\n由于每一次参数修改都有可能对之后的绘图产生痕迹，因此建议绘图后运行命令circos.clear()。\n2、grid等tracks设置 （1）grid顺序 1 2 3 4 chordDiagram(mat, order = c(\u0026#34;S2\u0026#34;, \u0026#34;S1\u0026#34;, \u0026#34;S3\u0026#34;, \u0026#34;E4\u0026#34;, \u0026#34;E1\u0026#34;, \u0026#34;E5\u0026#34;, \u0026#34;E2\u0026#34;, \u0026#34;E6\u0026#34;, \u0026#34;E3\u0026#34;)) circos.clear() （2）grid间距 1 2 3 4 5 6 7 8 9 10 11 12 ## 逐一设置 circos.par(gap.after = c(rep(5, nrow(mat)-1), 15, rep(5, ncol(mat)-1), 15)) # circos.par(gap.after = c(\u0026#34;S1\u0026#34; = 5, \u0026#34;S2\u0026#34; = 5, \u0026#34;S3\u0026#34; = 15, \u0026#34;E1\u0026#34; = 5, \u0026#34;E2\u0026#34; = 5, # \u0026#34;E3\u0026#34; = 5, \u0026#34;E4\u0026#34; = 5, \u0026#34;E5\u0026#34; = 5, \u0026#34;E6\u0026#34; = 15)) chordDiagram(mat) circos.clear() ## 分组设置 chordDiagram(mat, big.gap = 30, small.gap = 5) circos.clear() （3）grid排列位置\n以sender组的第一个grid的度数为参数，且默认为顺时针\n1 2 3 4 circos.par(start.degree = 85, clock.wise = FALSE) chordDiagram(mat) circos.clear() （4）grid颜色\ngrid的颜色默认每次随机生成\n1 2 3 4 5 grid.col = c(S1 = \u0026#34;red\u0026#34;, S2 = \u0026#34;green\u0026#34;, S3 = \u0026#34;blue\u0026#34;, E1 = \u0026#34;grey\u0026#34;, E2 = \u0026#34;grey\u0026#34;, E3 = \u0026#34;grey\u0026#34;, E4 = \u0026#34;grey\u0026#34;, E5 = \u0026#34;grey\u0026#34;, E6 = \u0026#34;grey\u0026#34;) chordDiagram(mat, grid.col = grid.col) circos.clear() （5）grid宽度设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 宽度保持一致 chordDiagram(mat, grid.col = grid.col, scale = TRUE) ## 两组grid的整体宽度比 df = expand.grid(letters[1:3], LETTERS[1:4]) df$value = 1 df$value2 = 0.5 head(df) # Var1 Var2 value value2 # 1 a A 1 0.5 # 2 b A 1 0.5 # 3 c A 1 0.5 # 4 a B 1 0.5 # chordDiagram(df[, 1:3], grid.col = grid.col) chordDiagram(df[, 1:4], grid.col = grid.col) circos.clear() （5）tracks显示\nannotationTrack() 设置显示的tracks\nannotationTrackHeight分别设置name至grid的距离、grid的宽度\n1 2 3 4 5 6 7 8 9 chordDiagram(mat, annotationTrack = c(\u0026#34;name\u0026#34;, \u0026#34;grid\u0026#34;,\u0026#34;axis\u0026#34;), annotationTrackHeight = mm_h(c(5, 5))) circos.clear() chordDiagram(mat, annotationTrack = c(\u0026#34;name\u0026#34;, \u0026#34;grid\u0026#34;), annotationTrackHeight = mm_h(c(5, 1))) ## 如下图 circos.clear() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 chordDiagram(mat, transparency = 0.2, grid.col = grid.col, annotationTrack = \u0026#34;grid\u0026#34;, #仅绘制grid层 preAllocateTracks = 1 #预留一个track用于绘制name层 ) circos.track(track.index = 1, panel.fun = function(x, y) { circos.text(CELL_META$xcenter, CELL_META$ylim[1], CELL_META$sector.index, facing = \u0026#34;clockwise\u0026#34;, niceFacing = TRUE, adj = c(0, 0.5), cex = 1 ) }, bg.border = NA) circos.clear() 3、link设置 （1）link的颜色\nlink的颜色默认\n为sender的grid颜色的50%透明度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ## 透明度 chordDiagram(mat, grid.col = grid.col, transparency = 0.9) ## 自定义颜色 col_mat = rand_color(length(mat), transparency = 0.5) dim(col_mat) = dim(mat) # to make sure it is a matrix chordDiagram(mat, grid.col = grid.col, col = col_mat) ## 颜色映射value col_fun = colorRamp2(range(mat), c(\u0026#34;#FFEEEE\u0026#34;, \u0026#34;#FF0000\u0026#34;), transparency = 0.5) chordDiagram(mat, grid.col = grid.col, col = col_fun) circos.clear() ## row.col将link的颜色随sender保持一致 ## column.col将link的颜色随receiver保持一致 par(mfrow = c(1,2)) # chordDiagram(mat, grid.col = grid.col, row.col = 1:3) chordDiagram(mat, grid.col = grid.col, row.col = rainbow(3)) # chordDiagram(mat, grid.col = grid.col, column.col = 1:6) chordDiagram(mat, grid.col = grid.col, column.col = rainbow(6)) circos.clear() par(mfrow = c(1,1)) （2）link的边框设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ## 统一设置 chordDiagram(mat, link.lwd = 2, link.lty = 2, link.border = \u0026#34;red\u0026#34;) ## 逐一设置 lwd_mat = matrix(1, nrow = nrow(mat), ncol = ncol(mat)) lwd_mat[mat \u0026gt; 12] = 2 border_mat = matrix(NA, nrow = nrow(mat), ncol = ncol(mat)) border_mat[mat \u0026gt; 12] = \u0026#34;red\u0026#34; chordDiagram(mat, grid.col = grid.col, link.lwd = lwd_mat, link.border = border_mat) ## 单组设置 border_mat2 = matrix(\u0026#34;black\u0026#34;, nrow = 1, ncol = ncol(mat)) rownames(border_mat2) = rownames(mat)[2] colnames(border_mat2) = colnames(mat) # E1 E2 E3 E4 E5 E6 # S2 \u0026#34;black\u0026#34; \u0026#34;black\u0026#34; \u0026#34;black\u0026#34; \u0026#34;black\u0026#34; \u0026#34;black\u0026#34; \u0026#34;black\u0026#34; chordDiagram(mat, grid.col = grid.col, link.lwd = 2, link.border = border_mat2) ## 指定link设置 lty_df = data.frame(c(\u0026#34;S1\u0026#34;, \u0026#34;S2\u0026#34;, \u0026#34;S3\u0026#34;), c(\u0026#34;E5\u0026#34;, \u0026#34;E6\u0026#34;, \u0026#34;E4\u0026#34;), c(1, 2, 3)) lwd_df = data.frame(c(\u0026#34;S1\u0026#34;, \u0026#34;S2\u0026#34;, \u0026#34;S3\u0026#34;), c(\u0026#34;E5\u0026#34;, \u0026#34;E6\u0026#34;, \u0026#34;E4\u0026#34;), c(2, 2, 2)) border_df = data.frame(c(\u0026#34;S1\u0026#34;, \u0026#34;S2\u0026#34;, \u0026#34;S3\u0026#34;), c(\u0026#34;E5\u0026#34;, \u0026#34;E6\u0026#34;, \u0026#34;E4\u0026#34;), c(1, 1, 1)) chordDiagram(mat, grid.col = grid.col, link.lty = lty_df, link.lwd = lwd_df, link.border = border_df) （3）link的排序设置 1 2 3 4 5 6 7 8 9 ## (1) 按receiver组内升降序排列 chordDiagram(mat, grid.col = grid.col, link.sort = TRUE, link.decreasing = TRUE) chordDiagram(mat, grid.col = grid.col, link.sort = TRUE, link.decreasing = FALSE) ## (2) 全局link的value排序 chordDiagram(mat, grid.col = grid.col, transparency = 0, link.zindex = rank(mat)) （4）link的方向设置 1 2 3 4 5 chordDiagram(mat, grid.col = grid.col, directional = 1) # 正向 chordDiagram(mat, grid.col = grid.col, directional = 1, diffHeight = mm_h(5)) chordDiagram(mat, grid.col = grid.col, directional = -1) # 反向 chordDiagram(mat, grid.col = grid.col, directional = 2) # 双向 1 2 3 4 5 arr.col = data.frame(c(\u0026#34;S1\u0026#34;, \u0026#34;S2\u0026#34;, \u0026#34;S3\u0026#34;), c(\u0026#34;E5\u0026#34;, \u0026#34;E6\u0026#34;, \u0026#34;E4\u0026#34;), c(\u0026#34;black\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;black\u0026#34;)) chordDiagram(mat, grid.col = grid.col, directional = 1, direction.type = c(\u0026#34;diffHeight\u0026#34;, \u0026#34;arrows\u0026#34;), link.arr.col = arr.col, link.arr.length = 0.3) 1 2 3 4 5 chordDiagram(mat, directional = 1, direction.type = c(\u0026#34;diffHeight\u0026#34;, \u0026#34;arrows\u0026#34;), link.arr.type = \u0026#34;big.arrow\u0026#34;, diffHeight = mm_h(5), target.prop.height = mm_h(5)) ","permalink":"https://lishensuo.github.io/en/posts/program/220r-%E5%8F%AF%E8%A7%86%E5%8C%96--%E5%BC%A6%E5%9B%BEchorddiagram/","summary":"\u003cp\u003e弦图常用于表示两组或多组成员之间的连接关系。如下简单学习\u003ccode\u003ecirclize\u003c/code\u003e包\u003ccode\u003eChordDiagram()\u003c/code\u003e绘制弦图的基础用法\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e参考教程：https://jokergoo.github.io/circlize_book/book/the-chorddiagram-function.html\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"0数据输入\"\u003e0、数据输入\u003c/h2\u003e\n\u003cp\u003e对于matrix：\u003c/p\u003e","title":"R-可视化--弦图chordDiagram"},{"content":" 桑基图(sankey plot)是一种特定类型的流图，用于描述一组值到另一组值的流向；理论上来表示前一组值与后一组值存在一定的逻辑关系。从泛化角度来看，也可用于呈现多组间的构成比例关系。从这个角度来看，冲积图(alluvial plot)就是一种特殊的桑基图。\nggsankey包的官方教程：https://github.com/davidsjoberg/ggsankey 1 2 # install.packages(\u0026#34;devtools\u0026#34;) devtools::install_github(\u0026#34;davidsjoberg/\u0026#34;) 1、构图要素 （1）图形组成\n一整列对应的每一组值表示一个stage，每个stage由若干个node组成； 相邻两个stage的node之间可存在流向关系，称为flow。 （2）图形参数\nfill设置填充颜色，可进一步分为node.fill与flow.fill; color设置边框颜色，可进一步分为node.color与flow.color; width设置node的宽度，flow.alpha设置flow的不透明度，space设置同组内node的间距。 2、准备数据 1 2 3 library(ggsankey) library(dplyr) library(ggplot2) 汽车型号数据mtcars 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 df \u0026lt;- mtcars %\u0026gt;% dplyr::select(cyl, vs, am, gear) %\u0026gt;% dplyr::mutate(cyl=paste0(\u0026#34;C\u0026#34;,cyl), vs=paste0(\u0026#34;V\u0026#34;,vs), am=paste0(\u0026#34;A\u0026#34;,am), gear=paste0(\u0026#34;G\u0026#34;,gear)) head(df) # cyl vs am gear # Mazda RX4 C6 V0 A1 G4 # Mazda RX4 Wag C6 V0 A1 G4 # Datsun 710 C4 V1 A1 G4 # Hornet 4 Drive C6 V1 A0 G3 # Hornet Sportabout C8 V0 A0 G3 # Valiant C6 V1 A0 G3 ## 格式转换：宽变长 df = make_long(df, cyl, vs, am, gear) head(df) # # A tibble: 6 × 4 # x node next_x next_node # \u0026lt;fct\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;chr\u0026gt; # 1 cyl C6 vs V0 # 2 vs V0 am A1 # 3 am A1 gear G4 # 4 gear G4 NA NA # 5 cyl C6 vs V0 # 6 vs V0 am A1 ## x列：当前node所处的stage ## node列：当前node ## next_x列：当前node流向的下一stage ## next_node：当前node流向的下一个node 3、绘制桑基图 主要函数\ngeom_sankey()绘制桑基图，主要参数见1.2 geom_sankey_text()/geom_sankey_label()添加node标签，相关参数同geom_text/label 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ggplot(df, aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(x), label = node,)) + geom_sankey(color = \u0026#34;grey\u0026#34;, # node.color=, flow.color= #fill = \u0026#34;brown\u0026#34;, # node.fill=, flow.fill= flow.alpha = 0.6, # space = 1, width = 0.1) + geom_sankey_text(size = 5, vjust = 0.5, hjust = -1, color = \u0026#34;black\u0026#34;, fontface = \u0026#34;bold\u0026#34;) + ggsci::scale_fill_aaas() + theme_sankey(base_size = 18) + labs(x = NULL) + theme(legend.position = \u0026#34;none\u0026#34;, plot.title = element_text(hjust = .5)) + ggtitle(\u0026#34;Car features\u0026#34;) 4、绘制冲击图 Alluvial plots are very similiar to sankey plots but have no spaces between nodes and start at y = 0 instead being centered around the x-axis.\n主要函数：\ngeom_alluvial()绘制冲积图，主要参数同geom_sankey() geom_alluvial_text()/geom_alluvial_label()添加node标签，相关参数同geom_text/label 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ggplot(df, aes(x = x, next_x = next_x, node = node, next_node = next_node, fill = factor(node), label = node)) + geom_alluvial(flow.alpha = 0.6, color=\u0026#34;grey\u0026#34;) + geom_alluvial_label(size = 3, color = \u0026#34;white\u0026#34;, fill = \u0026#34;grey\u0026#34;) + ggsci::scale_fill_d3() + theme_alluvial(base_size = 18) + theme(legend.position = \u0026#34;none\u0026#34;, axis.ticks.y = element_blank(), axis.text.y = element_blank(), axis.title = element_blank(), plot.title = element_text(hjust = .5)) + ggtitle(\u0026#34;Car features\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/program/221r-%E5%8F%AF%E8%A7%86%E5%8C%96--%E6%A1%91%E5%9F%BAsankey%E4%B8%8E%E5%86%B2%E5%87%BBalluvial%E5%9B%BEggsankey/","summary":"\u003cblockquote\u003e\n\u003cp\u003e桑基图(sankey plot)是一种特定类型的流图，用于描述一组值到另一组值的流向；理论上来表示前一组值与后一组值存在一定的逻辑关系。从泛化角度来看，也可用于呈现多组间的构成比例关系。从这个角度来看，冲积图(alluvial plot)就是一种特殊的桑基图。\u003c/p\u003e","title":"R-可视化--桑基(sankey)与冲击(alluvial)图ggsankey"},{"content":"1、pie() pie()是基础的绘制饼图函数，用法简单\n1 2 3 4 5 6 7 8 pie(Prop, labels = LETTERS[1:5], main = \u0026#34;Test Piechart\u0026#34;) # labels：设置标签 # radius：设置半径，default 0.8 # clockwise：设置是否顺时针，默认为F # init.angle：设置起始单元的角度 # col：设置颜色 # border与lty分别设置边的颜色与形状 2、pie3D() pie3D()是plotrix包中用于绘制3D效果饼图的函数 1 2 3 4 5 6 7 8 9 library(plotrix) slices \u0026lt;- c(10, 12, 4, 16, 8) lbls \u0026lt;- c(\u0026#34;US\u0026#34;, \u0026#34;UK\u0026#34;, \u0026#34;Australia\u0026#34;, \u0026#34;Germany\u0026#34;, \u0026#34;France\u0026#34;) pie3D(slices,labels=lbls,explode=0.1, main=\u0026#34;Pie Chart of Countries \u0026#34;) # 部分参数同上，特征参数如下 # theta：设置倾斜的角度，默认为pi/6 # explode：设置分开的距离，默认为0 # height：设置高度，默认为0.1 3、ggplot 本质上是绘制变形的柱状图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 library(tidygraph) df \u0026lt;- data.frame( group = c(\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;, \u0026#34;Child\u0026#34;), value = c(25, 25, 50) ) %\u0026gt;% dplyr::mutate(pc = paste0(value/sum(value)*100,\u0026#34;%\u0026#34;)) df # group value pc # 1 Male 25 25% # 2 Female 25 25% # 3 Child 50 50% ggplot(df, aes(x=\u0026#34;\u0026#34;, y=value, fill=group)) + geom_bar(width = 1, stat = \u0026#34;identity\u0026#34;, color=\u0026#34;white\u0026#34;) + coord_polar(\u0026#34;y\u0026#34;, start=0) + geom_text(aes(label = pc), position = position_stack(vjust = 0.5), size = 8) + theme_void() 4、ggpubr ggpubr支持方便的绘制饼图与环图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 library(ggpubr) library(tidygraph) library(patchwork) df \u0026lt;- data.frame( group = c(\u0026#34;Male\u0026#34;, \u0026#34;Female\u0026#34;, \u0026#34;Child\u0026#34;), value = c(25, 25, 50) ) %\u0026gt;% dplyr::mutate(pc = paste0(value/sum(value)*100,\u0026#34;%\u0026#34;)) df # group value pc # 1 Male 25 25% # 2 Female 25 25% # 3 Child 50 50% p1 = ggpie(df, \u0026#34;value\u0026#34;, label = \u0026#34;pc\u0026#34;, lab.pos = \u0026#34;in\u0026#34;, lab.font = \u0026#34;white\u0026#34;, fill = \u0026#34;group\u0026#34;, color = \u0026#34;white\u0026#34;, palette = c(\u0026#34;#00AFBB\u0026#34;, \u0026#34;#E7B800\u0026#34;, \u0026#34;#FC4E07\u0026#34;)) p2 = ggdonutchart(df, \u0026#34;value\u0026#34;, label = \u0026#34;pc\u0026#34;, lab.pos = \u0026#34;in\u0026#34;, lab.font = \u0026#34;white\u0026#34;, fill = \u0026#34;group\u0026#34;, color = \u0026#34;white\u0026#34;, palette = c(\u0026#34;#00AFBB\u0026#34;, \u0026#34;#E7B800\u0026#34;, \u0026#34;#FC4E07\u0026#34;)) p1 | p2 5、双环图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # devtools::install_github(\u0026#34;cardiomoon/moonBook\u0026#34;) # devtools::install_github(\u0026#34;cardiomoon/webr\u0026#34;) library(ggplot2) library(moonBook) library(webr) test=iris[,c(4,5)] test[,1]=ceiling(test[,1]) ## 将花按宽度分为1、2、3等共3类 table(test$Petal.Width, test$Species) # setosa versicolor virginica # 1 50 7 0 # 2 0 43 27 # 3 0 0 23 PieDonut(test,aes(pies=Petal.Width,donuts=Species)) PieDonut(test,aes(pies=Petal.Width,donuts=Species), ratioByGroup=FALSE, ,labelposition=1) PieDonut(test,aes(pies=Petal.Width,donuts=Species), explodeDonut=TRUE, explode=2, selected = c(1,2)) ","permalink":"https://lishensuo.github.io/en/posts/program/222r-%E5%8F%AF%E8%A7%86%E5%8C%96--%E9%A5%BC%E5%9B%BE%E4%B8%8E%E7%8E%AF%E5%9B%BE/","summary":"\u003ch2 id=\"1pie\"\u003e1、pie()\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003epie()\u003c/code\u003e是基础的绘制饼图函数，用法简单\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epie(Prop, labels = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eLETTERS\u003c/span\u003e[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e], main = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Test Piechart\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# labels：设置标签\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# radius：设置半径，default 0.8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# clockwise：设置是否顺时针，默认为F\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# init.angle：设置起始单元的角度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# col：设置颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# border与lty分别设置边的颜色与形状\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230311161634571.png\" alt=\"image-20230311161634571\"  /\u003e\r\n\u003c/p\u003e","title":"R-可视化--饼图与环图"},{"content":"1、ggplot geom_text()通过交代文本的坐标位置与内容绘制，通常与点图联用。相关参数包括： color 标签的颜色 alpha 标签的透明度 check_overlap 若有重叠的标签则不显示，默认为False 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library(tidyverse) library(patchwork) p = ggplot(mpg, aes(displ, hwy)) + geom_point() # 设置候选标签 best_in_class \u0026lt;- mpg %\u0026gt;% group_by(class) %\u0026gt;% filter(row_number(desc(hwy)) == 1) # nudge_x / nudge_y：设置标签的相对位置，移动单位与x/y轴匹配；大于0分别表示右、上 # hjust / vjust：设置标签的相对位置，移动单位与自身长宽匹配；小于0分别表示右，上 p1 = p + geom_text(aes(label = model), data = best_in_class) p2 = p + geom_text(aes(label = model), data = best_in_class, nudge_x = 1, nudge_y = 10) p1 | p2 geom_label()在上述的基础上设置文本框，相关参数包括： label.size：框轮廓线的宽度 label.r：框轮廓的平滑度 label.padding：框的大小 alpha：框的透明度 1 2 3 4 p1 = p + geom_label(aes(label = model), data = best_in_class) p2 = p + geom_label(aes(label = model), data = best_in_class, alpha=0.5, fill=\u0026#34;grey\u0026#34;, color=\u0026#34;red\u0026#34;) p1 | p2 2、ggrepel 上述函数对于重叠标签的处理能力有限，ggrepel包可对此进行有效的补充。简单理解就是确定文本标签的坐标后，对于存在互相重叠的标签进行适当偏移，使各自均能完整的显示。\ngeom_text_repel，部分参数与上相同 max.overlaps：所允许的最多重叠数，若超过则显示 box.padding：可以理解为设置标签与给定坐标的相对位置 min.segment.length：在超过此长度后才显示连接线段 arrow：设置箭头 1 2 3 4 5 6 library(ggrepel) p1 = p + geom_text_repel(aes(label = model), data = best_in_class) p2 = p + geom_text_repel(aes(label = model), data = best_in_class, box.padding = 2, min.segment.length = 2, arrow = arrow(length = unit(0.01, \u0026#34;npc\u0026#34;))) p1 | p2 geom_label_repel(), 用法与上述基本一致 label.padding可以设置文本框的大小 ","permalink":"https://lishensuo.github.io/en/posts/program/223r-%E5%8F%AF%E8%A7%86%E5%8C%96--ggplot%E6%A0%87%E6%B3%A8%E6%96%87%E6%9C%AC%E6%A0%87%E7%AD%BEtextlabel/","summary":"\u003ch2 id=\"1ggplot\"\u003e1、ggplot\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egeom_text()\u003c/code\u003e通过交代文本的坐标位置与内容绘制，通常与点图联用。相关参数包括：\n\u003cul\u003e\n\u003cli\u003ecolor 标签的颜色\u003c/li\u003e\n\u003cli\u003ealpha 标签的透明度\u003c/li\u003e\n\u003cli\u003echeck_overlap 若有重叠的标签则不显示，默认为False\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(patchwork)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep = ggplot(mpg, aes(displ, hwy)) + geom_point()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 设置候选标签\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebest_in_class \u0026lt;- mpg %\u0026gt;%\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  group_by(class) %\u0026gt;%\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  filter(row_number(desc(hwy)) == \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# nudge_x / nudge_y：设置标签的相对位置，移动单位与x/y轴匹配；大于0分别表示右、上\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# hjust / vjust：设置标签的相对位置，移动单位与自身长宽匹配；小于0分别表示右，上\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = p + geom_text(aes(label = model), data = best_in_class)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = p + geom_text(aes(label = model), data = best_in_class,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                   nudge_x = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, nudge_y = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 | p2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230311204246511.png\" alt=\"image-20230311204246511\" style=\"zoom: 67%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003egeom_label()\u003c/code\u003e在上述的基础上设置文本框，相关参数包括：\n\u003cul\u003e\n\u003cli\u003elabel.size：框轮廓线的宽度\u003c/li\u003e\n\u003cli\u003elabel.r：框轮廓的平滑度\u003c/li\u003e\n\u003cli\u003elabel.padding：框的大小\u003c/li\u003e\n\u003cli\u003ealpha：框的透明度\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = p + geom_label(aes(label = model), data = best_in_class)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 = p + geom_label(aes(label = model), data = best_in_class,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    alpha=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e, fill=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;grey\u0026#34;\u003c/span\u003e, color=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;red\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 | p2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230311205024367.png\" alt=\"image-20230311205024367\" style=\"zoom: 67%;\" /\u003e\r\n\u003ch2 id=\"2ggrepel\"\u003e2、ggrepel\u003c/h2\u003e\n\u003cp\u003e上述函数对于重叠标签的处理能力有限，ggrepel包可对此进行有效的补充。简单理解就是确定文本标签的坐标后，对于存在互相重叠的标签进行适当偏移，使各自均能完整的显示。\u003c/p\u003e","title":"R-可视化--ggplot标注文本标签text\u0026label"},{"content":" 1 2 3 4 5 6 # install.packages(\u0026#34;corrplot\u0026#34;) library(corrplot) # 计算相关性矩阵 M\u0026lt;-cor(mtcars) dim(M) # [1] 11 11 1、可视化R系数方式 method参数提供了如下6种可视化方式 circle(default), square, ellipse, number, shade, color, pie 1 corrplot(M, method=\u0026#34;ellipse\u0026#34;) 2、对称布局方式 type参数提供了如下3种布局方式 full(default), upper, lower 1 corrplot(M, type=\u0026#34;lower\u0026#34;) 3、样本排序 order参数提供了如下 original(default), AOE, FPC, hclust, alphabet 如果采用hclust，可以通过hclust.method参数设置聚类方法 1 corrplot(M, order=\u0026#34;hclust\u0026#34;) 4、颜色方案 （1）相关性颜色 1 2 3 col = colorRampPalette(c(\u0026#34;blue\u0026#34;, \u0026#34;white\u0026#34;, \u0026#34;red\u0026#34;))(20) # 连续型 col = RColorBrewer::brewer.pal(n=8, name=\u0026#34;RdBu\u0026#34;) #离散型 corrplot(M, col=col) （2）其它颜色 1 2 3 4 5 # 背景填充颜色 corrplot(M, bg=\u0026#34;grey\u0026#34;) # 方格边框颜色 corrplot(M, addgrid.col = \u0026#34;black\u0026#34;) 5、文本属性设置 （1）坐标轴名：通过tl.系列参数设置大小，颜色、角度等 1 corrplot(M, tl.col=\u0026#34;black\u0026#34;, tl.srt=45) （2）标注相关性系数 1 corrplot(M, addCoef.col = \u0026#34;black\u0026#34;, number.digits = 1) （3）标注P值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 首先得到P值矩阵 cor.mtest \u0026lt;- function(mat, ...) { mat \u0026lt;- as.matrix(mat) n \u0026lt;- ncol(mat) p.mat\u0026lt;- matrix(NA, n, n) diag(p.mat) \u0026lt;- 0 for (i in 1:(n - 1)) { for (j in (i + 1):n) { tmp \u0026lt;- cor.test(mat[, i], mat[, j], ...) p.mat[i, j] \u0026lt;- p.mat[j, i] \u0026lt;- tmp$p.value } } colnames(p.mat) \u0026lt;- rownames(p.mat) \u0026lt;- colnames(mat) p.mat } p.mat \u0026lt;- cor.mtest(mtcars) dim(p.mat) # [1] 11 11 sig.level 参数设置显著阈值 insig参数设置标注方式，可选项包括 pch（default）：将不显著的，标注为叉 blank：将不显著的，不显示 n：不作处理 label_sig 将显著的，标注星号 1 corrplot(M, p.mat = p.mat, sig.level = 0.01, insig = \u0026#34;blank\u0026#34;) 1 2 3 corrplot(M, p.mat = p.mat, sig.level = c(0.1, 0.01), insig = \u0026#34;label_sig\u0026#34;, pch.cex = 1.5, pch.col = \u0026#34;red\u0026#34;) 6、其它参数 is.corr参数， 默认为TRUE；即输入矩阵是否为相关性矩阵 1 corrplot(scale(t(mtcars)), is.corr = FALSE) diag参数，默认为TRUE；即是否显示对角线的相关性 1 corrplot(M, diag=FALSE) ","permalink":"https://lishensuo.github.io/en/posts/program/224r-%E5%8F%AF%E8%A7%86%E5%8C%96--corrplot%E7%9B%B8%E5%85%B3%E6%80%A7%E7%BB%98%E5%9B%BE/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# install.packages(\u0026#34;corrplot\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(corrplot)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 计算相关性矩阵\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eM\u0026lt;-cor(mtcars)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(M)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 11 11\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1可视化r系数方式\"\u003e1、可视化R系数方式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003emethod参数提供了如下6种可视化方式\u003c/li\u003e\n\u003cli\u003ecircle(default), square, ellipse, number, shade, color, pie\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, method=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ellipse\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401114538351.png\" alt=\"image-20230401114538351\" style=\"zoom: 50%;\" /\u003e\r\n\u003ch3 id=\"2对称布局方式\"\u003e2、对称布局方式\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003etype参数提供了如下3种布局方式\u003c/li\u003e\n\u003cli\u003efull(default), upper, lower\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, type=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;lower\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401114629730.png\" alt=\"image-20230401114629730\" style=\"zoom:50%;\" /\u003e\r\n\u003ch3 id=\"3样本排序\"\u003e3、样本排序\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eorder参数提供了如下\u003c/li\u003e\n\u003cli\u003eoriginal(default), AOE, FPC, hclust, alphabet\u003c/li\u003e\n\u003cli\u003e如果采用hclust，可以通过hclust.method参数设置聚类方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, order=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;hclust\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401114956459.png\" alt=\"image-20230401114956459\" style=\"zoom:50%;\" /\u003e\r\n\u003ch3 id=\"4颜色方案\"\u003e4、颜色方案\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e（1）相关性颜色\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecol = colorRampPalette(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;blue\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;white\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;red\u0026#34;\u003c/span\u003e))(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e20\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e# 连续型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecol = RColorBrewer::brewer.pal(n=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e, name=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;RdBu\u0026#34;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#离散型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, col=col)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e（2）其它颜色\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 背景填充颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, bg=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;grey\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 方格边框颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, addgrid.col = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;black\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"5文本属性设置\"\u003e5、文本属性设置\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e（1）坐标轴名：通过\u003ccode\u003etl.\u003c/code\u003e系列参数设置大小，颜色、角度等\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, tl.col=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;black\u0026#34;\u003c/span\u003e, tl.srt=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e45\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e（2）标注相关性系数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, addCoef.col = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;black\u0026#34;\u003c/span\u003e, number.digits = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401115659231.png\" alt=\"image-20230401115659231\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e（3）标注P值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 首先得到P值矩阵\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecor.mtest \u0026lt;- \u003cspan style=\"color:#fff;font-weight:bold\"\u003efunction\u003c/span\u003e(mat, \u003cspan style=\"color:#fff;font-weight:bold\"\u003e...\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mat \u0026lt;- as.matrix(mat)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    n \u0026lt;- ncol(mat)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    p.mat\u0026lt;- matrix(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNA\u003c/span\u003e, n, n)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    diag(p.mat) \u0026lt;- \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (i \u003cspan style=\"color:#fff;font-weight:bold\"\u003ein\u003c/span\u003e \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:(n - \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e (j \u003cspan style=\"color:#fff;font-weight:bold\"\u003ein\u003c/span\u003e (i + \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e):n) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            tmp \u0026lt;- cor.test(mat[, i], mat[, j], \u003cspan style=\"color:#fff;font-weight:bold\"\u003e...\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            p.mat[i, j] \u0026lt;- p.mat[j, i] \u0026lt;- tmp$p.value\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  colnames(p.mat) \u0026lt;- rownames(p.mat) \u0026lt;- colnames(mat)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  p.mat\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep.mat \u0026lt;- cor.mtest(mtcars)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edim(p.mat)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 11 11\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003esig.level 参数设置显著阈值\u003c/li\u003e\n\u003cli\u003einsig参数设置标注方式，可选项包括\n\u003cul\u003e\n\u003cli\u003epch（default）：将不显著的，标注为叉\u003c/li\u003e\n\u003cli\u003eblank：将不显著的，不显示\u003c/li\u003e\n\u003cli\u003en：不作处理\u003c/li\u003e\n\u003cli\u003elabel_sig 将显著的，标注星号\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, p.mat = p.mat, sig.level = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, insig = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;blank\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401145554687.png\" alt=\"image-20230401145554687\" style=\"zoom:50%;\" /\u003e\r\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, p.mat = p.mat, sig.level = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tinsig = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;label_sig\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tpch.cex = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1.5\u003c/span\u003e, pch.col = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;red\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401145726873.png\" alt=\"image-20230401145726873\" style=\"zoom: 50%;\" /\u003e\r\n\u003ch3 id=\"6其它参数\"\u003e6、其它参数\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003eis.corr参数， 默认为TRUE；即输入矩阵是否为相关性矩阵\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(scale(t(mtcars)), is.corr = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401150411920.png\" alt=\"image-20230401150411920\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003ediag参数，默认为TRUE；即是否显示对角线的相关性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecorrplot(M, diag=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFALSE\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230401150618944.png\" alt=\"image-20230401150618944\" style=\"zoom:50%;\" /\u003e","title":"R-可视化--corrplot相关性绘图"},{"content":" 示例数据 1 2 3 4 5 6 7 8 9 10 11 12 data(\u0026#34;mtcars\u0026#34;) df \u0026lt;- mtcars df$name \u0026lt;- rownames(df) df$cyl \u0026lt;- as.factor(df$cyl) head(df[,c(\u0026#34;name\u0026#34;,\u0026#34;cyl\u0026#34;,\u0026#34;mpg\u0026#34;,\u0026#34;wt\u0026#34;)]) # name cyl mpg wt # Mazda RX4 Mazda RX4 6 21.0 2.620 # Mazda RX4 Wag Mazda RX4 Wag 6 21.0 2.875 # Datsun 710 Datsun 710 4 22.8 2.320 # Hornet 4 Drive Hornet 4 Drive 6 21.4 3.215 # Hornet Sportabout Hornet Sportabout 8 18.7 3.440 # Valiant Valiant 6 18.1 3.460 方式1: cowplot 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 library(cowplot) p_main = ggplot(df, aes(x = wt, y = mpg, color = cyl))+ geom_point() p_right = axis_canvas(p_main, axis = \u0026#34;x\u0026#34;)+ geom_density(data = df, aes(x = wt, fill = cyl), alpha = 0.7, size = 0.2) p_top = axis_canvas(p_main, axis = \u0026#34;y\u0026#34;, coord_flip = TRUE)+ geom_density(data = df, aes(x = mpg, fill = cyl), alpha = 0.7, size = 0.2)+ coord_flip() p1 = insert_xaxis_grob(p_main, p_right, grid::unit(.2, \u0026#34;null\u0026#34;), position = \u0026#34;top\u0026#34;) p2 = insert_yaxis_grob(p1, p_top, grid::unit(.2, \u0026#34;null\u0026#34;), position = \u0026#34;right\u0026#34;) ggdraw(p2) 方式2: patchwork 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 library(patchwork) p_main = ggplot(df, aes(x = wt, y = mpg, color = cyl)) + geom_point() + theme(legend.position=\u0026#34;bottom\u0026#34;) p_top = ggplot(df, aes(x = wt, color = cyl)) + geom_boxplot() + theme_void() + theme(legend.position = \u0026#34;none\u0026#34;) p_right = ggplot(df, aes(x = mpg, color = cyl)) + geom_boxplot() + theme_void() + theme(legend.position = \u0026#34;none\u0026#34;) + coord_flip() p = p_top + plot_spacer() + p_main + p_right + plot_layout(ncol = 2, nrow = 2, heights = c(1, 5), widths = c(5, 1)) 方式3: ggpubr 1 2 3 4 5 6 7 library(ggpubr) ggscatterhist( df, x = \u0026#34;wt\u0026#34;, y = \u0026#34;mpg\u0026#34;, color = \u0026#34;cyl\u0026#34;, margin.plot = \u0026#34;density\u0026#34;, # (\u0026#34;density\u0026#34;, \u0026#34;histogram\u0026#34;, \u0026#34;boxplot\u0026#34;), margin.params = list(color = \u0026#34;black\u0026#34;,fill=\u0026#34;cyl\u0026#34;) ) 方式4: aplot Y叔写的R包之一：https://yulab-smu.top/pkgdocs/aplot.html，主要包括两方面用法 xlim2/ylim2 用于对齐不同图形的坐标轴范围及刻度值，具体效果如下示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 d \u0026lt;- group_by(mtcars, cyl) %\u0026gt;% summarize(mean=mean(disp), sd=sd(disp)) d2 \u0026lt;- dplyr::filter(mtcars, cyl != 8) %\u0026gt;% rename(var = cyl) p1 \u0026lt;- ggplot(d, aes(x=cyl, y=mean)) + geom_col(aes(fill=factor(cyl)), width=1) + theme(legend.position=\u0026#39;none\u0026#39;) p2 \u0026lt;- ggplot(d2, aes(var, disp)) + #有意缺失cyl=8的数据 geom_jitter(aes(color=factor(var)), width=.5) + theme(legend.position=\u0026#39;none\u0026#39;) p3 \u0026lt;- ggplot(filter(d, cyl != 4), aes(cyl, mean)) + #有意缺失cyl=4的数据 geom_col(aes(fill=factor(cyl)), width=.6) + theme(legend.position=\u0026#39;none\u0026#39;) # (1) 左图：x轴未对齐 pp \u0026lt;- list(p1, p2, p3) wrap_plots(pp, ncol=1) # (2) 中图：统一设置坐标轴范围 pp2 = list( p1 = p1 + xlim2(limits=c(3, 11)), p2 = p2 + xlim2(limits=c(3, 11)), p3 = p3 + xlim2(limits=c(3, 11)) ) wrap_plots(pp2, ncol=1) # (3) 右图：统一匹配成P1的坐标轴范围 pp3 = list( p1 = p1, p2 = p2 + xlim2(p1), p3 = p3 + xlim2(p1) ) wrap_plots(pp3, ncol=1) inser_*** insert_left,insert_top,insert_right,insert_bottom\n用于在主图上下左右插入副图，只有3个参数：主图对象，副图对象，副图相对于主图的比例\n（1）基本用法 1 2 3 4 5 6 7 8 9 10 p \u0026lt;- ggplot(mtcars, aes(mpg, disp)) + geom_point() p2 \u0026lt;- ggplot(mtcars, aes(mpg)) + geom_density(fill=\u0026#39;steelblue\u0026#39;, alpha=.5) + ggtree::theme_dendrogram() p3 \u0026lt;- ggplot(mtcars, aes(x=1, y=disp)) + geom_boxplot(fill=\u0026#39;firebrick\u0026#39;, alpha=.5) + theme_void() p %\u0026gt;% insert_top(p2, height=.3) %\u0026gt;% insert_right(p3, width=.1) （2）插入树图 当插入的副图是树图时，可按照聚类顺序调整主图\n1 2 3 4 5 6 7 8 9 10 11 12 13 library(ggtree) x \u0026lt;- rtree(10) d \u0026lt;- data.frame(taxa=x$tip.label, value = abs(rnorm(10))) # 树图 p \u0026lt;- ggtree(x) + geom_tiplab(align = TRUE) + xlim(NA, 3) # 主图 p2 \u0026lt;- ggplot(d, aes(value, taxa)) + geom_col() + scale_x_continuous(expand=c(0,0)) p2 %\u0026gt;% insert_left(p) # insert_left(p2, p) （3）复杂应用1 可视化样本Bulk基因表达矩阵\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 # 模拟表达矩阵 d \u0026lt;- matrix(rnorm(25), ncol=5) rownames(d) \u0026lt;- paste0(\u0026#39;g\u0026#39;, 1:5) colnames(d) \u0026lt;- paste0(\u0026#39;t\u0026#39;, 1:5) ## 宽变长 dd \u0026lt;- data.frame(d) dd$gene \u0026lt;- rownames(d) dd \u0026lt;- gather(dd, 1:5, key=\u0026#34;condition\u0026#34;, value=\u0026#39;expr\u0026#39;) # 主图：表达热图 p \u0026lt;- ggplot(dd, aes(condition,gene, fill=expr)) + geom_tile() + scale_fill_viridis_c() + scale_y_discrete(position=\u0026#34;right\u0026#34;) + theme_minimal() + xlab(NULL) + ylab(NULL) # 聚类热图：分别对基因(行)/样本(列) hc \u0026lt;- hclust(dist(d)) # 基因 phr \u0026lt;- ggtree(hc) hcc \u0026lt;- hclust(dist(t(d))) # 样本 phc \u0026lt;- ggtree(hcc) + layout_dendrogram() # 样本注释 ca \u0026lt;- data.frame(condition = paste0(\u0026#39;t\u0026#39;, 1:5), A1 = rep(LETTERS[1:2], times=c(3, 2)), A2 = rep(letters[3:5], times=c(1, 3, 1)) ) cad \u0026lt;- gather(ca, A1, A2, key=\u0026#39;anno\u0026#39;, value=\u0026#39;type\u0026#39;) pc \u0026lt;- ggplot(cad, aes(condition, y=anno, fill=type)) + geom_tile() + scale_y_discrete(position=\u0026#34;right\u0026#34;) + theme_minimal() + theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) + xlab(NULL) + ylab(NULL) # 基因注释1：表达范围 g \u0026lt;- ggplot(dplyr::filter(dd, gene != \u0026#39;g2\u0026#39;), aes(gene, expr, fill=gene)) + geom_boxplot() + coord_flip() + scale_fill_brewer(palette = \u0026#39;Set1\u0026#39;) + theme_minimal() + theme(axis.text.y = element_blank(), axis.ticks.y = element_blank(), panel.grid.minor = element_blank(), panel.grid.major.y = element_blank()) + xlab(NULL) + ylab(NULL) # 基因注释2：所属通路 dp \u0026lt;- data.frame(gene=factor(rep(paste0(\u0026#39;g\u0026#39;, 1:5), 2)), pathway = sample(paste0(\u0026#39;pathway\u0026#39;, 1:5), 10, replace = TRUE)) pp \u0026lt;- ggplot(dp, aes(pathway, gene)) + geom_point(size=5, color=\u0026#39;steelblue\u0026#39;) + theme_minimal() + theme(axis.text.x=element_text(angle=90, hjust=0), axis.text.y = element_blank(), axis.ticks.y = element_blank()) + xlab(NULL) + ylab(NULL) p %\u0026gt;% insert_left(phr, width=.3) %\u0026gt;% insert_right(pp, width=.4) %\u0026gt;% insert_right(g, width=.4) %\u0026gt;% insert_top(pc, height=.1) %\u0026gt;% insert_top(phc, height=.2) （4）复杂应用2 单细胞表达矩阵的可视化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 file \u0026lt;- system.file(\u0026#34;extdata\u0026#34;, \u0026#34;scRNA_dotplot_data.tsv.gz\u0026#34;, package=\u0026#34;aplot\u0026#34;) gene_cluster \u0026lt;- readr::read_tsv(file) gene_cluster = gene_cluster %\u0026gt;% dplyr::filter(Gene %in% sample(unique(gene_cluster$Gene),20)) head(gene_cluster) # 每个基因在每个cluster的表达信息 # cell_ct 表示cluster的细胞数 # cell_exp_ct 表示cluster中表达该基因的细胞数 # count 表示cluster对于该基因的平均表达水平 # 主图Dotplot dot_plot \u0026lt;- gene_cluster %\u0026gt;% mutate(`% Expressing` = (cell_exp_ct/cell_ct) * 100) %\u0026gt;% # 计算基因表达百分比 filter(count \u0026gt; 0, `% Expressing` \u0026gt; 1) %\u0026gt;% # 过滤低表达基因 ggplot(aes(x=cluster, y = Gene, color = count, size = `% Expressing`)) + geom_point() + cowplot::theme_cowplot() + theme(axis.line = element_blank(), axis.ticks = element_blank()) + theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1)) + ylab(NULL) + scale_color_gradientn(colours = viridis::viridis(20), limits = c(0,4), oob = scales::squish, name = \u0026#39;log2 (count + 1)\u0026#39;) + scale_y_discrete(position = \u0026#34;right\u0026#34;) # y轴基因名放右边 # 根据cluster--gene表达矩阵的聚类图 ## 长变宽 mat \u0026lt;- gene_cluster %\u0026gt;% select(Gene, cluster, count) %\u0026gt;% pivot_wider(names_from = cluster, values_from = count) %\u0026gt;% data.frame() row.names(mat) \u0026lt;- mat$Gene mat \u0026lt;- mat[,-1] clust \u0026lt;- hclust(dist(mat %\u0026gt;% as.matrix())) # 对基因(行)聚类 ggtree_plot \u0026lt;- ggtree::ggtree(clust) v_clust \u0026lt;- hclust(dist(mat %\u0026gt;% as.matrix() %\u0026gt;% t())) # 对样本(列)聚类 ggtree_plot_col \u0026lt;- ggtree(v_clust) + layout_dendrogram() ## 注释样本类别 labels= ggplot(gene_cluster, aes(cluster, y=1, fill=Group)) + geom_tile() + scale_fill_brewer(palette = \u0026#39;Set1\u0026#39;,name=\u0026#34;Cell Type\u0026#34;) + theme_void() dot_plot %\u0026gt;% insert_left(ggtree_plot, width=.2) %\u0026gt;% insert_top(labels, height=.05) %\u0026gt;% insert_top(ggtree_plot_col, height=.1) ","permalink":"https://lishensuo.github.io/en/posts/program/225r-%E5%8F%AF%E8%A7%86%E5%8C%96--ggplot%E6%B7%BB%E5%8A%A0%E5%9B%9B%E5%91%A8%E8%BE%B9%E9%99%85%E5%9B%BE/","summary":"\u003cul\u003e\n\u003cli\u003e示例数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mtcars\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf \u0026lt;- mtcars\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf$name \u0026lt;- rownames(df)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf$cyl \u0026lt;- as.factor(df$cyl)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(df[,c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;cyl\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mpg\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;wt\u0026#34;\u003c/span\u003e)])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                                name cyl  mpg    wt\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Mazda RX4                 Mazda RX4   6 21.0 2.620\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Mazda RX4 Wag         Mazda RX4 Wag   6 21.0 2.875\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Datsun 710               Datsun 710   4 22.8 2.320\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Hornet 4 Drive       Hornet 4 Drive   6 21.4 3.215\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Hornet Sportabout Hornet Sportabout   8 18.7 3.440\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Valiant                     Valiant   6 18.1 3.460\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"方式1-cowplot\"\u003e方式1: cowplot\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(cowplot) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep_main = ggplot(df, aes(x = wt, y = mpg, color = cyl))+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_point()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep_right = axis_canvas(p_main, axis = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;x\u0026#34;\u003c/span\u003e)+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_density(data = df, aes(x = wt, fill = cyl),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e              alpha = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep_top = axis_canvas(p_main, axis = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;y\u0026#34;\u003c/span\u003e, coord_flip = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e)+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_density(data = df, aes(x = mpg, fill = cyl),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                alpha = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.7\u003c/span\u003e, size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e)+\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  coord_flip()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep1 = insert_xaxis_grob(p_main, p_right, grid::unit(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e.2\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;null\u0026#34;\u003c/span\u003e), position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;top\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep2 =  insert_yaxis_grob(p1, p_top, grid::unit(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e.2\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;null\u0026#34;\u003c/span\u003e), position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;right\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggdraw(p2)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409102300016.png\" alt=\"image-20230409102300016\" style=\"zoom:67%;\" /\u003e\r\n\u003ch2 id=\"方式2-patchwork\"\u003e方式2: patchwork\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(patchwork)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep_main = ggplot(df, aes(x = wt, y = mpg, color = cyl)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tgeom_point() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\ttheme(legend.position=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;bottom\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep_top = ggplot(df, aes(x = wt, color = cyl)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tgeom_boxplot() + theme_void() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\ttheme(legend.position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep_right = ggplot(df, aes(x = mpg, color = cyl)) + \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tgeom_boxplot() + theme_void() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\ttheme(legend.position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;none\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tcoord_flip()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ep = p_top + plot_spacer() + p_main + p_right +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    plot_layout(ncol = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, nrow = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \t\t\theights = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e),  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \t\t\twidths = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230409102436406.png\" alt=\"image-20230409102436406\"  /\u003e\r\n\u003c/p\u003e","title":"R-可视化--ggplot绘制散点图添加边际图"},{"content":" 1 2 3 library(ggplot2) # install.packages(\u0026#34;ggbeeswarm\u0026#34;) library(ggbeeswarm) 0、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 set.seed(1995) y \u0026lt;- round(rnorm(200), 1) df \u0026lt;- data.frame(y = y, group = sample(c(\u0026#34;G1\u0026#34;, \u0026#34;G2\u0026#34;, \u0026#34;G3\u0026#34;), size = 200, replace = TRUE)) head(df) # y group # 1 1.1 G3 # 2 -0.3 G2 # 3 0.1 G2 # 4 0.4 G1 # 5 1.7 G3 # 6 -0.3 G3 1、基础绘图 1 2 ggplot(df, aes(x = group, y = y)) + geom_beeswarm() 2、cex参数设置点的间距 1 2 ggplot(df, aes(x = group, y = y)) + geom_beeswarm(cex = 3) 3、priority参数设置点的布局方式，\n可选\u0026quot;ascending\u0026quot;(default) \u0026ldquo;descending\u0026rdquo;, \u0026ldquo;density\u0026rdquo;, \u0026ldquo;random\u0026rdquo; , \u0026ldquo;none\u0026rdquo;\n1 2 ggplot(df, aes(x = group, y = y)) + geom_beeswarm(priority = \u0026#34;descending\u0026#34;) 此外side = c(0, -1, 1)参数可设置显示一侧的结果，具体可查看帮助文档\n4、增加百分位修饰线 1 2 3 4 5 6 ggplot(df, aes(x = group, y = y)) + geom_beeswarm() + stat_summary(fun = median, fun.min = median, fun.max = median, geom = \u0026#39;crossbar\u0026#39;, width = 0.35, linewidth = 0.5, color = \u0026#39;black\u0026#39;) + stat_summary(fun.data = function(x) median_hilow(x, 0.5), geom = \u0026#39;errorbar\u0026#39;, width = 0.2, color = \u0026#39;black\u0026#39;) ","permalink":"https://lishensuo.github.io/en/posts/program/226r-%E5%8F%AF%E8%A7%86%E5%8C%96--ggbeeswarm%E7%BB%98%E5%88%B6%E8%9C%82%E7%BE%A4%E5%9B%BE/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggplot2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# install.packages(\u0026#34;ggbeeswarm\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggbeeswarm)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e0、示例数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eset.seed(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1995\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey \u0026lt;- round(rnorm(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e), \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edf \u0026lt;- data.frame(y = y,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                group = sample(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G1\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G2\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;G3\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e200\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                               replace = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehead(df)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#      y group\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1  1.1    G3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2 -0.3    G2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3  0.1    G2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4  0.4    G1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5  1.7    G3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6 -0.3    G3\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e1、基础绘图\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(df, aes(x = group, y = y)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_beeswarm() \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230422082119980.png\" alt=\"image-20230422082119980\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e2、\u003ccode\u003ecex\u003c/code\u003e参数设置点的间距\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(df, aes(x = group, y = y)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_beeswarm(cex = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230422082244802.png\" alt=\"image-20230422082244802\" style=\"zoom: 50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e3、\u003ccode\u003epriority\u003c/code\u003e参数设置点的布局方式，\u003c/p\u003e","title":"R-可视化--ggbeeswarm绘制蜂群图"},{"content":" Github tutorial：https://github.com/const-ae/ggsignif\n1 2 library(ggplot2) library(ggsignif) 1、comparisons设置分组，计算并标注P值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ggplot(mpg, aes(class, hwy)) + geom_boxplot() + geom_signif( comparisons = list(c(\u0026#34;compact\u0026#34;, \u0026#34;midsize\u0026#34;), c(\u0026#34;minivan\u0026#34;, \u0026#34;suv\u0026#34;)), map_signif_level = TRUE, textsize = 6, test = \u0026#34;t.test\u0026#34;, # c(\u0026#34;wilcox.test\u0026#34;,\u0026#34;t.test\u0026#34;) vjust = -0.5 # 标签相对位置 ) + ylim(NA, 48) # map_signif_level： 将P值映射为等级 # test： 设置差异分析方法 # size、textsize分别设置线与标签的颜色 annotation直接交代P值/标签，手动设置 1 2 3 4 5 6 7 8 9 10 11 12 13 anno \u0026lt;- t.test( iris$Sepal.Width[iris$Species==\u0026#34;versicolor\u0026#34;], iris$Sepal.Width[iris$Species == \u0026#34;virginica\u0026#34;] )$p.value # [1] 0.001819483 ggplot(iris, aes(x = Species, y = Sepal.Width, fill = Species)) + geom_boxplot(position = \u0026#34;dodge\u0026#34;) + geom_signif( annotation = c(formatC(anno, digits = 1),\u0026#34;***\u0026#34;), y_position = c(4, 4.5), xmin = c(2,1), xmax = c(3,2), # 位置 tip_length = 0.02, ) 混合叠加多次注释 1 2 3 4 5 6 7 8 9 10 11 ggplot(dat, aes(Group, Value)) + geom_bar(aes(fill = Sub), stat = \u0026#34;identity\u0026#34;, position = \u0026#34;dodge\u0026#34;, width = .5) + geom_signif( y_position = c(5.3, 8.3), xmin = c(0.8, 1.8), xmax = c(1.2, 2.2), annotation = c(\u0026#34;**\u0026#34;, \u0026#34;NS\u0026#34;), tip_length = 0 ) + geom_signif( comparisons = list(c(\u0026#34;S1\u0026#34;, \u0026#34;S2\u0026#34;)), y_position = 9.3, tip_length = 0, vjust = 0.2 ) + scale_fill_manual(values = c(\u0026#34;grey80\u0026#34;, \u0026#34;grey20\u0026#34;)) ","permalink":"https://lishensuo.github.io/en/posts/program/227r-%E5%8F%AF%E8%A7%86%E5%8C%96--ggsignif%E6%B3%A8%E9%87%8A%E6%98%BE%E8%91%97%E6%80%A7/","summary":"\u003cblockquote\u003e\n\u003cp\u003eGithub tutorial：https://github.com/const-ae/ggsignif\u003c/p\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggplot2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(ggsignif)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e1、\u003ccode\u003ecomparisons\u003c/code\u003e设置分组，计算并标注P值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(mpg, aes(class, hwy)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_boxplot() +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_signif(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    comparisons = list(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;compact\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;midsize\u0026#34;\u003c/span\u003e), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \t\t\t\t   c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;minivan\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;suv\u0026#34;\u003c/span\u003e)),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    map_signif_level = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e, textsize = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    test = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;t.test\u0026#34;\u003c/span\u003e,  \u003cspan style=\"color:#007f7f\"\u003e# c(\u0026#34;wilcox.test\u0026#34;,\u0026#34;t.test\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    vjust = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e-0.5\u003c/span\u003e \u003cspan style=\"color:#007f7f\"\u003e# 标签相对位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ylim(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNA\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e48\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# map_signif_level： 将P值映射为等级\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# test： 设置差异分析方法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# size、textsize分别设置线与标签的颜色\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230422092438688.png\" alt=\"image-20230422092438688\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eannotation\u003c/code\u003e直接交代P值/标签，手动设置\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eanno \u0026lt;- t.test(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  iris$Sepal.Width[iris$Species==\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;versicolor\u0026#34;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  iris$Sepal.Width[iris$Species == \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;virginica\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)$p.value\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 0.001819483\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(iris, aes(x = Species, y = Sepal.Width, fill = Species)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_boxplot(position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dodge\u0026#34;\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_signif(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    annotation = c(formatC(anno, digits = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e),\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;***\u0026#34;\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    y_position = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4.5\u003c/span\u003e), xmin = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e), xmax = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e), \u003cspan style=\"color:#007f7f\"\u003e# 位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    tip_length = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.02\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  )\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230422092724964.png\" alt=\"image-20230422092724964\" style=\"zoom: 67%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e混合叠加多次注释\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eggplot(dat, aes(Group, Value)) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_bar(aes(fill = Sub), stat = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;identity\u0026#34;\u003c/span\u003e, position = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dodge\u0026#34;\u003c/span\u003e, width = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e.5\u003c/span\u003e) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_signif(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    y_position = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5.3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8.3\u003c/span\u003e), xmin = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.8\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1.8\u003c/span\u003e), xmax = c(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1.2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2.2\u003c/span\u003e),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    annotation = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;**\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;NS\u0026#34;\u003c/span\u003e), tip_length = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  geom_signif(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    comparisons = list(c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;S1\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;S2\u0026#34;\u003c/span\u003e)),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    y_position = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e9.3\u003c/span\u003e, tip_length = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, vjust = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ) +\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  scale_fill_manual(values = c(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;grey80\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;grey20\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230422093043189.png\" alt=\"image-20230422093043189\" style=\"zoom: 67%;\" /\u003e","title":"R-可视化--ggsignif注释显著性"},{"content":" https://github.com/funkyheatmap/funkyheatmap 1 2 3 4 5 6 7 8 # install.packages(\u0026#34;funkyheatmap\u0026#34;) library(funkyheatmap) library(tidyverse) data(\u0026#34;mtcars\u0026#34;) vignette(\u0026#34;dynbenchmark\u0026#34;, \u0026#34;funkyheatmap\u0026#34;) #vignette(\u0026#34;mtcars\u0026#34;, \u0026#34;funkyheatmap\u0026#34;) 1、简单用法 对于文本列，直接显示相应文本；对于数值列，使用几何图形映射数值大小。\n1 2 3 4 5 6 7 8 9 10 11 12 13 data \u0026lt;- mtcars[10:20,1:5] %\u0026gt;% rownames_to_column(\u0026#34;id\u0026#34;) %\u0026gt;% arrange(desc(mpg)) data$symbol =sample(c(\u0026#34;X\u0026#34;,\u0026#34;√\u0026#34;,\u0026#34;\u0026#34;),11,replace=T) data$item =sample(c(\u0026#34;word\u0026#34;,\u0026#34;ppt\u0026#34;,\u0026#34;excel\u0026#34;),11,replace=T) # id mpg cyl disp hp drat symbol item # 1 Toyota Corolla 33.9 4 71.1 65 4.22 X excel funky_heatmap(data) ## 设置列标签角度 # col_annot_offset = 3, # col_annot_angle = 30, ## 设置四周留白大小 # expand = c(xmin = 0, xmax = 2, ymin = 0, ymax = 0) 2、自定义每列方案 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 data \u0026lt;- mtcars[10:20,1:5] %\u0026gt;% rownames_to_column(\u0026#34;id\u0026#34;) %\u0026gt;% arrange(desc(mpg)) data$symbol =sample(c(\u0026#34;X\u0026#34;,\u0026#34;√\u0026#34;,\u0026#34;\u0026#34;),11,replace=T) data$item =sample(c(\u0026#34;word\u0026#34;,\u0026#34;ppt\u0026#34;,\u0026#34;excel\u0026#34;),11,replace=T) #通过column_info设置每一列方案 column_info = data.frame( id = colnames(data), #设置每列的标签名 name = paste0(\u0026#34;feature-\u0026#34;,seq(ncol(data))), # #设置列的分组情况 # group = c(rep(\u0026#34;group1\u0026#34;,3),rep(\u0026#34;group2\u0026#34;,3),rep(\u0026#34;group3\u0026#34;,2)), #设置每列的可视化类型 \u0026#34;funkyrect\u0026#34;, \u0026#34;circle\u0026#34;, \u0026#34;rect\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;pie\u0026#34;, or \u0026#34;text\u0026#34; geom = c(\u0026#34;text\u0026#34;, \u0026#34;bar\u0026#34;,\u0026#34;funkyrect\u0026#34;,\u0026#34;rect\u0026#34;,\u0026#34;circle\u0026#34;,\u0026#34;circle\u0026#34;,\u0026#34;text\u0026#34;,\u0026#34;text\u0026#34;), #设置每列的颜色方案 palette = c(NA, \u0026#34;palette1\u0026#34;,\u0026#34;palette1\u0026#34;,\u0026#34;palette2\u0026#34;,\u0026#34;palette3\u0026#34;,\u0026#34;palette2\u0026#34;,NA,NA), #设置每列的宽度 width = c(3,2,1,1,1,1,2,2) ) # 此外也可通过option的list列单独设置，支持所有参数 # 对于text列：size,hjust,vjust可分别设置字体大小，左右对齐，上下对齐 # 对于bar列：hjust可分别设置柱子的左右对齐 column_info$options = list(list(size=3,hjust=0,vjust=0),list(hjust=1),list(),list(),list(),list(),list(),list()) palettes = list( # 本质通过两个或者两个以上颜色，设置渐变色 palette1 = RColorBrewer::brewer.pal(n = 9, name = \u0026#34;Blues\u0026#34;), palette2 = c(\u0026#34;grey\u0026#34;,\u0026#34;red\u0026#34;), palette3 = c(\u0026#34;red\u0026#34;,\u0026#34;red\u0026#34;) ) funky_heatmap(data, column_info = column_info, palettes = palettes) *funkyrect是funkyheatmap(funkyheatmap::geom_rounded_rect())自定义的一种可视化方法：从小到大，从圆到方\n3、设置列(特征)/行(样本)分组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 data \u0026lt;- mtcars[10:20,1:5] %\u0026gt;% rownames_to_column(\u0026#34;id\u0026#34;) %\u0026gt;% arrange(desc(mpg)) data$symbol =sample(c(\u0026#34;X\u0026#34;,\u0026#34;√\u0026#34;,\u0026#34;\u0026#34;),11,replace=T) data$item =sample(c(\u0026#34;word\u0026#34;,\u0026#34;ppt\u0026#34;,\u0026#34;excel\u0026#34;),11,replace=T) #首先设置列的分组 column_info = data.frame( id = colnames(data), #设置列的分组情况 group = c(rep(\u0026#34;group1\u0026#34;,3),rep(\u0026#34;group2\u0026#34;,3),rep(\u0026#34;group3\u0026#34;,2)) ) #设置每组的配色名 column_groups = data.frame( group = c(\u0026#34;group1\u0026#34;,\u0026#34;group2\u0026#34;,\u0026#34;group3\u0026#34;), # level = c(\u0026#34;major1\u0026#34;,\u0026#34;major2\u0026#34;,\u0026#34;major2\u0026#34;), palette = c(\u0026#34;palette1\u0026#34;,\u0026#34;palette2\u0026#34;,\u0026#34;palette3\u0026#34;) ) #设置具体配色方案 palettes = list( palette1 = c(\u0026#34;red\u0026#34;,\u0026#34;red\u0026#34;), palette2 = c(\u0026#34;green\u0026#34;,\u0026#34;green\u0026#34;), palette3 = c(\u0026#34;brown\u0026#34;,\u0026#34;brown\u0026#34;) ) # 对于行，仅需要设置列的分组即可 row_info = data.frame( id = data$id, group = c(rep(\u0026#34;A\u0026#34;,5),rep(\u0026#34;B\u0026#34;,3),rep(\u0026#34;C\u0026#34;,3)) ) funky_heatmap(data, column_info = column_info, column_groups = column_groups, palettes = palettes, row_info = row_info ) 4、设置饼图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 data \u0026lt;- mtcars[10:20,1:5] %\u0026gt;% rownames_to_column(\u0026#34;id\u0026#34;) %\u0026gt;% arrange(desc(mpg)) data$pie_dat = list( c(a=1,b=2,c=3), c(a=1,b=2,c=3), c(a=1,b=2,c=3), c(a=1,b=2,c=3), c(a=1,b=2,c=3), c(a=1,b=2,c=3), c(a=1,b=2,c=1), c(a=1,b=2,c=1), c(a=1,b=2,c=1), c(a=1,b=2,c=1), c(a=1,b=2,c=1) ) column_info = data.frame( id = colnames(data), geom = c(\u0026#34;text\u0026#34;, \u0026#34;bar\u0026#34;,\u0026#34;funkyrect\u0026#34;,\u0026#34;rect\u0026#34;,\u0026#34;circle\u0026#34;,\u0026#34;circle\u0026#34;,\u0026#34;pie\u0026#34;), palette = c(NA,\u0026#34;palette0\u0026#34;,\u0026#34;palette0\u0026#34;,\u0026#34;palette0\u0026#34;,\u0026#34;palette0\u0026#34;,\u0026#34;palette0\u0026#34;,\u0026#34;palette1\u0026#34;) ) palettes = list( palette1 = c(a=\u0026#34;red\u0026#34;,b=\u0026#34;green\u0026#34;,c=\u0026#34;blue\u0026#34;) ) funky_heatmap(data, column_info=column_info, palettes = palettes) 5、几何图形叠加文本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 data \u0026lt;- mtcars[10:20,1:5] %\u0026gt;% rownames_to_column(\u0026#34;id\u0026#34;) %\u0026gt;% arrange(desc(mpg)) # 将该列转换为字符列，添加在原列后面 data = data %\u0026gt;% dplyr::mutate(disp_str=as.character(disp),.before=5) %\u0026gt;% dplyr::mutate(hp_str=as.character(hp),.before=7) column_info = data.frame( id = colnames(data), geom = c(\u0026#34;text\u0026#34;, \u0026#34;bar\u0026#34;,\u0026#34;funkyrect\u0026#34;,\u0026#34;rect\u0026#34;,\u0026#34;text\u0026#34;,\u0026#34;circle\u0026#34;,\u0026#34;text\u0026#34;,\u0026#34;circle\u0026#34;), palette = c(NA,\u0026#34;palette0\u0026#34;,\u0026#34;palette0\u0026#34;,\u0026#34;palette0\u0026#34;,NA,\u0026#34;palette1\u0026#34;,NA,\u0026#34;palette1\u0026#34;) ) column_info$options = list(list(),list(),list(),list(), list(label=\u0026#34;disp_str\u0026#34;,overlay=T,scale=F),list(), list(label=\u0026#34;hp_str\u0026#34;,overlay=T,scale=F),list()) funky_heatmap(data, column_info=column_info) ","permalink":"https://lishensuo.github.io/en/posts/program/228r-%E5%8F%AF%E8%A7%86%E5%8C%96--funkyheatmap%E7%BB%98%E5%88%B6table%E7%83%AD%E5%9B%BE/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/funkyheatmap/funkyheatmap\"\u003ehttps://github.com/funkyheatmap/funkyheatmap\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# install.packages(\u0026#34;funkyheatmap\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(funkyheatmap)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mtcars\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003evignette(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;dynbenchmark\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;funkyheatmap\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#vignette(\u0026#34;mtcars\u0026#34;, \u0026#34;funkyheatmap\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230613211126672.png\" alt=\"image-20230613211126672\"  /\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"1简单用法\"\u003e1、简单用法\u003c/h2\u003e\n\u003cp\u003e对于文本列，直接显示相应文本；对于数值列，使用几何图形映射数值大小。\u003c/p\u003e","title":"R-可视化--funkyheatmap绘制table热图"},{"content":"tidyr是tidyverse系列的组成工具包之一，其主要功能侧重于表格的reshaping and organizing. 下面简要学习其几个比较常用的函数。\nhttps://tidyr.tidyverse.org/\nhttps://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf\n1 library(tidyverse) 1. 表格长宽转换 类似reshape2包\n1 2 3 4 5 6 7 8 9 10 11 df \u0026lt;- data.frame( id = paste0(\u0026#34;sample_\u0026#34;,1:3), time1 = c(10, 20, 30), time2 = c(15, 25, 35), time3 = c(20, 30, 40) ) df # id time1 time2 time3 # 1 sample_1 10 15 20 # 2 sample_2 20 25 30 # 3 sample_3 30 35 40 1.1 pivot_longer() 宽变长 1 2 3 4 5 6 7 8 9 10 11 12 13 14 df_long \u0026lt;- df %\u0026gt;% pivot_longer(cols = starts_with(\u0026#34;time\u0026#34;), names_to = \u0026#34;time_point\u0026#34;, values_to = \u0026#34;value\u0026#34;) head(df_long) # # A tibble: 6 × 3 # id time_point value # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; # 1 sample_1 time1 10 # 2 sample_1 time2 15 # 3 sample_1 time3 20 # 4 sample_2 time1 20 # 5 sample_2 time2 25 # 6 sample_2 time3 30 1.2 pivot_wider() 长变宽 1 2 3 4 5 6 7 8 9 df_wide \u0026lt;- df_long %\u0026gt;% pivot_wider(names_from = \u0026#34;time_point\u0026#34;, values_from = \u0026#34;value\u0026#34;) df_wide # # A tibble: 3 × 4 # id time1 time2 time3 # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 sample_1 10 15 20 # 2 sample_2 20 25 30 # 3 sample_3 30 35 40 2. 表格单列分割 1 2 3 4 5 6 7 8 9 df \u0026lt;- data.frame( id = 1:3, info = c(\u0026#34;sp1_2010\u0026#34;, \u0026#34;sp2_2020\u0026#34;, \u0026#34;sp3_2025\u0026#34;) ) df # id info # 1 1 sp1_2010 # 2 2 sp2_2020 # 3 3 sp3_2025 2.1 separate_longer_delim() 纵向分割\u0026ndash;变长 1 2 3 4 5 6 7 8 9 df %\u0026gt;% separate_longer_delim(info, delim = \u0026#34;_\u0026#34;) # id info # 1 1 sp1 # 2 1 2010 # 3 2 sp2 # 4 2 2020 # 5 3 sp3 # 6 3 2025 2.2 separate_wider_delim() 横向分割\u0026ndash;变宽 1 2 3 4 5 6 7 8 df %\u0026gt;% separate_wider_delim(info, delim = \u0026#34;_\u0026#34;, names =c(\u0026#34;col_1\u0026#34;, \u0026#34;col_2\u0026#34;)) # # A tibble: 3 × 3 # id col_1 col_2 # \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 1 sp1 2010 # 2 2 sp2 2020 # 3 3 sp3 2025 3. expand()排列组合 生成两（or more）组向量的所有排列组合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 samples = c(\u0026#34;sp1\u0026#34;,\u0026#34;sp2\u0026#34;,\u0026#34;sp3\u0026#34;) years = c(1999, 1999, 2020) df = data.frame( col_1 = samples, col_2 = years ) df # col_1 col_2 # 1 sp1 1999 # 2 sp2 1999 # 3 sp3 2020 df %\u0026gt;% tidyr::expand(col_1, col_2) # # A tibble: 6 × 2 # col_1 col_2 # \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; # 1 sp1 1999 # 2 sp1 2020 # 3 sp2 1999 # 4 sp2 2020 # 5 sp3 1999 # 6 sp3 2020 Alternative ways 1 2 3 4 5 6 7 8 9 10 11 12 13 samples = c(\u0026#34;sp1\u0026#34;,\u0026#34;sp2\u0026#34;,\u0026#34;sp3\u0026#34;) years = c(1999, 2020) # keep with same length length(years) = 3 years # [1] 1999 2020 NA df = data.frame( col_1 = samples, col_2 = years ) df %\u0026gt;% tidyr::expand(col_1, col_2) %\u0026gt;% na.omit() R语言基础函数实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 samples = c(\u0026#34;sp1\u0026#34;,\u0026#34;sp2\u0026#34;,\u0026#34;sp3\u0026#34;) years = c(1999, 2020) expand.grid(samples, years) # Var1 Var2 # 1 sp1 1999 # 2 sp2 1999 # 3 sp3 1999 # 4 sp1 2020 # 5 sp2 2020 # 6 sp3 2020 combn(samples, m = 2) # [,1] [,2] [,3] # [1,] \u0026#34;sp1\u0026#34; \u0026#34;sp1\u0026#34; \u0026#34;sp2\u0026#34; # [2,] \u0026#34;sp2\u0026#34; \u0026#34;sp3\u0026#34; \u0026#34;sp3\u0026#34; ","permalink":"https://lishensuo.github.io/en/posts/program/229r-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90--tidyr%E8%A1%A8%E6%A0%BC%E6%93%8D%E4%BD%9C/","summary":"\u003cp\u003etidyr是\u003cstrong\u003etidyverse\u003c/strong\u003e系列的组成工具包之一，其主要功能侧重于表格的reshaping and organizing. 下面简要学习其几个比较常用的函数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://tidyr.tidyverse.org/\"\u003ehttps://tidyr.tidyverse.org/\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf\"\u003ehttps://github.com/rstudio/cheatsheets/blob/main/tidyr.pdf\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(tidyverse)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1-表格长宽转换\"\u003e1. 表格长宽转换\u003c/h1\u003e\n\u003cp\u003e类似reshape2包\u003c/p\u003e","title":"R-数据分析--tidyr表格操作"},{"content":"1、html基础与xpath语法 1.1 html基础 大多数网页内容都是html结构组织的，在我理解就是有众多节点(node)组成的树状结构； 而我们想要爬取的内容就是其中的某个或者某些节点的文本标签或者属性中。 更多可参考： （1）https://www.w3cschool.cn/html/html-basic.html （2）HTML零基础入门教程（详细）_ZONGXP的博客-CSDN博客_html5零基础入门教程 1.2 xpath语法 一个html网页往往包含非常多的节点，如何准确、快速定位到目标节点是爬虫过程中的关键问题；而xpath语法可以帮助我们实现这一点； xpath简单来说是帮助我们解析html结构的一种语言，简单入门比较推荐B站的视频：【智源学院】20分钟带你搞懂XPath — Scrapy数据解析神器_哔哩哔哩_bilibili\n语法应用笔记推荐： （1）XPath定位语法总结_Q0717168的博客-CSDN博客_xpath定位语法 （2）https://learnku.com/articles/50459\n2、xpath工具推荐 2.1 浏览器自带的定位功能 打开目标网页→ 右键单击“检查”→点击审查元素窗口左上角箭头→网页界面选择感兴趣内容→选中元素窗口高亮部分→右键单击，选择copy xpath 在元素窗口，使用ctrl+F快捷键，可以不断调试xpath 2.2 google插件之XPath Helper 可以用来非常方便地调试、验证我们的xpath 2.3 google插件之SelectorGadget 该插件只需要我们在网页选择好感兴趣的标签，然后会自动生成能够定位到目标节点的xpath路径； 不过有一个缺点就是：SelectorGadget生成的xpath路径一般比较复杂，如果我们自己花心思调试一下(2.1)往往会生成简洁的xpath路径【通往罗马的道路不止一条】 3、R语言爬虫流程 一开始学习R语言爬虫时，直接xml2::read_html()对提交的网址进行解析，但经常会出现提交正确的xpath路径，但是没有提取到节点内容的尴尬结果{xml_nodeset (0)}。 后来了解到针对动态网页的selenium爬取方法，尝试了一下果然可以得到预期的结果。而且我觉得动静态网页通吃，因此以后的R语言爬虫都采用下述的流程来操作。 参考笔记 ：微信公众号：老俊俊的生信笔记\u0026ndash;R语言爬虫系列笔记 R 爬虫之爬取文献信息 (qq.com) 4、selenium相关配置(window) ⭐ 参考笔记：https://zhuanlan.zhihu.com/p/24772389\nstep1：安装Java 下载、安装容易，但是将java命令添加到环境变量需要仔细一点 网上有很多笔记，例如：Java JDK安装和配置 - Java教程™ (yiibai.com) 如果在window的cmd平台调用java命令，出现如下结果，说明安装、配置java成功了 step2：chrome浏览器相关 首先要下载、安装Chrome浏览器，根据提示选择默认安装路径即可 https://www.google.cn/chrome/ 然后要下载ChromeDriver.exe https://sites.google.com/chromium.org/driver/ 有两点要注意（1）下载ChromeDriver版本要与Chrome版本一致（我的是94系列）；（2）储存路径要与chrome.exe在一个文件夹内；我的安装路径是 C:\\Program Files\\Google\\Chrome\\Application step3：下载selenium-server-standalone.jar 下载地址：http://selenium-release.storage.googleapis.com/index.html 有很多版本可供选择，我下载的是3.14版本；同时为了管理方便，与上面文件放在了同一文件夹内； 最后如果调用下面命令，出现如下图的结果说明selenium相关环境都配置好了\n1 java -Dwebdriver.chrome.driver=\u0026#34;C:\\Program Files\\Google\\Chrome\\Application\\chromedriver.exe\u0026#34; -jar \u0026#34;C:\\Program Files\\Google\\Chrome\\Application\\selenium-server-standalone-3.141.59.jar\u0026#34; 5、豆瓣爬虫实战 前期准备 （1）准备selenium环境 打开window命令行界面：win + r ，输入cmd回车；然后输入以下命令。待成功出现上图结果后，最小化界面即可。之后的操作都基于R 1 java -Dwebdriver.chrome.driver=\u0026#34;C:\\Program Files\\Google\\Chrome\\Application\\chromedriver.exe\u0026#34; -jar \u0026#34;C:\\Program Files\\Google\\Chrome\\Application\\selenium-server-standalone-3.141.59.jar\u0026#34; （2）安装、加载R包 1 2 3 4 5 6 library(RSelenium) #调试浏览器 library(xml2) #解析html结构 library(rvest) #结合xpath，定位目标节点 library(tidyverse) #数据整理、清洗 实战1：爬取最近热门电影的名字、评分 网址链接：https://movie.douban.com/ 目标i节点的xpath路径：//*[@id=\u0026quot;content\u0026quot;]/div/div[2]/div[4]/div[3]/div/div[1]/div//p Step1：调用浏览器，进入目标网址 1 2 3 4 remDr \u0026lt;- remoteDriver(remoteServerAddr = \u0026#34;localhost\u0026#34;, port = 4444, browserName = \u0026#34;chrome\u0026#34;) remDr$open() # 打开浏览器 remDr$navigate(\u0026#34;https://movie.douban.com\u0026#34;) #进入网址 Step2：获得、解析当前网页html内容 1 webpage \u0026lt;- read_html(remDr$getPageSource()[[1]][1]) #获得网页的html内容 Step3：应用xpath路径，定位、获取目标节点内容 html_text() 可获得目标节点的文本内容 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 xpath_name = \u0026#39;//*[@id=\u0026#34;content\u0026#34;]/div/div[2]/div[4]/div[3]/div/div[1]/div//p\u0026#39; text_raw = html_elements(webpage, xpath = xpath_name) %\u0026gt;% html_text() str(text_raw) # chr [1:70] \u0026#34;\\n \\n\\n 致命感应\\n\\n \\n 6.8\\n \\n \u0026#34; ... #运用各种字符处理技巧，清洗数据 text_fine = text_raw %\u0026gt;% gsub(\u0026#34; \u0026#34;,\u0026#34;\u0026#34;,.) %\u0026gt;% str_split(\u0026#34;\\n{2,}\u0026#34;,simplify = T) %\u0026gt;% .[,2:3] %\u0026gt;% as.data.frame() %\u0026gt;% rename(Name=V1, Score=V2) head(text_fine) # Name Score # 1 致命感应 6.8 # 2 密室逃生2 6.2 # 3 健听女孩 8.6 # 4 普吉岛的最后黄昏 9.0 # 5 X特遣队：全员集结 8.0 # 6 灵媒 6.4 关于目标节点的xpath路径确认是很关键的一。其次当xpath路径本身含有双引号时，创建字符串时两边要改到单引号。\n实战2：爬取最近热门电影的图片、详情页链接 爬取图片时本质上还是获得图片对应的链接，然后再下载即可。 而链接内容一般作为节点的属性值，而不会在网页显示出来。 html_attr()可获得目标节点的属性值 图片节点xapth：//*[@id='content']/div/div[2]/div[4]/div[3]/div/div[1]/div//div/img （1）爬取图片 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 xpath_img = \u0026#34;//*[@id=\u0026#39;content\u0026#39;]/div/div[2]/div[4]/div[3]/div/div[1]/div//div/img\u0026#34; img_link = html_elements(webpage, xpath = xpath_img) %\u0026gt;% html_attr(name = \u0026#39;src\u0026#39;) head(img_link) # [1] \u0026#34;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2672792129.jpg\u0026#34; # [2] \u0026#34;https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2729074424.jpg\u0026#34; # [3] \u0026#34;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2665001891.jpg\u0026#34; # [4] \u0026#34;https://img9.doubanio.com/view/photo/s_ratio_poster/public/p2652268085.jpg\u0026#34; # [5] \u0026#34;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2637084112.jpg\u0026#34; # [6] \u0026#34;https://img2.doubanio.com/view/photo/s_ratio_poster/public/p2661923862.jpg\u0026#34; #批量下载图片 #获取属性名为 src 的值 dir.create(\u0026#39;tmp\u0026#39;) for (i in 1:length(img_link)) { # i = 1 print(i) img_name \u0026lt;- paste0(\u0026#39;tmp/\u0026#39;,text_fine$Name[i],\u0026#34;.jpg\u0026#34;) download.file(url = img_link[i], destfile = img_name, method = \u0026#34;curl\u0026#34;) } 由于可以通过点击电影名进入电影详情页，由此判定在电影名节点的属性包含链接属性 电影名节点xapth：//*[@id='content']/div/div[2]/div[4]/div[3]/div/div[1]/div//a （2）爬取链接 1 2 3 4 5 6 7 8 9 10 11 12 xpath_link = \u0026#34;//*[@id=\u0026#39;content\u0026#39;]/div/div[2]/div[4]/div[3]/div/div[1]/div//a\u0026#34; movie_link = html_elements(webpage, xpath = xpath_link) %\u0026gt;% html_attr(name = \u0026#39;href\u0026#39;) movie_info = cbind(text_fine, movie_link) head(movie_info) # Name Score movie_link # 1 致命感应 6.8 https://movie.douban.com/subject/25909236/?tag=热门\u0026amp;from=gaia_video # 2 密室逃生2 6.2 https://movie.douban.com/subject/30469922/?tag=热门\u0026amp;from=gaia # 3 健听女孩 8.6 https://movie.douban.com/subject/35048413/?tag=热门\u0026amp;from=gaia # 4 普吉岛的最后黄昏 9.0 https://movie.douban.com/subject/35472124/?tag=热门\u0026amp;from=gaia # 5 X特遣队：全员集结 8.0 https://movie.douban.com/subject/26741632/?tag=热门\u0026amp;from=gaia # 6 灵媒 6.4 https://movie.douban.com/subject/35208823/?tag=热门\u0026amp;from=gaia 实战3：爬取不同类型标签的电影名、评分(模拟鼠标点击翻页) Selenium的强大之处至于可以模拟鼠标操作进行网页选择、切换； 如下图，我们想获得框选出的8种类别的电影名与评分 目标网址：https://movie.douban.com/tag/#/ Step1：调用浏览器，进入目标网址 1 2 3 4 remDr \u0026lt;- remoteDriver(remoteServerAddr = \u0026#34;localhost\u0026#34;, port = 4444, browserName = \u0026#34;chrome\u0026#34;) remDr$open() # 打开浏览器 remDr$navigate(\u0026#34;https://movie.douban.com\u0026#34;) #进入网址 Step2：获得、解析当前网页html内容 1 webpage \u0026lt;- read_html(remDr$getPageSource()[[1]][1]) #获得网页的html内容 Step3：我们需要模拟鼠标点击那个节点、点多少次 1 2 3 4 movie_type = webpage %\u0026gt;% html_elements(xpath = \u0026#34;//*[@id=\u0026#39;app\u0026#39;]/div/div[1]/div[1]/ul[5]//span\u0026#34;) %\u0026gt;% html_text() %\u0026gt;% .[2:9] movie_type # [1] \u0026#34;经典\u0026#34; \u0026#34;青春\u0026#34; \u0026#34;文艺\u0026#34; \u0026#34;搞笑\u0026#34; \u0026#34;励志\u0026#34; \u0026#34;魔幻\u0026#34; \u0026#34;感人\u0026#34; \u0026#34;女性\u0026#34; Step4：循环点击、进行目标文本爬取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 movie_stat = list() for(i in seq(movie_type)){ # i=1 print(i) #鼠标点击节点的xpath路径 button_xpath = sprintf(\u0026#34;//*[@id=\u0026#39;app\u0026#39;]/div/div[1]/div[1]/ul[5]//span[contains(text(), \u0026#39;%s\u0026#39;)]\u0026#34;, movie_type[i]) #该节点的鼠标点击属性 button = remDr$findElement(using =\u0026#39;xpath\u0026#39;, value = button_xpath) #模拟鼠标点击该节点 button$clickElement() Sys.sleep(3) #更新当前html内容 webpage \u0026lt;- read_html(remDr$getPageSource()[[1]][1]) xpath_name = \u0026#34;//*[@id=\u0026#39;app\u0026#39;]/div/div[1]/div[3]//span\u0026#34; #结合目标文本的xpath路径爬取内容 test_raw = html_elements(webpage, xpath = xpath_name) %\u0026gt;% html_text() movie_stat[[i]] = data.frame(Type = movie_type[i], Name=test_raw[seq(2,60,3)], Score=test_raw[seq(3,60,3)]) } movie_stats = do.call(rbind, movie_stat) head(movie_stats) # Type Name Score # 1 经典 沙丘 7.8 # 2 经典 肖申克的救赎 9.7 # 3 经典 我不是药神 9.0 # 4 经典 疯狂动物城 9.2 # 5 经典 千与千寻 9.4 # 6 经典 泰坦尼克号 9.4 table(movie_stats$Type) # 感人 搞笑 经典 励志 魔幻 女性 青春 文艺 # 20 20 20 20 20 20 20 20 实战4：爬取表格结构的文本 有时候我们的目标数据是以表格结构放在网页的；此时可直接利用html_table()将表格爬取下来 示例网址：由于豆瓣网没有找到表格数据，因此切换到之前学过的记录疾病相关信息的网站https://www.malacards.org/card/alzheimer_disease?search=Alzheimer%20Disease 进入此网址，想对AD相关的基因信息进行爬取； xpath路径：//*[@id=\u0026quot;RelatedGenes-table\u0026quot;] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 remDr \u0026lt;- remoteDriver(remoteServerAddr = \u0026#34;localhost\u0026#34;, port = 4444, browserName = \u0026#34;chrome\u0026#34;) remDr$open() # 打开浏览器 remDr$navigate(\u0026#34;https://www.malacards.org/card/alzheimer_disease?search=Alzheimer%20Disease\u0026#34;) #进入分类网址 webpage \u0026lt;- read_html(remDr$getPageSource()[[1]][1]) #获得网页的html内容 xpath_test = \u0026#39;//*[@id=\u0026#34;RelatedGenes-table\u0026#34;]\u0026#39; test = webpage %\u0026gt;% html_elements(xpath = xpath_test) %\u0026gt;% html_table() df = test[[1]] head(df) # A tibble: 6 x 7 # `#` Symbol Description Category Score Evidence `PubMed IDs` # \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 1 \u0026#34;APP\u0026#34; Amyloid Beta P~ \u0026#34;Protein~ 1408. \u0026#34;Molecular bas~ \u0026#34;1302033 1303239 ~ # 2 1 \u0026#34;APP::MIR1~ MIR106B Macro ~ \u0026#34;\u0026#34; NA \u0026#34;\u0026#34; \u0026#34;\u0026#34; # 3 2 \u0026#34;HFE\u0026#34; Homeostatic Ir~ \u0026#34;Protein~ 1098. \u0026#34;Molecular bas~ \u0026#34;12429850 8696333~ # 4 3 \u0026#34;NOS3\u0026#34; Nitric Oxide S~ \u0026#34;Protein~ 708. \u0026#34;Molecular bas~ \u0026#34;9737779 9894802 ~ # 5 4 \u0026#34;MPO\u0026#34; Myeloperoxidase \u0026#34;Protein~ 696. \u0026#34;Molecular bas~ \u0026#34;11087769 1291567~ # 6 5 \u0026#34;PLAU\u0026#34; Plasminogen Ac~ \u0026#34;Protein~ 695. \u0026#34;Molecular bas~ \u0026#34;12898287 1561577~ ","permalink":"https://lishensuo.github.io/en/posts/program/250r%E8%AF%AD%E8%A8%80rselenium%E7%88%AC%E8%99%AB/","summary":"\u003ch1 id=\"1html基础与xpath语法\"\u003e1、html基础与xpath语法\u003c/h1\u003e\n\u003ch2 id=\"11-html基础\"\u003e1.1 html基础\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e大多数网页内容都是html结构组织的，在我理解就是有众多节点(node)组成的树状结构；\u003c/li\u003e\n\u003cli\u003e而我们想要爬取的内容就是其中的某个或者某些节点的文本标签或者属性中。\u003c/li\u003e\n\u003cli\u003e更多可参考：\n（1）https://www.w3cschool.cn/html/html-basic.html\n（2）\u003ca href=\"https://blog.csdn.net/zong596568821xp/article/details/83277729\"\u003eHTML零基础入门教程（详细）_ZONGXP的博客-CSDN博客_html5零基础入门教程\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-f4feac53f781e66d.png\" alt=\"\"  /\u003e\r\n\u003c/p\u003e","title":"R语言RSelenium爬虫.md"},{"content":" 总结一下目前学习的，基于Rstudio的创建R包流程。\nPart1：创建R包基本流程 step1：建立开发环境 目的是创建一个文件夹，用于储存编写R包的各种文档；在创建之前想 好R包的名字，以及文件夹的路径。 这里示例R包名为newPackage。 进入Rstudio界面，依次点击File → New project → New Directory → R package,会出现如下界面，填写好R包名字，选择好开发包的工作目录（其它暂时都不用考虑）；最后点击Creat Project即可。 如上操作后，会进入新的工作环境，即R包开发环境；同时已经创建好R包开发所需的所必须的模板文档。主要包括4个部分： （1）R 文件夹：用于存放R函数脚本的文件夹；里面有一个示例文件hello.R （2）man 文件夹：用于存放对应上述R函数的说明文档Rd文件的文件夹；里面有一个示例文件hello.Rd。 （3）DESCRIPTION：关于R包的说明文档。 （4）NAMESPACE：声明R包导出以供外部使用的函数以及R包从其他包导入的外部函数。\n其中只有R函数脚本与DESCRIPTION需要我们细心准备外，其它可通过一些办法自动写入、更新。\nstep2：编写函数 首先先删除R文件夹里的示例文件、整个man文件夹、NAMESPACE文件；\n2.2 然后在R文件夹内创建后缀名为.R的函数脚本，编写自定义的函数；\n（1）如下在新创建的add.R脚本中，编写一个简单的加法函数。\n（2） 然后鼠标放置在函数上（如上图），按Ctrl+Alt+Shift+R组合快捷键为函数添加说明文档模板（Insert Roxygen Skeleton）(下左)；根据自己函数的功能完成注释(下右)\n（3）测试编写的函数，有没有问题\n1 2 3 4 5 #激活R文件夹内的所有函数，供测试使用 devtools::load_all() # i Loading newPackage add(1,6) # [1] 7 重复上述1~3步骤，不断添加新的函数。可以是一个函数对应一个脚本，也可以将同一类的函数都放置在一个脚本内。 （4）为所有函数在man文件夹(如果没有，会创建)下逐一自动建立Rd文档，以及更新NAMESPCAE文档\n1 2 3 4 5 6 7 # 重复上述1~3步骤，又创建了一个减法的函数脚本 devtools::document() # i Updating newPackage documentation # i Loading newPackage # Writing NAMESPACE # Writing NAMESPACE step3：编写DESCRIPTION文件 函数写好了之后，就需要对这个包的总体功能等信息进行描述与说明，这些信息主要包含在DESCRIPTION文件中\n首先如下图所示，修改其中的四点说明：Title包的名字，Authors@R、Maintainer作者以及维护者信息、Description包的简要描述 然后使用下述函数，自动编写License部分 1 2 # 如果没有依赖到别的具有不同版权的第三方包的话，一般选择最为广泛使用的 MIT 即可 usethis::use_mit_license() 此外，如果版本有更新，可手动修改 Version部分\n之后再补充依赖包的信息。分为两类：Imports、Suggests、Depends。三者的区别还没完全清楚，暂时觉得还是第一个常用。\n可使用函数usethis::use_package(package, type = \u0026quot;Imports\u0026quot;, min_version = NULL);\n假设其中的一个自定义的函数必须要用到dplyr包的filter()函数（因为实际中并未没有使用，之后会删去）\n1 2 3 4 5 6 usethis::use_package(\u0026#34;dplyr\u0026#34;, type = \u0026#34;Imports\u0026#34;, min_version = \u0026#34;1.0\u0026#34;) # √ Adding \u0026#39;dplyr\u0026#39; to Imports field in DESCRIPTION # * Refer to functions with `dplyr::fun()` # 在函数脚本中使用的过程调用其它包的函数时，必须按照`package::function`，如`dplyr::filter()`的形式调用。 最后再check一下上述的所有文件，包括函数脚本，看看有没有问题 在R包不断完善的过程中，可以随时check一下，保证之前的修改没有什么问题\n1 2 3 4 5 devtools::check() # -- R CMD check results --------------------- newPackage 0.1.0 ---- # Duration: 19s # # 0 errors √ | 0 warnings √ | 0 notes √ step4：收尾工作\u0026ndash;安装包 （1）将包安装到本地的电脑 点击Build → Install and restart，可将进行安装R，重启R，加载该包三个步骤。 （2）将包制成压缩包(*.tar.gz)，方便传输或者分享 点击Build → Build Source Package 1 2 install.packages(\u0026#34;path/to/newPackage_0.1.0.tar.gz\u0026#34;, repos=NULL, type=\u0026#34;source\u0026#34;) Part2：R包进阶操作 上面介绍了编写R包的最简单的流程，还有很多进阶知识点值得学习。下面总结其中三个方面的整理。\n2.1 示例数据集 （1）存储为rdata格式并使其对用户可用 使用usethis::use_data()函数，将数据对象（字符串、表格）储存到data文件夹里的rdata文件。\n1 2 3 4 5 6 7 8 9 x \u0026lt;- sample(1000) usethis::use_data(x) # √ Saving \u0026#39;x\u0026#39; to \u0026#39;data/x.rda\u0026#39; # * Document your data (see \u0026#39;https://r-pkgs.org/data.html\u0026#39; dataframe = mtcars usethis::use_data(dataframe) # √ Saving \u0026#39;dataframe\u0026#39; to \u0026#39;data/dataframe.rda\u0026#39; # * Document your data (see \u0026#39;https://r-pkgs.org/data.html\u0026#39;) 根据提示，需要在R文件夹下，创建内容框架如下的data.R说明文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #\u0026#39; x #\u0026#39; #\u0026#39; Just test number(Description) #\u0026#39; #\u0026#39; @examples #\u0026#39; head(x) \u0026#34;x\u0026#34; #\u0026#39; dataframe #\u0026#39; #\u0026#39; Just test dataframe(Description) #\u0026#39; #\u0026#39; @examples #\u0026#39; head(dataframe) \u0026#34;dataframe\u0026#34; （2）储存为原始文件的形式（例如.csv，.xlsx等） 创建inst/extdata文件夹，用于储存这些文件即可\n1 2 dir.create(\u0026#34;inst/extdata\u0026#34;, recursive = T) write.csv(mtcars, file = \u0026#34;inst/extdata/example.csv\u0026#34;) （3）调用这些数据 先document()、check()一下；重新安装，加载\n1 2 devtools::document() devtools::check() 点击Build → Install and restart\n调用示例数据\n1 2 3 4 5 6 7 8 9 10 11 12 data(x) ?x str(x) # int [1:1000] 134 448 373 532 823 646 567 146 776 503 ... data(dataframe) dim(dataframe) # [1] 32 11 system.file(\u0026#34;extdata\u0026#34;, \u0026#34;example.csv\u0026#34;, package = \u0026#34;newPackage\u0026#34;) # [1] \u0026#34;C:/Users/******/Documents/R/win-library/4.1/newPackage/extdata/example.csv\u0026#34; 2.2 代码整理 （1）代码美化 1 2 3 4 5 # 安装 {styler} # install.packages(\u0026#34;styler\u0026#34;) # 对整个包进行代码美化 styler::style_pkg() （2）代码规范性检查 1 2 3 4 5 # 安装 {lintr} # install.packages(\u0026#34;lintr\u0026#34;) # 对整个包进行不符合规范的代码查询（当然，都没有写多少代码，当然不会出现什么错误结果） lintr::lint_package() 2.3 上传github 在我理解，将个人创建的R包上传到github中，可以高效的实现版本的控制、备份以及与他人共享，自己的使用等\n（1）上传至github 已经基本完成了R包的成形工作（Part1），或者刚建立好R包开发环境也可以。\n下载安装 Github Desktop，并登陆自己的个人账户。\n如下图，将R包开发环境目录关联到respository仓库内。\n点击之后，一般会提示关联的R包开发环境目录不在Git的仓库列表中，点击creat a repository即可\n最后再点击Publish respository，并设置是否code private即可成功上传到github。\n（2）commit → push 之后对包的文档进行修改、更新等操作时，都可以通过Github Desktop进行方便的提交\n如下，对包添加了一个函数：在Github Desktop左下角填写更改的描述、点击Commit to main，再push到github上。之后在github主页看到的就是更新后的版本。\n（3）创建README文件 1 2 3 4 5 6 7 8 9 10 # 引入必备包 {rmarkdown} # install.packages(\u0026#34;rmarkdown\u0026#34;) # 默认的 README.Rmd 模版就创建完 usethis::use_readme_rmd() # 然后在README.Rmd文件中进行修改 # 最后Knit即可 # 最后再在Github Desktop里 commit→push即可再github页面创建美观的read.me文档 参考教程： 1、为新手准备的现代化 R 包开发流程 https://cosx.org/2021/02/writing-r-packages-a-modern-workflow-for-beginners/ 2、R包的开发 https://zhuanlan.zhihu.com/p/336425664 3、https://r-packages-zh-cn.readthedocs.io/zh_CN/latest/index.html\n补充 (1) 在代码脚本中引入管道符 %\u0026gt;% 1 usethis::use_pipe() #在R中使用管道符 (2) 本地安装R包方式\n1 2 3 4 5 6 7 ## 情况1 install.packages(\u0026#34;RJSONIO_0.2-3.tar.gz\u0026#34;, repos = NULL, type=\u0026#34;source\u0026#34;) ## 情况2 list.files(\u0026#34;BayesPrism-main/BayesPrism/\u0026#34;) # [1] \u0026#34;DESCRIPTION\u0026#34; \u0026#34;inst\u0026#34; \u0026#34;man\u0026#34; \u0026#34;NAMESPACE\u0026#34; \u0026#34;R\u0026#34; devtools::install_local(\u0026#34;BayesPrism-main/BayesPrism/\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/program/252%E5%9F%BA%E4%BA%8Erstudio%E5%88%9B%E5%BB%BAr%E5%8C%85/","summary":"\u003cblockquote\u003e\n\u003cp\u003e总结一下目前学习的，基于Rstudio的创建R包流程。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"part1创建r包基本流程\"\u003ePart1：创建R包基本流程\u003c/h2\u003e\n\u003ch3 id=\"step1建立开发环境\"\u003estep1：建立开发环境\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e目的是创建一个文件夹，用于储存编写R包的各种文档；在创建之前想 好R包的名字，以及文件夹的路径。\u003c/li\u003e\n\u003cli\u003e这里示例R包名为\u003ccode\u003enewPackage\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e进入Rstudio界面，依次点击\u003ccode\u003eFile → New project → New Directory → R package\u003c/code\u003e,会出现如下界面，填写好R包名字，选择好开发包的工作目录（其它暂时都不用考虑）；最后点击\u003ccode\u003eCreat Project\u003c/code\u003e即可。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-dfcc151f2e1b379a.png\" style=\"zoom:50%;\" /\u003e\n\u003cul\u003e\n\u003cli\u003e如上操作后，会进入新的工作环境，即R包开发环境；同时已经创建好R包开发所需的所必须的模板文档。主要包括4个部分：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/20354525-cbe293578c2aeb32.png\" style=\"zoom:67%;\" /\u003e\n\u003cp\u003e（1）\u003cstrong\u003eR 文件夹\u003c/strong\u003e：用于存放R函数脚本的文件夹；里面有一个示例文件hello.R\n（2）man 文件夹：用于存放对应上述R函数的说明文档Rd文件的文件夹；里面有一个示例文件hello.Rd。\n（3）\u003cstrong\u003eDESCRIPTION\u003c/strong\u003e：关于R包的说明文档。\n（4）NAMESPACE：声明R包导出以供外部使用的函数以及R包从其他包导入的外部函数。\u003c/p\u003e","title":"基于Rstudio创建R包"},{"content":" 主要参考教程 ：https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/\n1、基本框架 （1）ui：布局呈现给用户的输入、输出界面\n（2）server：处理用户的输入，返回输出结果的内部计算函数\n（3）shinyApp命令整合上述的ui与server\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ##(1) 模板--常见布局方式 library(shiny) ui \u0026lt;- fluidPage( #标题栏 titlePanel(\u0026#34;This is total title\u0026#34;), #主体部分 sidebarLayout( #侧边用户输入栏 sidebarPanel( \u0026#34;side panel\u0026#34;, ****Input() ), #展示计算输出栏 mainPanel( \u0026#34;main panle\u0026#34;, ****Output(\u0026#34;var1\u0026#34;) ) ) #sidebarLayout() ) #fluidPage() server \u0026lt;- function(input, output) { output$var1 \u0026lt;- render****({ *******input$** }) } shinyApp(ui, server) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ##(2)示例 library(shiny) ui \u0026lt;- fluidPage( titlePanel(\u0026#34;Hello Shiny!\u0026#34;), sidebarLayout( sidebarPanel( sliderInput(inputId = \u0026#34;bins\u0026#34;, label = \u0026#34;Number of bins:\u0026#34;, min = 1, max = 50, value = 30) ), mainPanel( plotOutput(outputId = \u0026#34;distPlot\u0026#34;) ) ) ) server \u0026lt;- function(input, output) { output$distPlot \u0026lt;- renderPlot({ x \u0026lt;- faithful$waiting bins \u0026lt;- seq(min(x), max(x), length.out = input$bins + 1) hist(x, breaks = bins, col = \u0026#34;#75AADB\u0026#34;, border = \u0026#34;white\u0026#34;, xlab = \u0026#34;Waiting time to next eruption (in mins)\u0026#34;, main = \u0026#34;Histogram of waiting times\u0026#34;) }) } shinyApp(ui = ui, server = server) 如上设置是比较基础、常规的shiny界面布局；对于具体控件、输出的位置完全可以自由安排。\n（1）在Rstudo的script面板中编辑、保存好上述三个部分好，在右上角会自动出现一个Run App的选项，可方便地调试。\n（2）调试完成后，将script重命名为app.R，放置在一个文件夹内。然后在该文件夹所在工作目录使用runApp()函数运行App\n1 2 3 4 5 6 7 library(shiny) list.files(\u0026#34;test01/\u0026#34;) # [1] \u0026#34;app.R\u0026#34; runApp(\u0026#34;test01\u0026#34;) #直接运行 runApp(\u0026#34;test01\u0026#34;, display.mode = \u0026#34;showcase\u0026#34;) #在界面同时显示app.R代码 runApp(\u0026#34;test01\u0026#34;, port = 3344) #指定端口，否则会随机选择 在之前，是将 ui与server分为两个单独的脚本，分别命名为ui.R，server.R。目前支持合并到了一个app.R里面，更方便些。\n2、ui输入栏widget （1）shiny最重要的特点是交互性，可根据用户特定的输入，进行内部计算后，然后在输出栏呈现。\n（2）这些输入可大体分为：字符串、数值、逻辑值等；shiny包相应地提供了一系列的***Input()函数，用于接受用户的输入。\n（3）通常这些函数的\n第一个参数inputId为输入变量的ID名，在之后内部计算时，传递这些变量，用户不可见。 第二个参数label设置这些widget的标签信息，用于提示用户输入。 之后的参数，因接受的不同类型输入，不同函数有不同的参数。可在每个函数的帮助文档获得详细的介绍。 （4）觉得比较常用的有如下\nradioButtons()：单选框 1 2 3 4 5 6 7 8 9 10 11 12 13 14 radioButtons(\u0026#34;inputID\u0026#34;, \u0026#34;Please choose one:\u0026#34;, # choices设置选项名以及每个选项对应的值（传递给inputId） choices = c(\u0026#34;Option A\u0026#34; = \u0026#34;norm\u0026#34;, \u0026#34;Option B\u0026#34; = \u0026#34;unif\u0026#34;, \u0026#34;Option C\u0026#34; = \u0026#34;lnorm\u0026#34;, \u0026#34;Option D\u0026#34; = \u0026#34;exp\u0026#34;), # selected设置初始值，默认为第一个选项的值 selected = \u0026#34;unif\u0026#34;, # inline设置是否横向排布选项 inline = FALSE) ## checkboxGroupInput()：多选框，可返回长度大于1的字符串变量 ## selectInput()：下拉列表，可调整参数设置单选或者多选 ## textInput()：用户接受用于自定义的字符串变量 numericInput()：滑动窗传递数值 1 2 3 4 5 6 7 sliderInput(\u0026#34;inputID\u0026#34;, \u0026#34;Please input a number:\u0026#34;, #设置初始值，以及允许的最小、最大值从，移动步长 value = 500, min = 0, max = 1000, #是否自动遍历所有的值，默认为FALSE animate = FALSE) ## numericInput()：用户自定义传递数值 此外checkboxInput()可用来传递逻辑值，fileInput()可用来上传csv等文件。 3、server计算与ui输出栏 （1）如下，server本质是一个自定义函数，有两个list-like的参数\ninput：可以理解为list对象，名字和值为上述widget传递的变量名与值 output：同样可以理解为list对象，如下所示每一个part都是为了计算一个output（根据input的值变而变） 1 2 3 4 5 6 7 8 9 10 server \u0026lt;- function(input, output) { output$outputID1 = render***({ ...input$inputID... ................... #默认返回最后一行的结果 }), output$outputID2 = render***({ ...input$inputID... ................... #默认返回最后一行的结果 }) } 需要注意在计算每一个output时，都必须嵌套在render***函数类，用以传递不同类型的输出结果。\n其中，目前觉得renderTable、renderPlot、renderText比较常用\n（2）对于上述server的计算结果，可在fluidPage()通过***Output系列函数传递给用户，基本与上面的render***函数存在对应关系。在使用时一般直接指定输出变量名作为参数即可。\n1 2 ##常置于fluidPage() → mainPanel()内 ***Output(\u0026#34;outputID\u0026#34;) 综上 ui与server，以及input与output的关系可以表示如下\n4、文本格式化 在UI界面中除了提示用户输入栏以及输出栏，还有可以添加一些文本、图片用以解释说明。\nshiny包提供了一些可供设置文本格式的系列函数，以达到美观的效果。\np()与div()均表示段落，前者文本格式可不同，后者格式需一致\nimg()插入图片时，需在app.R脚本同级路径创建一个www文件夹，然后将图片文件置于内。之后就可以直接应用图片名。\n在shiny的titlePanel()只能设置一个标题参数；对于其余主体部分，可自由布局文本、图片，以及input、output的位置。\n如下为一个示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 library(shiny) ui \u0026lt;- fluidPage( titlePanel(h1(\u0026#34;Hello Shiny!\u0026#34;, align=\u0026#34;center\u0026#34;)), sidebarLayout( sidebarPanel( p(\u0026#34;This is just a paragraph:To add more advanced content, use one of Shiny’s HTML tag functions. These functions parallel common HTML5 tags. Let’s try out a few of them.\u0026#34;, style = \u0026#34;font-family: \u0026#39;times\u0026#39;; font-size:16pt ; color:blue\u0026#34;), br(), p(\u0026#34;This is just another paragraph:\u0026#34;, strong(\u0026#34;ABCDE\u0026#34;),em(\u0026#34;qwert\u0026#34;), a(\u0026#34;This is a link.\u0026#34;, href = \u0026#34;http://baidu.com\u0026#34;), span(\u0026#34;this is red text\u0026#34;, style=\u0026#34;color:red\u0026#34;)), sliderInput(inputId = \u0026#34;bins\u0026#34;, label = \u0026#34;Number of bins:\u0026#34;, min = 1, max = 50, value = 30) ), mainPanel( img(src = \u0026#34;picture.png\u0026#34; , height = 50, width = 100), br(), code(\u0026#34;This is code-like text\u0026#34;), plotOutput(outputId = \u0026#34;distPlot\u0026#34;) ) ) ) server \u0026lt;- function(input, output) { output$distPlot \u0026lt;- renderPlot({ x \u0026lt;- faithful$waiting bins \u0026lt;- seq(min(x), max(x), length.out = input$bins + 1) hist(x, breaks = bins, col = \u0026#34;#75AADB\u0026#34;, border = \u0026#34;white\u0026#34;, xlab = \u0026#34;Waiting time to next eruption (in mins)\u0026#34;, main = \u0026#34;Histogram of waiting times\u0026#34;) }) } shinyApp(ui = ui, server = server) 5、加载其它数据 如上在app.R脚本有3部分内容，分别是ui，server以及shinyApp()\n由于特定的需求，在运行App前可能需要加载一些包、脚本或者数据，可以在app.R开头部分声明。\n其中对于自定义脚本文件可放在与app.R同级的路径；对于数据，建议放在app.R同级的路径新建data文件夹内。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # Load packages ---- library(shiny) library(dplyr) # Load data ---- dat1 \u0026lt;- readRDS(\u0026#34;data/dat1.rds\u0026#34;) dat2 \u0026lt;- read.csv(\u0026#34;data/dat2.csv\u0026#34;) # Source predefined functions scripts----- source(\u0026#34;function.R\u0026#34;) ui \u0026lt;- fluidPage( ........... ) server \u0026lt;- function(input, output) { ........... } shinyApp(ui, server) 6、shiny server shiny server可将app发布到服务器到，分享给其他人使用。\n前提是需要有服务器的ROOT权限，以下以ubuntu服务器操作为例。\n6.1、安装shiny server 参考：https://docs.rstudio.com/shiny-server/?_ga=2.30896886.831263136.1653093233-369539279.1626573788#host-a-directory-of-applications 简单来说：安装r-base → 安装shiny包 → 安装shiny Server\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ##(1) 安装r-base # update indices apt update -qq # install two helper packages we need apt install --no-install-recommends software-properties-common dirmngr # add the signing key (by Michael Rutter) for these repos # To verify key, run gpg --show-keys /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc # Fingerprint: E298A3A825C0D65DFD57CBB651716619E084DAB9 wget -qO- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo tee -a /etc/apt/trusted.gpg.d/cran_ubuntu_key.asc # add the R 4.0 repo from CRAN -- adjust \u0026#39;focal\u0026#39; to \u0026#39;groovy\u0026#39; or \u0026#39;bionic\u0026#39; as needed add-apt-repository \u0026#34;deb https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/\u0026#34; apt install --no-install-recommends r-base add-apt-repository ppa:c2d4u.team/c2d4u4.0+ ##(2) 安装shiny包 #准备编译环境 sudo apt-get install build-essential sudo apt-get install libz-dev #设置镜像 vi ~/.Rprofile #options(repos=structure(c(CRAN=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/CRAN/\u0026#34;))) #options(BioC_mirror=\u0026#34;https://mirrors.tuna.tsinghua.edu.cn/bioconductor\u0026#34;) #安装R包 R # install.packages(\u0026#34;shiny\u0026#34;) ##(3) 安装 shiny server sudo apt-get install gdebi-core wget https://download3.rstudio.org/ubuntu-18.04/x86_64/shiny-server-1.5.18.987-amd64.deb sudo gdebi shiny-server-1.5.18.987-amd64.deb 2、启动shiny server 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 ##(1) 查看config配置文件 cat /etc/shiny-server/shiny-server.conf ## 如下可以看到默认端口为 3838， 可自定义修改；需要确保服务器开放了这一端口（防火墙管理） # # Instruct Shiny Server to run applications as the user \u0026#34;shiny\u0026#34; # run_as shiny; # # # Define a server that listens on port 3838 # server { # listen 3838; # # # Define a location at the base URL # location / { # # # Host the directory of Shiny Apps stored in this directory # site_dir /srv/shiny-server; # # # Log all Shiny output to files in this directory # log_dir /var/log/shiny-server; # # # When a user visits the base URL rather than a particular application, # # an index of the applications available in this directory will be shown. # directory_index on; # } # } ##(2) 查看app脚本文件 tree /srv/shiny-server/ #/srv/shiny-server/ #├── index.html -\u0026gt; /opt/shiny-server/samples/welcome.html #└── sample-apps -\u0026gt; /opt/shiny-server/samples/sample-apps tree /opt/shiny-server/samples/ #/opt/shiny-server/samples/ #├── sample-apps #│ ├── hello #│ │ ├── server.R #│ │ └── ui.R #│ └── rmd #│ └── index.Rmd #└── welcome.html ##(3) 启动 shiny server服务 sudo systemctl start shiny-server #启动 sudo systemctl status shiny-server #查看状态 sudo systemctl stop shiny-server #停止 sudo systemctl restart shiny-server #重启 ##(4) 查看shiny网页 #只需将自己的shiny项目文件夹放置在/srv/shiny-server/目录下即可 #以下是我的试验服务器，仅做用法演示。 # /srv/shiny-server/index.html ---→ http://124.222.37.114:3838/ # /srv/shiny-server/sample-apps/hello ---→ http://124.222.37.114:3838/sample-apps/hello ","permalink":"https://lishensuo.github.io/en/posts/program/251shiny%E5%8C%85%E5%BC%80%E5%8F%91%E7%BD%91%E9%A1%B5app/","summary":"\u003cblockquote\u003e\n\u003cp\u003e主要参考教程 ：https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1基本框架\"\u003e1、基本框架\u003c/h1\u003e\n\u003cp\u003e（1）ui：布局呈现给用户的输入、输出界面\u003c/p\u003e","title":"shiny包开发网页APP基础"},{"content":" purrr包是tidyverse系列中用于函数编程的工具，很多用法类似R base的apply系列函数。现参考相关资料，学习其基本用法。\nhttps://jennybc.github.io/purrr-tutorial/index.html https://shixiangwang.github.io/home/cn/post/purrr-loop/ purrr包的核心是一系列map函数；如下所示，其参数主要有3部分\n1 2 library(tidyverse) map(.x, .f, ...) .x 即迭代对象，支持3类\u0026ndash;列表， 向量， 表格（每一列）； .f 即处理函数，有不同的表达形式； ... 表示设置.f的固定参数。 1. 迭代输出输出 输入是list\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 test = rnorm(12) names(test) = rep(LETTERS[1:4],each=3) test = split(test, rep(1:3,4)) # $`1` # A B C D # -1.0632186 -0.6765097 1.0856251 0.3742525 # $`2` # A B C D # -0.9695107 -2.4663956 -0.8396377 -1.1041372 # $`3` # A B C D # 0.05977038 1.54819774 1.66301988 -0.25377065 ## 遍历每个列表向量中name为A的元素 map(test, function(x) x[\u0026#34;A\u0026#34;]) # $`1` # A # -1.063219 # $`2` # A # -0.9695107 # $`3` # A # 0.05977038 ## 下面两种是map支持的快捷方式，可达到同样的效果 map(test, \u0026#39;A\u0026#39;) map(test, 1) 输入是表格\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 df = data.frame( a = rnorm(10), b = rnorm(10), c = rnorm(10), d = rnorm(10) ) map(df, mean, na.rm=TRUE) # $a # [1] -0.6680202 # $b # [1] 0.1260203 # $c # [1] -0.1479432 # $d # [1] -0.3777024 df %\u0026gt;% map(sd) 特定类型输出\n如上map默认输出为list\n对于输出结果是长度为1的情况，map_lgl()用于输出逻辑型向量；map_dbl()用于输出双精度型向量；map_chr()用于输出字符型向量。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 map_dbl(df, mean) # a b c d # -0.6680202 0.1260203 -0.1479432 -0.3777024 map_chr(df, mean) # a b c d # \u0026#34;-0.668020\u0026#34; \u0026#34;0.126020\u0026#34; \u0026#34;-0.147943\u0026#34; \u0026#34;-0.377702\u0026#34; # Warning message: # Automatic coercion from double to character was deprecated in purrr 1.0.0. # ℹ Please use an explicit call to `as.character()` within `map_chr()` instead. map_lgl(df, mean) # Error in `map_lgl()`: # ℹ In index: 1. # ℹ With name: a. # Caused by error: # ! Can\u0026#39;t coerce from a number to a logical vector. 对于输出结果是等长的情况，map_dfr()可按行合并为表格；map_dfc()可按列合并为表格。 1 2 3 4 5 6 7 8 9 10 map_dfr(df, quantile) # # A tibble: 4 × 5 # `0%` `25%` `50%` `75%` `100%` # \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; # 1 -1.72 -1.30 -0.534 -0.251 0.911 # 2 -1.07 -0.514 0.149 0.926 1.04 # 3 -1.28 -0.908 -0.104 0.503 1.01 # 4 -1.81 -0.962 -0.609 0.140 1.41 map_dfc(df, quantile) 2. 函数表达方式 单参数变量情况\n1 2 3 4 5 6 7 8 9 10 11 test = list(L1=c(\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;),L2=c(\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;)) ## 方式1 my_fun \u0026lt;- function(x) paste(x, collapse = \u0026#34; | \u0026#34;) map(test, my_fun) ## 方式2 map(test, paste, collapse = \u0026#34; | \u0026#34;) ## 方式3 map(test, ~ paste(., collapse = \u0026#34; | \u0026#34;)) 多参数变量情况\nmap2系列支持迭代两个输入对象 1 2 3 4 5 6 7 8 9 10 11 mu = list(5, 10, -3) sigma = list(1, 5, 10) ## 方式1 map(1:3, ~ rnorm(5, mu[[.]], sigma[[.]])) ## 方式2 map2(mu, sigma, rnorm, n = 5) ## 方式3 map2(mu, sigma, ~ rnorm(mean=.x, sd=.y, n = 5)) pmap系列支持迭代多个输入对象 1 2 3 4 5 6 ## 等价于上述的结果 pmap(list(n=c(5,5,5), mean=mu, sd=sigma), rnorm) ## 此外pmap支持表格作为批量参数迭代（每一列作为一个参数） pmap_dbl(mtcars[1:4,1:2], function(mpg, cyl){mpg+cyl}) # [1] 27.0 27.0 26.8 27.4 3. 其它用法 3.1 报错不中断 1 2 3 4 5 map(list(1, \u0026#34;a\u0026#34;, 10), log) # Error in `map()`: # ℹ In index: 2. # Caused by error: # ! non-numeric argument to mathematical function safely函数可记录报错信息，继续后面的迭代 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 map(list(1, \u0026#34;a\u0026#34;, 10), safely(log)) # [[1]] # [[1]]$result # [1] 0 # [[1]]$error # NULL # [[2]] # [[2]]$result # NULL # [[2]]$error # \u0026lt;simpleError in .Primitive(\u0026#34;log\u0026#34;)(x, base): non-numeric argument to mathematical function\u0026gt; # [[3]] # [[3]]$result # [1] 2.302585 # [[3]]$error # NULL possibly函数遇见报错则返回指定值 1 2 map_dbl(list(1, \u0026#34;a\u0026#34;, 10),possibly(log, NA)) # [1] 0.000000 NA 2.302585 3.2 walk重在过程 map系列以及apply家族的最终目的是将输入迭代函数处理，得到结果值。 walk函数更适用于不需要返回值的场景，例如屏幕输出，保存文件，保存图片等场景。 walk2可类比map2，pwalk可类比pmap 1 2 walk(LETTERS[1:3], print) walk2(LETTERS[1:3], 1:3, ~print(paste(.x, .y))) other examples：https://www.tidyverse.org/blog/2023/05/purrr-walk-this-way/\n3.3 furrr包多线程 https://furrr.futureverse.org/ furrr包提供多线程调用版本的purrr函数，简单用法如下 1 2 3 4 5 6 7 8 9 plan(multisession, workers = 3) 1:10 %\u0026gt;% future_map(rnorm, n = 10, .options = furrr_options(seed = 123)) %\u0026gt;% future_map_dbl(mean) future_walk(c(2, 2, 2), ~Sys.sleep(.x)) plan(multisession) 4. purrr其它用法 list转换\n1 2 3 4 5 6 7 8 test = list(L1=c(\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;),L2=c(\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;)) transpose(test)[1] # [[1]] # [[1]]$L1 # [1] \u0026#34;A\u0026#34; # [[1]]$L2 # [1] \u0026#34;X\u0026#34; reduce结合\n1 2 3 4 5 6 7 8 9 test = list(L1=c(\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;),L2=c(\u0026#39;X\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;Z\u0026#39;)) reduce(test, paste) # [1] \u0026#34;A X\u0026#34; \u0026#34;B C\u0026#34; \u0026#34;C Z\u0026#34; reduce(test, intersect) # [1] \u0026#34;C\u0026#34; reduce(1:4, `*`) # 24 cross_df排列组合\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 test = list(L1=c(\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;),L2=c(\u0026#39;X\u0026#39;,\u0026#39;Y\u0026#39;,\u0026#39;Z\u0026#39;)) cross_df(test) # # A tibble: 9 × 2 # L1 L2 # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 A X # 2 B X # 3 C X # 4 A Y # 5 B Y # 6 C Y # 7 A Z # 8 B Z # 9 C Z ## 上述对于较大空间排列处理较慢，此时可选择 tidyr::expand_grid() expand_grid(x=test$L1, y=test$L2) # # A tibble: 9 × 2 # x y # \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; # 1 A X # 2 A Y # 3 A Z # 4 B X # 5 B Y # 6 B Z # 7 C X # 8 C Y # 9 C Z ","permalink":"https://lishensuo.github.io/en/posts/program/253r%E5%8C%85purrr%E7%9A%84%E5%87%BD%E6%95%B0%E7%BC%96%E7%A8%8B/","summary":"\u003cblockquote\u003e\n\u003cp\u003epurrr包是tidyverse系列中用于函数编程的工具，很多用法类似R base的apply系列函数。现参考相关资料，学习其基本用法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://jennybc.github.io/purrr-tutorial/index.html\"\u003ehttps://jennybc.github.io/purrr-tutorial/index.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://shixiangwang.github.io/home/cn/post/purrr-loop/\"\u003ehttps://shixiangwang.github.io/home/cn/post/purrr-loop/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://ih1.redbubble.net/image.329884292.2339/sticker,375x360-bg,ffffff.u1.png\" alt=\"Introduction to purrr\"  /\u003e\r\n\u003c/p\u003e","title":"R包purrr的函数编程"},{"content":" shiny中server部分的render×××系列函数是生成reactive output的主要方式。只要其内部的任一input$×××输入参数发生变化都会重新将该函数内部代码全部重新计算一遍以更新输出。此外，类似reactive()，observeEvent()等可以帮助实现更加复杂的输入输出控制，下面简单学习记录下。\nhttps://shiny.posit.co/r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html 1. reactive() reactive()函数用于server部分存储中间计算变量。它可以减少不必要的重复计算过程，并提高了代码简洁性。\n在使用reactive()计算一个特定中间变量(geneids)时，只要其内部的input$×××变化(input$genes_input)，该中间变量的值就会更新。 后续使用这个中间变量时，若需要更新其它的input$×××(input$other1)，则并不会重新计算一遍该中间变量的值，而直接使用当前的缓存结果。 除了上面基础用法，还有两个小知识点\n（1）reactive()可以嵌套在另一个reactive()里，即理解为计算中间变量的中间变量，实现更加复杂的逻辑。\n（2）eventReactive()只有在其第一个参数的事件(通常是actionButton)状态变化才会计算{}内的代码，从而赋予该中间变量一个新的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 library(shiny) ui \u0026lt;- fluidPage( sidebarLayout( sidebarPanel( textInput( \u0026#34;genes_input\u0026#34;,\u0026#34;Input some genes(with comma as separator)\u0026#34; ), actionButton(\u0026#34;button\u0026#34;, \u0026#34;calculate!\u0026#34;) ), mainPanel( ) ) ) server \u0026lt;- function(input, output) { geneids \u0026lt;- reactive({ genenames = input$genes_input genenames = trimws(strsplit(aa,\u0026#34;,\u0026#34;)[[1]]) return(genenames) }) ## （1）geneids()变量可以用于后续server的多种运算目的 output$output_1 \u0026lt;- renderPrint({ function1(geneids(), input$other1) }) output$output_2 \u0026lt;- renderPrint({ function2(geneids(), input$other2) }) ## （2）多层嵌套 geneinfo = reactive({ function3(geneids(), input$other3) }) output$output_3 \u0026lt;- renderPrint({ function3(geneinfo()) }) ## （3）Button to trigger internal calculate geneids2 = eventReactive(input$button, { genenames = input$genes_input genenames = trimws(strsplit(aa,\u0026#34;,\u0026#34;)[[1]]) }) output$output_4 \u0026lt;- renderPrint({ function4(geneids2()) }) } # shinyApp(ui, server) 2. observe() observe()函数相比于reactive()，前者重点在观测与执行；后者在于计算与变量传递。简单来说，只要observe内的input$×××相关输入发生变化，就会执行内部的所有命令。命令执行的结果可以是产生一个新的output$×××；也可以是修改/更新UI里的控件参数。\nreactive()命令的执行结果是产生一个中间变量\n对于产生一个新的output$×××，如下示例（1）与（2）的效果理论上是一样的，（3）observe在观测到IF语句的条件为TRUE的情况下执行后面的代码 实际应用中observeEvent()函数出现的频率更多，其会在event触发事件（通常是actionButton）发生的条件下，执行后面{}里命令。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ui \u0026lt;- fluidPage( sidebarLayout( sidebarPanel( selectInput( \u0026#34;gene_id\u0026#34;, \u0026#34;Input a gene name\u0026#34;, choices = c(\u0026#34;GeneA\u0026#34;,\u0026#34;GeneB\u0026#34;, \u0026#34;GeneC\u0026#34;), selected = \u0026#34;GeneA\u0026#34; ), actionButton(\u0026#34;button\u0026#34;, \u0026#34;calculate!\u0026#34;) ), mainPanel( ) ) ) server \u0026lt;- function(input, output) { ## （1） output$output_1 = renderText({ function1(input$gene_id) }) ## （2） observe( output$output_2 = renderText({ function2(input$gene_id) }) ) ## （3） observe( if(input$gene_id %in% geneset){ output$output_3 = renderText({ function3(input$gene_id) }) } ) ## （4） observeEvent(input$button, { output$output_4 = renderText({ function4(input$gene_id) }) }) } 对于修改/更新UI里的控件参数，需要用到session参数，一般使用update系列函数，比如updateSelectInput(), updateTabsetPanel() 此时update系列函数的第一个参数是session，第二个参数是UI部分里对应元素的ID，后面的参数即可根据需要进行修改、更新。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ui \u0026lt;- fluidPage( sidebarLayout( sidebarPanel( actionButton(\u0026#34;butt\u0026#34;, \u0026#34;change choices randomly\u0026#34;), radioButtons(\u0026#34;candi_type\u0026#34;, \u0026#34;select gene or pathway!\u0026#34;, choices = c(\u0026#34;gene\u0026#34;,\u0026#34;pathway\u0026#34;), selected = \u0026#34;gene\u0026#34;), selectInput( \u0026#34;mol_id\u0026#34;, \u0026#34;select a item\u0026#34;, choices = NULL ), ), mainPanel( ) ) ) server \u0026lt;- function(input, output, session) { ## 根据UI中radioButtons的选择更新selectInput的选项值 observe({ if(input$candi_type==\u0026#34;gene\u0026#34;){ candis = c(\u0026#34;GeneA\u0026#34;,\u0026#34;GeneB\u0026#34;,\u0026#34;GeneC\u0026#34;) } else { candis = c(\u0026#34;PWA\u0026#34;, \u0026#34;PWB\u0026#34;, \u0026#34;PWC\u0026#34;) } updateSelectInput(session, \u0026#34;mol_id\u0026#34;, \u0026#34;select a item\u0026#34;, choices = candis) }) ## 通过点击actionButton，随机生成selectInput的选项值 observeEvent(input$butt, { candis_random = paste0(\u0026#34;Mol\u0026#34;,sample(LETTERS,3)) updateSelectInput(session, \u0026#34;mol_id\u0026#34;, \u0026#34;select a item\u0026#34;, choices = candis_random) }) } # shinyApp(ui, server) NOTE : shiny包还有一个isolate()函数主要是为了stop reactive，即包装在其内部的运算代码不会因input$×××相关输入发生变化而导致全部运行。\n3. renderUI() renderUI()函数（对应ui端的uiOutput()）可以根据input$×××输入的变化，生成可调整HTML元素。相比较于常规的render函数，\n它有两个特别应用场景。\n（1）输入控件系列的input， 包括同类input的不同参数或者不同类的input。举例如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ui \u0026lt;- fluidPage( selectInput(\u0026#34;input_id\u0026#34;, \u0026#34;Select Control Type:\u0026#34;, choices = c(\u0026#34;Text Box\u0026#34;, \u0026#34;Numeric Input\u0026#34;)), uiOutput(\u0026#34;dynamic_control\u0026#34;) ) server \u0026lt;- function(input, output, session) { output$dynamic_control \u0026lt;- renderUI({ choice \u0026lt;- input$input_id ##选择文本输入/数值输入 if (choice == \u0026#34;Text Box\u0026#34;) { textInput(\u0026#34;text_input_id\u0026#34;, \u0026#34;Enter Text:\u0026#34;, value = \u0026#34;\u0026#34;) } else if (choice == \u0026#34;Numeric Input\u0026#34;) { numericInput(\u0026#34;numeric_input_id\u0026#34;, \u0026#34;Enter Number:\u0026#34;, value = 0) } }) } （2）图表文本等output，可以针对×××output系列函数的自身参数实现对输出的细节调整等。如下是一个例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ui \u0026lt;- fluidPage( selectInput(\u0026#34;param1\u0026#34;, ...), selectInput(\u0026#34;param2\u0026#34;, ...), numericInput(\u0026#34;plot_size\u0026#34;, ...), uiOutput(\u0026#34;dynamic_control\u0026#34;) ) server \u0026lt;- function(input, output){ output$res_plot \u0026lt;- renderPlot({ plotfunction(input$param1, input$param2) }) output$dynamic_control \u0026lt;- renderUI({ # 通过numericInput动态调整输出图片的高度 plotOutput(\u0026#34;res_plot\u0026#34;, height = input$plot_size) }) } ","permalink":"https://lishensuo.github.io/en/posts/program/254shiny%E5%8C%85%E5%BC%80%E5%8F%91%E7%BD%91%E9%A1%B5app%E8%BF%9B%E9%98%B6/","summary":"\u003cblockquote\u003e\n\u003cp\u003eshiny中server部分的render×××系列函数是生成reactive output的主要方式。只要其内部的任一input$×××输入参数发生变化都会重新将该函数内部代码全部重新计算一遍以更新输出。此外，类似\u003ccode\u003ereactive()\u003c/code\u003e，\u003ccode\u003eobserveEvent()\u003c/code\u003e等可以帮助实现更加复杂的输入输出控制，下面简单学习记录下。\u003c/p\u003e","title":"shiny包开发网页APP进阶"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Part1 加载shiny包和其他可能需要的包 library(shiny) # Part2 加载可能需要的数据，函数，模块等 # Part3 设计ui与server ui \u0026lt;- fluidPage( \u0026#34;Hello, world!\u0026#34; ) server \u0026lt;- function(input, output, session) { } # Part4 启动app shinyApp(ui, server) shiny option https://shiny.posit.co/r/reference/shiny/latest/shinyoptions 1 2 3 4 5 6 7 8 # 若检测到相关shiny文件修改，则自动地重新加载；默认为FALSE options(shiny.autoreload = TRUE) # 只检测ui.R文件 options(shiny.autoreload.pattern = glob2rx(\u0026#34;ui.R\u0026#34;)) # 设置检测周期，默认为500毫秒 options(shiny.autoreload.interval = 2000) 1. 选项选择 1 2 3 4 5 6 7 # Input selectInput() selectizeInput() radioButtons() #单选 checkboxGroupInput() #多选 checkboxInput() #逻辑值 selectInput() 1 2 3 4 5 6 7 selectInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, choices = c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;), selected = \u0026#34;A\u0026#34;, multiple = FALSE) # choices参数设置选项，可通过named vector友好展示；也可以是list将选项分类 ## choices = c(\u0026#34;AA\u0026#34;=\u0026#34;A\u0026#34;, \u0026#34;BB\u0026#34;=\u0026#34;B\u0026#34;, \u0026#34;CC\u0026#34;=\u0026#34;C\u0026#34;) ## choices = list(\u0026#39;type1\u0026#39; = list(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;), \u0026#39;type2\u0026#39; = list(\u0026#34;C\u0026#34;,\u0026#34;D\u0026#34;)) selectizeInput() 适用于选项过多的情况，用法见第8小点。\nradioButtons() 1 2 3 4 5 6 7 radioButtons(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, choices = c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;),, selected = \u0026#34;A\u0026#34;, inline = FALSE) # 类似selectInput，choices参数设置选项，可通过named vector友好展示 ## 可通过另外设置参数choiceNames/choiceValues将name（可以是icon等ui元素）与value设置更优雅 # inline 是否将选项在一行内展示 checkboxGroupInput() 1 2 3 4 5 # 用法与radioButtons基本类似，主要区别在于可以多选 checkboxGroupInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, choices = c(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;),, selected = NULL, inline = FALSE) checkboxInput() 1 2 # 返回逻辑值 checkboxInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, value = FALSE) 2. 数值输入 1 2 numericInput() sliderInput() numericInput() 1 2 3 numericInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, value = 1, min = 0, max = 10, step = 0.5) # 只是名义上限制最值，仍然可以手动输入范围以外的值，例如-1 sliderInput() 1 2 3 sliderInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, value = 1, min = 0, max = 10, step = 0.5) # value可以是长度为2的数值向量，更多参数见帮助文档 3. 文本控件 1 2 3 4 5 6 7 8 9 10 11 12 # Input textInput() passwordInput() #密码 textAreaInput() #长段 # Output textOutput() # plain text verbatimTextOutput() # code-like text # renderXXX renderText() # → textOutput renderPrint() # → verbatimTextOutput textInput() 1 2 3 textInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, value = \u0026#34;\u0026#34;, placeholder = \u0026#34;input some\u0026#34;) 4. 表格数据 1 2 3 4 5 6 7 # Output tableOutput() dataTableOutput() # renderXXX renderTable() # → tableOutput renderDataTable() # → dataTableOutput tableOutput() 1 2 3 4 # 适合小的数据框 tableOutput(\u0026#34;id\u0026#34;) renderTable({expr}) #可选参数见帮助文档 dataTableOutput() 1 2 3 4 5 6 # 适合大的数据表格 dataTableOutput(\u0026#34;id\u0026#34;) renderDataTable({expr}, options = list()) #可选参数见帮助文档 # https://datatables.net/reference/option/ 5. 可视化图 1 2 3 4 5 6 # Output plotOutput() # renderXXX renderPlot() # → plotOutput renderImage() # → plotOutput plotOutput() 1 2 3 4 5 plotOutput(\u0026#34;id\u0026#34;, width = \u0026#34;100%\u0026#34;, height = \u0026#34;400px\u0026#34;) renderPlot({expr}, width = \u0026#34;auto\u0026#34;, height = \u0026#34;auto\u0026#34;, res = 96) 6. 动作按钮 1 2 3 4 actionButton() actionLink() actionButton(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, icon = ) icon网站\nshiny::icon(\u0026quot;box\u0026quot;): https://fontawesome.com/search bsicons::bs_icon(\u0026quot;calendar\u0026quot;): https://icons.getbootstrap.com/ 7. 上传下载 1 2 3 4 5 6 7 8 #上传 fileInput() #下载 downloadButton() downloadLink() downloadHandler() # server fileInput 1 2 3 4 5 6 7 8 9 10 11 12 13 fileInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, accept = \u0026#34;.csv\u0026#34;, buttonLabel = \u0026#34;Browse...\u0026#34;, placeholder = \u0026#34;No file selected\u0026#34;) # accept提醒输入的文件类型（仅为提醒，上传不受限制） ## 可使用validate函数检查 tools::file_ext()获取文件后缀 # 在server端， input$id是一个4列的表格，列名分别是 name, size, type, datapath ## 其中 datapath是读取路径的变量，最有用 ## 在初始状态，input为NULL值，可使用req(input$id)防止报错 downloadButton 1 2 3 4 5 6 7 8 9 10 11 12 13 # ui downloadButton(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, icon = shiny::icon(\u0026#34;download\u0026#34;)) # server output$id \u0026lt;- downloadHandler( filename = function() { \u0026#34;dataset.csv\u0026#34; }, content = function(file) { write.csv(data(), file) } ) 8. 动态控件 update***：适用于大多数输入控件与动作按钮等UI，用以在server端更新其参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 updateNumericInput() updateTextInput() ... ## 简单示例 ui \u0026lt;- fluidPage( sliderInput(\u0026#34;x1\u0026#34;, \u0026#34;x1\u0026#34;, 0, min = -10, max = 10), actionButton(\u0026#34;reset\u0026#34;, \u0026#34;Reset\u0026#34;) ) server \u0026lt;- function(input, output, session) { observeEvent(input$reset, { updateSliderInput(inputId = \u0026#34;x1\u0026#34;, value = 0) }) } selectizeInput()适用于动态加载部分选项\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # ui selectizeInput(\u0026#34;id\u0026#34;, \u0026#34;label\u0026#34;, choices = NULL, options = list(create = TRUE, maxOptions = 5, maxItems = 2, placeholder = \u0026#34;select some\u0026#34;) ) # create 允许新增选项 # maxOptions 界面最多展示5条 # maxItems 多选 # server server \u0026lt;- function(input, output, session) { updateSelectizeInput(session, \u0026#39;id\u0026#39;, choices = data, server = TRUE) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # `freezeReactiveValue()`特殊情况（temporary error）： ## updateSelectInput() only has an affect after all outputs and observers have run ui \u0026lt;- fluidPage( selectInput(\u0026#34;dataset\u0026#34;, \u0026#34;Choose a dataset\u0026#34;, c(\u0026#34;pressure\u0026#34;, \u0026#34;cars\u0026#34;)), selectInput(\u0026#34;column\u0026#34;, \u0026#34;Choose column\u0026#34;, character(0)), verbatimTextOutput(\u0026#34;summary\u0026#34;) ) server \u0026lt;- function(input, output, session) { dataset \u0026lt;- reactive(get(input$dataset, \u0026#34;package:datasets\u0026#34;)) observeEvent(input$dataset, { freezeReactiveValue(input, \u0026#34;column\u0026#34;) #一般多用于input value updateSelectInput(inputId = \u0026#34;column\u0026#34;, choices = names(dataset())) }) output$summary \u0026lt;- renderPrint({ summary(dataset()[[input$column]]) }) } renderUI()/uiOutput() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ui \u0026lt;- fluidPage( textInput(\u0026#34;label\u0026#34;, \u0026#34;label\u0026#34;), selectInput(\u0026#34;type\u0026#34;, \u0026#34;type\u0026#34;, c(\u0026#34;slider\u0026#34;, \u0026#34;numeric\u0026#34;)), uiOutput(\u0026#34;numeric\u0026#34;) ) server \u0026lt;- function(input, output, session) { output$numeric \u0026lt;- renderUI({ if (input$type == \u0026#34;slider\u0026#34;) { sliderInput(\u0026#34;dynamic\u0026#34;, input$label, value = 0, min = 0, max = 10) } else { numericInput(\u0026#34;dynamic\u0026#34;, input$label, value = 0, min = 0, max = 10) } }) } ","permalink":"https://lishensuo.github.io/en/posts/program/255shiny-basic-1-io/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-basic-1-IO"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\n1. 基本页面 1 2 3 4 fluidPage() # 最基本，最常用 fixedPage() # fixed maximum width fillPage() # fill the full page 经典布局 1 2 3 4 5 6 7 fluidPage( titlePanel(), #标题栏 sidebarLayout( sidebarPanel(), #侧边栏 mainPanel() #主要界面 ) ) 行列堆叠 1 2 3 4 5 6 7 8 9 10 fluidPage( fluidRow( column(4, ...), column(8, ...) ), fluidRow( column(6, ...), column(6, ...) ), ) 2. Panel布局 tabsetPanel: 横向拼接多个Panel（active仅显示一个） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 fluidPage( tabsetPanel( id = \u0026#34;tabset\u0026#34; # current panel tabPanel(\u0026#34;panel 1\u0026#34;, ...), #第一个参数为title（id） tabPanel(\u0026#34;panel 2\u0026#34;, ...), tabPanel(\u0026#34;panel 3\u0026#34;, ...) ) ) # input$id表示当前显示的panel名 # 可设置type=\u0026#34;hidden\u0026#34;参数，并配合server的updateTabsetPanel()参数灵活控制active panel ui \u0026lt;- fluidPage( radioButtons(\u0026#34;controller\u0026#34;, \u0026#34;Controller\u0026#34;, 1:3, 1) tabsetPanel( id = \u0026#34;hidden_tabs\u0026#34;, type = \u0026#34;hidden\u0026#34;, tabPanel(\u0026#34;panel1\u0026#34;, \u0026#34;Panel 1 content\u0026#34;), tabPanel(\u0026#34;panel2\u0026#34;, \u0026#34;Panel 2 content\u0026#34;), tabPanel(\u0026#34;panel3\u0026#34;, \u0026#34;Panel 3 content\u0026#34;) ) ) server \u0026lt;- function(input, output, session) { observeEvent(input$controller, { updateTabsetPanel(session, \u0026#34;hidden_tabs\u0026#34;, selected = paste0(\u0026#34;panel\u0026#34;, input$controller)) }) } navlistPanel()：左侧纵向拼接多个Panel（active仅显示一个） 1 2 3 4 5 6 7 8 9 10 fluidPage( navlistPanel( id = \u0026#34;tabset\u0026#34;, # current panel \u0026#34;Heading 1\u0026#34;, # section name tabPanel(\u0026#34;panel 1\u0026#34;, ...), \u0026#34;Heading 2\u0026#34;, tabPanel(\u0026#34;panel 2\u0026#34;, ...), tabPanel(\u0026#34;panel 3\u0026#34;, ...) ) ) navbarPage()：横向拼接多个Panel，每个Panel可以由多个二级Panel组成 1 2 3 4 5 6 7 8 9 10 11 fluidPage( navbarPage( \u0026#34;Page title\u0026#34;, tabPanel(\u0026#34;panel 1\u0026#34;, ...), tabPanel(\u0026#34;panel 2\u0026#34;, ...), navbarMenu(\u0026#34;subpanels\u0026#34;, tabPanel(\u0026#34;panel 3a\u0026#34;, ...), #二级panel tabPanel(\u0026#34;panel 3b\u0026#34;, ...), ) ) ) wellPanel() 1 wellPanel(style = \u0026#34;background: grey\u0026#34;) conditionalPanel() 1 2 3 4 conditionalPanel( condition = \u0026#34;input.Btn_id % 2 == 1\u0026#34;, ...ui... ) 3. HTML tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 tags$p(...) -\u0026gt; p(...) #段落文本 tags$span(...) -\u0026gt; span(...) # 对文本中的一部分进行样式设置 tags$strong(...) -\u0026gt; strong(...) #加粗 tags$em(...) -\u0026gt; em(...) #斜体 tags$h1(...) -\u0026gt; h1(..., align=\u0026#34;center\u0026#34;) tags$h2(...) -\u0026gt; h2(...) tags$h3(...) -\u0026gt; h3(...) tags$h4(...) -\u0026gt; h4(...) tags$h5(...) -\u0026gt; h5(...) tags$h6(...) -\u0026gt; h6(...) tags$a(...) -\u0026gt; a(..., href = \u0026#34;http://baidu.com\u0026#34;) tags$img(...) -\u0026gt; img(src=\u0026#34;p1.png\u0026#34;, height=, width=) #www文件夹内 tags$div(...) -\u0026gt; div(...) # 各种html元素 tags$code(...) -\u0026gt; code(...) tags$br(...) -\u0026gt; br(...) #换行 tags$hr(...) -\u0026gt; hr(...) #水平线 1 2 3 4 5 6 7 tagList() tags$head() tags$link() style = \u0026#34;font-size: 20px; color:grey; background: #f7f7f7; border-top: 1px dashed #000; margin-top: 5px; margin-bottom: 5px;\u0026#34; ","permalink":"https://lishensuo.github.io/en/posts/program/256shiny-basic-2-layout/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-basic-2-Layout"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\n在server端的代码，主要由多个reactive类型的代码块组成。\n1 2 3 server \u0026lt;- function(input, output, session) { } 1. render系列 计算输出结果\n1 2 3 4 5 6 7 8 9 10 11 12 output$Var1 = renderXXX({ ...... input$Var1 ...... }) renderText() # → textOutput renderPrint() # → verbatimTextOutput renderTable() # → tableOutput renderDataTable() # → dataTableOutput renderPlot() # → plotOutput renderImage() # → plotOutput 可renderXXX内的expression中的特定variable，通过isolate()函数包裹，使该变量值的变化不会引起renderXXX内的全部重新计算，以提高效率。\n1 2 3 4 5 6 7 output$Var1 = renderXXX({ ...... isolate(input$Var1) #Var1变化不会触发更新 input$Var2 #Var2变化会触发更新 ...... }) # 也同样适用于下面的reactive({}), observe({}) 2. reactive表达式 reactiveVal() 单个值 1 2 3 4 x \u0026lt;- reactiveVal(10) x() x(20) #修改 x() reactiveValues() list类型 1 2 3 4 r \u0026lt;- reactiveValues(x = 10, y = \u0026#34;a\u0026#34;) r$x r$x \u0026lt;- 20 #修改 r$x reactive()表达式 1 2 3 4 5 mid_var = reactive({ ... isolate() ... }) observe()与reactive类似，区别在于不返回结果，仅运算表达式，可用于更新reactive value；update widget等场景 1 2 3 4 5 observe({ ... isolate() ... }) 3. 动作触发 通过监督特定值（通常为button）是否发生变化，来控制是否表达式里的计算过程。\n此时表达式里包括的input值变化，不会触发表达式的重新计算\neventReactive() 1 2 3 mid_var = eventReactive(input$XXX, { }) observeEvent() 1 2 3 observeEvent(input$XXX, { }) ","permalink":"https://lishensuo.github.io/en/posts/program/257shiny-basic-3-reactive/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-basic-3-Reactive"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\n1. req() 中止执行，非常适用于一些输入控件textInput/selectInput/fileInput中，初始值为空的情况， 1 2 3 4 5 6 7 req() # 值若为 NULL, FALSE, \u0026#34;\u0026#34; 就不往下执行 req(input$dataset) req(input$data1, input$data2) #需要两个条件同时为真才行 req(input$dataset, cancelOutput = TRUE) #若中止执行，则output保持上一次有效的输出 2. validate()/need() validate() 同样用于异常排查。更多用于output输出以及相关的中间变量的检查。\n如果出现异常值，则中止执行，并且会在相应的output区域内给出文本提醒\n1 2 3 4 5 6 7 server \u0026lt;- function(input, output, session) { output$out \u0026lt;- renderText({ if (input$x \u0026lt; 0 \u0026amp;\u0026amp; input$trans %in% c(\u0026#34;log\u0026#34;, \u0026#34;square-root\u0026#34;)) { ## 表达式：不希望的情况 validate(\u0026#34;x can not be negative for this transformation\u0026#34;) } ) } 可联合need()，更方便的排查 1 2 3 4 5 6 7 8 9 server \u0026lt;- function(input, output) { output$plot \u0026lt;- renderPlot({ validate( need(input$in1, \u0026#39;Check at least one letter!\u0026#39;), ## 表达式：希望的情况 need(input$in2 != \u0026#39;\u0026#39;, \u0026#39;Please choose a state.\u0026#39;) #可以输入多个条件 ) plot(1:10, main = paste(c(input$in1, input$in2), collapse = \u0026#39;, \u0026#39;)) }) } 3. shinyFeedback shinyFeedback包可以更友好地对输入控件值的异常输出进行提醒 1 2 3 4 5 6 feedback(inputId = , #输入控件id show = , #条件：不希望的情况 text = ) #文本提醒 feedbackWarning() feedbackDanger() feedbackSuccess() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ui \u0026lt;- fluidPage( shinyFeedback::useShinyFeedback(), ## 需要在UI代码里声明 numericInput(\u0026#34;n\u0026#34;, \u0026#34;n\u0026#34;, value = 10), textOutput(\u0026#34;half\u0026#34;) ) server \u0026lt;- function(input, output, session) { half \u0026lt;- reactive({ even \u0026lt;- input$n %% 2 == 0 shinyFeedback::feedbackWarning(\u0026#34;n\u0026#34;, !even, \u0026#34;Please select an even number\u0026#34;) # req(even) input$n / 2 }) output$half \u0026lt;- renderText(half()) } ## 虽然提醒，但仍然执行；可进一步配合req()， 中止执行 4. Notifications showNotification()函数可用于复杂计算过程（非循环）的进程提醒，通常出现在页面右下角。 1 2 3 4 5 6 7 8 9 10 11 12 # 用法1：默认出现5s，然后自动消失 server \u0026lt;- function(input, output, session) { observeEvent(input$goodnight, { showNotification(\u0026#34;So long\u0026#34;) Sys.sleep(1) showNotification(\u0026#34;Farewell\u0026#34;) Sys.sleep(1) }) } # duration 参数设置持续时间 # type 参数设置ui主题 “message”, “warning”, or “error”. 1 2 3 4 5 6 7 8 9 # 用法2：直至动作（文件读取）完成，notification才会消失 server \u0026lt;- function(input, output, session) { data \u0026lt;- reactive({ id \u0026lt;- showNotification(\u0026#34;Reading data...\u0026#34;, duration = NULL, closeButton = FALSE) on.exit(removeNotification(id), add = TRUE) #reactive语句执行完毕时，运行remove命令 read.csv(input$file$datapath) }) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 用法3： 直至动作完成，notification才会消失，期间多个过程有不同的notification server \u0026lt;- function(input, output, session) { notify \u0026lt;- function(msg, id = NULL) { showNotification(msg, id = id, duration = NULL, closeButton = FALSE) } data \u0026lt;- reactive({ id \u0026lt;- notify(\u0026#34;Reading data...\u0026#34;) on.exit(removeNotification(id), add = TRUE) Sys.sleep(1) notify(\u0026#34;Reticulating splines...\u0026#34;, id = id) Sys.sleep(1) notify(\u0026#34;Herding llamas...\u0026#34;, id = id) Sys.sleep(1) mtcars }) output$data \u0026lt;- renderTable(head(data())) } 5. 循环进度条 withProgress()/incProgress() 1 2 3 4 5 6 7 8 9 10 11 12 13 server \u0026lt;- function(input, output, session) { data \u0026lt;- eventReactive(input$go, { withProgress(message = \u0026#34;Computing random number\u0026#34;, { for (i in seq_len(input$steps)) { Sys.sleep(0.5) #从0开始，直至1结束。incProgress表示每次增加的值 incProgress(1 / input$steps, details = paste0(\u0026#34;Now: \u0026#34;,i)) } runif(1) }) }) output$result \u0026lt;- renderText(round(data(), 2)) } waiter::Waitress() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ui \u0026lt;- fluidPage( waiter::use_waitress(), numericInput(\u0026#34;steps\u0026#34;, \u0026#34;How many steps?\u0026#34;, 10), actionButton(\u0026#34;go\u0026#34;, \u0026#34;go\u0026#34;), textOutput(\u0026#34;result\u0026#34;) ) server \u0026lt;- function(input, output, session) { data \u0026lt;- eventReactive(input$go, { waitress \u0026lt;- waiter::Waitress$new(max = input$steps) # 设置最大值 on.exit(waitress$close()) #表达式结束则退出进度条浮窗界面 for (i in seq_len(input$steps)) { Sys.sleep(0.5) waitress$inc(1) # 每次迭代增加的值 } runif(1) }) output$result \u0026lt;- renderText(round(data(), 2)) } waitress \u0026lt;- Waitress$new(selector = \u0026#34;#steps\u0026#34;, theme = \u0026#34;overlay\u0026#34;) #theme参数除默认外可选：overlay, overlay-opacity, overlay-percent ； #selector参数默认覆盖整个界面，如上可将进度条仅覆盖到某个input/output控件 6. 加载悬浮窗 waiter::Waiter() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(waiter) ui \u0026lt;- fluidPage( waiter::use_waiter(), actionButton(\u0026#34;go\u0026#34;, \u0026#34;go\u0026#34;), textOutput(\u0026#34;result\u0026#34;) ) server \u0026lt;- function(input, output, session) { data \u0026lt;- eventReactive(input$go, { waiter \u0026lt;- waiter::Waiter$new() # 覆盖整个页面 # waiter \u0026lt;- waiter::Waiter$new(id = ns(\u0026#34;result\u0026#34;), html = spin_pulse()) #覆盖result对应的控件 waiter$show() on.exit(waiter$hide()) Sys.sleep(sample(5, 1)) runif(1) }) output$result \u0026lt;- renderText(round(data(), 2)) } # id类似上面的sector，不设置则会覆盖整个屏幕 # html 设置浮窗的样式 ?waiter::spinners 7. 弹出对话框 showModal()/modalDialog() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 shinyApp( ui = basicPage( actionButton(\u0026#34;show\u0026#34;, \u0026#34;Show modal dialog\u0026#34;) ), server = function(input, output) { observeEvent(input$show, { showModal(modalDialog( title = \u0026#34;Important message\u0026#34;, size = \u0026#34;l\u0026#34;, \u0026#34;This is an important message!\u0026#34;, ...ui..., footer = modalButton(\u0026#34;Dismiss\u0026#34;) # 退出按钮 )) }) } ) ","permalink":"https://lishensuo.github.io/en/posts/program/258shiny-basic-4-feedback/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-basic-4-Feedback"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\n1. 基本形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # module file module_UI = function(id){ ns \u0026lt;- NS(id) tagList( XXXInput(ns(\u0026#34;var\u0026#34;),\u0026#34;label\u0026#34;,...) ) } module_Server = function(id){ moduleServer(id, function(input, output, session){ ns \u0026lt;- session$ns reactive({input$var}) ... }) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # App.R library(shiny) source(\u0026#34;module.R\u0026#34;) #加载模块文件 ui \u0026lt;- fluidPage( histogramUI(\u0026#34;hist1\u0026#34;) #使用模块的UI ) server \u0026lt;- function(input, output, session) { histogramServer(\u0026#34;hist1\u0026#34;) #使用模块的server } shinyApp(ui, server) 2. 其它参数 定义模块的UI/Server时，均可以设置额外的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module_UI = function(id, params = NULL){ ns \u0026lt;- NS(id) tagList( XXXInput(ns(\u0026#34;var\u0026#34;),\u0026#34;label\u0026#34;,...) ) } ## 对于module server函数的参数可以是普通值，也可以是reactive值 ## 可结合stopifnot()检查是否为预期的类型 module_Server = function(id, param_A, param_B){ stopifnot(is.reactive(data)) stopifnot(!is.reactive(filter)) moduleServer(id, function(input, output, session){ ns \u0026lt;- session$ns reactive({input$var}) ... }) } 2. reactive返回值 符合function()函数逻辑，默认返回最后一个语句对应的值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 返回单个值 datasetServer \u0026lt;- function(id) { moduleServer(id, function(input, output, session) { ...... reactive(get(input$dataset, \u0026#34;package:datasets\u0026#34;)) }) } # 返回一个list所包括的多个值 datasetServer \u0026lt;- function(id) { moduleServer(id, function(input, output, session) { ns \u0026lt;- session$ns ...... list( name = reactive(input$var), value = reactive(data()[[input$var]]) ) }) } # res$name, res$value 3. 模块嵌套 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # module file selectDataVarUI \u0026lt;- function(id) { ns \u0026lt;- NS(id) tagList( datasetInput(ns(\u0026#34;data\u0026#34;), filter = is.data.frame), #嵌套模块-1 selectVarInput(ns(\u0026#34;var\u0026#34;)) #嵌套模块-2 ) } selectDataVarServer \u0026lt;- function(id, filter = is.numeric) { moduleServer(id, function(input, output, session) { data \u0026lt;- datasetServer(\u0026#34;data\u0026#34;) #嵌套模块-1 var \u0026lt;- selectVarServer(\u0026#34;var\u0026#34;, data, filter = filter) #嵌套模块-2 var }) } ","permalink":"https://lishensuo.github.io/en/posts/program/259shiny-basic-5-module/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-basic-5-Module"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\nshinyWidgets包主要提供了一些精美的输入控件\n官方链接\nhttps://github.com/dreamRs/shinyWidgets https://dreamrs.github.io/shinyWidgets/reference/index.html 全部函数的帮助文档，基本都有示例代码 https://shinyapps.dreamrs.fr/shinyWidgets/ #部分常用控件的gallery展示 1 2 library(shiny) # v1.7.4 library(shinyWidgets) # v0.7.6 1. 输入控件系列 逻辑值 1 2 3 4 5 6 7 8 9 10 11 switchInput() prettyCheckbox() prettySwitch() prettyToggle() awesomeCheckbox() materialSwitch() 单选radio 1 2 3 4 5 radioGroupButtons() prettyRadioButtons() awesomeRadio() 多选radio 1 2 3 4 5 checkboxGroupButtons() prettyCheckboxGroup() awesomeCheckboxGroup() 选择select 1 2 3 4 pickerInput() # 特点之一：选择超过一定数量选项后，仅显示选择的数量 virtualSelectInput() 文本输入 1 2 3 4 searchInput # 特点之一：自带2个按钮 ## 按钮1：仅当点击该按钮时，才会传递输入值 ## 按钮2：重置按钮 颜色 1 2 3 colorPickr() colorSelectorInput() 滑动窗（数值/文本均可） 1 2 3 sliderTextInput() chooseSliderSkin() 动作按钮 1 2 3 4 5 actionBttn() circleButton() downloadBttn() 进度条 1 2 3 progressBar() progressSweetAlert() 2. 悬浮窗/布局系列 确认/提醒界面 1 2 3 4 5 6 7 sendSweetAlert() show_alert() inputSweetAlert() #适用于大多数输入控件 show_toast() # notification Panel显示或隐藏 1 2 3 4 5 dropdownButton() dropdown() dropMenu() 等待计算结果的缓冲 1 addSpinner() #常联合plotOutput使用 仪表盘 1 2 3 4 5 6 7 8 9 10 panel() alert() statiCard() verticalTabsetPanel() verticalTabPanel() appendVerticalTab() removeVerticalTab() reorderVerticalTabs() ","permalink":"https://lishensuo.github.io/en/posts/program/260shiny-pkg-1-shinywidgets/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-pkg-1-shinyWidgets"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\nshinyJS包主要提供了些个性化控制控件的函数\nTips: 使用该包提供的功能时，需要在ui部分声明useShinyjs()语句，对于Shiny Dashboards或者navbarPage layout有特殊的放置要求，详见教程文档的Advanced部分。\nhttps://github.com/daattali/shinyjs https://deanattali.com/shinyjs/overview 教程文档 https://daattali.com/shiny/shinyjs-basic/ 示例demo 1. 控件失效/激活 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 disable() #控件（包括输入控件/动作按钮等）失效 enable() #控件恢复 ## 示例：当文本输入为空时，submit按钮为失效状态 ui = fluidPage( useShinyjs(), # Set up shinyjs textInput(\u0026#34;name\u0026#34;,\u0026#34;Give your name\u0026#34;), actionButton(\u0026#34;submit\u0026#34;, \u0026#34;Click me\u0026#34;) ) server = function(input, output, session) { observe({ if (is.null(input$name) || input$name == \u0026#34;\u0026#34;) { shinyjs::disable(\u0026#34;submit\u0026#34;) } else { shinyjs::enable(\u0026#34;submit\u0026#34;) } }) } shinyApp(ui, server) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 toggleState() #可以进行更简单的控件状态转换 ## 示例1：当文本输入为空时，submit按钮为失效状态 ui = fluidPage( useShinyjs(), # Set up shinyjs textInput(\u0026#34;name\u0026#34;,\u0026#34;Give your name\u0026#34;), actionButton(\u0026#34;submit\u0026#34;, \u0026#34;Click me\u0026#34;) ) server = function(input, output, session) { observe({ shinyjs::toggleState(\u0026#34;submit\u0026#34;, !is.null(input$name) \u0026amp;\u0026amp; input$name != \u0026#34;\u0026#34;) }) } shinyApp(ui, server) ## 示例2：控制输入栏的失效与恢复 ui = fluidPage( useShinyjs(), actionButton(\u0026#34;btn\u0026#34;, \u0026#34;Click me\u0026#34;), textInput(\u0026#34;element\u0026#34;, \u0026#34;Watch what happens to me\u0026#34;) ) server = function(input, output, session) { observeEvent(input$btn, { toggleState(\u0026#34;element\u0026#34;) }) } shinyApp(ui, server) ## 示例3：disabled() 初始状态设置为失效状态 ui = fluidPage( useShinyjs(), actionButton(\u0026#34;btn\u0026#34;, \u0026#34;Click me\u0026#34;), disabled( textInput(\u0026#34;element\u0026#34;, \u0026#34;Watch what happens to me\u0026#34;) ) ) server = function(input, output, session) { observeEvent(input$btn, { toggleState(\u0026#34;element\u0026#34;) }) } shinyApp(ui, server) 2. UI的显示/隐藏 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 hide() show() # 示例 ui = fluidPage( useShinyjs(), # Set up shinyjs actionButton(\u0026#34;btn\u0026#34;, \u0026#34;Click me\u0026#34;), textInput(\u0026#34;text\u0026#34;, \u0026#34;Text\u0026#34;) ) server = function(input, output, session) { observe({ if(input$btn %% 2 ==0){ #点击1次消失，再点击一次出现 show(\u0026#34;text\u0026#34;) } else { hide(\u0026#34;text\u0026#34;) } }) } shinyApp(ui, server) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 toggle() #可以进行更简单的控件显示与隐藏 ## 示例1 ui = fluidPage( useShinyjs(), # Set up shinyjs actionButton(\u0026#34;btn\u0026#34;, \u0026#34;Click me\u0026#34;), textInput(\u0026#34;text\u0026#34;, \u0026#34;Text\u0026#34;) ) server = function(input, output, session) { observeEvent(input$btn, { toggle(\u0026#34;text\u0026#34;) }) } shinyApp(ui, server) ## 示例2：hidden() 设置UI初始的隐藏状态 ui = fluidPage( useShinyjs(), # Set up shinyjs actionButton(\u0026#34;btn\u0026#34;, \u0026#34;Click me\u0026#34;), hidden( div( #包裹在div或其它等 id = \u0026#34;this_div\u0026#34;, textInput(\u0026#34;text\u0026#34;, \u0026#34;Text\u0026#34;) ) ) ) server = function(input, output, session) { observeEvent(input$btn, { toggle(\u0026#34;this_div\u0026#34;) }) } shinyApp(ui, server) ","permalink":"https://lishensuo.github.io/en/posts/program/261shiny-pkg-2-shinyjs/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-pkg-2-shinyJS"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\nshinydashboard包定制化一种规范的shiny排版布局，帮助快速、优雅地实现一个简单的app。\nhttps://github.com/rstudio/shinydashboard https://rstudio.github.io/shinydashboard/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 library(shiny) # 1.7.4 version library(shinydashboard) # 0.7.2 version header = dashboardHeader() #标题栏 sidebar = dashboardSidebar() #侧边栏 body = dashboardBody()\t#主界面 ui \u0026lt;- dashboardPage( header = header, sidebar = sidebar, body = body, title = NULL, skin = \u0026#34;blue\u0026#34; ) server \u0026lt;- function(input, output, session) { } shinyApp(ui, server) 1. 标题栏 ?dashboardHeader()\ntitle 参数设置app的标题名 然后用dropdownMenu()设置3类下拉菜单，默认置于右侧，主要用于文本提醒 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 header \u0026lt;- dashboardHeader( title = \u0026#34;Dashboard Demo\u0026#34;, # Dropdown menu for messages dropdownMenu(type = \u0026#34;messages\u0026#34;, badgeStatus = \u0026#34;success\u0026#34;, messageItem(\u0026#34;Support Team\u0026#34;, \u0026#34;This is the content of a message.\u0026#34;, time = \u0026#34;5 mins\u0026#34; ) ), # Dropdown menu for notifications dropdownMenu(type = \u0026#34;notifications\u0026#34;, badgeStatus = \u0026#34;warning\u0026#34;, notificationItem(icon = icon(\u0026#34;users\u0026#34;), status = \u0026#34;info\u0026#34;, \u0026#34;5 new members joined today\u0026#34; ) ), # Dropdown menu for tasks, with progress bar dropdownMenu(type = \u0026#34;tasks\u0026#34;, badgeStatus = \u0026#34;danger\u0026#34;, taskItem(value = 20, color = \u0026#34;aqua\u0026#34;, \u0026#34;Refactor code\u0026#34; ) ) ) 2. 侧边栏 ?dashboardSidebar() 类似于shiny包的navlistPanel()函数\n通过sidebarMenu()设置多个面板menuItem() 每个menuItem()可以进一步包括多个二级面板menuSubItem() 可通过server()部分的renderMenu()动态更新sidebarMenuOutput()或者menuItemOutput() 1 2 3 4 5 6 7 8 9 10 11 12 13 sidebar = dashboardSidebar( sidebarMenu( id = \u0026#34;tabs\u0026#34;, menuItem(text = \u0026#34;Dashboard\u0026#34;, tabName = \u0026#34;dashboard\u0026#34;, icon = icon(\u0026#34;dashboard\u0026#34;), badgeLabel = \u0026#34;new\u0026#34;, badgeColor = \u0026#34;green\u0026#34;), menuItem(text = \u0026#34;Widget\u0026#34;, icon = icon(\u0026#34;box\u0026#34;), menuSubItem(\u0026#34;Sub-item 1\u0026#34;, tabName = \u0026#34;subitem1\u0026#34;), menuSubItem(\u0026#34;Sub-item 2\u0026#34;, tabName = \u0026#34;subitem2\u0026#34;)) ) ) 此外，sidebarSearchForm()可以设置搜索框，sidebarUserPanel()可以添加用户信息。甚至也可以添加Inut等UI元素。\n3. 主界面 ?dashboardBody()\n通过tabItems()设置多个tabItem()，\n其中每个tabItem()的tabName 需要与侧边栏menuItem/menuSubItem的tabname保持一致\n1 2 3 4 5 6 7 8 9 10 11 12 13 body \u0026lt;- dashboardBody( tabItems( tabItem(\u0026#34;dashboard\u0026#34;, div(p(\u0026#34;Dashboard tab content\u0026#34;)) ), tabItem(\u0026#34;subitem1\u0026#34;, \u0026#34;Sub-item 1 tab content\u0026#34; ), tabItem(\u0026#34;subitem2\u0026#34;, \u0026#34;Sub-item 2 tab content\u0026#34; ) ) ) 在每个tab中可设置常规的UI控件，实现特定的分析目的。shinydashboard提供了box()，可以提供简洁的卡片式(card)面板，并基于shiny的fluidRow()，column()进行合理的布局。 ?box() 1 2 3 4 5 6 7 8 9 10 box( title = \u0026#34;\u0026#34;, #左上角标题 status = \u0026#34;\u0026#34;, #上边的颜色，不设置则为白色 solidHeader = FALSE, #上边是否加粗（标题） collapsible = FALSE, #是否支持折叠 background = NULL, #填充颜色 width = 6, # 0~12 height = 300, # px footer = NULL ) 此外还提供有其它3种特定样式类型的box\ntabBox()：类似与tabsetPanel，在1个box中嵌套多个panel 1 2 3 4 5 6 tabBox( title = \u0026#34;tabBox\u0026#34;, id = \u0026#34;tabset1\u0026#34;, height = \u0026#34;250px\u0026#34;, tabPanel(\u0026#34;Tab1\u0026#34;, \u0026#34;First tab content\u0026#34;), tabPanel(\u0026#34;Tab2\u0026#34;, \u0026#34;Tab content 2\u0026#34;) ) infoBox()：展示关键的数字或者短文本 1 2 3 4 5 6 7 8 9 infoBox( title = , value = , # number/shorttext icon = shiny::icon(\u0026#34;bar-chart\u0026#34;), color = , # validColors() width = , # 0~12 fill = FALSE #右侧部分是否填充 ) 可使用renderValueBox()与valueBoxOutput()动态更新。\nvalueBox()：与上述info类似，只是主题样式不同 可使用renderInfoBox()与infoBoxOutput()动态更新。\n","permalink":"https://lishensuo.github.io/en/posts/program/262shiny-pkg-3-shinydashboard/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-pkg-3-shinydashboard"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\nshinydashboardPlus为shinydashboard包的升级版本，同时兼容shinydashboard的用法\nhttps://github.com/RinteRface/shinydashboardPlus https://shinydashboardplus.rinterface.com/ 1 2 library(shiny) # v1.7.4 library(shinydashboardPlus) # v2.0.3 1. skeleton更新 1.1 Controlbar https://shinydashboardplus.rinterface.com/articles/controlbar 通过dashboardPage()的controlbar参数设置右边侧边栏 具体是在dashboardControlbar()内设置UI控件，可进一步通过controlbarMenu()/controlbarItem()设置多个Tab的内容，建议最多设置5个 可通过updateControlbar以及updateControlbarMenu动态更新显示状态 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 menu \u0026lt;- controlbarMenu( id = \u0026#34;controlbarMenu\u0026#34;, controlbarItem( \u0026#34;Tab 1\u0026#34;, \u0026#34;Welcome to tab 1\u0026#34; ), controlbarItem( \u0026#34;Tab 2\u0026#34;, numericInput(\u0026#34;num\u0026#34;, \u0026#34;Observations:\u0026#34;, 200, min = 1, max = 1000, step = 100) ) ) ui = dashboardPage( ..., controlbar = dashboardControlbar( menu, ... ) ) 1.2 Footer https://shinydashboardplus.rinterface.com/articles/controlbar 通过dashboardPage()的footer参数设置底边尾注 具体是在dashboardFooter()内设置尾注的文本注释信息 1 2 3 4 5 6 7 8 9 10 ui = dashboardPage( header = dashboardHeader(), sidebar = dashboardSidebar(), body = dashboardBody(), footer = dashboardFooter(left = \u0026#34;Left content\u0026#34;, right = \u0026#34;Right content\u0026#34;), title = \u0026#34;DashboardPage\u0026#34; ) server = function(input, output) { } shinyApp(ui, server) 1.3 Header https://shinydashboardplus.rinterface.com/articles/enhanced-header 在shinydashboard包中可使用dropdownMenu在dashboardHeader设置不同类型的文本提醒下拉菜单（默认右侧） 而shinydashboardplus支持在dashboardHeader（leftUI参数）的左侧设置多种类型下拉菜单 来自shinyWidgets的dropdownButton()，可嵌入UI控件 来自shinydashboard的dropdownMenu()，可设置3类文本 来自shinydashboardplus的dropdownBlock()，可嵌入UI控件 1 2 3 4 5 6 7 8 9 10 ui = dashboardPage( ..., header = dashboardHeader( leftUi = tagList( dropdownButton(...), dropdownMenu(...), dropdownBlock(...), ) ) ) 2. box()更新 https://shinydashboardplus.rinterface.com/articles/improved-boxes\n2.1 动作按钮 在设置box的id（例如为\u0026quot;mybox\u0026quot;）前提下，有4类动作按钮\ntoggle：折叠或展开box body；(input$mybox$collapsed) remove：隐藏box；(input$mybox$visible为FALSE) restore：恢复box； (input$mybox$visible为TRUE) update：更新box内的content 1 2 3 4 # server.R observeEvent(input$toggle_box, { updateBox(\u0026#34;mybox\u0026#34;, action = \u0026#34;toggle\u0026#34;) }) 2.2 右上角装饰UI （1）通过box()函数的参数在box右上角设置多种功能的ui元素：\nlabel参数：通过函数boxLabel()设置，起到类似badge的作用； dropdownMenu参数：通过函数boxDropdown()/boxDropdownItem()设置下拉列表； collapsible参数：折叠box选项 closable参数：隐藏box选项 boxSidebar参数：通过函数boxSidebar()设置侧边栏 （2） descriptionBlock()函数可以在box内展示关键的数字/文本\nhttps://shinydashboardplus.rinterface.com/articles/box-elements 2.3 定制化box userBox()：展示个人信息，也可以通过updateBox()实现动态更新 1 2 3 4 5 6 userDescription( title = \u0026#34;Nadia Carmichael\u0026#34;, subtitle = \u0026#34;lead Developer\u0026#34;, type = 2, image = \u0026#34;https://adminlte.io/themes/AdminLTE/dist/img/user7-128x128.jpg\u0026#34;, ) flipBox()：具有正反面（front/back），可通过updateFlipBox()实现动态更新 3. 其它新增 3.1 accordion()布局 手风琴式布局 https://shinydashboardplus.rinterface.com/articles/extra-elements 每个accordion() 可以包括多个accordionItem()纵向堆叠而成；但只能保持其中一个为open的状态，其余均为collapsed 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 accordion( id = \u0026#34;accordion1\u0026#34;, accordionItem( title = \u0026#34;Accordion 1 Item 1\u0026#34;, status = \u0026#34;danger\u0026#34;, collapsed = TRUE, \u0026#34;This is some text!\u0026#34; ), accordionItem( title = \u0026#34;Accordion 1 Item 2\u0026#34;, status = \u0026#34;warning\u0026#34;, collapsed = FALSE, \u0026#34;This is some text!\u0026#34; ) ) 3.2 skin主题颜色 https://shinydashboardplus.rinterface.com/articles/more-skins 通过dashboardPage()函数的skin参数设置主题颜色，提供6种颜色，2类主题，以及一个黑夜模式 1 2 3 4 skin = c(\u0026#34;blue\u0026#34;, \u0026#34;blue-light\u0026#34;, \u0026#34;black\u0026#34;, \u0026#34;black-light\u0026#34;, \u0026#34;purple\u0026#34;, \u0026#34;purple-light\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;green-light\u0026#34;, \u0026#34;red\u0026#34;, \u0026#34;red-light\u0026#34;, \u0026#34;yellow\u0026#34;, \u0026#34;yellow-light\u0026#34;, \u0026#34;midnight\u0026#34;) 此外，也可以通过skinSelector()在右侧控制栏提供所有选择（midnight除外） 1 2 3 4 5 6 7 8 9 10 ui = dashboardPage( header = dashboardHeader(), sidebar = dashboardSidebar(), body = dashboardBody(), controlbar = dashboardControlbar(collapsed = FALSE, skinSelector()), title = \u0026#34;Skin Selector\u0026#34; ) server = function(input, output) { } shinyApp(ui, server) 3.3 preloader界面 https://shinydashboardplus.rinterface.com/articles/css-preloader 基于waiter包，在dashboardPage()函数的preloader参数设置app的启动加载悬窗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ui = dashboardPage( preloader = list(html = tagList(spin_1(), \u0026#34;Loading ...\u0026#34;), color = \u0026#34;#3c8dbc\u0026#34;), header = dashboardHeader(), body = dashboardBody( actionButton(\u0026#34;reload\u0026#34;, \u0026#34;Reload\u0026#34;) ), sidebar = dashboardSidebar() ) server = function(input, output, session) { observeEvent(input$reload, { session$reload() }) } shinyApp(ui, server) 4. bs4Dash Bootstrap 4 shinydashboard using AdminLTE3 兼容shinydashboard以及shinydashboardPlus的用法。\nhttps://github.com/RinteRface/bs4Dash https://bs4dash.rinterface.com/articles/bs4dash 4.1 Skeleton优化 https://bs4dash.rinterface.com/articles/step-by-step 如下仅列举部分新颖的更新参数，详见上方链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 library(shiny) # v0.7.2 library(bs4Dash) # v2.3.3 shinyApp( ui = dashboardPage( title = \u0026#34;Basic Dashboard\u0026#34;, header = dashboardHeader(), sidebar = dashboardSidebar(), controlbar = dashboardControlbar(), footer = dashboardFooter(), body = dashboardBody() ), server = function(input, output) {} ) dashboardPage()\nscrollToTop参数：快速回到顶部按钮 dashboardSidebar()\nminified参数：隐藏侧边栏时，仍保留图标 expandOnHover参数：鼠标触动时，自动展开侧边栏 dashboardHeader()\ntitle参数可通过dashboardBrand设置多元的标题属性 dashboardControlbar()\npinned参数可使右侧边栏保持open状态 dashboardBody()\nbox()内可通过设置maximizable参数添加全屏展示按钮 4.2 Popover, tooltips浮窗 popover()，addPopover()/removePopover() 点击触发式浮窗\ntooltip()，addTooltip()/removeTooltip 接触触发式浮窗\nTips: 上述两类浮窗需要在header栏右侧的help switch开启状态下才能生效\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 以tooltip为例，具体可查看每个函数的帮助文档 ui = dashboardPage( header = dashboardHeader(), sidebar = dashboardSidebar(), body = dashboardBody( tooltip( actionButton(\u0026#34;goButton\u0026#34;, \u0026#34;Hover to see the tooltip\u0026#34;), title = \u0026#34;My tooltip\u0026#34;, placement = \u0026#34;top\u0026#34; ) ) ) server = function(input, output, session) {} shinyApp(ui, server) 图片滑动gallery展示效果可通过carousel()/carouselItem()设置，其在bs4Dash与shinydashboardPlus均支持\n","permalink":"https://lishensuo.github.io/en/posts/program/263shiny-pkg-4-shinydashboardplus/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-pkg-4-shinydashboardPlus"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\nbslib包与shinydashboard包类似，提供了大量定制化的排版布局函数，方便快速搭建简洁的app。\nhttps://github.com/rstudio/bslib https://rstudio.github.io/bslib/index.html 1 2 3 library(shiny) # v0.7.2 library(bslib) # v0.6.2 library(htmltools) 1. 基本UI 1.1 Card面板 https://rstudio.github.io/bslib/articles/cards/index.html\n主要由card_header()）与card_body()两部分组成；\n一个card可以包括多个body；一个body内部可以由复杂的多个UI元素排版。\ncard内的元素默认是fillable（自适应填充），即根据其内容，自动调整其高度；可通过参数限制其最大最小高度（scroll滚动栏）\n1 2 3 4 5 6 7 8 9 10 11 12 13 card( full_screen = TRUE, #全屏展示按钮 card_header( \u0026#34;This is the header\u0026#34; ), card_body( p(\u0026#34;This is the body.\u0026#34;), p(\u0026#34;This is still the body.\u0026#34;) ), card_footer( \u0026#34;This is the footer\u0026#34; ) ) 1.2 Value box https://rstudio.github.io/bslib/articles/value-boxes/index.html 定制化布局的面板，用于展示关键的数字与文字 其中value参数的值可动态更新 1 2 3 4 5 6 7 8 value_box( title = \u0026#34;I got\u0026#34;, value = \u0026#34;99 problems\u0026#34;, #关键词展示 # value = textOutput(\u0026#34;time\u0026#34;), showcase = bs_icon(\u0026#34;music-note-beamed\u0026#34;), #图标 p(\u0026#34;bslib ain\u0026#39;t one\u0026#34;, bs_icon(\u0026#34;emoji-smile\u0026#34;)), #foot p(\u0026#34;hit me\u0026#34;, bs_icon(\u0026#34;suit-spade\u0026#34;)) ) 1.3 窗口弹出提示 https://rstudio.github.io/bslib/articles/tooltips-popovers/index.html tooltip(): 悬浮式文字弹出\u0026mdash;适用于文本帮助信息提示 1 2 3 4 5 actionButton( \u0026#34;btn_tip\u0026#34;, \u0026#34;Focus/hover here for tooltip\u0026#34; ) |\u0026gt; tooltip(\u0026#34;Tooltip message\u0026#34;) popover(): 点击触发弹出\u0026mdash;适用于放置一些输入控件用以设置绘图参数等 1 2 3 4 5 6 7 8 actionButton( \u0026#34;btn_pop\u0026#34;, \u0026#34;Click here for popover\u0026#34; ) |\u0026gt; popover( \u0026#34;Popover message\u0026#34;, title = \u0026#34;Popover title\u0026#34; ) 2. 布局排版 2.1 侧边栏式面板 https://rstudio.github.io/bslib/articles/sidebars/index.html\nlayout_sidebar()/sidebar()\n使用可弹出式的侧边栏增加控件展示的灵活性\n此外，也可以作为card()的body部分\n1 2 3 4 layout_sidebar( sidebar = sidebar(\u0026#34;Sidebar\u0026#34;), \u0026#34;Main contents\u0026#34; ) 2.2 column列式面板 https://rstudio.github.io/bslib/articles/column-layout/index.html\n将card()基本元素按照列column排版。其特点之一是在整体page宽度调整过程中，一行的多列card若太“拥挤”，会自动调整为2行\nlayout_columns(): 指定每个card的宽度\n1 2 3 4 5 6 7 8 x \u0026lt;- card(\u0026#34;A simple card\u0026#34;) layout_columns(x, x, x, x) layout_columns( col_widths = c(6, 6, 12), x, x, x ) layout_column_wrap()：每个card等宽，等高布局 1 2 3 4 5 6 7 layout_column_wrap( width = \u0026#34;200px\u0026#34;, #每个card的宽度均为200px # width = 1/2, #每行设置两个card height = 300, fixed_width = TRUE, card1, card2, card3 ) 2.3 navset多面板组合 https://rstudio.github.io/bslib/reference/navset.html#details\nnavset_xxx()一般由多个nav_panel()组成；可通过nav_menu()/nav_item()设置二级子面板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 navset_tab() navset_pill() navset_underline() navset_pill_list() navset_hidden() navset_bar() # card样式 navset_card_tab() navset_card_pill() navset_card_underline() ## 简单示例 navset_tab( nav_panel(title = \u0026#34;One\u0026#34;, p(\u0026#34;First tab content.\u0026#34;)), nav_panel(title = \u0026#34;Two\u0026#34;, p(\u0026#34;Second tab content.\u0026#34;)), nav_panel(title = \u0026#34;Three\u0026#34;, p(\u0026#34;Third tab content\u0026#34;)), nav_spacer(), # 标题栏面板之间的空间 nav_menu( title = \u0026#34;Links\u0026#34;, nav_item(link_shiny), nav_item(link_posit) ) ) 2.4 accordion手风琴式 accordion()/accordion_panel() 将多个面板折叠式堆放 open以及multiple参数可设置初始的面板打开状态 1 2 3 4 5 6 accordion( accordion_panel(\u0026#34;Section A\u0026#34;, \u0026#34;Some narrative for section A\u0026#34;), accordion_panel(\u0026#34;Section B\u0026#34;, \u0026#34;Some narrative for section B\u0026#34;), accordion_panel(\u0026#34;Section C\u0026#34;, \u0026#34;Some narrative for section C\u0026#34;), open = \u0026#34;Section B\u0026#34; ) 2.5 Page-level排版 1 2 3 4 5 6 7 8 # 侧边栏式页面 page_sidebar() # 多面板组合式页面 page_navbar() # 自适应式页面（特征之一：没有scroll滚动条） page_fillable() 主题设置：bs_theme()\nhttps://rstudio.github.io/bslib/articles/bs5-variables/index.html ","permalink":"https://lishensuo.github.io/en/posts/program/264shiny-pkg-5-bslib/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-pkg-5-bslib"},{"content":"Shiny Basic系列:\n参考教程：https://mastering-shiny.org/\n（1）IO控件\n（2）Layout布局\n（3）Reactive用法\n（4）Feedback提醒\n（5）Module模块\nShiny Package系列:\n（1）shinyWidgets\n（2）shinyJS\n（3）shinydashboard\n（4）shinydashboardPlus\n（5）bslib\n（6）Other pkgs\n1. shinythemes 定制化主题\nhttps://github.com/rstudio/shinythemes https://rstudio.github.io/shinythemes/ All themes: help(shinythemes) Live example: https://gallery.shinyapps.io/117-shinythemes/ 1 2 3 4 5 6 ## ui.R ## library(shinythemes) fluidPage(theme = shinytheme(\u0026#34;cerulean\u0026#34;), ... ) 2. shinyhelper 浮窗帮助信息（markdown）\nhttps://github.com/cwthom/shinyhelper 1 2 3 4 5 6 7 8 9 10 11 12 13 library(shinyhelper) shinyhelper_demo() ## ui.R ## helper(shiny::actionButton(\u0026#34;go\u0026#34;, \u0026#34;click me!\u0026#34;), icon = \u0026#34;exclamation\u0026#34;, colour = \u0026#34;red\u0026#34;, type = \u0026#34;markdown\u0026#34;, content = \u0026#34;ClickHelp\u0026#34;) # looks for \u0026#39;helpfiles/ClickHelp.md\u0026#39; ## serve.R ## observe_helpers(help_dir = \u0026#34;helpfiles\u0026#34;) 3. shinyBS 浮窗帮助信息（popover， tooltip）\nhttps://ebailey78.github.io/shinyBS/index.html popover， tooltip是两类不同类型的提示浮窗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library(shinyBS) # 示例 bsExample(\u0026#34;Tooltips_and_Popovers\u0026#34;) ## (1) bsTooltip()/bsPopover(): 在UI部分根据目标元素/控件的id直接设置 bsTooltip(id, title, placement = \u0026#34;bottom\u0026#34;, trigger = \u0026#34;hover\u0026#34;, options = NULL) # placement: top, bottom, left, or right # trigger: hover, focus, click, or manual # options: https://getbootstrap.com/docs/4.0/components/popovers/ bsPopover() #包括以下函数的参数与上述基本类似 ## (2) tipify()/popify(): 相比上述二者，更适合于在server端的renderUI()里的元素设置 tipify() popify() ## (3) addPopover()/addTooltip(): 在server端对output元素设置（例如plot的解释说明） addPopover() addTooltip() 4. waiter https://github.com/JohnCoene/waiter\n文档：https://waiter.john-coene.com/\nDemo：https://shiny.john-coene.com/waiter/ （100+ Spinner）\nwaiter系列主要用于设置spinner悬浮窗\nwaitress系列主要用于设置常规的进度条 （Attendant与之类似，均基于传统的进度条）\nhostess系列可以用于设置更加多样、个性化进度提醒元素\n","permalink":"https://lishensuo.github.io/en/posts/program/265shiny-pkg-6-others/","summary":"\u003cp\u003e\u003cstrong\u003eShiny Basic系列:\u003c/strong\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e参考教程：https://mastering-shiny.org/\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e（1）\u003ca href=\"https://lishensuo.github.io/posts/program/255shiny-basic-1-io/\"\u003eIO控件\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（2）\u003ca href=\"https://lishensuo.github.io/posts/program/256shiny-basic-2-layout/\"\u003eLayout布局\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（3）\u003ca href=\"https://lishensuo.github.io/posts/program/257shiny-basic-3-reactive/\"\u003eReactive用法\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（4）\u003ca href=\"https://lishensuo.github.io/posts/program/258shiny-basic-4-feedback/\"\u003eFeedback提醒\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e（5）\u003ca href=\"https://lishensuo.github.io/posts/program/259shiny-basic-5-module/\"\u003eModule模块\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eShiny Package系列:\u003c/strong\u003e\u003c/p\u003e","title":"Shiny-pkg-6-others"},{"content":" https://rstudio.github.io/renv 记录一个R项目所需的R包来源及其相应的版本号，方便对于其他用户的可重复性分析。 1. 初始化项目 在当前目录下创建一个文件夹，是包含一个R project对象的工作环境； 其中library文件夹是该工作环境安装R包的路径，renv.lock是记录R包及其版本后的重要文件。 1 2 3 renv::init(\u0026#34;foo_project\u0026#34;) #初始化后会自动切换到该环境下，如果没有可以手动切换 # setwd(\u0026#34;foo_project\u0026#34;) 在初始化时，会安装一些基本的R包 1 2 3 4 5 6 7 8 dim(installed.packages()) # [1] 30 16 names(installed.packages()[,1]) # [1] \u0026#34;renv\u0026#34; \u0026#34;base\u0026#34; \u0026#34;boot\u0026#34; \u0026#34;class\u0026#34; \u0026#34;cluster\u0026#34; \u0026#34;codetools\u0026#34; # [7] \u0026#34;compiler\u0026#34; \u0026#34;datasets\u0026#34; \u0026#34;foreign\u0026#34; \u0026#34;graphics\u0026#34; \u0026#34;grDevices\u0026#34; \u0026#34;grid\u0026#34; # [13] \u0026#34;KernSmooth\u0026#34; \u0026#34;lattice\u0026#34; \u0026#34;MASS\u0026#34; \u0026#34;Matrix\u0026#34; \u0026#34;methods\u0026#34; \u0026#34;mgcv\u0026#34; # [19] \u0026#34;nlme\u0026#34; \u0026#34;nnet\u0026#34; \u0026#34;parallel\u0026#34; \u0026#34;rpart\u0026#34; \u0026#34;spatial\u0026#34; \u0026#34;splines\u0026#34; # [25] \u0026#34;stats\u0026#34; \u0026#34;stats4\u0026#34; \u0026#34;survival\u0026#34; \u0026#34;tcltk\u0026#34; \u0026#34;tools\u0026#34; \u0026#34;utils\u0026#34; 2. 安装包 在执行项目过程中，需要安装特定的R包时，建议使用renv::install() 该函数支持下载来自不同repository库来源的R包 1 2 3 4 5 6 7 8 9 10 11 12 13 # (1) CRAN renv::install(\u0026#34;ggplot2\u0026#34;) # (2) Bioconductor renv::install(\u0026#34;BiocManager\u0026#34;) renv::install(\u0026#34;bioc::limma\u0026#34;) # \u0026#34;bioc::pkgname\u0026#34; # (3) Github renv::install(\u0026#34;easystats/correlation\u0026#34;) # (4) 其它更多详细的安装方式，见帮助文档 ?renv::install() # https://rstudio.github.io/renv/articles/package-sources.html 3. 更新lock.file lock.file文件为json格式，是记录R包工作环境的重要文件。 使用renv::snapshot()将当前环境的R包信息更新到lock.file文件 1 2 3 renv::snapshot() # 如果更新失败，参考文档可自行如下设置后，再次更新 renv::settings$snapshot.type(\u0026#34;all\u0026#34;) 4. 重复环境 在另一个renv激活的环境中，通过复制上述的lock.file文件进行相同R包环境的重新搭建。 1 renv::restore() ","permalink":"https://lishensuo.github.io/en/posts/program/266renv%E5%8C%85%E7%8E%AF%E5%A2%83%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://rstudio.github.io/renv\"\u003ehttps://rstudio.github.io/renv\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e记录一个R项目所需的R包来源及其相应的版本号，方便对于其他用户的可重复性分析。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://rstudio.github.io/renv/articles/renv.png\" style=\"zoom: 80%;\" /\u003e\r\n\u003ch2 id=\"1-初始化项目\"\u003e1. 初始化项目\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e在当前目录下创建一个文件夹，是包含一个R project对象的工作环境；\u003c/li\u003e\n\u003cli\u003e其中library文件夹是该工作环境安装R包的路径，\u003ccode\u003erenv.lock\u003c/code\u003e是记录R包及其版本后的重要文件。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erenv::init(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;foo_project\u0026#34;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#初始化后会自动切换到该环境下，如果没有可以手动切换\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# setwd(\u0026#34;foo_project\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240405112909657.png\" alt=\"image-20240405112909657\"  /\u003e\r\n\u003c/p\u003e","title":"renv包环境可重复性"},{"content":"rhinoverse系列\nrhinoverse系列-rhino包； rhinoverse系列-shiny.router包； https://github.com/Appsilon/rhino/ https://appsilon.github.io/rhino/ 1 2 3 4 5 6 7 install.packages(\u0026#34;rhino\u0026#34;) packageVersion(\u0026#34;rhino\u0026#34;) # [1] ‘1.7.0’ ## 启动项目 rhino::init(\u0026#34;example_app\u0026#34;) setwd(\u0026#34;./example_app\u0026#34;) 在初始化项目中，相对重要基础的文件如下：\napp/logic文件夹：自定义分析函数； app/view 文件夹：自定义shiny模块； app/main.R文件：shiny主体设计； app.R文件：shiny的执行文件（不用修改）； dependencies.R文件：记录所需的依赖包，以更新lock.file； .Rprofile文件：设置options https://appsilon.github.io/rhino/articles/tutorial/create-your-first-rhino-app.html#add-custom-styles app/static可以放置图片文件（img(src = \u0026quot;static/images/appsilon-logo.png\u0026quot;)）， CSS、JS等修饰文件（对于JS，需要使用rhino::build_sass()函数处理）\napp/style可以放置sass/scss等css预处理文件，需要使用build_sass()函数处理\n1. 安装包 pkg_install安装相关依赖包； 基于renv::install()函数在当前env环境内安装R包，并自动更新dependencies.R以及相应的lock.file； 1 rhino::pkg_install(c(\u0026#34;ggplot2\u0026#34;,\u0026#34;dplyr\u0026#34;)) 2. 定义函数 在app/logic文件夹内定义R函数； 一个文件内可以包含相关的多个函数，如下为app/logic/func_iris.R 首先需要通过box::use函数引入所需要的工具包或特定函数，相关用法可以参见https://klmr.me/box/介绍。（可以类比Python中import pkg or from pkg import aa, bb更好地理解） 然后在定义每个函数时，需要先加#' @export，再编写函数内容。其中使用导入的工具包里的某个函数或数据时需要使用$，例如下面的datasets$iris。 如下，共编写了两个iris相关的函数，iris_data返回表格；iris_plot返回图形。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # load packages or functions box::use( datasets, dplyr[filter, select], ggplot2[ggplot, aes_string, geom_point, geom_smooth, theme, element_text], stats[lm] ) #\u0026#39; @export iris_data = function(type = c(\u0026#34;setosa\u0026#34;,\u0026#34;versicolor\u0026#34;,\u0026#34;virginica\u0026#34;)){ type = match.arg(type) data = datasets$iris |\u0026gt; filter(Species==type) |\u0026gt; select(!Species) return(data) } #\u0026#39; @export iris_plot = function(var.1, var.2, data){ stopifnot(var.1 %in% colnames(data)) stopifnot(var.2 %in% colnames(data)) data |\u0026gt; ggplot(aes_string(var.1, var.2)) + geom_point() + geom_smooth(method = lm) + theme(text = element_text(size = 16)) } 测试函数 1 2 3 4 5 6 7 8 box::use(app/logic/func_iris) names(func_iris) # [1] \u0026#34;iris_plot\u0026#34; \u0026#34;iris_data\u0026#34; func_iris$iris_data(\u0026#34;setosa\u0026#34;) ## 修改函数后重新加载、测试 box::reload(func_iris) 3. 定义模块 在app/view文件夹内定义shiny模块，一个文件内包含一个模块（ui+server）。 首先需要使用box::use()加载所需工具包及特定函数，或自定义的函数。 然后按定义shiny模块的ui与server函数，同样需要添加#' @export语句。 如下，分别定义了两个模块，用于呈现表格与图形 app/view/mod_table.R\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # load packages or functions box::use( shiny[fluidPage, NS, moduleServer, tagList, reactive], shiny[dataTableOutput, renderDataTable, selectInput], ) # load self-defined functions box::use( app/logic/func_iris ) #\u0026#39; @export ui = function(id){ ns = NS(id) tagList( selectInput(ns(\u0026#34;type\u0026#34;),\u0026#34;Select one type:\u0026#34;, choices = c(\u0026#34;setosa\u0026#34;,\u0026#34;versicolor\u0026#34;,\u0026#34;virginica\u0026#34;), selected = \u0026#34;setosa\u0026#34; ), dataTableOutput(ns(\u0026#34;table\u0026#34;)) ) } #\u0026#39; @export server = function(id){ moduleServer(id, function(input, output, session){ data = reactive(func_iris$iris_data(input$type)) output$table = renderDataTable({ data() }, options = list(pageLength = 10)) data }) } app/view/mod_plot.R\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # load packages or functions box::use( shiny[fluidPage, NS, moduleServer, tagList], shiny[dataTableOutput, renderDataTable, selectInput], shiny[renderPlot, plotOutput], ) # load self-defined functions box::use( app/logic/func_iris ) #\u0026#39; @export ui = function(id){ ns = NS(id) tagList( selectInput(ns(\u0026#34;Var1\u0026#34;),\u0026#34;Select Var1:\u0026#34;, choices = colnames(datasets::iris), selected = \u0026#34;Sepal.Length\u0026#34; ), selectInput(ns(\u0026#34;Var2\u0026#34;),\u0026#34;Select Var2:\u0026#34;, choices = colnames(datasets::iris), selected = \u0026#34;Sepal.Width\u0026#34; ), plotOutput(ns(\u0026#34;plot\u0026#34;)) ) } #\u0026#39; @export server = function(id, data){ moduleServer(id, function(input, output, session){ output$plot = renderPlot({ func_iris$iris_plot(input$Var1, input$Var2, data()) # where from data }) }) } 4. 编写main.R 接下来，根据已有的模块、函数等，设计总体的shiny页面的布局； 如下，为简单的app/main.R文件。与编写模块类似，首先加载需要的工具包与函数，然后编写ui与server内容。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # packages or functions box::use( shiny[fluidPage, NS, moduleServer, column], shiny[dataTableOutput, renderDataTable], ) # load self-defined modules box::use( app/view/mod_table, app/view/mod_plot ) #\u0026#39; @export ui \u0026lt;- function(id) { ns \u0026lt;- NS(id) fluidPage( column(6, mod_table$ui(ns(\u0026#34;table\u0026#34;))), column(6, mod_plot$ui(ns(\u0026#34;plot\u0026#34;))) ) } #\u0026#39; @export server \u0026lt;- function(id) { moduleServer(id, function(input, output, session) { data = mod_table$server(\u0026#34;table\u0026#34;) # reactive value mod_plot$server(\u0026#34;plot\u0026#34;, data) }) } 5. 测试网页 调用 app.R文件，生成并测试网页； 然后，根据需要重复步骤1~4，修改或丰富app内容。 1 shiny::runApp() ","permalink":"https://lishensuo.github.io/en/posts/program/267rhinoverse%E7%B3%BB%E5%88%97-rhino%E5%8C%85/","summary":"\u003cp\u003e\u003cstrong\u003erhinoverse系列\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://lishensuo.github.io/posts/program/267rhinoverse%E7%B3%BB%E5%88%97-rhino%E5%8C%85/\"\u003erhinoverse系列-rhino包\u003c/a\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://lishensuo.github.io/posts/program/268rhinoverse%E7%B3%BB%E5%88%97-shiny.router%E5%8C%85/\"\u003erhinoverse系列-shiny.router包\u003c/a\u003e；\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Appsilon/rhino/\"\u003ehttps://github.com/Appsilon/rhino/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://appsilon.github.io/rhino/\"\u003ehttps://appsilon.github.io/rhino/\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240406215907465.png\" alt=\"image-20240406215907465\"  /\u003e\r\n\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-r\" data-lang=\"r\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einstall.packages(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;rhino\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epackageVersion(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;rhino\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] ‘1.7.0’\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 启动项目\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erhino::init(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;example_app\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esetwd(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./example_app\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e在初始化项目中，相对重要基础的文件如下：\u003c/p\u003e","title":"rhinoverse系列-rhino包"},{"content":"rhinoverse系列\nrhinoverse系列-rhino包； rhinoverse系列-shiny.router包； https://appsilon.github.io/shiny.router/ https://github.com/Appsilon/shiny.router 在网页设计和开发中，路由（Routing）是指确定用户在浏览器中访问不同页面（URL）时，应该加载哪些页面内容（UI）过程。其优点包括（1）允许单页面应用，无需一次性加载全部页面；（2）页面之间的流畅切换，不会感到明显的延迟等\n1 2 3 install.packages(\u0026#34;shiny.router\u0026#34;) packageVersion(\u0026#34;shiny.router\u0026#34;) # [1] ‘0.3.1’ 1. 基本用法 1 2 3 4 5 6 7 8 9 # ui part router_ui( route(path, ui) # path: url的路径 # ui：一套UI组件(div()/tagList()),或者模块Module的UI部分 ) # server part router_server(root_page = \u0026#34;/\u0026#34;) # 默认router_ui的首页为\u0026#34;/\u0026#34; 由于是page-level配置，router_ui()/router_server()一般用于main.R或者app.R，而不用于模块中。\n如下的例子，设计了两个路由映射，分别是/（根目录）与anoter，对应两个UI组件； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(shiny) library(shiny.router) home_page \u0026lt;- div( titlePanel(\u0026#34;Home page\u0026#34;), p(\u0026#34;This is the home page!\u0026#34;) ) another_page \u0026lt;- div( titlePanel(\u0026#34;Another page\u0026#34;), p(\u0026#34;This is the another page!\u0026#34;), ) ui \u0026lt;- fluidPage( router_ui( route(\u0026#34;/\u0026#34;, home_page), # 常规UI组件 route(\u0026#34;another\u0026#34;, another_page), # 常规UI组件 # route(\u0026#34;another2\u0026#34;, module_UI(ns(\u0026#34;id\u0026#34;))), # shiny module # route(\u0026#34;another3\u0026#34;, module$ui(ns(\u0026#34;id\u0026#34;))), # rhino module ) ) server = function(input, output, session){ router_server() } shinyApp(ui, server) 2. 页面切换 route_link：在UI端实现路由页面间的切换，自动为path添加/#!/前缀来指定目标界面 1 route_link(path) 如下示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 library(shiny) library(shiny.router) home_page \u0026lt;- tagList( titlePanel(\u0026#34;Home page\u0026#34;), p(\u0026#34;This is the home page!\u0026#34;), a(\u0026#34;Go to another page!\u0026#34;, href = route_link(\u0026#34;another\u0026#34;)) ) another_page \u0026lt;- tagList( titlePanel(\u0026#34;Another page\u0026#34;), p(\u0026#34;This is the another page!\u0026#34;), a(\u0026#34;Go to root page!\u0026#34;, href = route_link(\u0026#34;/\u0026#34;)) ) ui \u0026lt;- fluidPage( router_ui( route(\u0026#34;/\u0026#34;, home_page), route(\u0026#34;another\u0026#34;, another_page) ) ) server = function(input, output, session){ router_server() } shinyApp(ui, server) change_page：在Server端，通过event事件触发路由页面切换 1 change_page 如下示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 library(shiny) library(shiny.router) home_page \u0026lt;- tagList( titlePanel(\u0026#34;Home page\u0026#34;), p(\u0026#34;This is the home page!\u0026#34;), actionButton(\u0026#34;btn1\u0026#34;,\u0026#34;Click to another page!\u0026#34;) ) another_page \u0026lt;- tagList( titlePanel(\u0026#34;Another page\u0026#34;), p(\u0026#34;This is the another page!\u0026#34;), actionButton(\u0026#34;btn2\u0026#34;,\u0026#34;Click to root page!\u0026#34;) ) ui \u0026lt;- fluidPage( router_ui( route(\u0026#34;/\u0026#34;, home_page), route(\u0026#34;another\u0026#34;, another_page) ) ) server = function(input, output, session){ router_server() observeEvent(input$btn1, { change_page(\u0026#34;another\u0026#34;) }) observeEvent(input$btn2, { change_page(\u0026#34;/\u0026#34;) }) } shinyApp(ui, server) 3. 参数URL get_query_param：在路由url映射的过程中，可根据特定组件的参数值自动更新页面 1 get_query_param(field = NULL) 如下示例，设置柱状图的bins数量为url的额外参数，field名为bins。 一方面，可直接设置特定的http://127.0.0.1:5306/#!/another?bins=5 URL链接，修改直方图的bins数 ； 另一方面，可结合change_page()，设置相应的输入控件，动态调整url。（虽然该控件可以直接对接绘图函数） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 home_page \u0026lt;- tagList( titlePanel(\u0026#34;Home page\u0026#34;), p(\u0026#34;This is the home page!\u0026#34;) ) plot_page \u0026lt;- tagList( titlePanel(\u0026#34;Plot page\u0026#34;), p(\u0026#34;This is the plot page!\u0026#34;), sliderInput(\u0026#34;bins\u0026#34;, \u0026#34;The number of bins:\u0026#34;, value = 6, step = 1, min = 3, max = 10), plotOutput(\u0026#34;plot\u0026#34;) ) ui \u0026lt;- fluidPage( router_ui( route(\u0026#34;/\u0026#34;, home_page), route(\u0026#34;another\u0026#34;, plot_page) ) ) server \u0026lt;- function(input, output, session){ router_server() bins \u0026lt;- reactive({ bins \u0026lt;- get_query_param(\u0026#34;bins\u0026#34;) # e.g. http://127.0.0.1:5306/#!/another?bins=5 if(is.null(bins)){ #初始默认值 bins = 3 } as.numeric(bins) #文本字符转数值变量 }) output$plot \u0026lt;- renderPlot({ hist(mtcars$mpg, breaks = bins()) }) observeEvent(input$bins,{ #根据sliderInput自动更新url change_page(paste0(\u0026#34;another?bins=\u0026#34;, input$bins)) }) } shinyApp(ui, server) 4. 404页面 在输入的路由url不存在时，可通过page404()函数设置router_ui()的page_404参数，以显示个性化的404提醒界面 如下例所示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 library(shiny) library(shiny.router) home_page \u0026lt;- tagList( titlePanel(\u0026#34;Home page\u0026#34;), p(\u0026#34;This is the home page!\u0026#34;) ) page_404 \u0026lt;- tagList( titlePanel(\u0026#34;None page for the given url.\u0026#34;), actionButton(\u0026#34;btn\u0026#34;,\u0026#34;Go to root page!\u0026#34;) ) ui \u0026lt;- fluidPage( router_ui( route(\u0026#34;/\u0026#34;, home_page), page_404 = page_404 ) ) server = function(input, output, session){ router_server() observeEvent(input$btn, { change_page(\u0026#34;/\u0026#34;) }) } shinyApp(ui, server) ","permalink":"https://lishensuo.github.io/en/posts/program/268rhinoverse%E7%B3%BB%E5%88%97-shiny.router%E5%8C%85/","summary":"\u003cp\u003e\u003cstrong\u003erhinoverse系列\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ca href=\"https://lishensuo.github.io/posts/program/267rhinoverse%E7%B3%BB%E5%88%97-rhino%E5%8C%85/\"\u003erhinoverse系列-rhino包\u003c/a\u003e；\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://lishensuo.github.io/posts/program/268rhinoverse%E7%B3%BB%E5%88%97-shiny.router%E5%8C%85/\"\u003erhinoverse系列-shiny.router包\u003c/a\u003e；\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://appsilon.github.io/shiny.router/\"\u003ehttps://appsilon.github.io/shiny.router/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Appsilon/shiny.router\"\u003ehttps://github.com/Appsilon/shiny.router\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在网页设计和开发中，路由（Routing）是指确定用户在浏览器中访问不同页面（URL）时，应该加载哪些页面内容（UI）过程。其优点包括（1）允许单页面应用，无需一次性加载全部页面；（2）页面之间的流畅切换，不会感到明显的延迟等\u003c/p\u003e","title":"rhinoverse系列-shiny.router包"},{"content":" Recently, we have added some new modules for general TCGA data analysis and visualization. Here, we will provide the tutorials for easy use. Please note it is not the latest version and we are still in the stage of development. Therefore, if you have any question, please do not hesitate to contact us on GitHub or email (lishensuo@163.com) which could greatly contribute to UCSCXenaShiny V2.0 process.\nThe temporary tutorial is based on the latest commit On November 18, 2023. It may be outdated in the future and we will update the latest tutorials as soon as possible.\n0 Prior knowledge Paper: UCSCXenaShiny: An R/CRAN Package for Interactive Analysis of UCSC Xena Data, Bioinformatics, 2021;, btab561, https://doi.org/10.1093/bioinformatics/btab561. GitHub: https://github.com/openbiox/UCSCXenaShiny Website: https://shiny.hiplot.cn/ucsc-xena-shiny/ 1. key features For the general exploration of TCGA data, we support the following key features.\n3 analysis methods: (1) Correlation; (2) Comparison; (3) Survival analysis. 3 analysis modes: (1) One data on one cancer; (2) One data on multiple cancers; (3) Multiple data on one cancer. \u0026ldquo;22 + X\u0026rdquo; data types: 4 main data type (Level1) including 22 minor types (Level2) are ensembled. In addition, users can upload customized TCGA sample metadata. Personalized operation: Several modules are provided for personalized analysis, like sample filtering/grouping, dataset modification. 2. Basic use Take correlation analysis for example, we will introduce the basic pipeline.\n(1) Firstly, once you enter the shiny app, click the TCGA Analysis navigation and select the \u0026ldquo;TCGA Association analysis\u0026rdquo; module.\n(2) Then, select one panel for the corresponding mode. By default, you will be in the left panel which support one data analysis.\n(3) Next, what you need do is to just follow the sequential steps from left to right.\nIn step S1, you should choose the intended cancer type(s). In addition, we support some optional and personalized operations which will be introduced in other section below. In step S2 and S3, you need to assign the specific data. For correlation analysis, it involves X and Y variable selections of two items. For other analysis, you should also set the groups. In step S4, you can finally execute the correlation analysis and visualization. Some parameters can be modified like correlation method, point color. Notably, we support the result download for the table of raw or analyzed data, and figure of visualization. 3. Sample selection Once you choose the cancer types(s), all the samples under the related project(s) will be chosen, such as tumor and normal samples. However, we need some filtering operations for specific analysis tasks.\nFor example, we only want the tumor samples for survival analysis or one gene-pair correlation under TP53 mutant samples.\nIn the 2nd part of S1 step , we provide the UI including two filters to select interesting subset of all samples.\nFirstly, users can directly perform the quick filter according to the tissue code types under the cancer(s) selections.\nSecondly, users can perform the exact filter when entering the following example dialog box.\nBy default, we have prepared several clinical phenotypes such as code, gender, age, stage. User can add any data as the extra filter conditions. According to the condition class, there are different filter operations. For character class, users can retain or discard some categories; For numeric class, users can set the cutoff based on absolute or percentile values. When setting multiple condition filters, each is executed independently and take the overall intersection finally. Note: If you perform both quick and exact filters, the shared samples will be selected.\n4. Custom metadata As the first figure above shown, we ensemble the TCGA feature data into 3 levels. Level1 and Level2 refer to the main and minor data types. Level3 refer to the specific item id. We have prepared 4 Level1 types which could be queried in detail from the Help→Id reference page.\nIn addition, we allow users to upload customized TCGA metadata or annotation as the 5th Level1 type in the 3rd part of S1 step.\nFor the file to upload, it should be CSV format. Its first column must be standard TCGA sample id (TCGA-XX-XXXX-XX) with the column name \u0026ldquo;Sample\u0026rdquo;. As it is not necessary to include all TCGA samples, you can upload limited samples information according to your analysis task.\n5. Modify datasets Among the UCSC Xena data portal, there are great alternative datasets for the sample data type, like different normalization of mRNA expression, different array of DNA methylation. By default, we have set one common dataset for each Level2 data type (). Now, it is accessible for users to change the default dataset selection in the 4th part of S1 step.\nAs the preliminary try, we temporarily allow the selection of DNA methylation and CNV data.\nFor the CNV data, uses can set whether to use the threshold data (default is TRUE); For the DNA methylation, users can have more options. On the one hand, you can choose 450K or 27K array (only limited samples for 27K). As one gene often covers multiple CpG sites, the mean value will be calculated by default. You can change the aggregation methods and CpG range. For example, you can just consider one CpG site for one gene as follows (right figure). Tip: The CpG Chromosomal coordinate information can be queried from Help→Id reference page.\nIn the future update, we will consider more options for other molecular profile data type, like mRNA expression.\n6. Binary grouping For comparison or survival analysis, it is necessary to divide samples into groups. Therefore, we design the module for binary grouping operation.\nTake comparison analysis for example, you should firstly confirm the S1 preset. Like sample filtering, we preliminarily provide common clinical phenotypes and you can also add any data from ensembled features. However, only one could be considered as grouping condition.\nFor character class, you can assign one or several categories for either group; For numeric class, you can set the min and max range of each group. Absolute and percentile value are all supported. Please note it will cause a warning when existing shared samples between groups which should be avoided.\nIn addition, you can also set the group names and levels. By default, they are \u0026ldquo;Group1\u0026rdquo; and \u0026ldquo;Goup2\u0026rdquo; in order.\n7. Multiple items selection For the mode of multiple data on one cancer which is located in the second right panel of analysis page, users can perform batch analysis easily to screen significant items.\nFor example, we can find the most correlated immune infiltration with one gene expression. The main operation difference is involved the selection of multiple items.\nHere, take batch correlation analysis for example, users can set multiple items in step S2 in three ways under one specific Level2 data type.\nFirstly, users can select some items one by one (left option \u0026ldquo;Selection\u0026rdquo;); Secondly, users can directly select all the ids (middle option \u0026ldquo;All\u0026rdquo;, like the figure below). However, it will take much time and cache to download molecular profile data. So, it will choose random 100 items for this Level1 type which need for better optimization in the future. Lastly, users can upload item file and see the format requirements by downloading the example file. ","permalink":"https://lishensuo.github.io/en/posts/program/300ucscxenashiny-dev-tutorials--231119/","summary":"\u003cblockquote\u003e\n\u003cp\u003eRecently, we have added some new modules for general TCGA data analysis and visualization. Here, we will provide the tutorials for easy use. Please note it is not the latest version and we are still in the stage of development. Therefore, if you have any question, please do not hesitate to contact us on GitHub or email (\u003ca href=\"mailto:lishensuo@163.com\"\u003elishensuo@163.com\u003c/a\u003e) which could greatly contribute to UCSCXenaShiny V2.0  process.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eThe temporary tutorial is based on the latest \u003ca href=\"https://github.com/openbiox/UCSCXenaShiny/commit/5bd91911c85590fc369ab61471450fa9564bda7a\"\u003ecommit \u003c/a\u003e On November 18, 2023. It may be outdated in the future and we will update the latest tutorials as soon as possible.\u003c/strong\u003e\u003c/p\u003e","title":"UCSCXenaShiny development tutorials(231119)"},{"content":" 前列腺癌（Prostate cancer, PCa）肿瘤生物学基础的学习笔记 课程链接：https://www.bilibili.com/video/BV1Dj411R73C 1. 生物基础 1.1 前列腺癌 前列腺 (Prostate) 一种男性的腺体器官，核桃大小，位于膀胱下方； (1) 防止尿路感染；(2) 产生的Prostate Specific Antigen (PSA, 前列腺特异性抗原) 蛋白酶可以帮助液化精液 （与勃起、生殖无关）。 良性前列腺增生 (Benign Prostatic Hyperplasia, BPH) 随着年龄增长而表现出的前列腺增大，导致排尿困难； 它不是前列腺癌的诱发因素。 前列腺癌(Prostate Cancer, PCa) （1）发病率\n男性最常见的癌症之一，每年有22万人确诊（美国） 每年全球有110万男性确诊为PC，约占男性癌症的15% 男性致死率第二的肿瘤类型，每年有2.7万人死于PC（美国） 每年全球约有30万死于PC，约占男性死亡的6.6%（第五） （2）发展历程\n1）正常前列腺上皮细胞；主要由基底细胞和分泌细胞组成；\n2）增生性炎性萎缩(PIA)：细胞萎缩（体积减小）但伴随不正常的增殖。炎症细胞的浸润（如淋巴细胞）在局部可见；\n3）高级别前列腺上皮内瘤变(HGPIN)：异常增生的上皮细胞(核增大等)，但尚未侵入基底膜，因此还没有形成真正的癌症；\n4）局限性PCa：细胞突破基底膜，但仍局限于前列腺内部，尚未扩散到周围组织或远处器官；\n5）转移性PCa：癌细胞扩散到前列腺外的其他组织或器官。\n（3）风险因素\n年龄：多发于老年男性。60%诊断于65岁以上男性，较少在40岁以下男性中发现； 种族：多发于非遗美国人，少见于亚洲男性 家族史：有较显著遗传倾向，父亲或兄弟确诊的男性发病率翻倍 基因：HOXB13，BRCA1/2，MSH2，MLH1 饮食：多吃红肉、少吃蔬菜的发病率更高 1.2 癌症特征 （1）What is cancer：\n\u0026ldquo;Uncontrolled growth\u0026rdquo;: 体内某些异常细胞的不受控制的分裂； 也称为Tumor，由组织异常生长（良性/恶性）引起的身体某个部位的肿胀，通常没有炎症； 也称为Neoplasm，描述了体内组织的任何新的和异常的生长。 （2）How cancer can be classifed by the originated tissue\nCarcinoma，起源于上皮组织，有两种常见亚型 Adenocarcinomas腺癌：源自腺体的上皮细胞，腺体是分泌物的组织（如乳腺、前列腺、胃腺等）； Squamous cell carcinomas鳞状细胞癌：源自鳞状上皮细胞，这种细胞常见于皮肤和许多内脏器官的表面。 Sarcoma肉瘤：起源于间叶组织，包括结缔组织、肌肉、脂肪、血管和淋巴组织等 Leukemia白血病：起源于骨髓中 Lymphoma淋巴瘤：起源于淋巴系统 （3） Genetic Disease\n癌症由基因组的异常突变累积导致，单基因突变通常不会引起； 例如： 一个抑癌基因（tumor suppressor gene）发生突变，导致失活。 负责DNA修复的基因发生突变，导致更多突变； 致癌基因（Oncogene）发生突变，细胞快速增殖 （4）Cancer Hallmarks\n肿瘤细胞可以刺激它们的生长； 抵抗抑制信号； 抵抗程序性细胞死亡； 无限繁殖； 刺激血管生成； 侵入邻近组织，转移到远端组织； 异常的代谢通路（能量 ） 逃避免疫系统 基因组不稳定 与炎症相关 2. 筛查与诊断 2.1 筛查手段 （1）DRE（肛肠指检）\n50岁以上，每年DRE 使用手指感受前列腺处是否有肿 （2）PSA检查\n检测血液中PSA含量，单位通常为(ng/mL)\n55-69岁之间，正常范围是4ng/mL，年轻（\u0026lt;50）男性样本应低于2.5\n争议：高水平的PSA含量不一定是PC，只有25%高PSA男性被确诊为前列腺癌（过度筛查）\n改进版的PSA评估\nFree versus total PSA (\u0026lsquo;Free\u0026rsquo;: not bound to other proteins) 较低的比值(小于0.1)，即更少的Free PSA与Aggressive cancer更相关； Age-specific的PSA含量阈值：年老的患者的阈值更高 PSA velocity：每年PSA含量的变化(\u0026gt;0.7 ) PSA doubling：PSA含量提高一倍时的时间窗口 （3）PHI, Prostate Health Index →相比前者better predictor\n基于free PSA，total PSA，[-2]proPSA isoform of free PSA三者的组合。 ProPSA，特别是[-2]proPSA，具体指的是一种PSA的前体形式。 （4）4Kscore\n基于4种kallikrein(激肽释放酶)的检测结果及临床信息进行打分 与PSA相关的指标相互补充，更适合用于aggressive PC 2.2 诊断方式 超声成像检查（Ultrasound） 将超声探头放置直肠内，对前列腺成像 穿刺活检（Needle Biopsies） 对前列腺不同区域，进行12处穿刺（对于穿刺异常的区域，会两次取样） 医生一般将前列腺分为 (1)外周区，(2)中间区，(3) 过渡区。PC一般发生于外周区，靠近直肠。 核磁共振（MRI）：检查PC是否突破前列腺包膜，侵入其它周围组织 CT扫描：观察淋巴结是否变大（可能是由于PC转移，也有可能是炎症等导致） 骨扫描/X-rays：观察是否存在骨损伤（可能是由于PC转移） 2.3 分期分级 （1）TNM分期\nT = Tumor size T1c ：通过PSA筛查发现 T2 ：局限性PC T3：突破前列腺包膜 T4：进入到直肠或膀胱 N = Lymph node involvement Nx：未进行相关检查 N0：没有侵入淋巴结 N1：存在侵入淋巴结 N2、N3表示程度更高 M = Presence of metastases Mx：未进行相关检查 M1：发生了远端转移 M1a：转移至骨盆(Pelvis)以外的淋巴结 M1b：转移至骨 M1c：转移到其它区域 （2）组织形态\n正常前列腺 腺体部分（glandular epithelium）：包括前列腺腺泡（glandular acini）和导管，负责分泌前列腺液。 间质部分（stroma）：主要由基质细胞（如成纤维细胞）、平滑肌细胞、血管、神经以及结缔组织组成。 前列腺间质存在细胞炎症时\n表现为细胞浸润（炎症细胞，包括淋巴细胞、巨噬细胞或浆细胞等）、纤维化和长期的组织反应 前列腺上皮内瘤变（PIN）\n前列腺内的细胞异常增生情况。 （3）Gleason分数\nGleason分数用于评估前列腺癌分化程度，主要基于前列腺癌细胞的形态学特征，将腺体分化程度划分为五个等级：\n1级：癌细胞分化较好，腺体结构基本保持正常；\n2级：癌细胞分化较好，腺体结构出现一些不规则性；\n3级：癌细胞分化较差，腺体结构明显异常，腺体边界不规则；\n4级：癌细胞分化较差，几乎没有形成正常腺体的特征，明显的浸润性生长。\n5级：癌细胞完全分化不良，几乎没有腺体结构，癌细胞成片生长，极具侵袭性。\n细胞分化是指细胞在生长过程中逐渐获得特定功能和形态的过程。\n高度分化的细胞与其来源的正常组织细胞非常相似，形态较规则，仍保留了部分或大部分的正常功能。 生长速度慢；局限于原位，侵袭性弱；转移风险低等 低度分化的细胞则与正常细胞相去甚远，功能异常，形态不规则，表现出更强的恶性特征。 Gleason评分通过将前列腺癌组织中最常见的肿瘤形态（主要模式）和第二常见的肿瘤形态（次要模式）分别进行评分，然后相加得出总分。\nGleason 6：低度恶性\nGleason 7：中度恶性 （3+4或者4+3，前者更危险）\nGleason 8-10：高度恶性\n3. 治疗方式 在治疗前，会对患者进行Risk categories风险评估，选择合适的治疗方式。\n评估的是\u0026quot;Risk of recurrence\u0026quot;，即经过治疗后，癌症又重新复发的可能性 基于initial PSA, Cancer stage, PSA density, Gleason scre进行评估 主要分为如下类别 Very Low-risk：T1c，Gleason score\u0026lt;6, PSA \u0026lt; 10等 Low-risk：T1-T2a, Gleason score≤6，PSA ＜ 10等 Intermediate risk：T2b-c，Gleason 7，PSA 10-20 ng/mL High risk：T3a，Gleason 8-10，PSA\u0026gt;20 Very High-risk：T3b-T4, Gleason 8-10 下面按局限性与转移性两大类PCa介绍下相应的治疗方式\n3.1 局限性PCa 手术或放疗对localized low and intermediate risk PC同样有效；\n放疗+激素治疗可用于locally advanced PC\nActive surveillance（主动监测）\nChemotherapy (generallly not used in local treatment)\nTarget therapy (generallly not used in local treatment)\nImmunotherapy (generallly not used in local treatment)\n手术和放疗是早期前列腺癌（未发生侵袭）的主要手段\n（1）Surgery （手术）\n切除肿瘤在内的整个前列腺组织 耻骨后根治性前列腺切除术 (Radical retropubic prostatectomy) Neoadjuvant therapy 新辅助治疗（术前） 使肿瘤变得更小，更易于手术切除，减少复发的风险，并提高长期生存的可能性。 Adjuvant therapy 辅助治疗 （术后） 消灭任何可能残留的癌细胞，防止癌症复发。 （2）Radiation （放疗）\n使用X-射线等产生的能量造成DNA损伤，杀伤肿瘤细胞 形式上包括外照射放射治疗（External Beam Radiation Therapy, EBRT），近距离放射治疗（Brachytherapy）等 手术或放疗的副作用常包括尿失禁、勃起障碍、消化道相关问题。\n（3）Hormone therapy（激素治疗）\n人体产生的化学物质（激素）告诉每个器官应该做什么，同时也会促进肿瘤生长\n女性的雌激素（hormone estrogen）控制女性的第二性征发育，包括乳房发育、月经调节等；\n抗雌激素药物可以用于治疗乳腺癌。 男性的睾酮激素（hormone testosterone）负责促进男性生殖器官（如睾丸和前列腺）的发育和生长，还促进肌肉质量增加、骨骼密度增强以及体毛的生长。\n抗睾酮激素药物可以用于治疗前列腺癌 ADT(Androgen Deprivation Therapy)称为雄激素剥夺治疗，通过手术或药物手段来降低雄激素水平或作用。\n手术层面：主要指手术性阉割（即双侧睾丸切除术）； 药物层面：如上机制，可以有两种途径： LHRH阻断剂：抑制垂体前叶分泌LH，从而减少睾丸产生的睾酮量。 AR阻断剂：占据AR的位置，使真正的雄激素无法与之结合，从而阻止雄激素的信号传导。 睾酮激素调节机制\n（1）首先在下丘脑（Hypothalamus），会分泌促黄体生成素释放激素（LHRH，也称为GnRH）。然后这种激素通过垂体门脉系统传递给垂体前叶（Pituitary），刺激垂体前叶产生并释放出促黄体生成素（LH）；\n（2）血液中的促黄体生成素（LH）到达睾丸（Testis），促进分泌睾酮（T），大约有90%的睾酮与血浆蛋白结合；\n（3）当睾酮进入前列腺癌细胞（PCA cell）后，它会被转化为更强效的雄性激素双氢睾酮（DHT）。\n（4）睾酮或其衍生物如双氢睾酮（DHT），与靶细胞表面或细胞质内的雄激素受体（AR）结合后，一系列生化反应就会被激活。\n激素治疗副作用主要由于睾酮激素降低所导致的： Hot flash (超热)，性欲降低，肌肉减少，骨密度降低，代谢降低（体重增加）等。 3.2 转移性PC的治疗 PCa最常见的转移形式是骨转移。\n（1）激素治疗\n转移性PCa的一线治疗方案，生存时间5-6年\n有时联合化疗药物（e.g. Docetaxel多西他赛）取得更佳的效果\n最终由于耐药性，导致CRPC：Castrate-resistant prostate cancer\n目前有多种角度解释，其中最主要的是PCa促进AR（雄激素受体）的增多，使得尽可能利用体内的睾酮激素。 （2）Supra-castration hormonal agents（超去势激素药物）为二线治疗药物\n（3）化疗药物，主要有两类\n干扰有丝分裂 （e.g. 多西他赛，Docetaxel），如下图 多西他赛是一线化疗药，用于二线激素治疗失败后 副作用主要是损伤正常细胞，例如脱发、食欲不振、恶心等 干扰DNA复制 （较少用）； （3）对于骨转移患者的治疗方案最终无效（大部分）时，可以基于driver gene mutation参加临床试验clinical trial （precison medicion）\n此类研究（targeted gene/pathway以及immune therapy）将在后续阅读文献学习。\nBRCA2，BRCA2，ATM：19.2%；MLH1，MLH2\n","permalink":"https://lishensuo.github.io/en/posts/basic/301%E7%94%9F%E7%89%A9-%E5%89%8D%E5%88%97%E8%85%BA%E7%99%8C%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/","summary":"\u003cul\u003e\n\u003cli\u003e前列腺癌（Prostate cancer, PCa）肿瘤生物学基础的学习笔记\u003c/li\u003e\n\u003cli\u003e课程链接：https://www.bilibili.com/video/BV1Dj411R73C\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1-生物基础\"\u003e1. 生物基础\u003c/h1\u003e\n\u003ch2 id=\"11-前列腺癌\"\u003e1.1 前列腺癌\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e前列腺 (Prostate)\n\u003cul\u003e\n\u003cli\u003e一种男性的腺体器官，核桃大小，位于膀胱下方；\u003c/li\u003e\n\u003cli\u003e(1) 防止尿路感染；(2) 产生的Prostate Specific Antigen (PSA, 前列腺特异性抗原) 蛋白酶可以帮助液化精液 （与勃起、生殖无关）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e良性前列腺增生 (Benign Prostatic Hyperplasia, BPH)\n\u003cul\u003e\n\u003cli\u003e随着年龄增长而表现出的前列腺增大，导致排尿困难；\u003c/li\u003e\n\u003cli\u003e它不是前列腺癌的诱发因素。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240918211100038.png\" alt=\"image-20240918211100038\" style=\"zoom: 50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e前列腺癌(Prostate Cancer, PCa)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e（1）发病率\u003c/strong\u003e\u003c/p\u003e","title":"文献--前列腺癌基础学习"},{"content":" 1 2 3 4 5 6 7 8 test=\u0026#34;https://www.baidu.com\u0026#34; #打印字符串内容 echo ${test} #https://www.baidu.com #打印字符串长度 echo ${#test} #21 1、截取 （1）指定截取字符串的起始位置与长度 对于字符串的起始位置定义：如果是从左到右，则第一个字符位置为0； 如果是从右到左，则第一个字符位置为1。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 从第8个字符串开始，截取长度为10的子字符串 echo ${test:8:10} # www.baidu. # 从第1个字符串开始，截取长度为5的子字符串 echo ${test:0:5} # https # 从第8个字符串开始，截取后面的所有字符串内容 echo ${test:8} # www.baidu.com # 从倒数第11个字符串开始，截取后面的所有字符串内容 echo ${test:0-11} # w.baidu.com # 从倒数第11个字符串开始，截取长度为5的子字符串 echo ${test:0-11:5} # w.bai （2）指定分隔符进行截取 注意*号的位置！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 取字符串中第一次出现`.`点号的右边全部内容 echo ${test#*.} # baidu.com # 取字符串中最后一次出现`.`点号的右边全部内容 echo ${test##*.} # com # 取字符串中最后一次出现`.`点号的左边全部内容 echo ${test%.*} # https://www.baidu # 取字符串中第一次出现`.`点号的左边全部内容 echo ${test%%.*} # https://www 2、替换操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 将字符串里的第一个点号`.`替换为短横`-` echo ${test/./-} # https://www-baidu.com # 将字符串里的全部点号`.`替换为短横`-`【与上面的区别是多了一个 / 】 echo ${test//./-} # https://www-baidu-com # 可配合正则表达式完成自定义的替换方式，例如 echo ${test//[bd]/-} # https://www.-ai-u.com # 删除字符串 echo ${test//[bd]/} # https://www.aiu.com ","permalink":"https://lishensuo.github.io/en/posts/program/400shell%E5%9F%BA%E7%A1%80--%E5%8F%98%E9%87%8F%E5%90%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etest=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;https://www.baidu.com\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#打印字符串内容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eecho\u003c/span\u003e \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${\u003c/span\u003etest\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#https://www.baidu.com\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#打印字符串长度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eecho\u003c/span\u003e \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e${#\u003c/span\u003etest\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#21\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1截取\"\u003e1、截取\u003c/h1\u003e\n\u003ch3 id=\"1指定截取字符串的起始位置与长度\"\u003e（1）指定截取字符串的起始位置与长度\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于字符串的起始位置定义：如果是从左到右，则第一个字符位置为0；\n如果是从右到左，则第一个字符位置为1。\u003c/p\u003e","title":"shell基础--变量名字符串操作"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 第一个参数交待查找路径，默认为当前路径 # -name 参数指定需要查找的文件名，支持正则表达式 find -name \u0026#39;*.txt\u0026#39; find ./dir1/ -name \u0026#39;*.txt\u0026#39; # -maxdepth 指定查找的最大目录层级深度 find -maxdepth 2 -name \u0026#39;*.txt\u0026#39; # -type d 表示查找目录类型 # -type f 表示查找文件类型 find -type f -name \u0026#39;*.txt\u0026#39; # 查找指定大小范围的文件；如下表示查找大小范围在50M~100M范围之间的文件 find -size +50M -size -100M # 找到文件后，执行一些命令操作 ## 查看找到文件的详细信息 find -name \u0026#39;*.txt\u0026#39; -exec ls -l {} \\; ## 返回找到文件的文件名（去除路径） find -name \u0026#39;*.txt\u0026#39; -exec basename {} \\; ","permalink":"https://lishensuo.github.io/en/posts/program/401shell%E5%9F%BA%E7%A1%80--find%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 第一个参数交待查找路径，默认为当前路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  -name 参数指定需要查找的文件名，支持正则表达式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind -name \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;*.txt\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind ./dir1/ -name \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;*.txt\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -maxdepth 指定查找的最大目录层级深度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind -maxdepth \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e -name \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;*.txt\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -type d 表示查找目录类型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -type f 表示查找文件类型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind -type f -name \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;*.txt\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 查找指定大小范围的文件；如下表示查找大小范围在50M~100M范围之间的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind -size +50M -size -100M\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 找到文件后，执行一些命令操作\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 查看找到文件的详细信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind -name \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;*.txt\u0026#39;\u003c/span\u003e -exec ls -l {} \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 返回找到文件的文件名（去除路径）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efind -name \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;*.txt\u0026#39;\u003c/span\u003e -exec basename {} \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"shell基础--find查找文件"},{"content":" tar相关 1 2 3 4 5 6 7 8 9 10 11 #(1) 将多个文件打包为 .tar文件 tar -cvf test.tar dir1 file4 #(2) 将多个文件打包并压缩为 .tar.gz tar -czvf test.tar.gz dir1 file4 #(3) 将 .tar文件拆包 tar -xvf test.tar #(4) 将 .tar.gz文件解压拆包 tar -xzvf test.tar.gz gzip压缩是的文件多为file.gz, 对应的linux命令为：\n（1）压缩：gzip; （2）解压缩：gunzip\n1 2 3 4 5 6 7 #压缩 gzip f1.txt # f1.txt.gz #解压缩 gunzip f1.txt.gz # f1.txt 但是gzip压缩仅支持单个文件。如果是文件夹或者多个文件则需要tar归档为一个文件\n1 2 3 4 5 6 7 #先将dir1 file1归档为test.tar包，然后再进行gzip压缩 tar -czvf test.tar.gz dir1 file1 # test.tar.gz #解压缩再解包 tar -xzvf test.tar.gz # dir1 file1 pigz软件可提供并行gzip压缩/解压缩过程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #conda安装 conda install -c conda-forge pigz pigz # 参数 -p设置进程数，默认为8 #pigz单文件压缩 pigz f1.txt #pigz归档压缩 tar -cvf - dir1/ file1 | pigz -p 8 \u0026gt; test.tar.gz #pigz解压 ## -d 参数表示解压缩 pigz -d test.gz ## 如果是tar.gz，需要先解压，再拆包 pigz -d test.tar.gz tar -xvf test.tar ","permalink":"https://lishensuo.github.io/en/posts/program/402sehll%E5%9F%BA%E7%A1%80--gzip%E5%8E%8B%E7%BC%A9%E4%B8%8Epigz%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"\u003cul\u003e\n\u003cli\u003etar相关\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(1) 将多个文件打包为 .tar文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etar -cvf test.tar dir1 file4\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(2) 将多个文件打包并压缩为 .tar.gz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etar -czvf test.tar.gz dir1 file4\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(3) 将 .tar文件拆包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etar -xvf test.tar\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#(4) 将 .tar.gz文件解压拆包\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etar -xzvf test.tar.gz\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003egzip压缩是的文件多为\u003ccode\u003efile.gz\u003c/code\u003e, 对应的linux命令为：\u003c/p\u003e","title":"shell基础--tar.gz相关、gzip压缩与pigz多线程"},{"content":"1、grep 主要功能：查询符合条件的行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #返回符合条件的行,可使用正则表达式 who | grep \u0026#34;wuyt\u0026#34; # -n参数：返回符合条件的行，及其在原文件中的位置 who | grep -n \u0026#34;wuyt\u0026#34; # -c参数：仅返回符合条件的行数 who | grep -c \u0026#34;wuyt\u0026#34; # -v参数：反选 who | grep -v \u0026#34;wuyt\u0026#34; # -E参数：符合多个条件之一 who | grep -E \u0026#34;wuyt|ssli\u0026#34; 2、sed 主要功能：增删改查 （1）删除\n1 2 3 4 5 6 7 8 #删除第一行 who | sed \u0026#39;1d\u0026#39; #删除最后一行 who | sed \u0026#39;$d\u0026#39; #删除第3-5行 who | sed \u0026#39;3,5d\u0026#39; （2）查看\n1 2 3 4 5 6 7 8 #显示第一行 who | sed -n \u0026#39;1p\u0026#39; #显示最后一行 who | sed -n \u0026#39;$p\u0026#39; #显示第3-5行 who | sed -n \u0026#39;3,5p\u0026#39; （3）增加/插入\n1 2 3 4 5 #在第一行前插入 who | sed \u0026#39;1i this is the new first line\u0026#39; #在最后一行后插入 who | sed \u0026#39;$a this is the new last line\u0026#39; （4）修改/替换\n1 2 3 4 5 6 7 8 9 #将第一行替换为其它内容 who | sed \u0026#39;1c this line has been changed\u0026#39; #替换--整体替换 who | sed \u0026#39;s/ssli/abc/g\u0026#39; #替换--一一替换 who | sed \u0026#39;y/abc/ABC/\u0026#39; ##替换为空值即为删除 3、awk 主要功能：筛选符合条件的行 （1）打印指定列。默认分割符为空格或者Tab键,输出分隔符为单个空格。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #打印第1列 who | awk \u0026#39;{print $1}\u0026#39; #打印第2列 who | awk \u0026#39;{print $1,$2}\u0026#39; #打印第1,2列，中间以逗号为分隔符 who | awk \u0026#39;{print $1\u0026#34;,\u0026#34;$2}\u0026#39; # -v FS= 指定输入分隔符 head /etc/passwd | awk -v FS=\u0026#34;:\u0026#34; \u0026#39;{print $1}\u0026#39; # -v OFS= 指定输出分隔符 # $NF 最后一列 # $(NF-1) 倒数第二列 # $0 表示原文件的行内容 head /etc/passwd | awk -v FS=\u0026#34;:\u0026#34; -v OFS=\u0026#34;\\t\u0026#34; \u0026#39;{print $1,$2,$(NF-1),$NF}\u0026#39; （2）按照列的特征筛选行\n1 2 3 4 5 6 7 8 9 10 11 12 13 #第四列值大于0的行 #比较下面两个命令的差异，$0表示原文件的行内容 head /etc/passwd | awk -v FS=\u0026#34;:\u0026#34; -v OFS=\u0026#34;\\t\u0026#34; \u0026#39;$4 \u0026gt; 0{print $0}\u0026#39; head /etc/passwd | awk -v FS=\u0026#34;:\u0026#34; -v OFS=\u0026#34;\\t\u0026#34; \u0026#39;$4 \u0026gt; 0{print $1,$2,$4}\u0026#39; #第六列值内容为 \u0026#34;/sbin\u0026#34;的行 head /etc/passwd | awk -v FS=\u0026#34;:\u0026#34; -v OFS=\u0026#34;\\t\u0026#34; \u0026#39;$6 == \u0026#34;/sbin\u0026#34; {print $1,$2,$6}\u0026#39; #最后一列值内容包含 \u0026#34;nologin\u0026#34;的行 head /etc/passwd | awk -v FS=\u0026#34;:\u0026#34; -v OFS=\u0026#34;\\t\u0026#34; \u0026#39;$NF ~ nologin {print $1,$2,$NF}\u0026#39; ## 可使用 \u0026amp;\u0026amp; || 将多个筛选条件结合起来进行筛选 ## 还有更多更复杂的筛选方法，具体需要用到时在做学习 4、cut （1）截取每行指定位置的字符(串)\n1 2 3 4 5 6 7 8 #截取第3个字符 who | cut -b 3 #截取第3,4,5,7个字符串 who | cut -b 3-5,7 #截取第3个字符至末尾的字符串 who | cut -b 3- （2）指定分隔符(-d)，取指定片段的字符串(-f)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ##只能指定单个字符为分隔符 #以冒号为分隔符，取第一列 head /etc/passwd | cut -d : -f 1 #以冒号为分割符，取第2,4,6列 head /etc/passwd | cut -d : -f 2,4-6 #以单个空格为分隔符 who | cut -d \u0026#39; \u0026#39; -f 1 ##cut默认制表符为分隔符。可使用sed语句判断不确定的空白是制表符还是空格 printf \u0026#39;a b\\n\u0026#39; | sed -n l printf \u0026#39;a\\tb\\n\u0026#39; | sed -n l printf \u0026#39;a\\tb\\n\u0026#39; | cut -f 1 5、sort 主要功能：对单列字符串排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #正序 head /etc/passwd | cut -d : -f 1 | sort # -r 逆序 head /etc/passwd | cut -d : -f 1 | sort -r # -u 去重 who | cut -d \u0026#39; \u0026#39; -f 1 | sort -u # -n 按数值排序 head /etc/passwd | cut -d : -f 4 | sort -n #按照某一列(-t指定分隔符)顺序调整每行的顺序；输出仍为行文本内容 head /etc/passwd | sort -n -t \u0026#39;:\u0026#39; -k 4 6、uniq 主要功能：搭配sort计算频率 1 2 3 4 5 6 7 8 9 10 11 #uniq只会对相邻的重复值进行去重处理 head /etc/passwd | cut -d : -f 4 | uniq head /etc/passwd | cut -d : -f 4 | sort | uniq # -c 统计频数 head /etc/passwd | cut -d : -f 4 | sort | uniq -c #按频数排序 head /etc/passwd | cut -d : -f 4 | sort | uniq -c | sort -n # -d 只显示有重复的行 head /etc/passwd | cut -d : -f 4 | sort | uniq -dc 7、tr 主要功能：单个字符一一替换 1 2 3 4 5 6 7 8 9 10 who | tr \u0026#39;abc\u0026#39; \u0026#39;123\u0026#39; who | tr \u0026#39;a-z\u0026#39; \u0026#39;A-Z\u0026#39; #替换分隔符 head /etc/passwd | tr \u0026#39;:\u0026#39; \u0026#39;,\u0026#39; head /etc/passwd | tr \u0026#39;:\u0026#39; \u0026#39;\\t\u0026#39; #单个字符删除 -d who | tr -d \u0026#39;a-z\u0026#39; who | tr -d \u0026#39;a\u0026#39; 8、cat，paste，join cat：纵向合并文件 1 cat f1.txt f2.txt \u0026gt; f3.txt paste：横向合并文件 1 2 3 4 5 6 7 paste f1.txt f2.txt # -d 可指定分隔符 paste -d \u0026#39;,\u0026#39; f1.txt f2.txt #每两行合并为一行,以制表符为分隔符 cat f1.txt | paste - - 此外 join 可按公共列纵向合并文件。类似R中join系列函数\n","permalink":"https://lishensuo.github.io/en/posts/program/403shell%E5%9F%BA%E7%A1%80--grep%E7%AD%89%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","summary":"\u003ch1 id=\"1grep\"\u003e1、grep\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e主要功能：查询符合条件的行\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#返回符合条件的行,可使用正则表达式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewho | grep \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;wuyt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -n参数：返回符合条件的行，及其在原文件中的位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewho | grep -n \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;wuyt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -c参数：仅返回符合条件的行数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewho | grep -c \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;wuyt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -v参数：反选\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewho | grep -v \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;wuyt\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -E参数：符合多个条件之一\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewho | grep -E \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;wuyt|ssli\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2sed\"\u003e2、sed\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e主要功能：增删改查\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e（1）删除\u003c/p\u003e","title":"shell基础--grep等文本处理命令"},{"content":"1、关于CPU与线程 1.1 简单理解进程与线程 进程：计算机执行的一个命令或者程序 线程：一般来说一个进程对应一个线程。但是如果进程任务可以分为若干独立子任务独立运行时，可以调用多线程，加快分析速度。 1.2 cpu与核数 CPU(Central Processing Unit)中央处理器，属于硬件。一般window笔记本电脑有一个CPU(physical cpu) 核心（core），又称为内核。一个CPU芯片可以物理技术上集成多个内核，每个内核可以独立运行一个线程，最大化利用CPU资源。 逻辑CPU数，是指通过虚拟化技术每个内核划分为两个虚拟(logical)CPU内核，可以理解为每个内核的超线程数，一般为2。目前window/linux系统都支持。 总逻辑CPU数=物理CPU数 × 每个CPU芯片上的集成内核数 × 每个内核的超线程数 1.3 查看系统CPU属性 1.3.1 Windows系统查看CPU属性 1.3.2 Linux系统查看CPU属性 1 2 3 4 5 6 7 8 9 10 11 ## (1)查看物理CPU个数 cat /proc/cpuinfo| grep \u0026#34;physical id\u0026#34;| sort| uniq| wc -l ## (2)查看每个物理CPU中core的个数(即核数) cat /proc/cpuinfo| grep \u0026#34;cpu cores\u0026#34;| uniq ## (3)查看总逻辑CPU的个数 cat /proc/cpuinfo| grep \u0026#34;processor\u0026#34;| wc -l ## (4)查看每个逻辑CPU的属性 cat /proc/cpuinfo 1.4 CPU与RAM内存 当CPU的运算速度很快，需要执行一个命令时，需要调用储存在硬盘的程序数据进行交互。\n硬盘是计算机的外部储存器，容量大，不易丢失；但是数据读取太慢；\n内存(RAM, Random Access Memory)作为衔接二者之间的桥梁，一方面储存空间少于硬盘(具体看内存条的性能)；但一方面文件读取速度快于硬盘，从而提高CPU的计算效率。断电时，会清空内存数据；而硬盘数据不受影响。\n2、进程管理 2.1 ps：查看进程状态 1 2 3 4 5 6 7 8 9 10 ps au #显示通过终端启动的程序 ps aux #显示所有进程，包括后台启动的程序 ps aux | grep username #查找特定行模式的进程状态 ## USER : 执行进程的用户 ## PID : 进程ID ## %CPU, %MEM : 进程的CPU以及内存占有率 ## TTY, TIME, TIME : 进程在哪个终端，于哪个时间被启动的，已消耗CPU多长时间 ## COMMAND : 具体的进程命令 ## STAT : 表示当前命令的状态，常见的有 R--运行，S--睡眠，T--终止.... 2.2 top：实时监控进程信息 1 2 3 4 5 6 7 8 9 top top -d 3 #每隔3秒刷新一次进程状态 top -u usrname #指定用户的进程 top -c #显示全命令 # 快捷键：shift + P 将进程按CPU占有率降序排列(默认) # 快捷键：shift + M 将进程按内存占有率降序排列 ## 上半部分显示系统的CPU与内存状态，可重点关注 第三行 99.8 id表示空闲的CPU；第四行 221232.0 free 表示空闲的内存 ## 下半部分显示进程状态信息，每列字段含义基本同ps 2.3 kill：终止进程。 需要知道进程的PID，可通过ps或者top命令获得。 1 2 3 4 kill PID #默认为 -15, 正常杀死进程 kill PID1 PID2 #杀死多个进程 kill -9 PID #强制杀死进程 kill -1 PID #重新加载进程 3、后台运行进程 快捷键 Ctrl + C终止前台进程；Ctrl + Z 暂停前台进程，并置于后台\n\u0026lt;command\u0026gt; \u0026amp; : 在当前终端的后台执行命令。退出该终端后，后台进程也随之终止。\nnohup \u0026lt;command\u0026gt; \u0026amp; : 将在linux后台不挂断的执行命令。即使退出终端，也不影响该进程。\njobs : 查看当前终端的后台运行的进程，以及JobID\nfg \u0026lt;JobID\u0026gt; : 将后台进程放到前台\nbg \u0026lt;JobID\u0026gt; : 在后台运行后台暂停的进程\n3.1 终端后台执行命令 1 2 3 4 5 6 7 8 9 10 11 12 ##(1) 将命令直接放在后台开始执行 sleep 100 \u0026amp; #[1] 1916159 ##如上仅返回进程PID jobs # [1]+ Running sleep 100 \u0026amp; ##(2) 将正在前台运行的命令放到后台运行 sleep 100 #按 Ctrl + Z， 然后执行下述bg命令(以jobid为1示例) bg 1 3.2 不挂断地后台执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## (1)nohub \u0026lt;command\u0026gt; \u0026amp; 命令组合 nohup sleep 300 \u0026amp; #默认将命令的日志文件输出至当前路径的nohup.out文件中 #如下可将命令的日志文件输出到指定文件 nohup sleep 300 1\u0026gt; command.log 2\u0026gt;\u0026amp;1 \u0026amp; ## (2)将正在运行的命令转为不挂断地后台执行 sleep 300 #按 Ctrl + Z， 然后执行下述bg命令(以jobid为1示例) bg 1 disown %1 jobs ps aux | grep \u0026#39;sleep\u0026#39; Bug records\nFor nohup command to execute python scrip with print(XXXXX) code， it does not write the printed info into the output log. According to the hint from this blog, it can be solved by one python parameter -u. The following is an example:\n1 2 3 4 nohup python -u ./deploy/cal_fi.py 1\u0026gt; ./deploy/cal_fi.log 2\u0026gt;\u0026amp;1 \u0026amp; # check the log in real-time mode tail -f ./deploy/cal_fi.log ","permalink":"https://lishensuo.github.io/en/posts/program/450linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E4%B8%8E%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C/","summary":"\u003ch1 id=\"1关于cpu与线程\"\u003e1、关于CPU与线程\u003c/h1\u003e\n\u003ch2 id=\"11-简单理解进程与线程\"\u003e1.1 简单理解进程与线程\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e进程：计算机执行的一个命令或者程序\u003c/li\u003e\n\u003cli\u003e线程：一般来说一个进程对应一个线程。但是如果进程任务可以分为若干独立子任务独立运行时，可以调用多线程，加快分析速度。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"12-cpu与核数\"\u003e1.2 cpu与核数\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eCPU(Central Processing Unit)中央处理器，属于硬件。一般window笔记本电脑有一个CPU(physical cpu)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSfAH-Rz4sfQuBkCaJ1ZWz_M7oUUZTAgQLUBb4ZYekdFcawewIPG-u8nHySkZfp1OMUFrI\u0026usqp=CAU\" alt=\"電腦CPU多核數和多線程的區別對比！4核8線程和6核6線程哪個好？ - 壹讀\" style=\"zoom:33%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e核心（core），又称为内核。一个CPU芯片可以物理技术上集成多个内核，每个内核可以独立运行一个线程，最大化利用CPU资源。\u003c/li\u003e\n\u003cli\u003e逻辑CPU数，是指通过虚拟化技术每个内核划分为两个虚拟(logical)CPU内核，可以理解为每个内核的超线程数，一般为2。目前window/linux系统都支持。\u003c/li\u003e\n\u003cli\u003e总逻辑CPU数=物理CPU数 × 每个CPU芯片上的集成内核数 × 每个内核的超线程数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/aHR0cDovL2hpLmNzZG4ubmV0L2F0dGFjaG1lbnQvMjAxMTA3LzMxLzBfMTMxMjExOTc3OUp0SDUuZ2lm\" alt=\"CPU、核心数、线程数、运行内存、超线程理解_郝少的博客-CSDN博客_超线程数\"  /\u003e\r\n\u003c/p\u003e","title":"linux进程管理与后台运行"},{"content":"现阶段在学习深度学习超参数优化过程中涉及到SLURM相关知识。这几天探索了一番，简单记录一下目前简单认识。\nSLURM，Simple Linux Utility for Resource Management的缩写，是一个开源、容错、高度可扩展的集群管理和作业调度系统。\n几个关键概念：\n**node节点 **理解成一台独立的服务器（有若干内核，一定大小的内存）；\n**task任务 **理解为一个可执行脚本(.sh或者.py等)，最一般情况下执行一个脚本仅需要一个内核；\n**Job作业 **理解为一次slurm提交，可包含一个或多个任务\n基本使用流程为（1）用户进入登陆节点\u0026mdash;（2）编写任务以及所需配置资源\u0026mdash;（3）提交任务，分配节点，开始计算\n基础查询命令 1 2 3 4 5 6 sinfo #查看所有计算节点状态，第一列为分区名，后面会多次用到 squeue #查看正在运行的作业，包括比较重要的JobID信息 sacct #查看登陆节点以来所有的作业 scancel #根据JobID，取消正在运行的作业 两种运行方式 1、sbatch/srun提交脚本方式 （1）脚本与参数 需要考虑两部分（1）正确无误的可执行任务脚本文件；（2）指定运行脚本所需的节点资源\n脚本文件如下简单的示例 1 2 3 4 5 6 7 8 9 10 11 12 vi hello.py #---如下为脚本内容 #!/usr/bin/env python import time print(\u0026#34;t1: \u0026#34;,time.asctime(time.localtime())) print(\u0026#34;hello world\u0026#34;) time.sleep(5) print(\u0026#34;t2: \u0026#34;,time.asctime(time.localtime())) print(\u0026#34;hello world again!\u0026#34;) chmod +x hello.py #赋予执行权限 通过一些参数，设置运行环境（根据sinfo了解可用节点，以及相应的性能）。\n其中sbatch/srun的参数基本相同\n1 2 3 4 5 6 7 8 9 10 -p, --partition=partition name # 在指定分区中分配资源 -N, --nodes #节点数;如果作业不能跨节点(MPI)运行, 申请的节点数应不超过1 -n, --ntasks #请求执行任务数/分配的核心数， 默认情况下一个任务一个核心(可通过-c参数修改) # -n, --ntasks-per-node #每个节点执行的任务数/分配的核心数，如果申请一个节点与上一个参数意义等价 -c, --cpus-per-task #每个任务所需的核心数，默认为1 -J myFirstJob #设置作业名 -o job.%j.out #脚本执行的输出另保存 -e job.%j.err #脚本执行的报错另保存 --time=4-00:00 #限制运行时间 （2）srun执行 如下srun调用分区中一个c-4-1节点（已知该节点共有4个核心），并启用1个核心执行hello.py脚本任务\nsrun运行作业的主要特点之一是阻塞式的，直到运行结束后才会释放命令行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 srun -N 1 -n 1 -p c-4-1 ./hello.py # 结果输出如下 # t1: Sat Sep 10 14:13:31 2022 # hello world # t2: Sat Sep 10 14:13:36 2022 # hello world again! ## 如果调用2个核心，则输出结果如下，可以体会与上述启用一个节点的差异 srun -N 1 -n 2 -p c-4-1 ./hello.py # t1: Sat Sep 10 14:15:28 2022 # hello world # t2: Sat Sep 10 14:15:33 2022 # hello world again! # t1: Sat Sep 10 14:15:28 2022 # hello world # t2: Sat Sep 10 14:15:33 2022 # hello world again! （3）sbatch执行 与srun相比，sbatch更适合后台批量提交作业。\nsbatch执行的是一个shell作业脚本文件（注意与上面任务脚本是不同的），如下示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vi hello.slurm #---如下为脚本内容 #!/bin/bash #SBATCH -J hello #SBATCH -p c-4-1 #SBATCH -o %j.out #SBATCH -e %j.err #SBATCH -n 1 source activate mypython3 #加载所需的conda环境 python -c \u0026#39;print(\u0026#34;hello, world!\u0026#34;)\u0026#39; #也可以结合srun使用 srun -n 1 ./hello.py 如上，sbatch的参数可以写在作业脚本内，相对更加便捷。\n如下执行脚本，然后会返回一个jobID；输出结果会相应保存在out与err文件中。\n1 2 3 4 5 6 7 8 9 10 sbatch hello.slurm # Submitted batch job 34 cat 34.out # hello, world! # t1: Sat Sep 10 14:36:37 2022 # hello world # t2: Sat Sep 10 14:36:42 2022 # hello world again! （4）sbatch单节点多任务 如上sbatch执行作业脚本的逻辑就是简单的自上而下思路。\n在申请一个多核的节点，结合shell命令技巧同时运行多个任务即并行。\n（1）多任务，并没有并行的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vi multi_hello.slurm #---如下为脚本内容 #!/bin/bash #SBATCH -J hello #SBATCH -p c-4-1 #SBATCH -o %j.out #SBATCH -e %j.err #SBATCH -n 2 source activate mypython3 #加载所需的conda环境 #任务1 srun -n 1 ./hello.py #任务2 srun -n 1 ./hello.py 如上为整个作业申请2个核心，使用1个核心执行单个任务\n1 2 3 4 5 6 7 8 9 10 11 12 sbatch multi_hello.slurm # Submitted batch job 35 cat 35.out # t1: Sat Sep 10 14:52:07 2022 # hello world # t2: Sat Sep 10 14:52:12 2022 # hello world again! # t1: Sat Sep 10 14:52:12 2022 ##可以看到是在第一个任务结束后再执行的 # hello world # t2: Sat Sep 10 14:52:17 2022 # hello world again! （2）多任务，且并行的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 vi multi_hello.slurm #---如下为脚本内容 #!/bin/bash #SBATCH -J hello #SBATCH -p c-4-1 #SBATCH -o %j.out #SBATCH -e %j.err #SBATCH -n 2 source activate mypython3 #加载所需的conda环境 #任务1 srun -n 1 ./hello.py \u0026amp; #任务2 srun -n 1 ./hello.py \u0026amp; wait 如上有两点特殊处理\n\u0026amp; 加在每个任务的末尾，表示放在后台运行，否则任务脚本就会卡在这一行。\nwait 放在作业脚本的末尾， 让脚本等待以上后台任务运行结束后再停止，否则作业脚本运行到末尾就结束了。\n1 2 3 4 5 6 7 8 9 10 11 12 sbatch multi_hello.slurm # Submitted batch job 36 cat 36.out # t1: Sat Sep 10 14:58:37 2022 # hello world # t2: Sat Sep 10 14:58:42 2022 # hello world again! # t1: Sat Sep 10 14:58:37 2022 ##可以看到是在第一个任务同时开始的 # hello world # t2: Sat Sep 10 14:58:42 2022 # hello world again! 2、salloc交互式运行计算 salloc可以直接调用指定配置的节点（-p等参数同上），然后通过ssh方式进入节点。之后的操作基本等同在一台相应的服务器上操作。\n可以先在salloc模式下调试脚本，之后再通过sbatch批量放到后台运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 查看节点 sinfo # 申请节点 salloc -p c-4-1 # 查看状态 squeue # JOBID PARTITION NAME USER ST TIME NODES NODELIST(REASON) # 38 c-4-1 bash cloudam R 0:11 1 c-4-1-worker0001 # 进入节点 ssh c-4-1-worker0001 主要参考链接\nhttp://hpc.whu.edu.cn/info/1028/1019.htm\nhttps://docs.hpc.sjtu.edu.cn/app/compilers_and_languages/python.html\n","permalink":"https://lishensuo.github.io/en/posts/program/451%E5%88%9D%E8%AF%86slurm%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/","summary":"\u003cp\u003e现阶段在学习深度学习超参数优化过程中涉及到SLURM相关知识。这几天探索了一番，简单记录一下目前简单认识。\u003c/p\u003e\n\u003cp\u003eSLURM，Simple Linux Utility for Resource Management的缩写，是一个开源、容错、高度可扩展的集群管理和作业调度系统。\u003c/p\u003e","title":"初识slurm基础操作"},{"content":" https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html https://github.com/snakemake/snakemake 1. 简介 1.1 工具介绍 Snakemake 是一个用于创建可重现、模块化、自动化的工作流管理工具，主要用于处理复杂的数据分析流程；在生物信息学领域中有较多的应用。 例如对于RNA-seq上游分析流程，通常涉及（1）质控；（2）比对；（3）定量等三大步骤。\n一方面，每个步骤一般需要使用特定的软件处理，需要特定的输入输出数据。 snakemake可以对每个步骤进行定制化/模块化。 另一方面，通常需要多个样本的数据执行完全相同的分析。 snakemake可以对方便的执行批量分析。 1.2 基本语法 关键步骤是编写一个Snakefile，定义整个流程Pipeline的分析步骤 snakemake定义的语法规则是基于python的扩展； 每个分析步骤通过rule语句定义，如下示例： 在第1行，通过rule，声明一个名字\u0026quot;sort\u0026quot;的分析步骤 通过input，指定该步骤的输入数据 通过output，指定该步骤的输出结果 通过shell，定义执行的shell命令 1 2 3 4 5 6 7 rule sort: input: \u0026#34;path/to/dataset.txt\u0026#34; output: \u0026#34;dataset.sorted.txt\u0026#34; shell: \u0026#34;sort {input} \u0026gt; {output}\u0026#34; 1.3 安装 推荐为一个分析流程，创建特定的conda环境； 首先在进入该环境后，安装snakemake工具（需要python\u0026gt;3.5） 1 2 3 4 5 # 轻量版：保留核心功能，适用于本地分析。 conda install bioconda::snakemake-minimal # 完整版：支持执行不同计算环境（如本地集群、云服务等）时所需要的全部功能。 conda install bioconda::snakemake 再根据流程需要，安装其它的生信分析工具。\n教程文档提供的示例分析conda环境\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 mkdir snakemake-tutorial cd snakemake-tutorial cat environment.yaml #yaml文件见2.1 # channels: # - conda-forge # - bioconda # dependencies: # - snakemake-minimal \u0026gt;=8.4.4 # - jinja2 # - matplotlib # - graphviz # - bcftools =1.19 # - samtools =1.19.2 # - bwa =0.7.17 # - pygments # - pip: # # at the time of writing - 7. Feb 24 - pysam on bioconda will require # # a lower python version than snakemake, install pysam # # using pip # - pysam ==0.22 conda activate snakemake-tutorial # 上述的pysam安装若由于pip超时而报错，需重新指定镜像源安装 pip install pysam==0.22 -i https://pypi.tuna.tsinghua.edu.cn/simple snakemake --help 教程中推荐使用mamba安装，这里还是替换了为了的conda命令。\n2. 示例分析 2.1 下载示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 curl -L https://api.github.com/repos/snakemake/snakemake-tutorial-data/tarball -o snakemake-tutorial-data.tar.gz # 解压 tar --wildcards -xf snakemake-tutorial-data.tar.gz --strip 1 \u0026#34;*/data\u0026#34; \u0026#34;*/environment.yaml\u0026#34; # . # ├── data # │ ├── genome.fa # │ ├── genome.fa.amb # │ ├── genome.fa.ann # │ ├── genome.fa.bwt # │ ├── genome.fa.fai # │ ├── genome.fa.pac # │ ├── genome.fa.sa # │ └── samples # │ ├── A.fastq # │ ├── B.fastq # │ └── C.fastq # ├── environment.yaml # └── snakemake-tutorial-data.tar.gz 2.2 基础分析 （1）Snakefile 如下是完整的示例Snakefile文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 SAMPLES = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;] rule all: input: \u0026#34;plots/quals.svg\u0026#34; rule bwa_map: input: \u0026#34;data/genome.fa\u0026#34;, \u0026#34;data/samples/{sample}.fastq\u0026#34; output: \u0026#34;mapped_reads/{sample}.bam\u0026#34; shell: \u0026#34;bwa mem {input} | samtools view -Sb - \u0026gt; {output}\u0026#34; rule samtools_sort: input: \u0026#34;mapped_reads/{sample}.bam\u0026#34; output: \u0026#34;sorted_reads/{sample}.bam\u0026#34; shell: \u0026#34;samtools sort -T sorted_reads/{wildcards.sample} \u0026#34; \u0026#34;-O bam {input} \u0026gt; {output}\u0026#34; rule samtools_index: input: \u0026#34;sorted_reads/{sample}.bam\u0026#34; output: \u0026#34;sorted_reads/{sample}.bam.bai\u0026#34; shell: \u0026#34;samtools index {input}\u0026#34; rule bcftools_call: input: fa=\u0026#34;data/genome.fa\u0026#34;, bam=expand(\u0026#34;sorted_reads/{sample}.bam\u0026#34;, sample=SAMPLES), bai=expand(\u0026#34;sorted_reads/{sample}.bam.bai\u0026#34;, sample=SAMPLES) output: \u0026#34;calls/all.vcf\u0026#34; shell: \u0026#34;bcftools mpileup -f {input.fa} {input.bam} | \u0026#34; \u0026#34;bcftools call -mv - \u0026gt; {output}\u0026#34; rule plot_quals: input: \u0026#34;calls/all.vcf\u0026#34; output: \u0026#34;plots/quals.svg\u0026#34; script: \u0026#34;scripts/plot-quals.py\u0026#34; 相关知识点：\n在第一个 rule all语句声明该流程的最终target输出是什么，然后snakemake会逐步回溯上一步的分析步骤，从而了解全部的分析流程。\n第一行的SAMPLES = [\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;]命令通常用于设置批量运行的样本。 如果上面的例子是生成bam文件结束（没有plot_qual） 1 2 3 4 5 SAMPLES = [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;] rule all: input: expand(\u0026#34;sorted_reads/{sample}.bam\u0026#34;, sample=SAMPLES) snakemake语法中支持灵活的通配符方式，结合{}调用。可在实践中多加练习尝试\n上面的示例已展示了多个通配符，还有一种没提到的是： 1 2 3 4 5 6 7 8 rule sort_and_annotate: input: \u0026#34;path/to/{dataset}.txt\u0026#34;, \u0026#34;path/to/annotation.txt\u0026#34; output: \u0026#34;{dataset}.sorted.txt\u0026#34; shell: \u0026#34;paste \u0026lt;(sort {input[0]}) {input[1]} \u0026gt; {output}\u0026#34; 在rule语句中，除了使用常规的shell命令，也可以设置bash/python/R等脚本script程序。\n在上面示例流程的最后一步则使用了python脚本： 1 2 3 4 5 6 7 8 9 10 # ./scripts/plot-quals.py import matplotlib matplotlib.use(\u0026#34;Agg\u0026#34;) import matplotlib.pyplot as plt from pysam import VariantFile quals = [record.qual for record in VariantFile(snakemake.input[0])] plt.hist(quals) plt.savefig(snakemake.output[0]) 如下为R语言的示例脚本（与上述流程不相关）\n1 2 3 data \u0026lt;- read.table(snakemake@input[[1]]) data \u0026lt;- data[order(data$id),] write.table(data, file = snakemake@output[[1]]) 其它细节包括： 对于output的保存路径，如果当前目录不存在，则会自动创建。建议每个rule步骤都有独立的output路径 当shell命令过长时，可以分行编写；但需要再尾部添加空格。（例如第25、46行） （2）snakemake 接下来，使用snakemake命令执行即可。 1 2 3 4 5 6 7 8 9 10 11 12 # (1) snakemake会自动寻找当前路径的Snakefile, snakefile, workflow/Snakefile, workflow/snakefile文件； # 此外也可以重命名为其它，再使用 -s 参数指定即可： # (2) -n 只打印出即将执行的命令和任务顺序，而不实际执行 # -p 在任务执行前打印 Shell 命令 snake -n -p # (3) --dag 可视化工作流中的依赖关系 (DAG，Directed Acyclic Graph)，如下示意图 snakemake --dag | dot -Tpdf \u0026gt; test_dag.pdf # (4) 直接执行 snakemake -p 2.3 进阶分析 （1）Snakefile 如下是完整的示例Snakefile文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 configfile: \u0026#34;config.yaml\u0026#34; rule all: input: \u0026#34;plots/quals.svg\u0026#34; def get_bwa_map_input_fastqs(wildcards): return config[\u0026#34;samples\u0026#34;][wildcards.sample] rule bwa_map: input: \u0026#34;data/genome.fa\u0026#34;, get_bwa_map_input_fastqs output: temp(\u0026#34;mapped_reads/{sample}.bam\u0026#34;) params: rg=r\u0026#34;@RG\\tID:{sample}\\tSM:{sample}\u0026#34; log: \u0026#34;logs/bwa_mem/{sample}.log\u0026#34; threads: 8 shell: \u0026#34;(bwa mem -R \u0026#39;{params.rg}\u0026#39; -t {threads} {input} | \u0026#34; \u0026#34;samtools view -Sb - \u0026gt; {output}) 2\u0026gt; {log}\u0026#34; rule samtools_sort: input: \u0026#34;mapped_reads/{sample}.bam\u0026#34; output: protected(\u0026#34;sorted_reads/{sample}.bam\u0026#34;) shell: \u0026#34;samtools sort -T sorted_reads/{wildcards.sample} \u0026#34; \u0026#34;-O bam {input} \u0026gt; {output}\u0026#34; rule samtools_index: input: \u0026#34;sorted_reads/{sample}.bam\u0026#34; output: \u0026#34;sorted_reads/{sample}.bam.bai\u0026#34; shell: \u0026#34;samtools index {input}\u0026#34; rule bcftools_call: input: fa=\u0026#34;data/genome.fa\u0026#34;, bam=expand(\u0026#34;sorted_reads/{sample}.bam\u0026#34;, sample=config[\u0026#34;samples\u0026#34;]), bai=expand(\u0026#34;sorted_reads/{sample}.bam.bai\u0026#34;, sample=config[\u0026#34;samples\u0026#34;]) output: \u0026#34;calls/all.vcf\u0026#34; params: rate=config[\u0026#34;prior_mutation_rate\u0026#34;] log: \u0026#34;logs/bcftools_call/all.log\u0026#34; shell: \u0026#34;(bcftools mpileup -f {input.fa} {input.bam} | \u0026#34; \u0026#34;bcftools call -mv -P {params.rate} - \u0026gt; {output}) 2\u0026gt; {log}\u0026#34; rule plot_quals: input: \u0026#34;calls/all.vcf\u0026#34; output: \u0026#34;plots/quals.svg\u0026#34; script: \u0026#34;scripts/plot-quals.py\u0026#34; 此时为更通用的snakemake流程，相关知识点如下：\nconfig.yaml: 将工作流所需的所有参数(例如样本路径、参考基因组位置、工具设置)集中在一个配置文件中，而无需直接修改snakefile 1 2 3 4 5 samples: A: data/samples/A.fastq B: data/samples/B.fastq prior_mutation_rate: 0.001 类似get_bwa_map_input_fastqs函数，往往用于流程第一步的输入数据读取\nrule语句还支持其它更多的选项\nparams 用于设置生信工具命令参数 log 用于保存该步骤的log文件 threads 用户设置线程 resources: mem_mb=100 对于每个步骤的output分析结果，有两个特殊关键字\ntemp() 使得特定中间结果(例如sam/bam)在使用后会被删除，避免不必要的空间消耗 protected() 使得比较重要的中间结果不会由于报错等意外原因而被删除。 （2）snakemake 而在执行snake命令时，也有更多的参数方便个性化分析 1 2 3 4 5 6 7 8 9 10 11 12 # (1) -j 同时执行的任务数 snakemake -p -j 2 # (2) --core 允许调用的线程上限 snakemake --cores 10 # (3) --rerun-incomplete 断点继续运行未完成的任务 snakemake --rerun-incomplete # (4) --force 强制重新运行指定的目标，即使目标文件已经存在。 snakemake --force results/output.txt # 关于这一点，请参看下图： ","permalink":"https://lishensuo.github.io/en/posts/program/452snakemake%E6%B5%81%E7%A8%8B%E6%90%AD%E5%BB%BA/","summary":"\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html\"\u003ehttps://snakemake.readthedocs.io/en/stable/tutorial/tutorial.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/snakemake/snakemake\"\u003ehttps://github.com/snakemake/snakemake\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://genomics.ed.ac.uk/wp-content/uploads/2024/08/snakemake_logo.png\" alt=\"Snakemake\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"1-简介\"\u003e1. 简介\u003c/h1\u003e\n\u003ch2 id=\"11-工具介绍\"\u003e1.1 工具介绍\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eSnakemake 是一个用于创建可重现、模块化、自动化的工作流管理工具，主要用于处理复杂的数据分析流程；在生物信息学领域中有较多的应用。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240922130122018.png\" alt=\"image-20240922130122018\"  /\u003e\r\n\u003c/p\u003e","title":"Snakemake流程搭建"},{"content":" 最近有在window系统安装linux子系统(WSL, Windows Subsystem for Linux)的需求，搜索发现Microsoft最近(4月8号)提供了更加简便的安装方式。在此记录一下安装过程，的确非常简单。\n参考官方文档\nhttps://docs.microsoft.com/zh-cn/windows/wsl/install https://docs.microsoft.com/zh-cn/windows/wsl/setup/environment 根据文档说明，此方式只适用于Windows 10 版本 2004 及更高版本（内部版本 19041 及更高版本）或 Windows 11。\n1、wsl安装 进入window的cmd模式：Win+R 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ###(1) 选择wsl所支持的linux版本 wsl --list --online # 以下是可安装的有效分发的列表。 # 请使用“wsl --install -d \u0026lt;分发\u0026gt;”安装。 # NAME FRIENDLY NAME # Ubuntu Ubuntu # Debian Debian GNU/Linux # kali-linux Kali Linux Rolling # openSUSE-42 openSUSE Leap 42 # SLES-12 SUSE Linux Enterprise Server v12 # Ubuntu-16.04 Ubuntu 16.04 LTS # Ubuntu-18.04 Ubuntu 18.04 LTS # Ubuntu-20.04 Ubuntu 20.04 LTS ###(2) 选择其中的Ubuntu版本进行安装 wsl --install -d Ubuntu #如上会自动下载、安装、启动Ubuntu系统；然后根据提示设置用户名与密码。 #在创建第一个用户账号后，该账户就被视为系统管理员，能够运行`sudo`管理命令。 #已安装的发行版 wsl --list --verbose #目前WSL有两个版本，WSL1与WSL2；WSL2相较于WSL1更贴近真实Linux内核 #可如下设置指定版本的WSL默认Linux发行版 wsl --set-version \u0026lt;distribution name\u0026gt; 1/2 wsl --set-default Ubuntu-20.04 2 理论上Ubuntu子系统就已经安装了，点击window的开始选项，会出现该图标，点击即可运行。\n2、关于密码 1 2 3 4 5 6 7 8 9 10 11 ##(1) 只是想单纯修改密码，使用linux的password命令解决 #进入ubuntu系统 password #然后根据提示输入旧密码，再输入新密码 ##(2) 如果是忘记了密码，想要修改密码 #进入window的cmd模式 wsl -u root passwd \u0026lt;username\u0026gt; # \u0026lt;username\u0026gt;为忘记密码的账户名 # 然后就可以直接设置新密码了 3、互访文件 linux子系统中访问window桌面\n1 2 3 4 5 6 ls /mnt/ # c d #对应window的c盘与d盘 ## 进入window桌面文件夹，xiaoxin是我的用户名 cd /mnt/c/Users/xiaoxin/Desktop/ window访问linux子系统的文件目录：在Windows资源管理器路径栏输入\\\\wsl$便可逐级查看\n关于ubuntu子系统的磁盘空间：https://docs.microsoft.com/zh-cn/windows/wsl/vhd-size\n4、安装conda 因为在安装conda过程中遇到了一个之前在服务器linux中没遇到的问题，特此记录一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ##(1)下载、执行安装脚本 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh bash Miniconda3-latest-Linux-x86_64.sh source ~/.bashrc ##(2)添加镜像源 conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda conda config --set show_channel_urls yes #查看已设置的channels conda config --get ##然后此时直接使用conda安装软件时，会出现类似下面的报错 conda install -c anaconda ipython CondaHTTPError: HTTP 000 CONNECTION FAILED for url https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/linux-64/current_repodata.json Elapsed: -\nAn HTTP error occurred when trying to retrieve this URL. HTTP errors are often intermittent, and a simple retry will get you on your way. \u0026lsquo;https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/linux-64'\n网上搜了一些办法，例如更改镜像源、把https换为http，试了以下都不行。最后重启了一下电脑，就可以了。虽然还不知道为什么原因，但现在ubuntu子系统的conda算是正式安装好了，可以安装软件了。\n1 2 3 4 conda install -c anaconda ipython conda install -c anaconda jupyter pip install numpy pip install pandas ","permalink":"https://lishensuo.github.io/en/posts/program/500window%E7%B3%BB%E7%BB%9F%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85ubuntu%E5%AD%90%E7%B3%BB%E7%BB%9F/","summary":"\u003cblockquote\u003e\n\u003cp\u003e最近有在window系统安装linux子系统(WSL, \u003cem\u003eWindows\u003c/em\u003e Subsystem for \u003cem\u003eLinux\u003c/em\u003e)的需求，搜索发现Microsoft最近(4月8号)提供了更加简便的安装方式。在此记录一下安装过程，的确非常简单。\u003c/p\u003e","title":"window系统快速安装ubuntu子系统"},{"content":" conda 安装 1 2 3 4 conda install -c conda-forge openbabel obabel # Open Babel 3.1.0 -- Nov 2 2021 -- 08:43:45 查看支持的格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 obabel -L # charges # descriptors # fingerprints # forcefields # formats # loaders # ops obabel -L formats | head # acesin -- ACES input format [Write-only] # acesout -- ACES output format [Read-only] # acr -- ACR format [Read-only] # adf -- ADF cartesian input format [Write-only] # adfband -- ADF Band output format [Read-only] # adfdftb -- ADF DFTB output format [Read-only] # adfout -- ADF output format [Read-only] # alc -- Alchemy format # aoforce -- Turbomole AOFORCE output format [Read-only] 格式转换\n例如将mol2转为pdbqt格式\n1 2 3 4 5 6 7 8 ls *mol2 # MOL000006.mol2 MOL000098.mol2 #单个文件格式转换 obabel -imol2 MOL000006.mol2 -opdbqt -O MOL000006.pdbqt #批量转换 ls *mol2 | while read id; do obabel -imol2 $id -opdbqt -O ${id%.*}.pdbqt; done obabel -L formats: All supported format\nabinit \u0026ndash; ABINIT Output Format [Read-only] acesin \u0026ndash; ACES input format [Write-only] acesout \u0026ndash; ACES output format [Read-only] acr \u0026ndash; ACR format [Read-only] adf \u0026ndash; ADF cartesian input format [Write-only] adfband \u0026ndash; ADF Band output format [Read-only] adfdftb \u0026ndash; ADF DFTB output format [Read-only] adfout \u0026ndash; ADF output format [Read-only] alc \u0026ndash; Alchemy format aoforce \u0026ndash; Turbomole AOFORCE output format [Read-only] arc \u0026ndash; Accelrys/MSI Biosym/Insight II CAR format [Read-only] ascii \u0026ndash; ASCII format [Write-only] axsf \u0026ndash; XCrySDen Structure Format [Read-only] bgf \u0026ndash; MSI BGF format box \u0026ndash; Dock 3.5 Box format bs \u0026ndash; Ball and Stick format c09out \u0026ndash; Crystal 09 output format [Read-only] c3d1 \u0026ndash; Chem3D Cartesian 1 format c3d2 \u0026ndash; Chem3D Cartesian 2 format cac \u0026ndash; CAChe MolStruct format [Write-only] caccrt \u0026ndash; Cacao Cartesian format cache \u0026ndash; CAChe MolStruct format [Write-only] cacint \u0026ndash; Cacao Internal format [Write-only] can \u0026ndash; Canonical SMILES format car \u0026ndash; Accelrys/MSI Biosym/Insight II CAR format [Read-only] castep \u0026ndash; CASTEP format [Read-only] ccc \u0026ndash; CCC format [Read-only] cdjson \u0026ndash; ChemDoodle JSON cdx \u0026ndash; ChemDraw binary format [Read-only] cdxml \u0026ndash; ChemDraw CDXML format cht \u0026ndash; Chemtool format [Write-only] cif \u0026ndash; Crystallographic Information File ck \u0026ndash; ChemKin format cml \u0026ndash; Chemical Markup Language cmlr \u0026ndash; CML Reaction format cof \u0026ndash; Culgi object file format com \u0026ndash; Gaussian Input [Write-only] confabreport \u0026ndash; Confab report format [Write-only] CONFIG \u0026ndash; DL-POLY CONFIG CONTCAR \u0026ndash; VASP format CONTFF \u0026ndash; MDFF format copy \u0026ndash; Copy raw text [Write-only] crk2d \u0026ndash; Chemical Resource Kit diagram(2D) crk3d \u0026ndash; Chemical Resource Kit 3D format csr \u0026ndash; Accelrys/MSI Quanta CSR format [Write-only] cssr \u0026ndash; CSD CSSR format [Write-only] ct \u0026ndash; ChemDraw Connection Table format cub \u0026ndash; Gaussian cube format cube \u0026ndash; Gaussian cube format dallog \u0026ndash; DALTON output format [Read-only] dalmol \u0026ndash; DALTON input format dat \u0026ndash; Generic Output file format [Read-only] dmol \u0026ndash; DMol3 coordinates format dx \u0026ndash; OpenDX cube format for APBS ent \u0026ndash; Protein Data Bank format exyz \u0026ndash; Extended XYZ cartesian coordinates format fa \u0026ndash; FASTA format fasta \u0026ndash; FASTA format fch \u0026ndash; Gaussian formatted checkpoint file format [Read-only] fchk \u0026ndash; Gaussian formatted checkpoint file format [Read-only] fck \u0026ndash; Gaussian formatted checkpoint file format [Read-only] feat \u0026ndash; Feature format fh \u0026ndash; Fenske-Hall Z-Matrix format [Write-only] fhiaims \u0026ndash; FHIaims XYZ format fix \u0026ndash; SMILES FIX format [Write-only] fps \u0026ndash; FPS text fingerprint format (Dalke) [Write-only] fpt \u0026ndash; Fingerprint format [Write-only] fract \u0026ndash; Free Form Fractional format fs \u0026ndash; Fastsearch format fsa \u0026ndash; FASTA format g03 \u0026ndash; Gaussian Output [Read-only] g09 \u0026ndash; Gaussian Output [Read-only] g16 \u0026ndash; Gaussian Output [Read-only] g92 \u0026ndash; Gaussian Output [Read-only] g94 \u0026ndash; Gaussian Output [Read-only] g98 \u0026ndash; Gaussian Output [Read-only] gal \u0026ndash; Gaussian Output [Read-only] gam \u0026ndash; GAMESS Output [Read-only] gamess \u0026ndash; GAMESS Output [Read-only] gamin \u0026ndash; GAMESS Input gamout \u0026ndash; GAMESS Output [Read-only] gau \u0026ndash; Gaussian Input [Write-only] gjc \u0026ndash; Gaussian Input [Write-only] gjf \u0026ndash; Gaussian Input [Write-only] got \u0026ndash; GULP format [Read-only] gpr \u0026ndash; Ghemical format gr96 \u0026ndash; GROMOS96 format [Write-only] gro \u0026ndash; GRO format gukin \u0026ndash; GAMESS-UK Input gukout \u0026ndash; GAMESS-UK Output gzmat \u0026ndash; Gaussian Z-Matrix Input hin \u0026ndash; HyperChem HIN format HISTORY \u0026ndash; DL-POLY HISTORY [Read-only] inchi \u0026ndash; InChI format inchikey \u0026ndash; InChIKey [Write-only] inp \u0026ndash; GAMESS Input ins \u0026ndash; ShelX format [Read-only] jin \u0026ndash; Jaguar input format jout \u0026ndash; Jaguar output format [Read-only] k \u0026ndash; Compare molecules using InChI [Write-only] lmpdat \u0026ndash; The LAMMPS data format [Write-only] log \u0026ndash; Generic Output file format [Read-only] lpmd \u0026ndash; LPMD format mcdl \u0026ndash; MCDL format mcif \u0026ndash; Macromolecular Crystallographic Info MDFF \u0026ndash; MDFF format mdl \u0026ndash; MDL MOL format ml2 \u0026ndash; Sybyl Mol2 format mmcif \u0026ndash; Macromolecular Crystallographic Info mmd \u0026ndash; MacroModel format mmod \u0026ndash; MacroModel format mna \u0026ndash; Multilevel Neighborhoods of Atoms (MNA) [Write-only] mol \u0026ndash; MDL MOL format mol2 \u0026ndash; Sybyl Mol2 format mold \u0026ndash; Molden format molden \u0026ndash; Molden format molf \u0026ndash; Molden format molreport \u0026ndash; Open Babel molecule report [Write-only] moo \u0026ndash; MOPAC Output format [Read-only] mop \u0026ndash; MOPAC Cartesian format mopcrt \u0026ndash; MOPAC Cartesian format mopin \u0026ndash; MOPAC Internal mopout \u0026ndash; MOPAC Output format [Read-only] mp \u0026ndash; Molpro input format [Write-only] mpc \u0026ndash; MOPAC Cartesian format mpd \u0026ndash; MolPrint2D format [Write-only] mpo \u0026ndash; Molpro output format [Read-only] mpqc \u0026ndash; MPQC output format [Read-only] mpqcin \u0026ndash; MPQC simplified input format [Write-only] mrv \u0026ndash; Chemical Markup Language msi \u0026ndash; Accelrys/MSI Cerius II MSI format [Read-only] msms \u0026ndash; M.F. Sanner\u0026rsquo;s MSMS input format [Write-only] nul \u0026ndash; Outputs nothing [Write-only] nw \u0026ndash; NWChem input format [Write-only] nwo \u0026ndash; NWChem output format [Read-only] orca \u0026ndash; ORCA output format [Read-only] orcainp \u0026ndash; ORCA input format [Write-only] out \u0026ndash; Generic Output file format [Read-only] outmol \u0026ndash; DMol3 coordinates format output \u0026ndash; Generic Output file format [Read-only] paint \u0026ndash; Painter format [Write-only] pc \u0026ndash; PubChem format [Read-only] pcjson \u0026ndash; PubChem JSON pcm \u0026ndash; PCModel Format pdb \u0026ndash; Protein Data Bank format pdbqt \u0026ndash; AutoDock PDBQT format png \u0026ndash; PNG 2D depiction pointcloud \u0026ndash; Point cloud on VDW surface [Write-only] pos \u0026ndash; POS cartesian coordinates format [Read-only] POSCAR \u0026ndash; VASP format POSFF \u0026ndash; MDFF format pov \u0026ndash; POV-Ray input format [Write-only] pqr \u0026ndash; PQR format pqs \u0026ndash; Parallel Quantum Solutions format prep \u0026ndash; Amber Prep format [Read-only] pwscf \u0026ndash; PWscf format [Read-only] qcin \u0026ndash; Q-Chem input format [Write-only] qcout \u0026ndash; Q-Chem output format [Read-only] report \u0026ndash; Open Babel report format [Write-only] res \u0026ndash; ShelX format [Read-only] rinchi \u0026ndash; RInChI [Write-only] rsmi \u0026ndash; Reaction SMILES format rxn \u0026ndash; MDL RXN format sd \u0026ndash; MDL MOL format sdf \u0026ndash; MDL MOL format siesta \u0026ndash; SIESTA format [Read-only] smi \u0026ndash; SMILES format smiles \u0026ndash; SMILES format smy \u0026ndash; SMILES format using Smiley parser [Read-only] stl \u0026ndash; STL 3D-printing format [Write-only] svg \u0026ndash; SVG 2D depiction [Write-only] sy2 \u0026ndash; Sybyl Mol2 format t41 \u0026ndash; ADF TAPE41 format [Read-only] tdd \u0026ndash; Thermo format text \u0026ndash; Read and write raw text therm \u0026ndash; Thermo format tmol \u0026ndash; TurboMole Coordinate format txt \u0026ndash; Title format txyz \u0026ndash; Tinker XYZ format unixyz \u0026ndash; UniChem XYZ format VASP \u0026ndash; VASP format vmol \u0026ndash; ViewMol format wln \u0026ndash; Wiswesser Line Notation [Read-only] xed \u0026ndash; XED format [Write-only] xml \u0026ndash; General XML format [Read-only] xsf \u0026ndash; XCrySDen Structure Format [Read-only] xtc \u0026ndash; XTC format [Read-only] xyz \u0026ndash; XYZ cartesian coordinates format yob \u0026ndash; YASARA.org YOB format zin \u0026ndash; ZINDO input format [Write-only]\nobabel -L fingerprints\nECFP0 Extended-Connectivity Fingerprints (ECFPs) ECFP10 Extended-Connectivity Fingerprints (ECFPs) ECFP2 Extended-Connectivity Fingerprints (ECFPs) ECFP4 Extended-Connectivity Fingerprints (ECFPs) ECFP6 Extended-Connectivity Fingerprints (ECFPs) ECFP8 Extended-Connectivity Fingerprints (ECFPs) FP2 Indexes linear fragments up to 7 atoms. FP3 SMARTS patterns specified in the file patterns.txt FP4 SMARTS patterns specified in the file SMARTS_InteLigand.txt MACCS SMARTS patterns specified in the file MACCS.txt\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/500obabel%E5%8C%96%E5%AD%A6%E5%B0%8F%E5%88%86%E5%AD%90%E6%A0%BC%E5%BC%8F%E8%BD%AC%E6%8D%A2/","summary":"\u003cul\u003e\n\u003cli\u003econda 安装\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003econda install -c conda-forge openbabel\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eobabel\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Open Babel 3.1.0 -- Nov  2 2021 -- 08:43:45\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e查看支持的格式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-shell\" data-lang=\"shell\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eobabel -L\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# charges\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# descriptors\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fingerprints\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# forcefields\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# formats\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# loaders\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# ops\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eobabel -L formats | head\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# acesin -- ACES input format [Write-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# acesout -- ACES output format [Read-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# acr -- ACR format [Read-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# adf -- ADF cartesian input format [Write-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# adfband -- ADF Band output format [Read-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# adfdftb -- ADF DFTB output format [Read-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# adfout -- ADF output format [Read-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# alc -- Alchemy format\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# aoforce -- Turbomole AOFORCE output format [Read-only]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e格式转换\u003c/p\u003e","title":"obabel化学小分子格式转换"},{"content":"1、rdkit 1 2 3 4 5 6 # conda install -c conda-forge rdkit from rdkit import Chem from rdkit.Chem import MACCSkeys from rdkit import DataStructs from rdkit.Chem import Draw 1.1 指纹编码式 （1）Topological Fingerprints 1 2 3 4 5 6 7 8 m = Chem.MolFromSmiles(\u0026#39;CCOC\u0026#39;) # Chem.MolToSmiles(mol) fp = Chem.RDKFingerprint(m, fpSize=1024) # fpSize 自定义数目,默认为2048 fp.GetNumBits() # 1024 fp.ToBitString() （2）MACCS Fingerprints 长度为167的分子指纹，每一位都表示一种特定的化学结构特征\nhttps://github.com/openbabel/openbabel/blob/master/data/MACCS.txt\n1 2 3 4 5 6 from rdkit.Chem import MACCSkeys fp = MACCSkeys.GenMACCSKeys(m) fp.GetNumBits() # 167 fp.ToBitString() （3）Morgan/ECFP 1 2 3 4 5 from rdkit.Chem import AllChem fp = AllChem.GetMorganFingerprintAsBitVect(m1, radius = 6, nBits = 1024) fp.GetNumBits() # 1024 fp.ToBitString() 1.2 计算相似度 https://www.rdkit.org/docs/GettingStartedInPython.html#fingerprinting-and-molecular-similarity 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 m = Chem.MolFromSmiles(\u0026#39;CCOC\u0026#39;) fp = MACCSkeys.GenMACCSKeys(m) m2 = Chem.MolFromSmiles(\u0026#39;CCO\u0026#39;) fp2 = MACCSkeys.GenMACCSKeys(m2) DataStructs.FingerprintSimilarity(fp, fp2) # 0.5 #默认评价相似度指标为Tanimoto DataStructs.FingerprintSimilarity(fp, fp2, metric=DataStructs.TanimotoSimilarity) #还有其它指标 metic_list = [\u0026#39;DataStructs.TanimotoSimilarity\u0026#39;, \u0026#39;DataStructs.DiceSimilarity\u0026#39;, \u0026#39;DataStructs.CosineSimilarity\u0026#39;, \u0026#39;DataStructs.SokalSimilarity\u0026#39;, \u0026#39;DataStructs.RusselSimilarity\u0026#39;, \u0026#39;DataStructs.KulczynskiSimilarity\u0026#39;, \u0026#39;DataStructs.McConnaugheySimilarity\u0026#39;] for i in metic_list: print(DataStructs.FingerprintSimilarity(fp, fp2, metric=eval(i))) # 0.5 # 0.6666666666666666 # 0.6735753140545634 # 0.3333333333333333 # 0.041916167664670656 # 0.6805555555555556 # 0.3611111111111111 可视化看一下 1 2 imgs = Draw.MolsToGridImage([m,m2],molsPerRow=2,subImgSize=(200,200), legends=[\u0026#34;mol-1\u0026#34;,\u0026#34;mol-2\u0026#34;]) imgs 2、Padel https://github.com/ecrl/padelpy\nhttps://dataprofessor.github.io/ws/bioinformatics/cheminformatics/padelpy/scikit-learn/qsar/qspr/2021/07/06/padelpy.html#Install-padelpy\n1 2 pip install padelpy # pip install pandas 示例小分子SMILES文件：https://raw.githubusercontent.com/dataprofessor/data/master/HCV_NS5B_Curated.csv\n2.1 指纹编码式 （1）12种分子指纹解析文件：https://github.com/dataprofessor/padel/raw/main/fingerprints_xml.zip 1 2 3 4 5 6 7 unzip fingerprints_xml.zip mkdir fingerprints_xml ls *.xml | while read id; do mv $id ./fingerprints_xml/; done ls ./fingerprints_xml # AtomPairs2DFingerprintCount.xml ExtendedFingerprinter.xml KlekotaRothFingerprintCount.xml PubchemFingerprinter.xml # AtomPairs2DFingerprinter.xml Fingerprinter.xml KlekotaRothFingerprinter.xml SubstructureFingerprintCount.xml # EStateFingerprinter.xml GraphOnlyFingerprinter.xml MACCSFingerprinter.xml SubstructureFingerprinter.xml （2）映射指纹解析文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import glob xml_files = glob.glob(\u0026#34;./fingerprints_xml/*.xml\u0026#34;) xml_files.sort() xml_files FP_list = [\u0026#39;AtomPairs2DCount\u0026#39;, \u0026#39;AtomPairs2D\u0026#39;, \u0026#39;EState\u0026#39;, \u0026#39;CDKextended\u0026#39;, \u0026#39;CDK\u0026#39;, \u0026#39;CDKgraphonly\u0026#39;, \u0026#39;KlekotaRothCount\u0026#39;, \u0026#39;KlekotaRoth\u0026#39;, \u0026#39;MACCS\u0026#39;, \u0026#39;PubChem\u0026#39;, \u0026#39;SubstructureCount\u0026#39;, \u0026#39;Substructure\u0026#39;] fp = dict(zip(FP_list, xml_files)) fp （3）目标小分子smiles文件 1 2 3 4 df = pd.read_csv(\u0026#39;./HCV_NS5B_Curated.csv\u0026#39;) df[[\u0026#39;CANONICAL_SMILES\u0026#39;,\u0026#39;CMPD_CHEMBLID\u0026#39;]].head() # 保存文件 df2.head(50).to_csv(\u0026#39;molecule.smi\u0026#39;, sep=\u0026#39;\\t\u0026#39;, index=False, header=False) （4）进行目标格式的指纹转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from padelpy import padeldescriptor # 假设需要转换为Substructure指纹 fingerprint = \u0026#39;Substructure\u0026#39; fingerprint_output_file = \u0026#39;\u0026#39;.join([fingerprint,\u0026#39;.csv\u0026#39;]) #Substructure.csv 结果文件名 fingerprint_descriptortypes = fp[fingerprint] #解析文件地址 padeldescriptor(mol_dir=\u0026#39;molecule.smi\u0026#39;, d_file=fingerprint_output_file, #\u0026#39;Substructure.csv\u0026#39; #descriptortypes=\u0026#39;SubstructureFingerprint.xml\u0026#39;, descriptortypes= fingerprint_descriptortypes, detectaromaticity=True, standardizenitro=True, standardizetautomers=True, threads=2, removesalt=True, log=True, fingerprints=True) descriptors = pd.read_csv(fingerprint_output_file) descriptors 2.2 分子描述符 可根据小分子的SMILES式计算出1875种分子描述符\n1 2 3 4 5 6 df = pd.read_csv(\u0026#39;./HCV_NS5B_Curated.csv\u0026#39;) smi = list(df[\u0026#34;CANONICAL_SMILES\u0026#34;][0:50]) descriptors = from_smiles(smi) descriptors_df = pd.DataFrame(descriptors) descriptors_df.shape # (50, 1875) 3、mordred https://github.com/mordred-descriptor/mordred 该工具用于生成化合物的描述符，分成2D（1613个）与3D（213个）两类，共1826个 1 2 3 4 5 6 7 8 9 10 # 安装过程，由于版本冲突原因费了一番周折 # (1) python 3.9的环境下 conda install numpy=1.20 networkx=2.3 conda install -c rdkit -c mordred-descriptor mordred # https://github.com/mordred-descriptor/mordred/issues/84 # (2) 修改DetourMatrix.py模块文件的源代码 # for bcc in networkx.biconnected_component_subgraphs(self.G, False): # to: # for bcc in (self.G.subgraph(c) for c in networkx.biconnected_components(self.G)): 参考github教程，有shell端与python端两种使用方式，如下介绍第一种 1 2 3 # 准备好仅包含一列smiles式的文本文件 python -m mordred tmp/canocical_1_col.smi -p 1 --3D \\ -o ./mordred_descriptor1826.csv 4、ChemDes ChemDes网站是由中南大学药学院开发的支持在线计算多种化合物指纹编码式与描述符的网站\nhttp://www.scbdd.com/chemdes/ ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/501%E5%8C%96%E5%90%88%E7%89%A9%E6%8C%87%E7%BA%B9%E4%B8%8E%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%94%9F%E6%88%90%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7/","summary":"\u003ch1 id=\"1rdkit\"\u003e1、rdkit\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# conda install -c conda-forge rdkit\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e rdkit \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e Chem\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e rdkit.Chem \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e MACCSkeys\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e rdkit \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e DataStructs\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e rdkit.Chem \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e Draw\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"11-指纹编码式\"\u003e1.1 指纹编码式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e（1）Topological Fingerprints\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003em = Chem.MolFromSmiles(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;CCOC\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Chem.MolToSmiles(mol)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efp = Chem.RDKFingerprint(m, fpSize=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1024\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fpSize 自定义数目,默认为2048\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efp.GetNumBits()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1024\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efp.ToBitString()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220618214401457.png\" alt=\"image-20220618214401457\"  /\u003e\r\n\u003c/p\u003e","title":"化合物指纹与描述符生成系列工具"},{"content":"docker介绍 docker可以理解为轻量级的虚拟机，创建一个独立的环境，应用于特定的分析流程。 docker的镜像是一个定制的环境模板，而容器则是镜像实例化而得到的，可供实际分析的“虚拟机” 可以自己编辑dockfile创建一个镜像，或者下载安装别人写好的镜像(Docker Hub)。 docker的安装、使用需要sudo权限；但后续使用可通过下述命令使普通用户可以使用docker命令\n1 2 3 4 sudo groupadd docker #添加docker用户组 sudo gpasswd -a $USER docker #将登陆用户加入到docker用户组中 newgrp docker #更新用户组 docker ps #测试docker命令是否可以使用sudo正常使用 podman是类似docker，但是安装后的使用不需要root权限，也可以通过conda安装。使用方式只需要将下面的docker换为podman即可。\n1 conda install -c conda-forge podman 镜像命令 1 2 3 4 5 6 7 8 9 10 11 12 # https://registry.hub.docker.com/ ##(1) search搜索镜像 docker search ubuntu ##(2) pull下载镜像 docker pull ubuntu #默认最新版本 ##(3) images查看已安装的镜像 docker images ##(4) rmi删除镜像 docker rmi ubuntu 容器命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 ##(1) run创建容器示例 docker run -it --name \u0026#34;ubuntu001\u0026#34; ubuntu /bin/bash ## -it 交互模式运行容器 ## -d 后台运行容器 ## --name 自定义容器实例名 ## -v 关联宿主机目录与容器虚拟机目录() docker run -it \\ -v $(pwd)/v01:/mydat1 \\ -v $(pwd)/v02:/mydat2 \\ -v $(pwd)/v03:/mydat3 \\ ubuntu /bin/bash ## -p 指定端口 宿主机端口:容器端口 #jupyter/datascience-notebook只开放8888端口 docker pull jupyter/datascience-notebook docker run -d -p 8080:8888 jupyter/datascience-notebook ##(2) 退出交互模式容器 # exit命令 或者 CTRL+D 退出，并停止容器 # CTRL+P+Q 退出，但不停止容器（把前台容器放到后台） ##(3) ps查看正在运行的容器 docker ps #当前正在运行的容器，第一列为容器ID docker ps -a #所有容器包括正在运行的，历史运行过的 docker ps -aq ##(4) 停止/启动容器 docker stop 7d97d76e6f04 docker start 7d97d76e6f04 ##(5) 进入被放到后台的容器 # attach 进入容器后，exit命令会停止容器 docker attach af55cfa46000 # exec 相当于容器的新进程，不影响正在运行的进程 docker exec -it af55cfa46000 /bin/bash ##(6) 宿主机与容器的文件复制 #将容器内的文件复制到本地 docker cp 68a6b45156a4:/home/jovyan/yyyy.txt . #将本地的文件复制到容器内 docker cp ./file 68a6b45156a4:/home/jovyan/ ##(7) 删除容器 #删除容器 docker rm 7d97d76e6f04 #删除所有容器 docker rm $(docker ps -aq) #强制删除正在运行的容器 docker rm -f e91439d11fa6 ##(8) 查看容器日志 docker logs 7d97d76e6f04 docker logs -f 7d97d76e6f04 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 su #当前工作目录切换为root #切换到root权限及root目录 #查看所有用户 cat /etc/passwd #新建用户 useradd -s /bin/bash -m xiaobei #修改用户密码 passwd xiaobei cat /etc/passwd #切换用户 su - xiaobei #删除用户 userdel -r xiaobei ","permalink":"https://lishensuo.github.io/en/posts/program/501docker%E5%88%9D%E5%AD%A6/","summary":"\u003ch1 id=\"docker介绍\"\u003edocker介绍\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003edocker可以理解为轻量级的虚拟机，创建一个独立的环境，应用于特定的分析流程。\u003c/li\u003e\n\u003cli\u003edocker的\u003cstrong\u003e镜像\u003c/strong\u003e是一个定制的环境模板，而\u003cstrong\u003e容器\u003c/strong\u003e则是镜像实例化而得到的，可供实际分析的“虚拟机”\u003c/li\u003e\n\u003cli\u003e可以自己编辑dockfile创建一个镜像，或者下载安装别人写好的镜像(Docker Hub)。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://docs.docker.com/engine/images/architecture.svg\" alt=\"Docker overview | Docker Documentation\" style=\"zoom:50%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003edocker的安装、使用需要sudo权限；但后续使用可通过下述命令使普通用户可以使用docker命令\u003c/p\u003e","title":"docker初学"},{"content":"一、GDSC GDSC : https://www.cancerrxgene.org/，已上传至阿里云盘\n1、原始数据整理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 ## 预处理 # library(tidyverse) # #RAW 文件夹 # gdsc_drug = read.csv(\u0026#34;GDSC_drug.csv\u0026#34;) # colnames(gdsc_drug) = gsub(\u0026#34;[.]\u0026#34;, \u0026#34;_\u0026#34;, colnames(gdsc_drug)) # # gdsc_cl = read.csv(\u0026#34;GDSC_cellline.csv\u0026#34;) # colnames(gdsc_cl) = gsub(\u0026#34;[.]\u0026#34;, \u0026#34;_\u0026#34;, colnames(gdsc_cl)) # gdsc_cl = gdsc_cl %\u0026gt;% # reshape2::dcast(Cell_line_Name+Model_ID+COSMIC_ID+TCGA_Classfication+Tissue+Tissue_sub_type~Datasets, # value.var = \u0026#34;number_of_drugs\u0026#34;) # # GDSC1 = readxl::read_excel(\u0026#34;GDSC1_fitted_dose_response_25Feb20.xlsx\u0026#34;) # GDSC1 = GDSC1[,c(-4, -6)] # GDSC1 = GDSC1[,c(-6, -8, -9)] # GDSC1 = GDSC1 %\u0026gt;% # dplyr::select(DATASET, DRUG_NAME, CELL_LINE_NAME, TCGA_DESC, LN_IC50, AUC, RMSE, Z_SCORE, everything()) # GDSC1 = GDSC1 %\u0026gt;% as.data.frame() # head(GDSC1) # # GDSC2 = readxl::read_excel(\u0026#34;GDSC2_fitted_dose_response_25Feb20.xlsx\u0026#34;) # GDSC2 = GDSC2[,c(-4, -6)] # GDSC2 = GDSC2[,c(-6, -8, -9)] # GDSC2 = GDSC2 %\u0026gt;% # dplyr::select(DATASET, DRUG_NAME, CELL_LINE_NAME, TCGA_DESC, LN_IC50, AUC, RMSE, Z_SCORE, everything()) # GDSC2 = GDSC2 %\u0026gt;% as.data.frame() # head(GDSC2) # # GDSC_merge = rbind(GDSC1, GDSC2) # head(GDSC_merge) # # head(gdsc_cl) 2、敏感度实验结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 GDSC_res = read.csv(\u0026#34;GDSC/GDSC_result.csv\u0026#34;) # DATASET DRUG_NAME CELL_LINE_NAME TCGA_DESC LN_IC50 AUC RMSE Z_SCORE # 1 GDSC1 Erlotinib MC-CAR MM 2.395685 0.982114 0.022521 -0.189576 # 2 GDSC1 Erlotinib ES3 UNCLASSIFIED 3.140923 0.984816 0.031840 0.508635 # 3 GDSC1 Erlotinib ES5 UNCLASSIFIED 3.968757 0.985693 0.026052 1.284229 # 4 GDSC1 Erlotinib ES7 UNCLASSIFIED 2.692768 0.972699 0.110056 0.088760 # 5 GDSC1 Erlotinib EW-11 UNCLASSIFIED 2.478678 0.944462 0.087011 -0.111820 # 6 GDSC1 Erlotinib SK-ES-1 UNCLASSIFIED 2.034050 0.950763 0.016288 -0.528390 ## 总共药物数 GDSC_res %\u0026gt;% dplyr::distinct(DRUG_NAME) %\u0026gt;% dim() # [1] 449 1 ## 每期药物数 GDSC_res %\u0026gt;% dplyr::distinct(DATASET, DRUG_NAME) %\u0026gt;% dplyr::count(DATASET, name = \u0026#34;Drugs\u0026#34;) # DATASET Drugs # 1 GDSC1 345 # 2 GDSC2 192 ## 每个细胞系的实验数 GDSC_res %\u0026gt;% dplyr::count(DATASET, CELL_LINE_NAME, name = \u0026#34;assays\u0026#34;) %\u0026gt;% reshape2::dcast(CELL_LINE_NAME ~ DATASET, value.var = \u0026#34;assays\u0026#34;) %\u0026gt;% dplyr::arrange(desc(GDSC1)) %\u0026gt;% head() # CELL_LINE_NAME GDSC1 GDSC2 # 1 A253 367 179 # 2 AMO-1 367 178 # 3 KCL-22 367 178 # 4 KNS-42 367 NA summary(GDSC_res$LN_IC50) # Min. 1st Qu. Median Mean 3rd Qu. Max. # -10.5793 0.8435 2.6228 2.2052 4.1216 12.3591 summary(GDSC_res$AUC) # Min. 1st Qu. Median Mean 3rd Qu. Max. # 0.00479 0.78839 0.92309 0.84467 0.97306 0.99984 cor(GDSC_res$LN_IC50, GDSC_res$AUC) # [1] 0.7534196 关于IC50与AUC：https://blog.csdn.net/linkequa/article/details/88221975\n理论上IC50值或者AUC值越小，表明细胞系对于药物越敏感。\n3、药物与细胞系信息 1 2 3 4 5 6 7 8 9 10 11 12 13 GDSC_drug = read.csv(\u0026#34;GDSC/GDSC_drug.csv\u0026#34;) head(GDSC_drug) # Drug_Id Name Synonyms Targets Target_pathway PubCHEM Datasets number_of_cell_lines Screening_site # 1 1242 (5Z)-7-Oxozeaenol 5Z-7-Oxozeaenol, LL-Z1640-2 TAK1 Other, kinases 9863776 GDSC1 899 SANGER # 2 1824 123138 Unclassified GDSC2 717 SANGER # 3 1820 123829 Unclassified GDSC2 717 SANGER GDSC_cl = read.csv(\u0026#34;GDSC/GDSC_cl.csv\u0026#34;) head(GDSC_cl) # Cell_line_Name Model_ID COSMIC_ID TCGA_Classfication Tissue Tissue_sub_type GDSC1 GDSC2 # 1 22RV1 SIDM00499 924100 PRAD urogenital_system prostate 353 282 # 2 23132-87 SIDM00980 910924 STAD digestive_system stomach 344 281 # 3 42-MG-BA SIDM00982 687561 GBM nervous_system glioma 345 281 https://cellmodelpassports.sanger.ac.uk/downloads\n在上面网址可下载肿瘤细胞系的多种组学数据，包括转录组、基因组等，有需要时再整理。\n二、CTRL https://ocg.cancer.gov/programs/ctd2/data-portal/ ，已上传至阿里云盘\n1、原始数据处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # ## ctrlv1 # ctrlv1_res = data.table::fread(\u0026#34;CTRPv1.0_2013_pub_Cell_154_1151/v10.D3.area_under_conc_curve.txt\u0026#34;) # # ctrlv1_drug = data.table::fread(\u0026#34;CTRPv1.0_2013_pub_Cell_154_1151/v10.M1.informer_set.txt\u0026#34;) # # ctrlv1_cl = data.table::fread(\u0026#34;CTRPv1.0_2013_pub_Cell_154_1151/v10.M2.cell_line_info.txt\u0026#34;) # # write.csv(ctrlv1_res, file = \u0026#34;CTRL/ctrl_v1_res.csv\u0026#34;, row.names = F) # write.csv(ctrlv1_drug, file = \u0026#34;CTRL/ctrl_v1_drug.csv\u0026#34;, row.names = F) # write.csv(ctrlv1_cl, file = \u0026#34;CTRL/ctrl_v1_cl.csv\u0026#34;, row.names = F) # # ## ctrlv2 # ctrlv2_res = data.table::fread(\u0026#34;CTRPv2.0_2015_ctd2_ExpandedDataset/v20.data.curves_post_qc.txt\u0026#34;) # ctrlv2_res = ctrlv2_res %\u0026gt;% # dplyr::left_join(exp_id[,c(\u0026#34;experiment_id\u0026#34;,\u0026#34;master_ccl_id\u0026#34;)]) %\u0026gt;% # dplyr::select(master_ccl_id, master_cpd_id, area_under_curve, apparent_ec50_umol) %\u0026gt;% # dplyr::group_by(master_ccl_id, master_cpd_id) %\u0026gt;% # dplyr::summarise(area_under_curve = mean(area_under_curve), # apparent_ec50_umol = mean(apparent_ec50_umol)) %\u0026gt;% as.data.frame() # # # ctrlv2_drug = data.table::fread(\u0026#34;CTRPv2.0_2015_ctd2_ExpandedDataset/v20.meta.per_compound.txt\u0026#34;) # # ctrlv2_cl = data.table::fread(\u0026#34;CTRPv2.0_2015_ctd2_ExpandedDataset/v20.meta.per_cell_line.txt\u0026#34;) # # ctrlv2_res2 = ctrlv2_res %\u0026gt;% # dplyr::left_join(ctrlv2_drug[,c(\u0026#34;master_cpd_id\u0026#34;,\u0026#34;cpd_name\u0026#34;)]) %\u0026gt;% # dplyr::left_join(ctrlv2_cl[,c(\u0026#34;master_ccl_id\u0026#34;,\u0026#34;ccl_name\u0026#34;)]) %\u0026gt;% # dplyr::select(cpd_name, ccl_name, area_under_curve, apparent_ec50_umol) # # write.csv(ctrlv2_res2, file = \u0026#34;CTRL/ctrl_v2_res.csv\u0026#34;, row.names = F) # write.csv(ctrlv2_drug, file = \u0026#34;CTRL/ctrl_v2_drug.csv\u0026#34;, row.names = F) # write.csv(ctrlv2_cl, file = \u0026#34;CTRL/ctrl_v2_cl.csv\u0026#34;, row.names = F) v10.D3.area_under_conc_curve.txt：AUCs \u0026lt; 3.5 are considered sensitive to compound treatment, AUCs \u0026gt; 5.5 are considered non-responsive to compound treatment\n即AUC值越小，表示细胞系对药物越敏感\nIC50 (half maximal inhibitory concentration) EC50 (concentration for 50% of maximal effect,EC50) 2、CTRL v1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ### 敏感度实验结果 ctrl1_res = read.csv(\u0026#34;CTRL/ctrl_v1_res.csv\u0026#34;) head(ctrl1_res) # ccl_name cpd_name area_under_curve # 1 U2OS zebularine 6.0416 # 2 U2OS maraviroc 6.8981 # 3 U2OS DL-TBOA 6.8593 length(unique(ctrl1_res$cpd_name)) # [1] 354 length(unique(ctrl1_res$ccl_name)) # [1] 242 summary(ctrl1_res$area_under_curve) # Min. 1st Qu. Median Mean 3rd Qu. Max. # 0.04763 4.27830 5.81120 5.33269 6.72490 15.71900 ### 药物/细胞系信息 ctrl1_drug = read.csv(\u0026#34;CTRL/ctrl_v1_drug.csv\u0026#34;) t(ctrl1_drug[1,]) # 1 # cpd_name \u0026#34;(-)-gallocatechin-3-monogallate\u0026#34; # cpd_synonym \u0026#34;gallocatechin gallate;L-GCG;GCG\u0026#34; # cpd_status \u0026#34;probe\u0026#34; # target_or_activity_of_compound \u0026#34;natural product\u0026#34; # gene_symbol_of_protein_target \u0026#34;\u0026#34; # top_test_conc_umol \u0026#34;296\u0026#34; # percent_cpd_purity NA # cpd_smiles \u0026#34;Oc1cc(O)c2C[C@@H](OC(=O)c3cc(O)c(O)c(O)c3)[C@@H](Oc2c1)c4cc(O)c(O)c(O)c4\u0026#34; # pubchem_cid \u0026#34;199472\u0026#34; # broad_cpd_id \u0026#34;BRD-K19216856\u0026#34; # master_cpd_id \u0026#34;411730\u0026#34; ctrl2_drug = read.csv(\u0026#34;CTRL/ctrl_v1_cl.csv\u0026#34;) # master_ccl_id ccl_name ccl_availability ccle_primary_site ccle_primary_hist ccle_hist_subtype_1 # 1 1 697 ccle;public haematopoietic_and_lymphoid_tissue lymphoid_neoplasm acute_lymphoblastic_B_cell_leukaemia # 2 3 5637 ccle;public urinary_tract carcinoma # 3 4 2313287 ccle;public stomach carcinoma adenocarcinoma # 4 5 1321N1 ccle central_nervous_system glioma astrocytoma 3、CTRL v2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 ### 敏感度实验结果 ctrl2_res = read.csv(\u0026#34;CTRL/ctrl_v2_res.csv\u0026#34;) head(ctrl2_res) # cpd_name ccl_name area_under_curve apparent_ec50_umol # 1 BRD4132 697 11.128 10.060 # 2 BRD6340 697 12.328 18.610 # 3 ML006 697 12.305 32.730 # 4 Bax channel blocker 697 13.085 8.402 length(unique(ctrl2_res$cpd_name)) # [1] 545 length(unique(ctrl2_res$ccl_name)) # [1] 887 summary(ctrl2_res$area_under_curve) # Min. 1st Qu. Median Mean 3rd Qu. Max. # 0.0691 11.6080 13.4410 12.7647 14.5820 29.3500 ### 药物/细胞系信息 ctrl2_drug = read.csv(\u0026#34;CTRL/ctrl_v2_drug.csv\u0026#34;) t(ctrl2_drug[1,]) # 1 # master_cpd_id \u0026#34;1788\u0026#34; # cpd_name \u0026#34;CIL55\u0026#34; # broad_cpd_id \u0026#34;BRD-K46556387\u0026#34; # top_test_conc_umol \u0026#34;10\u0026#34; # cpd_status \u0026#34;probe\u0026#34; # inclusion_rationale \u0026#34;pilot-set\u0026#34; # gene_symbol_of_protein_target \u0026#34;\u0026#34; # target_or_activity_of_compound \u0026#34;screening hit\u0026#34; # source_name \u0026#34;Columbia University\u0026#34; # source_catalog_id \u0026#34;\u0026#34; # cpd_smiles \u0026#34;CN(C)CCNC(=O)c1cc2CSc3cc(Cl)ccc3-c2s1\u0026#34; ctrl2_drug = read.csv(\u0026#34;CTRL/ctrl_v2_cl.csv\u0026#34;) head(ctrl2_drug) # master_ccl_id ccl_name ccl_availability ccle_primary_site ccle_primary_hist ccle_hist_subtype_1 # 1 1 697 ccle;public haematopoietic_and_lymphoid_tissue lymphoid_neoplasm acute_lymphoblastic_B_cell_leukaemia # 2 3 5637 ccle;public urinary_tract carcinoma # 3 4 2313287 ccle;public stomach carcinoma adenocarcinoma # 4 5 1321N1 ccle central_nervous_system glioma astrocytoma ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/502%E6%95%B0%E6%8D%AE%E5%BA%93--%E5%8C%96%E5%90%88%E7%89%A9%E6%95%8F%E6%84%9F%E5%BA%A6gdsc_ctrl/","summary":"\u003ch2 id=\"一gdsc\"\u003e一、GDSC\u003c/h2\u003e\n\u003cp\u003eGDSC : \u003ca href=\"https://www.cancerrxgene.org/\"\u003ehttps://www.cancerrxgene.org/\u003c/a\u003e，已上传至阿里云盘\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20221009090318241.png\" alt=\"image-20221009090318241\"  /\u003e\r\n\u003c/p\u003e\n\u003ch3 id=\"1原始数据整理\"\u003e1、原始数据整理\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 预处理\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# library(tidyverse)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# #RAW 文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# gdsc_drug = read.csv(\u0026#34;GDSC_drug.csv\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# colnames(gdsc_drug) = gsub(\u0026#34;[.]\u0026#34;, \u0026#34;_\u0026#34;, colnames(gdsc_drug))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# gdsc_cl = read.csv(\u0026#34;GDSC_cellline.csv\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# colnames(gdsc_cl) = gsub(\u0026#34;[.]\u0026#34;, \u0026#34;_\u0026#34;, colnames(gdsc_cl))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# gdsc_cl = gdsc_cl %\u0026gt;% \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   reshape2::dcast(Cell_line_Name+Model_ID+COSMIC_ID+TCGA_Classfication+Tissue+Tissue_sub_type~Datasets,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                   value.var = \u0026#34;number_of_drugs\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC1 = readxl::read_excel(\u0026#34;GDSC1_fitted_dose_response_25Feb20.xlsx\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC1 = GDSC1[,c(-4, -6)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC1 = GDSC1[,c(-6, -8, -9)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC1 = GDSC1 %\u0026gt;% \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   dplyr::select(DATASET, DRUG_NAME, CELL_LINE_NAME, TCGA_DESC, LN_IC50, AUC, RMSE, Z_SCORE, everything())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC1 = GDSC1 %\u0026gt;% as.data.frame()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# head(GDSC1)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC2 = readxl::read_excel(\u0026#34;GDSC2_fitted_dose_response_25Feb20.xlsx\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC2 = GDSC2[,c(-4, -6)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC2 = GDSC2[,c(-6, -8, -9)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC2 = GDSC2 %\u0026gt;% \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   dplyr::select(DATASET, DRUG_NAME, CELL_LINE_NAME, TCGA_DESC, LN_IC50, AUC, RMSE, Z_SCORE, everything())\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC2 = GDSC2 %\u0026gt;% as.data.frame()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# head(GDSC2)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# GDSC_merge = rbind(GDSC1, GDSC2)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# head(GDSC_merge)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# head(gdsc_cl)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2敏感度实验结果\"\u003e2、敏感度实验结果\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGDSC_res = read.csv(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;GDSC/GDSC_result.csv\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   DATASET DRUG_NAME CELL_LINE_NAME    TCGA_DESC  LN_IC50      AUC     RMSE   Z_SCORE\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1   GDSC1 Erlotinib         MC-CAR           MM 2.395685 0.982114 0.022521 -0.189576\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2   GDSC1 Erlotinib            ES3 UNCLASSIFIED 3.140923 0.984816 0.031840  0.508635\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3   GDSC1 Erlotinib            ES5 UNCLASSIFIED 3.968757 0.985693 0.026052  1.284229\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4   GDSC1 Erlotinib            ES7 UNCLASSIFIED 2.692768 0.972699 0.110056  0.088760\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 5   GDSC1 Erlotinib          EW-11 UNCLASSIFIED 2.478678 0.944462 0.087011 -0.111820\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 6   GDSC1 Erlotinib        SK-ES-1 UNCLASSIFIED 2.034050 0.950763 0.016288 -0.528390\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 总共药物数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGDSC_res %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::distinct(DRUG_NAME) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dim()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 449   1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 每期药物数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGDSC_res %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::distinct(DATASET, DRUG_NAME) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::count(DATASET, name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Drugs\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   DATASET Drugs\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1   GDSC1   345\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2   GDSC2   192\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 每个细胞系的实验数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eGDSC_res %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::count(DATASET, CELL_LINE_NAME, name = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;assays\u0026#34;\u003c/span\u003e) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  reshape2::dcast(CELL_LINE_NAME ~ DATASET, value.var = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;assays\u0026#34;\u003c/span\u003e) %\u0026gt;% \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  dplyr::arrange(desc(GDSC1)) %\u0026gt;% head()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#   CELL_LINE_NAME GDSC1 GDSC2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1           A253   367   179\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2          AMO-1   367   178\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3         KCL-22   367   178\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 4         KNS-42   367    NA\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esummary(GDSC_res$LN_IC50)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     Min.  1st Qu.   Median     Mean  3rd Qu.     Max. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# -10.5793   0.8435   2.6228   2.2052   4.1216  12.3591\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esummary(GDSC_res$AUC)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 0.00479 0.78839 0.92309 0.84467 0.97306 0.99984 \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecor(GDSC_res$LN_IC50, GDSC_res$AUC)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [1] 0.7534196\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e关于IC50与AUC：https://blog.csdn.net/linkequa/article/details/88221975\u003c/p\u003e","title":"化合物敏感度数据库GDSC_CTRL"},{"content":" 之前就了解过Jupyter notebook，是调试python代码的简洁、高效软件。现在大致整理下目前学到的在Linux系统里部署Jupyter环境的小流程，以供之后自己学习python及相关分析时使用。\n1、安装Jupyter 这里假设已经对conda环境有一定了解，并已在linux里安装； 官方安装教程 https://jupyter.org/install，推荐使用conda安装 1 conda install -c conda-forge notebook tips：先暂时在base环境里安装，之后会介绍如何通用于其它环境。\n查看版本 1 2 jupyter notebook --version # 6.4.5 调用jupyter(不推荐这么使用) 1 # jupyter notebook 2、本地端口登录 如上虽然可以直接在Linux默认的浏览器里调用Jupyter页面，但之前发现不仅启动慢，而且使用过程也很不流畅；应该是Linux调用默认浏览器的原因。可以通过如下方式，在本地电脑端口使用\n2.1 生成jupyter notebook 配置文件 1 jupyter notebook --generate-config 2.2 设置登录密码 需要两次确认 1 jupyter notebook password 如上就会在.jupyter隐藏文件夹下生成两个文件：jupyter_notebook_config.json与jupyter_notebook_config.py\n2.3 在Linux端启动jupyter 需要设置两个参数：指定端口号，不在Linux浏览器里启动\n1 jupyter notebook --port=8889 --no-browser 2.4 在本地电脑端设置链接端口 1 2 3 # Win + r 进入本地电脑命令行模式 ssh -L localhost:8889:localhost:8889 user_name@xxx.xxx.xxx.xxx -p 22 # 根据提示输入用户的密码即可进行关联 2.5 在本地任意浏览器登录 在浏览器网址栏输入：localhost:8889；在根据提示输入之前设置的密码即可在本地电脑端登入Linux系统里的Jupyter notebook软件，流畅得使用了。 参考教程 （1）远程访问服务器Jupyter Notebook的两种方法 https://www.jianshu.com/p/8fc3cd032d3c （2）关于Jupyter notebook远程连接服务器踩坑记 https://zhuanlan.zhihu.com/p/161221247\n3、Jupyter 基本使用 如下图所示 Jupyter是由一个个单元格Cell组成，可以是Python的代码块，也可以是支持Rmarkown模式的注释文档；默认为代码块，可通过功能栏的下拉列表进行切换。\n很多快捷键的用法，例如：\nEsc + H 快捷键大全 Esc + M 将单元格切换到markdown模式 Esc + Y 将单元格切换为代码code模式 Shift + Enter 运行当前单元格的内容，并选中下一个单元格的内容； Ctrl + Enter 运行当前单元格的内容，光标保留在当前单元格。 最后需要注意的是Jupyter保存的文件格式后缀为：.ipynb（即ipython notebook缩写） Jupyter使用教程：https://cloud.tencent.com/developer/article/1091924\n4、切换conda环境 在第一步里有介绍是在base环境中安装的Jupyter。通过安装nb_conda_kernels，可以实现建立基于某一特定conda环境的python脚本(前提是该conda环境已经安装好jupyter) 1 2 # 在base环境安装 conda install nb_conda_kernels 之后在，新建文件时，可以选择在基于哪一个conda环境下创建，非常方便 5、jupyter插件之jupyter-contrib-nbextensions jupyter-contrib-nbextensions提供了很多jupyter的插件，其中有些还是非常实用的。\n5.1 安装 jupyter_contrib_nbextensions 1 conda install -c conda-forge jupyter_contrib_nbextensions 5.2 配置 nbextension 1 jupyter contrib nbextension install --user 5.3 启用插件 如上述第2步的方法，在本地端口登陆Linux里的Jupyter Edit → 选择新增的Nbextensions，勾选想启用的插件功能即可。 我这里主要设置了三个插件 （1）Table of Contents(2)：根据rmarkdown注释的标题文档，在右边显示实时的目录信息； （2）Codefolding：可将python代码块里的函数、循环语句等折叠起来； （3）Variable Inspector：查看当前Python环境里所定义的变量信息。 参考教程 （1）Jupyter Notebook——如何显示目录的导航栏（安装 Jupyter Notebook extension） https://www.jianshu.com/p/61562bc5988b （2）工具篇-Jupyter Notebook效率提升小技巧 https://zhuanlan.zhihu.com/p/68328243 （3）真香！Jupyter Notebook 五大效率插件！ https://zhuanlan.zhihu.com/p/434052042\n报错记录 （1）20220329 最近遇到一个问题，遇到的问题是在localhost无法打开ipynb文件，在linux端显示的报错如下：Permission denied: '/usr/local/share/jupyter/conf.json' 在localhost端则显示的500:internal server error。 后来经查询一番https://discourse.jupyter.org/t/500-internal-server-error-while-trying-to-open-python-notebook-on-jupyterhub/9738发现是nbconvert软件的版本的问题，安装指定的5.6.1版本后问题就解决了。 1 conda install nbconvent=5.6.1 ","permalink":"https://lishensuo.github.io/en/posts/program/502%E5%9C%A8linux%E7%B3%BB%E7%BB%9F%E9%87%8C%E9%83%A8%E7%BD%B2jupyter%E7%8E%AF%E5%A2%83/","summary":"\u003cblockquote\u003e\n\u003cp\u003e之前就了解过Jupyter notebook，是调试python代码的简洁、高效软件。现在大致整理下目前学到的在Linux系统里部署Jupyter环境的小流程，以供之后自己学习python及相关分析时使用。\u003c/p\u003e","title":"在Linux系统里部署Jupyter环境"},{"content":" ChemmineR是使用R语言实现化合物基础操作的工具包，现根据其官方文档学习其主要用法如下：\nhttps://www.bioconductor.org/packages/release/bioc/vignettes/ChemmineR/inst/doc/ChemmineR.html 1 2 3 4 5 6 if (!requireNamespace(\u0026#34;BiocManager\u0026#34;, quietly=TRUE)) install.packages(\u0026#34;BiocManager\u0026#34;) BiocManager::install(\u0026#34;ChemmineR\u0026#34;) library(\u0026#34;ChemmineR\u0026#34;) # library(\u0026#34;ChemmineOB\u0026#34;) 1. SDFset格式 ChemmineR基础操作是围绕SDFset对象展开的，其表示多个SDF格式的化合物集合 1 2 3 4 5 6 7 8 9 data(sdfsample) sdfset = sdfsample # valid \u0026lt;- validSDF(sdfset) # sdfset \u0026lt;- sdfset[valid] class(sdfset) # SDFset length(sdfset) # 100 c(sdfset[1:4], sdfset[5:8]) # 合并 sdfset[1:4] # 子集 每个SDFset集合是由单个SDF对象组成的，主要由4部分构成 \u0026lt;\u0026lt;header\u0026raquo; : 化合物id等基本信息 \u0026lt;\u0026lt;atomblock\u0026raquo; : 原子信息，\u0026lt;\u0026lt;bondblock\u0026raquo;: 键信息 \u0026lt;\u0026lt;datablock\u0026raquo; : 化合物的属性/其它注释信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 sdfset[[1]] as(sdfset[[1]], \u0026#34;list\u0026#34;) ## ID cid(sdfset[1:2]) # slot ID sdfid(sdfset[1:2]) # header ID cid(sdfset) = sdfid(sdfset) ## Component header(sdfset[[1]]) # character atomblock(sdfset[[1]]) # matrix bondblock(sdfset[[1]]) # matrix datablock(sdfset[[1]]) # character blockmatrix = datablock2ma(datablock(sdfset[1:2])) 补充：ChemmineR提供一些函数可计算化合物的基本属性信息，例如分子量等。此外ChemmineOB也可以实现类似功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 ## ChemmineR propma \u0026lt;- data.frame(MF=MF(sdfset, addH=FALSE), MW=MW(sdfset, addH=FALSE), Ncharges=sapply(bonds(sdfset, type=\u0026#34;charge\u0026#34;), length), atomcountMA(sdfset, addH=FALSE), groups(sdfset, type=\u0026#34;countMA\u0026#34;), rings(sdfset, upper=6, type=\u0026#34;count\u0026#34;, arom=TRUE)) ## based on ChemmineOB propma = propOB(sdfset[1]) colnames(propma) # [1] \u0026#34;cansmi\u0026#34; \u0026#34;cansmiNS\u0026#34; \u0026#34;formula\u0026#34; \u0026#34;title\u0026#34; \u0026#34;InChI\u0026#34; \u0026#34;HBA1\u0026#34; \u0026#34;HBA2\u0026#34; # [8] \u0026#34;HBD\u0026#34; \u0026#34;logP\u0026#34; \u0026#34;MR\u0026#34; \u0026#34;MW\u0026#34; \u0026#34;nF\u0026#34; \u0026#34;TPSA\u0026#34; # datablock(sdfset) \u0026lt;- cbind(datablock(sdfset), propma) 2. 格式转换（smi） SDFset → SMIset 1 2 3 smiles \u0026lt;- sdf2smiles(sdfset[1:2]) class(smiles) cid(smiles) SMIset → smiles string 1 as.character(smiles) smiles string → SMIset/SDFset 1 2 3 sdf \u0026lt;- smiles2sdf(\u0026#34;CC(=O)OC1=CC=CC=C1C(=O)O\u0026#34;) as(as.character(smiles), \u0026#34;SMIset\u0026#34;) 此外ChemmineOB支持更多化合物格式间的转换 1 2 3 4 5 6 7 8 9 ## R object convertFormat(\u0026#34;smi\u0026#34;,\u0026#34;sdf\u0026#34;,\u0026#34;CC(=O)OC1=CC=CC=C1C(=O)O\u0026#34;) convertFormat(\u0026#34;smi\u0026#34;,\u0026#34;mol2\u0026#34;,\u0026#34;CC(=O)OC1=CC=CC=C1C(=O)O\u0026#34;) ## File ## 将smi文件(第一列smi，第二列optional ID)转换为sdf文件 convertFormatFile(\u0026#34;smi\u0026#34;,\u0026#34;sdf\u0026#34;,\u0026#34;example.smi\u0026#34;,\u0026#34;example.sdf\u0026#34;) # 可参见obabel的笔记了解其支持的全部格式 3. 导出与读入 SDF 1 2 3 4 5 6 7 8 9 10 11 12 # 一般导出 write.SDF(sdfset[1:4], file=\u0026#34;sub.sdf\u0026#34;) # 分批导出 write.SDFsplit(x=sdfstr, filetag=\u0026#34;myfile\u0026#34;, nmol=10) # 对于大量分子，可保存为二进制rda，减少文件大小 save(sdfstr, file=\u0026#34;sdfstr.rda\u0026#34;) # 读入为SDFset subsdfset \u0026lt;- read.SDFset(\u0026#34;sub.sdf\u0026#34;) SMI 1 2 3 4 5 data(smisample) smiset \u0026lt;- smisample write.SMI(smiset[1:4], file=\u0026#34;sub.smi\u0026#34;) smiset \u0026lt;- read.SMIset(\u0026#34;sub.smi\u0026#34;) 4. AP/FP特征 AP表示原子对特征(Atom Pair Descriptors)。APset 表示若干化合物的AP特征集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sdfset = sdfsample ap \u0026lt;- sdf2ap(sdfset[[1]]) # single apset \u0026lt;- sdf2ap(sdfset) # many(common) ## 计算特定两两相似度 cmp.similarity(apset[1],apset[2]) # [1] 0.2637037 ## 批量计算 cmp.search(apset,apset[1], type=3, cutoff = 0.3, quiet=TRUE) # index cid scores # 1 1 CMP1 1.0000000 # 2 96 CMP96 0.3516643 # 3 67 CMP67 0.3117569 # 4 88 CMP88 0.3094629 # 5 15 CMP15 0.3010753 FP表示指纹编码特征(Fingerprints)。FPset表示若干化合物的FP特征集合。 （1）ChemmineR内置了一种根据APset计算FP的函数\n1 2 3 4 5 ?desc2fp fpset \u0026lt;- desc2fp(apset, descnames=1024, type=\u0026#34;FPset\u0026#34;) fpma \u0026lt;- desc2fp(apset, descnames=512, type=\u0026#34;matrix\u0026#34;) fpch \u0026lt;- desc2fp(apset, descnames=64, type=\u0026#34;character\u0026#34;) （2）ChemmineOB支持计算化合物的ECFP、SMARTs等指纹类型(详见obabel笔记)\n1 2 fpset \u0026lt;-fingerprintOB(sdfset,\u0026#34;FP2\u0026#34;) fpset \u0026lt;-fingerprintOB(sdfset,\u0026#34;ECFP10\u0026#34;) （3）计算化合物间FP的相似度\n1 fpSim(fpset[1], fpset, method=\u0026#34;Tanimoto\u0026#34;) 5. Pubchem接口 fingerprintR提供简单的pubchem api调用，用于特征场景的查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # (1) PID → SDFset sdfset_01 \u0026lt;- pubchemCidToSDF(c(111,123)) # (2) inchikeys → SDFset inchikeys \u0026lt;- c( \u0026#34;ZFUYDSOHVJVQNB-FZERPYLPSA-N\u0026#34;, \u0026#34;KONGRWVLXLWGDV-BYGOPZEFSA-N\u0026#34;, \u0026#34;AANKDJLVHZQCFG-WLIQWNBFSA-N\u0026#34;, \u0026#34;SNFRINMTRPQQLE-JQWAAABSSA-N\u0026#34; ) inchikey_query \u0026lt;- pubchemInchikey2sdf(inchikeys) sdfset_02 = inchikey_query$sdf_set sdfid(sdfset_02) # [1] \u0026#34;162880185\u0026#34; \u0026#34;11276107\u0026#34; \u0026#34;442060\u0026#34; ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/503chemminer%E5%A4%84%E7%90%86%E5%8C%96%E5%90%88%E7%89%A9%E4%BF%A1%E6%81%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7r%E5%8C%85/","summary":"\u003cblockquote\u003e\n\u003cp\u003eChemmineR是使用R语言实现化合物基础操作的工具包，现根据其官方文档学习其主要用法如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.bioconductor.org/packages/release/bioc/vignettes/ChemmineR/inst/doc/ChemmineR.html\"\u003ehttps://www.bioconductor.org/packages/release/bioc/vignettes/ChemmineR/inst/doc/ChemmineR.html\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20230720110642101.png\" alt=\"image-20230720110642101\" style=\"zoom:50%;\" /\u003e\u003c/blockquote\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e (!requireNamespace(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BiocManager\u0026#34;\u003c/span\u003e, quietly=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTRUE\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    install.packages(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;BiocManager\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eBiocManager::install(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ChemmineR\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elibrary(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;ChemmineR\u0026#34;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# library(\u0026#34;ChemmineOB\u0026#34;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1-sdfset格式\"\u003e1. SDFset格式\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eChemmineR基础操作是围绕SDFset对象展开的，其表示多个SDF格式的化合物集合\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata(sdfsample)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esdfset = sdfsample\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# valid \u0026lt;- validSDF(sdfset)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# sdfset \u0026lt;- sdfset[valid]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclass(sdfset)  \u003cspan style=\"color:#007f7f\"\u003e# SDFset\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elength(sdfset) \u003cspan style=\"color:#007f7f\"\u003e# 100\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ec(sdfset[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e], sdfset[5:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e8\u003c/span\u003e]) \u003cspan style=\"color:#007f7f\"\u003e# 合并\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esdfset[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e]    \u003cspan style=\"color:#007f7f\"\u003e# 子集\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e每个SDFset集合是由单个SDF对象组成的，主要由4部分构成\n\u003cul\u003e\n\u003cli\u003e\u0026lt;\u0026lt;header\u0026raquo; : 化合物id等基本信息\u003c/li\u003e\n\u003cli\u003e\u0026lt;\u0026lt;atomblock\u0026raquo; : 原子信息，\u0026lt;\u0026lt;bondblock\u0026raquo;:  键信息\u003c/li\u003e\n\u003cli\u003e\u0026lt;\u0026lt;datablock\u0026raquo; : 化合物的属性/其它注释信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esdfset[[1]]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eas(sdfset[[1]], \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;list\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## ID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecid(sdfset[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e])       \u003cspan style=\"color:#007f7f\"\u003e# slot ID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esdfid(sdfset[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e])     \u003cspan style=\"color:#007f7f\"\u003e# header ID\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecid(sdfset) =  sdfid(sdfset)  \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## Component\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eheader(sdfset[[1]])    \u003cspan style=\"color:#007f7f\"\u003e# character\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eatomblock(sdfset[[1]]) \u003cspan style=\"color:#007f7f\"\u003e# matrix\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebondblock(sdfset[[1]]) \u003cspan style=\"color:#007f7f\"\u003e# matrix\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edatablock(sdfset[[1]]) \u003cspan style=\"color:#007f7f\"\u003e# character\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eblockmatrix = datablock2ma(datablock(sdfset[1:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e])) \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e补充：ChemmineR提供一些函数可计算化合物的基本属性信息，例如分子量等。此外ChemmineOB也可以实现类似功能。\u003c/p\u003e","title":"ChemmineR处理化合物信息的基础工具R包"},{"content":" 我对于parallel并行的简单理解即同时执行多个命令语句。尽管目前很多生信软件支持多线程运行(一条命令语句内)，但并不是设置的越多就越快，比如trim_galore命令建议对于一对fastq文件，不超过8个线程。因此，如果有多个文件需要处理，想尽可能利用计算机几十个线程的资源，可以使用parallel。\n1 2 3 4 #使用conda安装可以避免root权限的限制 conda install -c conda-forge parallel parallel --help 1、基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ##(1) ::: 传递不同遍历值 parallel echo ::: A B C # A # B # C ##(2) --dryrun 仅打印命令，而不执行 parallel --dryrun echo ::: A B C parallel --dryrun echo {} ::: A B C parallel --dryrun echo {1} ::: A B C # echo A # echo B # echo C ##(3) 可提供双参数 parallel --dryrun echo {1} and_{2} ::: A B ::: D E # echo A and_D # echo A and_E # echo B and_D # echo B and_E parallel --dryrun --xapply echo {1} {2} ::: A B ::: D E # echo A D # echo B E ##(4) -j 指定同时执行的命令数,相当于线程数 ## --verbose参数可以在执行命令语句前，先打印出该命令 ## --progress参数可以实时显示任务的完成进度 parallel -j 3 echo chr{}.fa ::: {1..22} X Y Z 2、{}的字符处理 {} – full name 全名 {.} – 以（最后一个）逗号为分隔符的前半部分 {/} – 去除路径 {//} – 仅保留路径\n1 2 3 4 5 6 ls # 1.txt 2.txt 3.txt parallel echo mv {1} {1.}.doc ::: ./*.txt # mv 1.txt 1.doc # mv 2.txt 2.doc # mv 3.txt 3.doc 3、文件传递参数/命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 cat chrID.txt # 1 # 2 # 3 # 4 # 5 # 6 # X # Y parallel echo chr{}.fa :::: chrID.txt ## 等同于 cat chrID.txt | parallel echo chr{}.fa # chr1.fa # chr2.fa # chr3.fa # chr4.fa # chr5.fa # chr6.fa # chrX.fa # chrY.fa ","permalink":"https://lishensuo.github.io/en/posts/program/503linux%E7%9A%84parallel%E5%B9%B6%E8%A1%8C%E6%96%B9%E6%B3%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003e我对于parallel并行的简单理解即同时执行多个命令语句。尽管目前很多生信软件支持多线程运行(一条命令语句内)，但并不是设置的越多就越快，比如trim_galore命令建议对于一对fastq文件，不超过8个线程。因此，如果有多个文件需要处理，想尽可能利用计算机几十个线程的资源，可以使用\u003cstrong\u003eparallel\u003c/strong\u003e。\u003c/p\u003e","title":"Linux的parallel并行方法"},{"content":"1、shell脚本 1.1 脚本执行 （1）命令行直接执行\n如下示例：脚本第一行设置脚本解释器的路径，如写错或没写，系统会调用默认解释器执行。然后在运行脚本时，需要先赋予可执行权限。（下同）\n1 2 3 4 5 6 7 8 cat \u0026gt; test.sh #!/bin/bash echo \u0026#34;Hello World!\u0026#34; chmod u+x test.sh ./test.sh # Hello World! （2）bash命令执行 1 2 3 4 5 6 cat \u0026gt; test.sh echo \u0026#34;Hello World!\u0026#34; bash ./test.sh # Hello World! 1.2 脚本传参 $0 脚本名 $1 第一个参数 $2 第二个参数\u0026hellip; $@ 全部参数 $# 输入参数个数 1 2 3 4 5 6 cat \u0026gt; plus.sh num1=$1 num2=$2 echo \u0026#34;${num1}+${num2}\u0026#34; | bc bash ./plus.sh 1 2 2、python脚本 2.1 脚本执行 （1）命令行直接执行 1 2 3 4 5 6 7 cat \u0026gt; test.py #!/usr/bin/python print(\u0026#34;Hello World!\u0026#34;) chmod u+x test.py ./test.py （2）python命令执行 1 2 3 4 5 cat \u0026gt; test.py print(\u0026#34;Hello world\u0026#34;) python test.py 2.2 脚本传参 | sys模块 一般使用sys模块传参,储存在sys.argv列表里，第0个元素表示脚本名，第一个元素表示第一个参数.. 1 2 3 4 5 6 7 cat \u0026gt; test.py import sys num1 = sys.argv[1] num2 = sys.argv[2] print(int(num1) + int(num2)) python test.py 1 2 2.3 脚本传参 | argparse模块 https://docs.python.org/3/howto/argparse.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import argparse # 创建 ArgumentParser 对象 parser = argparse.ArgumentParser(description=\u0026#34;A script to train a model and save the results.\u0026#34;) # 添加参数 parser.add_argument( \u0026#34;-s\u0026#34;, # 短选项（简洁） \u0026#34;--save_dir\u0026#34;, # 长选项（容易理解） type=str, default=\u0026#39;path/to/there\u0026#39;, required=True, help=\u0026#34;The directory to save the trained model and the results.\u0026#34;, ) parser.add_argument(\u0026#34;--eval_interval\u0026#34;, type=int, default=1) #一般最常用形式 parser.add_argument(\u0026#34;--pos_embed\u0026#34;, type=bool, default=True, help=\u0026#39;Using Gene2vec encoding or not.\u0026#39;) # 解析命令行参数 args = parser.parse_args() # 使用参数 SAVE_DIR = args.save_dir 长选项参数中间如果存在连字符-，在参数解析时，会自动替换为下划线_\n1 2 3 python script.py --save_dir \u0026#34;path/to/dir\u0026#34; python script.py -h action=\u0026quot;store_true\u0026quot; if the option is specified, assign the value True to args.params. Not specifying it implies False. 1 2 3 4 5 6 7 import argparse parser = argparse.ArgumentParser() parser.add_argument(\u0026#34;--verbose\u0026#34;, help=\u0026#34;increase output verbosity\u0026#34;, action=\u0026#34;store_true\u0026#34;) args = parser.parse_args() if args.verbose: print(\u0026#34;verbosity turned on\u0026#34;) 1 2 3 4 5 python prog.py --verbose # args.verbose → True python prog.py # args.verbose → False 3、R脚本 3.1 脚本执行 （1）命令行直接执行 1 2 3 4 5 6 7 cat \u0026gt; test.r #!/usr/bin/Rscript print(\u0026#34;Hello world\u0026#34;) chmod u+x test.r ./test.r （2）Rscript命令执行 1 2 3 4 5 cat \u0026gt; test.r print(\u0026#34;Hello world\u0026#34;) Rscript test.r 3.2 脚本传参 使用commandArgs()函数传参 1 2 3 4 5 6 7 cat \u0026gt; test.r args \u0026lt;- commandArgs(trailingOnly = TRUE) num1=args[1] num2=args[2] print(as.numeric(num1)+as.numeric(num2)) Rscript test.r 1 2 nohup后台运行，以python脚本为例：\n1 nohup python drug_fp.py 1\u0026gt; ./drug_fp.log 2\u0026gt;\u0026amp;1 \u0026amp; ","permalink":"https://lishensuo.github.io/en/posts/program/504shell_python_r%E8%84%9A%E6%9C%AC%E5%9F%BA%E7%A1%80/","summary":"\u003ch1 id=\"1shell脚本\"\u003e1、shell脚本\u003c/h1\u003e\n\u003ch2 id=\"11-脚本执行\"\u003e1.1 脚本执行\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e（1）命令行直接执行\u003c/p\u003e\n\u003cp\u003e如下示例：脚本第一行设置脚本解释器的路径，如写错或没写，系统会调用默认解释器执行。然后在运行脚本时，需要先赋予可执行权限。（下同）\u003c/p\u003e","title":"Shell_Python_R脚本基础"},{"content":" JSON (JavaScript Object Notation)：一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。它广泛用于网络数据传输和配置文件。 JSON的整体是由花括号{}定义的键值对，值包括字符串、数字、布尔值、对象、数组和 null 1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;isStudent\u0026#34;: false, \u0026#34;fruit\u0026#34;: [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;], \u0026#34;birthday\u0026#34;: { \u0026#34;year\u0026#34;: 2000, \u0026#34;month\u0026#34;: 12, \u0026#34;day\u0026#34;: null } } 在python中，可使用json库高效处理json格式： 键值对（对象） → Python字典 布尔值true/false → Python True/False 数组 → Python 列表list null → Python None 1 import json 1. json对象 json对象 → Python字典 1 2 3 4 5 6 7 8 9 10 # JSON 字符串 json_str = \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;isStudent\u0026#34;: false}\u0026#39; # 解析 JSON data = json.loads(json_str) data.items() # dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;isStudent\u0026#39;, False)]) data[\u0026#39;birth\u0026#39;] = {\u0026#34;year\u0026#34;:2000, \u0026#39;month\u0026#39;:12, \u0026#34;day\u0026#34;:None} data[\u0026#39;like\u0026#39;] = [\u0026#39;apple\u0026#39;, \u0026#39;banana\u0026#39;, \u0026#39;cherry\u0026#39;] **Python字典 → json对象 ** 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 json_str = json.dumps(data) print(json_str) # {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;isStudent\u0026#34;: false, \u0026#34;birth\u0026#34;: {\u0026#34;year\u0026#34;: 2000, \u0026#34;month\u0026#34;: 12, \u0026#34;day\u0026#34;: null}, \u0026#34;like\u0026#34;: [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;]} json_str = json.dumps(data, indent=4) print(json_str) # { # \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, # \u0026#34;age\u0026#34;: 30, # \u0026#34;isStudent\u0026#34;: false, # \u0026#34;birth\u0026#34;: { # \u0026#34;year\u0026#34;: 2000, # \u0026#34;month\u0026#34;: 12, # \u0026#34;day\u0026#34;: null # }, # \u0026#34;like\u0026#34;: [ # \u0026#34;apple\u0026#34;, # \u0026#34;banana\u0026#34;, # \u0026#34;cherry\u0026#34; # ] # } 2. json文件 保存python字典为json文件 1 2 with open(\u0026#39;demo.json\u0026#39;, \u0026#39;w\u0026#39;) as file: json.dump(data, file, indent=4) 读取json文件为python字典 1 2 with open(\u0026#39;demo.json\u0026#39;, \u0026#39;r\u0026#39;) as file: data = json.load(file) ","permalink":"https://lishensuo.github.io/en/posts/program/505json%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/","summary":"\u003cul\u003e\n\u003cli\u003eJSON (JavaScript Object Notation)：一种轻量级的数据交换格式，易于人类阅读和编写，同时也易于机器解析和生成。它广泛用于网络数据传输和\u003cstrong\u003e配置文件\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003eJSON的整体是由花括号\u003ccode\u003e{}\u003c/code\u003e定义的键值对，值包括字符串、数字、布尔值、对象、数组和 \u003ccode\u003enull\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Alice\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;age\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e30\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;isStudent\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#fff;font-weight:bold\"\u003efalse\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;fruit\u0026#34;\u003c/span\u003e: [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;apple\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;banana\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;cherry\u0026#34;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;birthday\u0026#34;\u003c/span\u003e: {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;year\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2000\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;month\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"font-weight:bold\"\u003e\u0026#34;day\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#fff;font-weight:bold\"\u003enull\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e在python中，可使用json库高效处理json格式：\n\u003cul\u003e\n\u003cli\u003e键值对（对象） → Python字典\u003c/li\u003e\n\u003cli\u003e布尔值\u003ccode\u003etrue/false\u003c/code\u003e → Python \u003ccode\u003eTrue/False\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e数组 → Python 列表list\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enull\u003c/code\u003e → Python \u003ccode\u003eNone\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e json\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1-json对象\"\u003e1. json对象\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ejson对象 → Python字典\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# JSON 字符串\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejson_str = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;isStudent\u0026#34;: false}\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 解析 JSON\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata = json.loads(json_str)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata.items()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Alice\u0026#39;), (\u0026#39;age\u0026#39;, 30), (\u0026#39;isStudent\u0026#39;, False)])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;birth\u0026#39;\u003c/span\u003e] = {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;year\u0026#34;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2000\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;month\u0026#39;\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;day\u0026#34;\u003c/span\u003e:\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;like\u0026#39;\u003c/span\u003e] = [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;apple\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;banana\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;cherry\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e**Python字典 → json对象 **\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejson_str = json.dumps(data)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(json_str)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;isStudent\u0026#34;: false, \u0026#34;birth\u0026#34;: {\u0026#34;year\u0026#34;: 2000, \u0026#34;month\u0026#34;: 12, \u0026#34;day\u0026#34;: null}, \u0026#34;like\u0026#34;: [\u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, \u0026#34;cherry\u0026#34;]}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ejson_str = json.dumps(data, indent=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(json_str)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     \u0026#34;name\u0026#34;: \u0026#34;Alice\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     \u0026#34;age\u0026#34;: 30,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     \u0026#34;isStudent\u0026#34;: false,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     \u0026#34;birth\u0026#34;: {\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         \u0026#34;year\u0026#34;: 2000,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         \u0026#34;month\u0026#34;: 12,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         \u0026#34;day\u0026#34;: null\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     },\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     \u0026#34;like\u0026#34;: [\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         \u0026#34;apple\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         \u0026#34;banana\u0026#34;,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         \u0026#34;cherry\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     ]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# }\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2-json文件\"\u003e2. json文件\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e保存python字典为json文件\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ewith\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;demo.json\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;w\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e file:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    json.dump(data, file, indent=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e读取json文件为python字典\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ewith\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;demo.json\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;r\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e file:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    data = json.load(file)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Json文件格式"},{"content":" MySQL是一个常用的数据库管理系统，关于数据库可以简单理解多个有关联的二维表组成。\n其中SQL(Structured Query Language)指操作关系型数据库的编程语言。\n特点（1）关键字不区分大小写；（2）分号; 作为语句结束标志\n笔记主要参考资料：【黑马程序员 MySQL数据库入门到精通，从mysql安装到mysql高级、mysql优化全囊括】的基础入门部分 https://www.bilibili.com/video/BV1Kr4y1i7ru?share_source=copy_web\u0026vd_source=6edf13733e01570d1376e8b5e1ccbd6e\n一、安装与用户管理 1、在centos7 linux系统中安装mysql [上述教学视频中为window安装]，需要ROOT权限。\nhttps://www.hostinger.in/tutorials/how-to-install-mysql-on-centos-7\n在安装过程中遇到的注意事项\n如果之前已经安装，需要卸载干净之前的记录，参考https://learnku.com/articles/35042 其中遇到公钥尚未安装的问题解决报错，参考Centos7 yum安装的时候遇到公钥尚未安装的问题解决_张志翔 ̮的博客-CSDN博客解决 初次修改密码需要包含数字、字符、大小写，且长度大于8；可在之后修改密码强度要求等级。https://stackoverflow.com/questions/43094726/your-password-does-not-satisfy-the-current-policy-requirements 1 2 3 4 5 6 7 # 以root身份进入mysql系统，根据提示输入密码 mysql -h localhost -u root -p quit -- systemctl status mysqld -- systemctl start mysqld -- systemctl stop mysqld 2、创建新用户\n1 2 3 4 5 6 7 8 9 10 11 12 ## 查看所有用户 select Host, User from mysql.user; ## 创建用户并设置密码 create user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;; alter user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; identified with mysql_native_password by \u0026#39;654321\u0026#39;; drop user \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39;; ## 用户权限管理 SHOW GRANTS FOR \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39; ; grant all on *.* to \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39;; # *.*表示匹配任意数据库的任一表 revoke all on *.* to \u0026#39;test\u0026#39;@\u0026#39;localhost\u0026#39;; # *.*表示匹配任意数据库的任一表 二、数据查询与操作 1、database基础操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # (1)查询所有数据库 show databases; # (2)进入/切换至某一数据库 use sys; # (3)查看当前所处于的数据库 select database(); # (4)创建数据库 create database firstdb; create database if not exists firstdb; # (5)删除数据库 drop database firstdb; 2、table表基础操作 1 2 3 4 5 6 7 8 9 10 11 # (1)查询当前库的所有表 show tables; # (2)查看指定表的每一列数据概况 desc host_summary; # (3)修改表名 alter table new_table rename to first_table; # (4)删除表 drop table first_table; 3、创建表以及列修改 创建一张表的关键是交代每一列(字段)的名字、数据类型等。其中常见的数据类型包括 整型：int\n小数：float，float(4, 1)\n定长字符串：char, char(3)\n变长字符串：varchar, varchar(10)\n日期：date \u0026ndash; 年月日\nnull为特使的数据类型，表示空值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # (1) 如下创建一个名为first_table的表，对应的comment表示列备注、表备注 create table first_table( id int comment \u0026#39;编号\u0026#39;, name varchar(50) comment \u0026#39;姓名\u0026#39;, age int comment \u0026#39;年龄\u0026#39;, gender varchar(1) comment \u0026#39;性别\u0026#39; ) comment \u0026#39;用户表\u0026#39;; desc first_table; # (2) 修改列名及数据类型 alter table first_table change name fakename char(3); # (3) 仅修改列的数据类型 alter table first_table modify fakename char(5); # (4) 删除列 alter table first_table drop fakename; # (5) 增加列 alter table first_table add nickname varchar(10) comment \u0026#39;昵称\u0026#39;; 4、行内容(表数据)修改 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # (1) 增加1/多行数据 insert into first_table(id,name,age,gender) values (1, \u0026#34;张三\u0026#34;, 18, \u0026#34;男\u0026#34;); insert into first_table values (2, \u0026#34;李四\u0026#34;, 19, \u0026#34;男\u0026#34;), (3, \u0026#34;王二\u0026#34;, 20, \u0026#34;女\u0026#34;); select * from first_table; # (2) 修改特定数据 update first_table set age=88 where name=\u0026#34;张三\u0026#34;; update first_table set gender=\u0026#34;男\u0026#34;; # (3) 删除行数据 delete from first_table where age\u0026gt;80; delete from first_table # (4) 删除某一个值，可使用update更新为 null 5、创建示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ### 员工表 create table emp( id int comment \u0026#39;编号\u0026#39;, workno varchar(10) comment \u0026#39;工号\u0026#39;, salary int comment \u0026#39;工资\u0026#39;, name varchar(10) comment \u0026#39;姓名\u0026#39;, gender char(1) comment \u0026#39;性别\u0026#39;, age tinyint unsigned comment \u0026#39;年龄\u0026#39;, idcard char(18) comment \u0026#39;身份证号\u0026#39;, workaddress varchar(50) comment \u0026#39;工作地址\u0026#39;, entrydate date comment \u0026#39;入职时间\u0026#39;, dept_id int comment \u0026#39;部门\u0026#39; )comment \u0026#39;员工表\u0026#39;; INSERT INTO emp values (1, \u0026#39;00001\u0026#39;, 5000, \u0026#39;柳清尘\u0026#39;, \u0026#39;女\u0026#39;, 20, \u0026#39;123456789012345678\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;2000-01-01\u0026#39;,1), (2, \u0026#39;00002\u0026#39;, 8000, \u0026#39;张无忌\u0026#39;, \u0026#39;男\u0026#39;, 18, \u0026#39;123456789012345670\u0026#39;, \u0026#39;江苏\u0026#39;, \u0026#39;2005-09-01\u0026#39;,1), (3, \u0026#39;00003\u0026#39;, 12000, \u0026#39;韦一笑\u0026#39;, \u0026#39;男\u0026#39;, 68, \u0026#39;123456789712345670\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;2005-08-01\u0026#39;,2), (4, \u0026#39;00004\u0026#39;, 9000, \u0026#39;赵敏\u0026#39;, \u0026#39;女\u0026#39;, 18, \u0026#39;123456757123845670\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;2009-12-01\u0026#39;,2), (5, \u0026#39;00005\u0026#39;, 8800, \u0026#39;小昭\u0026#39;, \u0026#39;女\u0026#39;, 16, \u0026#39;123456769012345678\u0026#39;, \u0026#39;上海\u0026#39;, \u0026#39;2007-07-01\u0026#39;,2), (6, \u0026#39;00006\u0026#39;, 5000, \u0026#39;杨逍\u0026#39;, \u0026#39;男\u0026#39;, 28, \u0026#39;12345678931234567X\u0026#39;, \u0026#39;西安\u0026#39;, \u0026#39;2006-01-01\u0026#39;,3), (7, \u0026#39;00007\u0026#39;, 6500, \u0026#39;范瑶\u0026#39;, \u0026#39;男\u0026#39;, 40, \u0026#39;123456789212345670\u0026#39;, \u0026#39;北京\u0026#39;, \u0026#39;2005-05-01\u0026#39;,3), (8, \u0026#39;00008\u0026#39;, 10000, \u0026#39;黛绮丝\u0026#39;, \u0026#39;女\u0026#39;, 38, null, \u0026#39;天津\u0026#39;, \u0026#39;2015-05-01\u0026#39;,3); ### 部门表 create table dept( id int comment \u0026#39;ID\u0026#39;, name varchar(10) comment \u0026#39;部门名称\u0026#39; )comment \u0026#39;部门表\u0026#39;; INSERT INTO dept VALUES (1, \u0026#39;研发部\u0026#39;), (2, \u0026#39;市场部\u0026#39;), (3, \u0026#39;财务部\u0026#39;), (4, \u0026#39;销售部\u0026#39;), (5, \u0026#39;总经办\u0026#39;); 6、数据常用查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # (1) 基础查询 select * from emp; #全部数据 select name ,gender from emp; #特定列 select name 姓名, gender 性别 from emp; #起别名 # (2) 去重查询 select distinct gender from emp; select distinct gender, workaddress from emp; # (3) 条件查询 ## \u0026gt; \u0026lt; = \u0026gt;= \u0026lt;= != ## between .. and .. , in, is null, like _匹配单个字符 %匹配任意字符 ## and or not select * from emp where age \u0026gt; 30; select * from emp where idcard is null; select * from emp where gender = \u0026#34;女\u0026#34; and age \u0026lt; 30; select * from emp where workaddress in (\u0026#34;北京\u0026#34;,\u0026#34;天津\u0026#34;); select * from emp where name like \u0026#39;小_\u0026#39;; # (4) 联合查询 select * from emp where salary \u0026lt; 8000 union select * from emp where age \u0026gt; 50; # (5) 排序查询： asc(默认)、desc select * from emp order by age; select * from emp order by age, entrydate desc; # (6) 分页查询/指定范围查询：从a开始，查询b条数据(第一条数据序号为0) select * from emp limit 0,5; select * from emp limit 3,3; select * from emp limit 1 \\G 7、统计与分组统计 常用统计函数\ncount() 行数\navg(), max(), min(), sum()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # (1) 基础统计 select count(*) from emp; select count(*) count from emp; select avg(age) from emp; # (2) 分组统计 select gender, count(*) count from emp group by gender; select workaddress, avg(age) mean_age from emp group by workaddress; # (3) 先筛选再统计 select workaddress, avg(age) mean_age from emp where gender = \u0026#34;男\u0026#34; group by workaddress; # (4) 先统计再筛选 select workaddress, avg(age) mean_age from emp group by workaddress having mean_age \u0026gt; 30; ## 书写顺序：select -- from -- where -- group by -- having ## 执行顺序：from → where → group by → having → select ## select关键字为最后一项执行 8、常用函数与语句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # (1) 字符串函数 /* concat() lower(), upper() lpad(), rpad() trim(), substring() */ select lpad(workno, 10, \u0026#39;0\u0026#39;) from emp; select concat(name, \u0026#34;,\u0026#34;, gender) from emp; select substring(idcard, 7, 8) birthday from emp; # (2) 数值函数 /* ceiling(), floor() mod() 余数 rand() 返回0-1随机数 round() */ select round(age/10)*10 from emp; # (3) 日期函数 /* curdate 当前日期 curtime 当前时间 now 当前日期+时间 */ select curdate(); select now(); select year(now()); # (4) 逻辑语句 select name, if (workaddress in (\u0026#34;北京\u0026#34;,\u0026#34;上海\u0026#34;), \u0026#34;一线\u0026#34;, \u0026#34;二线\u0026#34;) adress_type from emp; select name, case when age \u0026gt; 40 then \u0026#34;中年\u0026#34; when age \u0026gt; 30 then \u0026#34;中青年\u0026#34; else \u0026#34;青年\u0026#34; end age_type from emp; 9、连接两张表 1 2 3 4 5 6 7 8 9 # (1) 内连接 select * from emp, dept where emp.dept_id = dept.id; select e.name, d.name from emp e inner join dept d on e.dept_id = d.id; # (2) 左连接 select e.name, d.name from emp e left join dept d on e.dept_id = d.id; # (3) 右连接 select e.name, d.name from emp e right join dept d on e.dept_id = d.id; 10、嵌套查询 条件语句中的阈值/候选值由嵌套的另一个select语句间接确定 1 2 3 4 5 6 7 8 9 10 11 # (1) 嵌套select返回单个值 select * from emp where dept_id = (select id from dept where name = \u0026#39;研发部\u0026#39;); select * from emp where entrydate \u0026gt; (select entrydate from emp where name = \u0026#39;韦一笑\u0026#39;); # (2) 嵌套select返回单列值 ## in, not in, any, all select * from emp where dept_id in (select id from dept where name in (\u0026#39;研发部\u0026#39;,\u0026#39;市场部\u0026#39;)); ## 多重嵌套 select * from emp where salary \u0026gt; all (select salary from emp where dept_id = (select id from dept where name = \u0026#39;研发部\u0026#39;)); 11、主键与外键 主键(primary key)：具有表的唯一标识符的一列数据，一张表只能有一个主键。\n外键(foreign key): 其中的一列数据含义与另一张表的主键相同时，可视为外键。\n定义两张表的外键关系时，外键所在表称为子表，另一张表称为父表。\n如上示例数据中，员工表(子表)的dept_id列与部门表(父表)的id列含义相同，可建立外键关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # 可以在创建表时声明主键与外键，也可以在之后再修改(如下演示) #(1)设置主键 alter table emp add primary key(id); alter table dept add primary key(id); #(2)删除主键 alter table emp drop primary key; #(3)设置外键 alter table emp add constraint fk_emp_dept_id #外键名 foreign key (dept_id) #外键列 references dept(id); #对应哪个表的那个主键 #(4)删除外键 alter table emp drop foreign key fk_emp_dept_id; #建立外键关系后，默认不允许随意删除delete/修改update父表(dept)的主键数据 -- no action/ restrict #cascade：父表数据删除，子表对应数据也随之删除 #set null：父表数据删除，子表对应数据改为null alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade; 三、数据导出与导入 1、数据导出 导出表为txt或者csv文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 查看导出的默认路径 show variables like \u0026#39;%secure%\u0026#39;; -- +--------------------------+-----------------------+ -- | Variable_name | Value | -- +--------------------------+-----------------------+ -- | require_secure_transport | OFF | -- | secure_file_priv | /var/lib/mysql-files/ | -- +--------------------------+-----------------------+ # 导出为txt文件 select * from dept into outfile \u0026#39;/var/lib/mysql-files/tmp.txt\u0026#39;; # 导出为csv文件 select * from dept into outfile \u0026#39;/var/lib/mysql-files/tmp.csv\u0026#39; FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\r\\n\u0026#39;; ## 关于导出csv文件用excel打开中文乱码 https://blog.csdn.net/u010735147/article/details/83827857 导处数据库/表为.sql文件(需要退出mysql，在shell界面完成) 1 2 3 4 5 # 导出整个数据库 mysqldump -u root -p firstdb \u0026gt; /path/to/dir/firstdb.sql # 导出某数据库的某个表 mysqldump -u root -p firstdb emp \u0026gt; /path/to/dir/firstdb.sql 2、数据导入 导入本地表文件至数据库的某个表里，注意导入时列顺序需要相同。 由于无法直接从默认目录读取ERROR 13 (HY000): File '/var/lib/mysql-files/tmp.txt' not found (OS errno 13 - 权限不够)。可以将待读取文件放到mysql所支持的/tmp/临时文件夹\n1 cp /var/lib/mysql-files/tmp.txt /tmp/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 show variables like \u0026#39;%tmpdir%\u0026#39;; SET GLOBAL local_infile=1; # quit # mysql --local-infile=1 -u root -p create table new_table( id int comment \u0026#39;ID\u0026#39;, name varchar(10) comment \u0026#39;部门名称\u0026#39; )comment \u0026#39;部门表\u0026#39;; ## 导入txt文件 load data local infile \u0026#39;/tmp/tmp.txt\u0026#39; into table new_table LINES TERMINATED BY \u0026#39;\\r\\n\u0026#39;; ## 导入csv文件 load data local infile \u0026#39;/tmp/tmp.csv\u0026#39; into table new_table FIELDS TERMINATED BY \u0026#39;,\u0026#39; ENCLOSED BY \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED BY \u0026#39;\\r\\n\u0026#39;; 导入本地sql至数据库中 1 2 # 在mysql创建一个新数据库 create database seconddb; 1 2 # 在shell端将sql文件导入至该数据库 mysql -u root -p seconddb \u0026lt; /path/to/dir/firstdb.sql 补 1、修改sql数据库位置：https://www.tecmint.com/change-default-mysql-mariadb-data-directory-in-linux/\n1 2 3 4 5 6 mysql -u root -p -e \u0026#34;SELECT @@datadir;\u0026#34; -- +-----------------------+ -- | @@datadir | -- +-----------------------+ -- | /var/lib/mysql/ | -- +-----------------------+ 四、Chembl数据库实战 关于Chembl数据库：https://www.ebi.ac.uk/chembl/\nChembl数据库SQL下载：https://ftp.ebi.ac.uk/pub/databases/chembl/ChEMBLdb/latest/\n文件大小\u0026mdash;压缩包1.6G；解压缩后\u0026mdash;15G；读入至SQL\u0026mdash;33G\n首先读入至mysql中 1 2 3 4 5 6 7 8 # 在mysql中创建一个名为chembl_31的数据库 create database chembl_31 DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci; # mysql -u root -p chembl_31 \u0026lt; chembl_31_mysql.dmp # 大概需要2~3个小时 use chembl_31; show tables; （1）实验对应的靶点信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 select * from activities limit 1 \\G select * from target_components limit 1 \\G select * from component_sequences limit 1 \\G #导入uniprot基因注释 create table uniprot2gene( uniprot varchar(30) , gene varchar(50) ); load data local infile \u0026#39;/tmp/chembl_uniprot2gene.csv\u0026#39; into table uniprot2gene FIELDS TERMINATED BY \u0026#39;,\u0026#39; LINES TERMINATED BY \u0026#39;\\r\\n\u0026#39; ; select * from uniprot2gene limit 10; select * from uniprot2gene limit 1 \\G create table tmp_target_info select a.assay_id assay_id, a.tid tid, b.component_id component_id, c.component_type component_type, c.accession accession, c.organism organism, d.gene gene from assays a left join target_components b on a.tid = b.tid left join component_sequences c on b.component_id = c.component_id left join uniprot2gene d on c.accession = d.uniprot where c.organism = \u0026#34;Homo sapiens\u0026#34; and c.component_type = \u0026#34;PROTEIN\u0026#34; ; select count(*) from tmp_target_info; #415795 select * from tmp_target_info limit 5; -- +----------+--------+--------------+----------------+-----------+--------------+--------+ -- | assay_id | tid | component_id | component_type | accession | organism | gene | -- +----------+--------+--------------+----------------+-----------+--------------+--------+ -- | 142605 | 104282 | 2 | PROTEIN | P02708 | Homo sapiens | CHRNA1 | -- | 142606 | 104282 | 2 | PROTEIN | P02708 | Homo sapiens | CHRNA1 | -- | 143098 | 104282 | 2 | PROTEIN | P02708 | Homo sapiens | CHRNA1 | -- | 143099 | 104282 | 2 | PROTEIN | P02708 | Homo sapiens | CHRNA1 | -- | 143100 | 104282 | 2 | PROTEIN | P02708 | Homo sapiens | CHRNA1 | -- +----------+--------+--------------+----------------+-----------+--------------+--------+ （2）化合物ID对应靶点的实验结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 select * from activities limit 1 \\G; select * from molecule_dictionary limit 1 \\G create table tmp_compound_assay select a.assay_id assay_id, a.molregno molregno, b.chembl_id chembl_id, a.standard_relation standard_relation, a.standard_value standard_value, a.standard_units standard_units, a.standard_flag standard_flag, a.standard_type standard_type, a.pchembl_value a.pchembl_value from activities a left join molecule_dictionary b on a.molregno=b.molregno where a.assay_id in (select assay_id from tmp_target_info) ; select count(*) from tmp_compound_assay; #5951349 select * from tmp_compound_assay limit 5; -- +----------+----------+--------------+-------------------+--------------------------------------+----------------+---------------+---------------+ -- | assay_id | molregno | chembl_id | standard_relation | standard_value | standard_units | standard_flag | standard_type | -- +----------+----------+--------------+-------------------+--------------------------------------+----------------+---------------+---------------+ -- | 4 | 167941 | CHEMBL321330 | \u0026gt; | 10000.000000000000000000000000000000 | nM | 0 | 135 | -- | 18 | 144846 | CHEMBL313630 | = | 300.000000000000000000000000000000 | nM | 1 | AC50 | -- | 18 | 144716 | CHEMBL315582 | = | 200.000000000000000000000000000000 | nM | 1 | AC50 | -- | 18 | 144887 | CHEMBL313613 | = | 500.000000000000000000000000000000 | nM | 1 | AC50 | -- | 18 | 144715 | CHEMBL316389 | = | 200.000000000000000000000000000000 | nM | 1 | AC50 | -- +----------+----------+--------------+-------------------+--------------------------------------+----------------+---------------+---------------+ （3） 查询PubChemID对应的CHEMBL的化合物实验信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 查询表query_tb包括两列：第一列，pubchem id；第二列，chembl id create table query_tb( CID int , Chembl varchar(20) ); #读入本地csv文件 load data local infile \u0026#39;/tmp/query_chembl.csv\u0026#39; into table query_tb FIELDS TERMINATED BY \u0026#39;,\u0026#39; LINES TERMINATED BY \u0026#39;\\r\\n\u0026#39;; select * from query_tb limit 10; #得到筛选结果query_res_tb create table query_res_tb select cp.chembl_id chembl_id, cp.standard_relation standard_relation, cp.standard_value standard_value, cp.standard_units standard_units, cp.standard_flag standard_flag, cp.standard_type standard_type, cp.pchembl_value pchembl_value, target.gene gene from tmp_compound_assay cp left join tmp_target_info target on cp.assay_id=target.assay_id where cp.chembl_id in (select Chembl from query_tb); show variables like \u0026#39;%secure%\u0026#39;; select * from query_res_tb into outfile \u0026#39;/var/lib/mysql-files/query_chembl_res.txt\u0026#39;; # c(\u0026#34;chembl_id\u0026#34;,\u0026#34;relation\u0026#34;,\u0026#34;value\u0026#34;,\u0026#34;units\u0026#34;,\u0026#34;flag\u0026#34;,\u0026#34;type\u0026#34;,\u0026#34;pchembl_value\u0026#34;,\u0026#34;gene\u0026#34;) ","permalink":"https://lishensuo.github.io/en/posts/program/600mysql%E5%88%9D%E5%AD%A6/","summary":"\u003cblockquote\u003e\n\u003cp\u003eMySQL是一个常用的数据库管理系统，关于数据库可以简单理解多个有关联的二维表组成。\u003c/p\u003e\n\u003cp\u003e其中SQL(Structured Query Language)指操作关系型数据库的编程语言。\u003c/p\u003e","title":"MySQL初学"},{"content":" 深度学习组成要素 线性回归可以认为是最简单的一层深度神经网络 一、从零实现 1 2 3 import numpy as np import torch import random 1、示例数据 模拟样本特征与标签数据，并分成小批量传入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #模拟生成含有n个特征的线性回归数据 def synthetic_data(w, b, num_examples): X = torch.normal(0, 1, (num_examples, len(w))) y = torch.matmul(X, w) + b y += torch.normal(0, 0.01, y.shape) return X, y.reshape((-1, 1)) def data_iter(batch_size, features, labels): num_examples = len(features) indices = list(range(num_examples)) random.shuffle(indices) for i in range(0, num_examples, batch_size): batch_indices = torch.tensor( indices[i:min(i+batch_size, num_examples)]) yield features[batch_indices], labels[batch_indices] # true_w = torch.tensor([2.5, -6.2]) # true_b = 1.2 # features, labels = synthetic_data(true_w, true_b, 10) # next(iter(data_iter(2, features, labels))) # # (tensor([[-0.0439, -0.0902], # # [ 1.2628, 1.4977]]), # # tensor([[ 1.6495], # # [-4.9359]])) 2、定义模型 根据输入，计算输出结果\n1 2 3 4 5 def linreg(X, w, b): return torch.matmul(X, w) + b #初始化模型参数 w = torch.normal(0, 0.01, size=(2,1), requires_grad=True) b = torch.zeros(1, requires_grad=True) 3、定义损失函数 计算模型输出结果与真实值的差异\n1 2 def squard_loss(y_hat, y): return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2 4、定义优化算法 更新模型参数，使得损失降低\n1 2 3 4 5 def sgd(params, lr, batch_size): with torch.no_grad(): for param in params: param -= lr * param.grad / batch_size param.grad.zero_() 5、训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 true_w = torch.tensor([2.5, -6.2]) true_b = 1.2 features, labels = synthetic_data(true_w, true_b, 100) batch_size = 10 lr = 0.01 net = linreg loss = squard_loss num_epochs = 30 for epoch in range(num_epochs): for X, y in data_iter(batch_size, features, labels): l = loss(net(X, w, b), y) l.sum().backward() sgd([w, b], lr, batch_size) with torch.no_grad(): train_l = loss(net(features, w, b), labels) print(f\u0026#39;epoch {epoch + 1}, loss {train_l.mean():f}\u0026#39;) 二、torch框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ## 2.1 示例数据 def synthetic_data(w, b, num_examples): X = torch.normal(0, 1, (num_examples, len(w))) y = torch.matmul(X, w) + b y += torch.normal(0, 0.01, y.shape) return X, y.reshape((-1, 1)) ## 小批量传入样本特征与标签数据 def load_array(data_arrays, batch_size, is_train=True): # 类似zip，将两个具有相同行数的数据对应关联在一起 dataset = data.TensorDataset(*data_arrays) # dataset[0:3] return data.DataLoader(dataset, batch_size, shuffle=is_train) ## 2.2 定义模型 net = nn.Sequential(nn.Linear(2, 1)) ## 2.3 定义损失函数 loss = nn.MSELoss() ## 2.4 定义优化算法 optimizer = torch.optim.SGD(net.parameters(), lr=0.01) ## 2.5 训练模型 true_w = torch.tensor([2.5, -6.2]) true_b = 1.2 features, labels = synthetic_data(true_w, true_b, 50) batch_size = 5 data_iter = load_array((features, labels), batch_size) # next(iter(data_iter)) num_epochs = 100 for epoch in range(num_epochs): for X, y in data_iter: l = loss(net(X), y) optimizer.zero_grad() l.backward() optimizer.step() l = loss(net(features), labels) print(f\u0026#39;epoch {epoch + 1}, loss {l:f}\u0026#39;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/701%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0d2l--01--%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/","summary":"\u003cul\u003e\n\u003cli\u003e深度学习组成要素\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220731132558728.png\" alt=\"image-20220731132558728\" style=\"zoom:80%;\" /\u003e\r\n\u003cul\u003e\n\u003cli\u003e线性回归可以认为是最简单的一层深度神经网络\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220731133150401.png\" alt=\"image-20220731133150401\"  /\u003e\r\n\u003ch1 id=\"一从零实现\"\u003e一、从零实现\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e random\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1示例数据\"\u003e1、示例数据\u003c/h2\u003e\n\u003cp\u003e模拟样本特征与标签数据，并分成小批量传入\u003c/p\u003e","title":"深度学习D2L--01--线性回归"},{"content":"\r一、从零实现 1 2 3 4 import torch import torchvision from torch.utils import data from torchvision import transforms 1、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##数据集为fashion_minist，10类衣服及对应的图片 def load_data_fashion_minist(batch_size): #将图片转为张量矩阵 trans = transforms.ToTensor() mnist_train = torchvision.datasets.FashionMNIST( root=\u0026#34;./data\u0026#34;, train=True, transform=trans, download=True) mnist_test = torchvision.datasets.FashionMNIST( root=\u0026#34;./data\u0026#34;, train=False, transform=trans, download=True) #生成训练集数据迭代器 train_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=True) #生成测试集数据迭代器 test_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=False) return train_iter, test_iter # batch_size = 256 # train_iter, test_iter = load_data_fashion_minist(batch_size) # X, y = next(iter(train_iter)) # X.shape # # torch.Size([256, 1, 28, 28]) 2、定义模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def net(X): # W.shape -- torch.Size([784, 10]) # b.shape -- torch.Size([10]) # 全连接层 X = torch.matmul(X.reshape((-1, 784)), W) + b # 激活函数(见上) X_softmax = softmax(X) return X_softmax def softmax(X): # 幂函数使数据具有非负性 X_exp = torch.exp(X) partition = X_exp.sum(1, keepdim=True) # 归一化，一个样本对于全部类别预测结果和为1 return X_exp/partition # W = torch.normal(0, 0.01, (784, 10), requires_grad = True) # b = torch.zeros(10, requires_grad = True) # y_hat = net(X) # y_hat.shape # # torch.Size([256, 10]) 3、定义损失函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def cross_entropy(y_hat, y): # 对于某个样本真实类别的预测概率 y_hat_target = y_hat[range(len(y_hat)), y] # 负log转换--→ 符合最小化 return - torch.log(y_hat_target) # cross_entropy(y_hat, y).shape # # torch.Size([256]) ## 计算分类精度评价指标 # 计算1个batch的分类正确数 def accuracy(y_hat, y): y_hat_class = y_hat.argmax(1) # 样本类别预测与否(True/False) cmp = y_hat_class.type(y.dtype) == y return cmp.sum().item() # accuracy(y_hat, y) # # 8 # 定义一个累加值计数器：用以累计1轮epoch所有batch的分类精度 class Accumulator: def __init__(self, n): self.data = [0.0]*n # [0, 0] def add(self, *args): # [0, 0] + [1, 2] = [1, 2] self.data = [a + b for a, b in zip(self.data, args)] def reset(self): self.data = [0.0]*len(self.data) def __getitem__(self, idx): return self.data[idx] # 计算测试集的分类精度 def evaluate_accuracy(net, data_iter): metric = Accumulator(2) with torch.no_grad(): for X, y in data_iter: metric.add(accuracy(net(X), y), len(y)) Acc_avg = metric[0]/metric[1] return Acc_avg # evaluate_accuracy(net, test_iter) # # 0.0257 4、定义优化算法 1 2 3 4 5 6 # (同线性回归) def sgd(params, lr, batch_size): with torch.no_grad(): for param in params: param -= lr * param.grad / batch_size param.grad.zero_() 5、训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 W = torch.normal(0, 0.01, (784, 10), requires_grad = True) b = torch.zeros(10, requires_grad = True) lr = 0.01 batch_size=256 epoch_metric = [] num_epochs = 10 for epoch in range(num_epochs): train_metric = Accumulator(3) for X, y in train_iter: y_hat = net(X) l = cross_entropy(y_hat, y) l.sum().backward() sgd([W, b], lr, batch_size) train_metric.add(l.sum().item(), accuracy(y_hat, y), len(y)) acc_avg = train_metric[1]/train_metric[2] loss_avg = train_metric[0]/train_metric[2] test_acc_avg = evaluate_accuracy(net, test_iter) epoch_metric.append([loss_avg, acc_avg, test_acc_avg]) print(f\u0026#39;epoch {epoch + 1},train loss {loss_avg:.3f} | train acc {acc_avg:.3f} | test acc {test_acc_avg:.3f}\u0026#39;) import pandas as pd epoch_metric_df = pd.DataFrame(epoch_metric, columns=[\u0026#34;train_loss\u0026#34;,\u0026#34;train_acc\u0026#34;,\u0026#34;test_acc\u0026#34;]) epoch_metric_df.plot.line() 二、torch框架 1 2 3 4 5 import torch import torchvision from torch import nn from torch.utils import data from torchvision import transforms 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 ## (1) 示例数据 def load_data_fashion_minist(batch_size): trans = transforms.ToTensor() mnist_train = torchvision.datasets.FashionMNIST( root=\u0026#34;./data\u0026#34;, train=True, transform=trans, download=True) mnist_test = torchvision.datasets.FashionMNIST( root=\u0026#34;./data\u0026#34;, train=False, transform=trans, download=True) train_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=True) test_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=False) return train_iter, test_iter # batch_size = 256 # train_iter, test_iter = load_data_fashion_minist(batch_size) # X, y = next(iter(train_iter)) # X.shape # # torch.Size([256, 1, 28, 28]) ## (2) 定义模型 net = nn.Sequential(nn.Flatten(), nn.Linear(784, 10)) # len(net) # # 2 # net[1].weight # net[1].bias # y_hat = net(X) # y_hat.shape # # torch.Size([256, 10]) ## (3) 定义损失函数 loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) # loss(y_hat, y).shape # # torch.Size([256]) # 计算1个batch的分类正确数 def accuracy(y_hat, y): y_hat_class = y_hat.argmax(1) # 样本类别预测与否(True/False) cmp = y_hat_class.type(y.dtype) == y return cmp.sum().item() # accuracy(y_hat, y) # # 13 # 定义一个累加值计数器：用以累计1轮epoch所有batch的分类精度 class Accumulator: def __init__(self, n): self.data = [0.0]*n # [0, 0] def add(self, *args): # [0, 0] + [1, 2] = [1, 2] self.data = [a + b for a, b in zip(self.data, args)] def reset(self): self.data = [0.0]*len(self.data) def __getitem__(self, idx): return self.data[idx] # 计算测试集的分类精度 def evaluate_accuracy(net, data_iter): metric = Accumulator(2) with torch.no_grad(): for X, y in data_iter: metric.add(accuracy(net(X), y), len(y)) Acc_avg = metric[0]/metric[1] return Acc_avg # evaluate_accuracy(net, test_iter) # # 0.0515 ## (4) 定义优化算法 net = nn.Sequential(nn.Flatten(), nn.Linear(784, 10)) optimizer = torch.optim.SGD(net.parameters(), lr = 0.1) ## (5) 训练模型 batch_size=256 train_iter, test_iter = load_data_fashion_minist(batch_size) epoch_metric = [] num_epochs = 10 for epoch in range(num_epochs): train_metric = Accumulator(3) net.train() for X, y in train_iter: y_hat = net(X) l = loss(y_hat, y) optimizer.zero_grad() l.mean().backward() optimizer.step() train_metric.add(l.sum().item(), accuracy(y_hat, y), len(y)) acc_avg = train_metric[1]/train_metric[2] loss_avg = train_metric[0]/train_metric[2] net.eval() test_acc_avg = evaluate_accuracy(net, test_iter) epoch_metric.append([loss_avg, acc_avg, test_acc_avg]) print(f\u0026#39;epoch {epoch + 1},train loss {loss_avg:.3f} | train acc {acc_avg:.3f} | test acc {test_acc_avg:.3f}\u0026#39;) import pandas as pd epoch_metric_df = pd.DataFrame(epoch_metric, columns=[\u0026#34;train_loss\u0026#34;,\u0026#34;train_acc\u0026#34;,\u0026#34;test_acc\u0026#34;]) epoch_metric_df.plot.line() 值得注意的是在使用torch框架时，并没有像从零实现那样进行幂函数归一化转换。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/702%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0d2l--02--softmax%E5%A4%9A%E5%88%86%E7%B1%BB/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220731205814540.png\" alt=\"image-20220731205814540\"  /\u003e\r\n\u003c/p\u003e\n\u003ch1 id=\"一从零实现\"\u003e一、从零实现\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torchvision\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torch.utils \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e data\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torchvision \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e transforms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"1示例数据\"\u003e1、示例数据\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##数据集为fashion_minist，10类衣服及对应的图片\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e load_data_fashion_minist(batch_size):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#007f7f\"\u003e#将图片转为张量矩阵\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    trans = transforms.ToTensor()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mnist_train = torchvision.datasets.FashionMNIST(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./data\u0026#34;\u003c/span\u003e, train=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e, transform=trans, download=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mnist_test = torchvision.datasets.FashionMNIST(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./data\u0026#34;\u003c/span\u003e, train=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFalse\u003c/span\u003e, transform=trans, download=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e#生成训练集数据迭代器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e#生成测试集数据迭代器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    test_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFalse\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e train_iter, test_iter\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# batch_size = 256\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# train_iter, test_iter = load_data_fashion_minist(batch_size)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# X, y = next(iter(train_iter))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# X.shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # torch.Size([256, 1, 28, 28])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2定义模型\"\u003e2、定义模型\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e net(X):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# W.shape -- torch.Size([784, 10])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# b.shape -- torch.Size([10])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 全连接层\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    X = torch.matmul(X.reshape((-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e784\u003c/span\u003e)), W) + b\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 激活函数(见上)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    X_softmax = softmax(X)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e X_softmax\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e softmax(X):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 幂函数使数据具有非负性\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    X_exp = torch.exp(X)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    partition = X_exp.sum(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, keepdim=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 归一化，一个样本对于全部类别预测结果和为1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e X_exp/partition\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# W = torch.normal(0, 0.01, (784, 10), requires_grad = True)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# b = torch.zeros(10, requires_grad = True)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# y_hat = net(X)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# y_hat.shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # torch.Size([256, 10])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"3定义损失函数\"\u003e3、定义损失函数\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e cross_entropy(y_hat, y):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 对于某个样本真实类别的预测概率\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    y_hat_target = y_hat[\u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(y_hat)), y]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 负log转换--→ 符合最小化\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e - torch.log(y_hat_target)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# cross_entropy(y_hat, y).shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # torch.Size([256])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 计算分类精度评价指标\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 计算1个batch的分类正确数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e accuracy(y_hat, y):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    y_hat_class = y_hat.argmax(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 样本类别预测与否(True/False)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cmp = y_hat_class.type(y.dtype) == y\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e cmp.sum().item()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# accuracy(y_hat, y)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # 8\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 定义一个累加值计数器：用以累计1轮epoch所有batch的分类精度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eclass\u003c/span\u003e Accumulator:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e __init__(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, n):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.0\u003c/span\u003e]*n\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e# [0, 0]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e add(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, *args):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e# [0, 0] + [1, 2] = [1, 2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data = [a + b \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e a, b in \u003cspan style=\"color:#fff;font-weight:bold\"\u003ezip\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data, args)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e reset(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.0\u003c/span\u003e]*\u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e __getitem__(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, idx):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data[idx]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 计算测试集的分类精度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e evaluate_accuracy(net, data_iter):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    metric = Accumulator(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ewith\u003c/span\u003e torch.no_grad():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e X, y in data_iter:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            metric.add(accuracy(net(X), y), \u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(y))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Acc_avg = metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]/metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e Acc_avg\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# evaluate_accuracy(net, test_iter)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # 0.0257\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"4定义优化算法\"\u003e4、定义优化算法\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (同线性回归)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e sgd(params, lr, batch_size):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#fff;font-weight:bold\"\u003ewith\u003c/span\u003e torch.no_grad():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e param in  params:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tparam -= lr * param.grad / batch_size\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tparam.grad.zero_()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"5训练模型\"\u003e5、训练模型\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eW = torch.normal(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e, (\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e784\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e), requires_grad = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb = torch.zeros(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, requires_grad = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elr = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebatch_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e256\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eepoch_metric = []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enum_epochs = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e epoch in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(num_epochs):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_metric = Accumulator(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e X, y in train_iter:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        y_hat = net(X)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        l = cross_entropy(y_hat, y)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        l.sum().backward()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        sgd([W, b], lr, batch_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        train_metric.add(l.sum().item(), accuracy(y_hat, y), \u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(y))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    acc_avg = train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]/train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    loss_avg = train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]/train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    test_acc_avg = evaluate_accuracy(net, test_iter)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    epoch_metric.append([loss_avg, acc_avg, test_acc_avg])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;epoch \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eepoch + \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e,train loss \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eloss_avg\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.3f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e | train acc \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eacc_avg\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.3f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e | test acc \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003etest_acc_avg\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.3f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eepoch_metric_df = pd.DataFrame(epoch_metric, columns=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train_loss\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train_acc\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test_acc\u0026#34;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eepoch_metric_df.plot.line()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220731211211079.png\" alt=\"image-20220731211211079\" style=\"zoom:80%;\" /\u003e\r\n\u003ch1 id=\"二torch框架\"\u003e二、torch框架\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torchvision\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torch \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e nn\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torch.utils \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e data\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torchvision \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e transforms\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e47\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e48\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e49\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e50\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e51\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e52\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e53\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e54\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e55\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e56\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e57\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e58\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e59\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e60\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e61\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e62\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e63\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e64\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e65\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e66\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e67\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e68\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e69\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e70\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e71\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e72\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e73\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e74\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e75\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e76\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e77\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e78\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e79\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e80\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e81\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e82\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e83\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e84\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e85\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e86\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e87\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e88\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e89\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e90\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e91\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e92\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e93\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e94\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (1) 示例数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e load_data_fashion_minist(batch_size):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    trans = transforms.ToTensor()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mnist_train = torchvision.datasets.FashionMNIST(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./data\u0026#34;\u003c/span\u003e, train=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e, transform=trans, download=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    mnist_test = torchvision.datasets.FashionMNIST(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        root=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./data\u0026#34;\u003c/span\u003e, train=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFalse\u003c/span\u003e, transform=trans, download=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    test_iter = data.DataLoader(mnist_train, batch_size=batch_size, shuffle=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFalse\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e train_iter, test_iter\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# batch_size = 256\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# train_iter, test_iter = load_data_fashion_minist(batch_size)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# X, y = next(iter(train_iter))\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# X.shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # torch.Size([256, 1, 28, 28])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (2) 定义模型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enet = nn.Sequential(nn.Flatten(), nn.Linear(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e784\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# len(net)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # 2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# net[1].weight\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# net[1].bias\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# y_hat = net(X)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# y_hat.shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # torch.Size([256, 10])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (3) 定义损失函数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eloss = nn.CrossEntropyLoss(reduction=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;none\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# loss(y_hat, y).shape\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # torch.Size([256])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 计算1个batch的分类正确数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e accuracy(y_hat, y):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    y_hat_class = y_hat.argmax(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 样本类别预测与否(True/False)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    cmp = y_hat_class.type(y.dtype) == y\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e cmp.sum().item()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# accuracy(y_hat, y)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # 13\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 定义一个累加值计数器：用以累计1轮epoch所有batch的分类精度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eclass\u003c/span\u003e Accumulator:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e __init__(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, n):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.0\u003c/span\u003e]*n\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e# [0, 0]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e add(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, *args):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e# [0, 0] + [1, 2] = [1, 2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data = [a + b \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e a, b in \u003cspan style=\"color:#fff;font-weight:bold\"\u003ezip\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data, args)] \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e reset(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.0\u003c/span\u003e]*\u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e __getitem__(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, idx):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.data[idx]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 计算测试集的分类精度\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e evaluate_accuracy(net, data_iter):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    metric = Accumulator(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ewith\u003c/span\u003e torch.no_grad():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e X, y in data_iter:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            metric.add(accuracy(net(X), y), \u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(y))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    Acc_avg = metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]/metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e Acc_avg\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# evaluate_accuracy(net, test_iter)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# # 0.0515\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (4) 定义优化算法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enet = nn.Sequential(nn.Flatten(), nn.Linear(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e784\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptimizer = torch.optim.SGD(net.parameters(), lr = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## (5) 训练模型\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebatch_size=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e256\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_iter, test_iter = load_data_fashion_minist(batch_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eepoch_metric = []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enum_epochs = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e epoch in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(num_epochs):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_metric = Accumulator(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    net.train()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e X, y in train_iter:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        y_hat = net(X)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        l = loss(y_hat, y)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        optimizer.zero_grad()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        l.mean().backward()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        optimizer.step()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        train_metric.add(l.sum().item(), accuracy(y_hat, y), \u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(y))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    acc_avg = train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]/train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    loss_avg = train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]/train_metric[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    net.eval()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    test_acc_avg = evaluate_accuracy(net, test_iter)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    epoch_metric.append([loss_avg, acc_avg, test_acc_avg])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;epoch \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eepoch + \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e,train loss \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eloss_avg\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.3f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e | train acc \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eacc_avg\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.3f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e | test acc \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003etest_acc_avg\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.3f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eepoch_metric_df = pd.DataFrame(epoch_metric, columns=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train_loss\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train_acc\u0026#34;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test_acc\u0026#34;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eepoch_metric_df.plot.line()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cimg src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220731211938373.png\" alt=\"image-20220731211938373\" style=\"zoom:80%;\" /\u003e\r\n\u003cblockquote\u003e\n\u003cp\u003e值得注意的是在使用torch框架时，并没有像从零实现那样进行幂函数归一化转换。\u003c/p\u003e","title":"深度学习D2L--02--softmax多分类"},{"content":"1、加载库 1 2 3 4 5 6 7 import pandas as pd import torch from torch import nn from torch.nn import functional as F from torch.utils import data import itertools 2、示例数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_train.csv # http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_test.csv train_data = pd.read_csv(\u0026#34;../data/kaggle_house_pred_train.csv\u0026#34;) test_data = pd.read_csv(\u0026#34;../data/kaggle_house_pred_test.csv\u0026#34;) train_data.shape, test_data.shape all_features = pd.concat((train_data.iloc[:, 1:-1], test_data.iloc[:, 1:])) num_features = all_features.dtypes[all_features.dtypes != \u0026#34;object\u0026#34;].index all_features[num_features] = all_features[num_features].apply( lambda x: (x - x.mean()) / (x.std()) ) all_features[num_features] = all_features[num_features].fillna(0) all_features = pd.get_dummies(all_features, dummy_na=True) all_features.shape n_train = train_data.shape[0] train_feats = torch.tensor(all_features[:n_train].values, dtype=torch.float32) test_feats = torch.tensor(all_features[n_train:].values, dtype=torch.float32) train_labels = torch.tensor(train_data.SalePrice.values.reshape((-1,1)), dtype=torch.float32) 3、定义模型框架 1 2 3 4 5 6 7 8 9 10 11 class MLP(nn.Module): def __init__(self, in_feats, hidden_feats, dropout): super().__init__() self.hidden = nn.Linear(in_feats, hidden_feats) self.out = nn.Linear(hidden_feats, 1) self.dropout = nn.Dropout(dropout) def forward(self, X): hiddens = F.relu(self.hidden(X)) output = self.out(self.dropout(hiddens)) return output torch模型基础 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 model = MLP(10, 6, 0.1) model ## 查看torch默认初始化的每一层参数 model.state_dict() model.state_dict().keys() model.state_dict()[\u0026#39;hidden.bias\u0026#39;] model.hidden.bias.data model.out.weight.grad == None #自定义模型参数初始化方式 def init_normal(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, mean=0, std=0.01) nn.init.zeros_(m.bias) model.apply(init_normal) model.state_dict() def xvaier(m): if type(m) == nn.Linear: nn.init.xavier_uniform_(m.weight) model.apply(xvaier) model.state_dict() #保存与加载模型参数 torch.save(model.state_dict(), \u0026#34;mlp.params\u0026#34;) new_model = MLP(10, 6, 0.1) new_model.load_state_dict(torch.load(\u0026#34;mlp.params\u0026#34;)) #GPU加速 nvidia-smi #查看当前系统的GPU情况 watch -n 0.1 -d nvidia-smi #动态刷新查看 torch.cuda.is_available() #是否有GPU资源 torch.cuda.device_count() #查看可用的GPU数量 ##将数据与模型都转移到同一个GPU上 def try_gpu(i=0): if torch.cuda.device_count() \u0026gt;= i + 1 : return torch.device(f\u0026#39;cuda:{i}\u0026#39;) return torch.device(\u0026#34;cpu\u0026#34;) X = torch.ones(2, 3, device = try_gpu(0)) model.to(\u0026#34;cuda:0\u0026#34;) 4、定义损失函数与性能评价方法 1 2 3 4 5 6 loss = nn.MSELoss() def log_rmse(model, feature, labels): clipped_preds = torch.clamp(model(feature), 1, float(\u0026#39;inf\u0026#39;)) rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels))) return rmse.item() 5、小批量训练框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def load_array(data_arrays, batch_size, is_train=True): dataset = data.TensorDataset(*data_arrays) return data.DataLoader(dataset, batch_size, shuffle=is_train) def train(model, train_feats, train_labels, test_feats, test_labels, num_epochs, lr, weight_decay, batch_size): train_ls, test_ls = [],[] #记录每一轮epoch的训练集/测试集性能 train_iter = load_array((train_feats, train_labels), batch_size) optimizer = torch.optim.Adam(model.parameters(), lr = lr, weight_decay=weight_decay) for epoch in range(num_epochs): for X, y in train_iter: optimizer.zero_grad() l = loss(model(X), y) l.backward() optimizer.step() train_ls.append(log_rmse(model, train_feats, train_labels)) if test_labels is not None: test_ls.append(log_rmse(model, test_feats, test_labels)) return train_ls, test_ls 6、K折交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def get_k_fold_data(k, i, X, y): assert k \u0026gt; 1 fold_size = X.shape[0] // k X_train, y_train = None, None for j in range(k): idx = slice(j*fold_size, (j+1)*fold_size) X_part, y_part = X[idx, :], y[idx] if j == i: X_valid, y_valid = X_part, y_part elif X_train is None: X_train, y_train = X_part, y_part else: X_train = torch.cat([X_train, X_part], 0) y_train = torch.cat([y_train, y_part], 0) return X_train, y_train, X_valid, y_valid def k_fold(k, X_train, y_train, num_epochs, learning_rate, weight_decay, batch_size, in_feats, hidden_feats, dropout): train_l_sum, valid_l_sum = 0,0 for i in range(k): data = get_k_fold_data(k, i, X_train, y_train) model = MLP(in_feats, hidden_feats, dropout) train_ls, valid_ls = train(model, *data, num_epochs, learning_rate, weight_decay, batch_size) #将最后一轮的性能作为该模型的最终性能 train_l_sum += train_ls[-1] valid_l_sum += valid_ls[-1] # print(f\u0026#39;Fold-{i+1}, train log rmse {float(train_ls[-1]):f},\u0026#39; # f\u0026#39;valid log rmse {float(valid_ls[-1]):f}\u0026#39;) return train_l_sum / k, valid_l_sum / k # k, num_epochs, learning_rate, weight_decay, batch_size = 10, 100, 5, 0, 64 # in_feats, hidden_feats, dropout = train_feats.shape[1], 64, 0.5 # train_l, valid_l = k_fold(k, train_feats, train_labels, # num_epochs, learning_rate, weight_decay, batch_size, # in_feats, hidden_feats, dropout) 7、超参数遍历 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 k, num_epochs= 5, 100 in_feats = [train_feats.shape[1]] learning_rate = [0.1, 1, 3, 5] weight_decay = [0, 0.001] batch_size = [32, 64] hidden_feats = [16, 64, 128] dropout = [0, 0.1] grid_iter = itertools.product(learning_rate, weight_decay, batch_size, in_feats, hidden_feats, dropout) len_grids = len(list(grid_iter)) grid_train_l, grid_valid_l = [], [] for j, args in enumerate(itertools.product(learning_rate, weight_decay, batch_size, in_feats, hidden_feats, dropout)): print(f\u0026#39;{j+1}--{len_grids}: {args}\u0026#39;) train_l, valid_l = k_fold(k, train_feats, train_labels, num_epochs, *args) grid_train_l.append(train_l) grid_valid_l.append(valid_l) print(f\u0026#39;---- valid rmse {valid_l:.2f}\u0026#39;) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/703%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0d2l--03--k%E6%8A%98%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E7%9A%84torch%E8%AE%AD%E7%BB%83%E5%9F%BA%E7%A1%80%E6%B5%81%E7%A8%8B/","summary":"\u003ch1 id=\"1加载库\"\u003e1、加载库\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torch \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e nn\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torch.nn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e functional \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e F\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torch.utils \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e data\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e itertools\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2示例数据\"\u003e2、示例数据\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_train.csv\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# http://d2l-data.s3-accelerate.amazonaws.com/kaggle_house_pred_test.csv\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_data = pd.read_csv(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;../data/kaggle_house_pred_train.csv\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etest_data = pd.read_csv(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;../data/kaggle_house_pred_test.csv\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_data.shape, test_data.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eall_features = pd.concat((train_data.iloc[:, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e], test_data.iloc[:, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:]))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enum_features = all_features.dtypes[all_features.dtypes != \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;object\u0026#34;\u003c/span\u003e].index\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eall_features[num_features] = all_features[num_features].apply(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003elambda\u003c/span\u003e x: (x - x.mean()) / (x.std())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eall_features[num_features] = all_features[num_features].fillna(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eall_features = pd.get_dummies(all_features, dummy_na=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eall_features.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003en_train = train_data.shape[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_feats = torch.tensor(all_features[:n_train].values, dtype=torch.float32)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etest_feats = torch.tensor(all_features[n_train:].values, dtype=torch.float32)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrain_labels = torch.tensor(train_data.SalePrice.values.reshape((-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)), dtype=torch.float32)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3定义模型框架\"\u003e3、定义模型框架\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eclass\u003c/span\u003e MLP(nn.Module):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e __init__(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, in_feats, hidden_feats, dropout):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003esuper\u003c/span\u003e().__init__()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.hidden = nn.Linear(in_feats, hidden_feats)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.out = nn.Linear(hidden_feats, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.dropout = nn.Dropout(dropout)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e forward(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, X):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        hiddens = F.relu(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.hidden(X))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        output = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.out(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.dropout(hiddens))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e output\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"torch模型基础\"\u003etorch模型基础\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e44\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel = MLP(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 查看torch默认初始化的每一层参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.state_dict()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.state_dict().keys()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.state_dict()[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;hidden.bias\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.hidden.bias.data\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.out.weight.grad == \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#自定义模型参数初始化方式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e init_normal(m):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e(m) == nn.Linear:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        nn.init.normal_(m.weight, mean=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, std=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        nn.init.zeros_(m.bias)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.apply(init_normal)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.state_dict()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e xvaier(m):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e(m) == nn.Linear:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        nn.init.xavier_uniform_(m.weight)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.apply(xvaier)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.state_dict()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#保存与加载模型参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.save(model.state_dict(), \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mlp.params\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enew_model = MLP(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enew_model.load_state_dict(torch.load(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;mlp.params\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#GPU加速\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003envidia-smi    \u003cspan style=\"color:#007f7f\"\u003e#查看当前系统的GPU情况\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewatch -n \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e -d nvidia-smi  \u003cspan style=\"color:#007f7f\"\u003e#动态刷新查看\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.cuda.is_available()   \u003cspan style=\"color:#007f7f\"\u003e#是否有GPU资源\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.cuda.device_count()   \u003cspan style=\"color:#007f7f\"\u003e#查看可用的GPU数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e##将数据与模型都转移到同一个GPU上\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e try_gpu(i=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e torch.cuda.device_count() \u0026gt;= i + \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e :\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e torch.device(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;cuda:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ei\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e torch.device(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;cpu\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX = torch.ones(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, device = try_gpu(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.to(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;cuda:0\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"4定义损失函数与性能评价方法\"\u003e4、定义损失函数与性能评价方法\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eloss = nn.MSELoss()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e log_rmse(model, feature, labels):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    clipped_preds = torch.clamp(model(feature), \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003efloat\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;inf\u0026#39;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    rmse = torch.sqrt(loss(torch.log(clipped_preds),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                          torch.log(labels)))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e rmse.item()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"5小批量训练框架\"\u003e5、小批量训练框架\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e load_array(data_arrays, batch_size, is_train=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    dataset = data.TensorDataset(*data_arrays)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e data.DataLoader(dataset, batch_size, shuffle=is_train)    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e train(model, train_feats, train_labels, test_feats, test_labels,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e          num_epochs, lr, weight_decay, batch_size):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_ls, test_ls = [],[]  \u003cspan style=\"color:#007f7f\"\u003e#记录每一轮epoch的训练集/测试集性能\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_iter = load_array((train_feats, train_labels), batch_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    optimizer = torch.optim.Adam(model.parameters(),\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                lr = lr,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                                weight_decay=weight_decay)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e epoch in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(num_epochs):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e X, y in train_iter:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            optimizer.zero_grad()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            l = loss(model(X), y)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            l.backward()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            optimizer.step()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        train_ls.append(log_rmse(model, train_feats, train_labels))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e test_labels is not \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            test_ls.append(log_rmse(model, test_feats, test_labels))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e train_ls, test_ls\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"6k折交叉验证\"\u003e6、K折交叉验证\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e get_k_fold_data(k, i, X, y):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eassert\u003c/span\u003e k \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    fold_size = X.shape[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e] // k\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    X_train, y_train = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e, \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e j in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(k):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        idx = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eslice\u003c/span\u003e(j*fold_size, (j+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)*fold_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        X_part, y_part = X[idx, :], y[idx]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e j == i:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            X_valid, y_valid = X_part, y_part\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelif\u003c/span\u003e X_train is \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            X_train, y_train = X_part, y_part\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            X_train = torch.cat([X_train, X_part], \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            y_train = torch.cat([y_train, y_part], \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e X_train, y_train, X_valid, y_valid\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e k_fold(k, X_train, y_train, \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           num_epochs, learning_rate, weight_decay, batch_size,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e           in_feats, hidden_feats, dropout):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_l_sum, valid_l_sum = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e i in \u003cspan style=\"color:#fff;font-weight:bold\"\u003erange\u003c/span\u003e(k):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        data = get_k_fold_data(k, i, X_train, y_train)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        model = MLP(in_feats, hidden_feats, dropout)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        train_ls, valid_ls = train(model, *data, num_epochs, learning_rate, weight_decay, batch_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e#将最后一轮的性能作为该模型的最终性能\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        train_l_sum += train_ls[-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        valid_l_sum += valid_ls[-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e# print(f\u0026#39;Fold-{i+1}, train log rmse {float(train_ls[-1]):f},\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#007f7f\"\u003e#      f\u0026#39;valid log rmse {float(valid_ls[-1]):f}\u0026#39;)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e train_l_sum / k, valid_l_sum / k\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# k, num_epochs, learning_rate, weight_decay, batch_size = 10, 100, 5, 0, 64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# in_feats, hidden_feats, dropout = train_feats.shape[1], 64, 0.5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# train_l, valid_l = k_fold(k, train_feats, train_labels, \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                           num_epochs, learning_rate, weight_decay, batch_size,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#                           in_feats, hidden_feats, dropout)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"7超参数遍历\"\u003e7、超参数遍历\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ek, num_epochs= \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ein_feats = [train_feats.shape[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elearning_rate = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eweight_decay = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.001\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebatch_size = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e32\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e64\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehidden_feats = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e16\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e64\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e128\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edropout = [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.1\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_iter = itertools.product(learning_rate, weight_decay, batch_size,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                              in_feats, hidden_feats, dropout)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elen_grids = \u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e(grid_iter))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrid_train_l, grid_valid_l = [], []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e j, args in \u003cspan style=\"color:#fff;font-weight:bold\"\u003eenumerate\u003c/span\u003e(itertools.product(learning_rate, weight_decay, batch_size,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                         in_feats, hidden_feats, dropout)):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ej+\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e--\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003elen_grids\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e: \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eargs\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    train_l, valid_l = k_fold(k, train_feats, train_labels, num_epochs, *args)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    grid_train_l.append(train_l)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    grid_valid_l.append(valid_l)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;---- valid rmse \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003evalid_l\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e:\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e.2f\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"深度学习D2L--03--K折交叉验证的torch训练基础流程"},{"content":" 自动编码器（AE, autoencoder）是应用神经网络进行数据降维的有效方，其结构分为编码器（encoder）与解码器（decoder）两部分；基于损失函数优化使模型的编码器输入数据与解码器输出数据尽可能相一致。中间层数据可视为低维结果。\n变分编码器（VAE, Variational Autoencoder）在上述的基础上，预测低维结果的分布空间（均值~方差），从而避免过拟合的情况。\n代码教程：https://www.kaggle.com/code/schmiddey/variational-autoencoder-with-pytorch-vs-pca/notebook 原理介绍：https://towardsdatascience.com/understanding-variational-autoencoders-vaes-f70510919f73 示例代码：将包含13个特征的红酒数据集(N=178)降维到3维。\n下载地址：https://www.kaggle.com/code/schmiddey/variational-autoencoder-with-pytorch-vs-pca/data\n1、前期准备 加载工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import numpy as np import pandas as pd import torch import torch.nn as nn import torch.nn.functional as F from torch import nn, optim from torch.autograd import Variable from torch.utils.data import Dataset, DataLoader from sklearn import preprocessing device = torch.device(\u0026#39;cuda\u0026#39; if torch.cuda.is_available() else \u0026#39;cpu\u0026#39;) device 2、导入特征数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 df = pd.read_csv(\u0026#34;./STUDY/VAE/kaggle/input/Wine.csv\u0026#34;, header=None) df = df.fillna(-99) df_feat = df.iloc[:, 1:].astype(\u0026#39;float32\u0026#39;) df_feat.shape # (178, 13) ## 数据标准化 standardizer = preprocessing.StandardScaler() df_feat = standardizer.fit_transform(df_feat) ## 准换成可迭代对象 def numpyToTensor(x): x_train = torch.from_numpy(x).to(device) return x_train class DataBuilder(Dataset): def __init__(self, path): self.x, self.standardizer = df_feat, standardizer self.x = numpyToTensor(self.x) self.len=self.x.shape[0] def __getitem__(self,index): return self.x[index] def __len__(self): return self.len data_set=DataBuilder() trainloader=DataLoader(dataset=data_set,batch_size=1024) 3、定义模型框架 按照下述示例进行定义，可根据实际需要进行修改。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 class Autoencoder(nn.Module): def __init__(self,D_in,H=50,H2=12,latent_dim=3): #Encoder super(Autoencoder,self).__init__() self.linear1=nn.Linear(D_in,H) self.lin_bn1 = nn.BatchNorm1d(num_features=H) self.linear2=nn.Linear(H,H2) self.lin_bn2 = nn.BatchNorm1d(num_features=H2) self.linear3=nn.Linear(H2,H2) self.lin_bn3 = nn.BatchNorm1d(num_features=H2) # Latent vectors mu and sigma self.fc1 = nn.Linear(H2, latent_dim) self.bn1 = nn.BatchNorm1d(num_features=latent_dim) self.fc21 = nn.Linear(latent_dim, latent_dim) self.fc22 = nn.Linear(latent_dim, latent_dim) # Sampling vector self.fc3 = nn.Linear(latent_dim, latent_dim) self.fc_bn3 = nn.BatchNorm1d(latent_dim) self.fc4 = nn.Linear(latent_dim, H2) self.fc_bn4 = nn.BatchNorm1d(H2) # Decoder self.linear4=nn.Linear(H2,H2) self.lin_bn4 = nn.BatchNorm1d(num_features=H2) self.linear5=nn.Linear(H2,H) self.lin_bn5 = nn.BatchNorm1d(num_features=H) self.linear6=nn.Linear(H,D_in) self.lin_bn6 = nn.BatchNorm1d(num_features=D_in) self.relu = nn.ReLU() def encode(self, x): lin1 = self.relu(self.lin_bn1(self.linear1(x))) lin2 = self.relu(self.lin_bn2(self.linear2(lin1))) lin3 = self.relu(self.lin_bn3(self.linear3(lin2))) fc1 = F.relu(self.bn1(self.fc1(lin3))) r1 = self.fc21(fc1) r2 = self.fc22(fc1) return r1, r2 def reparameterize(self, mu, logvar): if self.training: std = logvar.mul(0.5).exp_() eps = Variable(std.data.new(std.size()).normal_()) return eps.mul(std).add_(mu) else: return mu def decode(self, z): fc3 = self.relu(self.fc_bn3(self.fc3(z))) fc4 = self.relu(self.fc_bn4(self.fc4(fc3))) lin4 = self.relu(self.lin_bn4(self.linear4(fc4))) lin5 = self.relu(self.lin_bn5(self.linear5(lin4))) return self.lin_bn6(self.linear6(lin5)) def forward(self, x): mu, logvar = self.encode(x) z = self.reparameterize(mu, logvar) # self.decode(z) ist später recon_batch, mu ist mu und logvar ist logvar return self.decode(z), mu, logvar class customLoss(nn.Module): def __init__(self): super(customLoss, self).__init__() self.mse_loss = nn.MSELoss(reduction=\u0026#34;sum\u0026#34;) # x_recon ist der im forward im Model erstellte recon_batch, x ist der originale x Batch, mu ist mu und logvar ist logvar def forward(self, x_recon, x, mu, logvar): loss_MSE = self.mse_loss(x_recon, x) loss_KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp()) return loss_MSE + loss_KLD def weights_init_uniform_rule(m): classname = m.__class__.__name__ # for every Linear layer in a model.. if classname.find(\u0026#39;Linear\u0026#39;) != -1: # get the number of the inputs n = m.in_features y = 1.0/np.sqrt(n) m.weight.data.uniform_(-y, y) m.bias.data.fill_(0) 4、设置参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ## (1) 每层的神经元数量，实例化模型 D_in = data_set.x.shape[1] H = 50 H2 = 12 model = Autoencoder(D_in, H, H2).to(device) model.apply(weights_init_uniform_rule) ## (2) 损失函数 class customLoss(nn.Module): def __init__(self): super(customLoss, self).__init__() self.mse_loss = nn.MSELoss(reduction=\u0026#34;sum\u0026#34;) # x_recon ist der im forward im Model erstellte recon_batch, x ist der originale x Batch, mu ist mu und logvar ist logvar def forward(self, x_recon, x, mu, logvar): loss_MSE = self.mse_loss(x_recon, x) loss_KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp()) return loss_MSE + loss_KLD loss_mse = customLoss() ## (3) 优化器 optimizer = optim.Adam(model.parameters(), lr=1e-3) 5、训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 epochs = 1500 # log_interval = 50 val_losses = [] train_losses = [] def train(epoch): model.train() train_loss = 0 for batch_idx, data in enumerate(trainloader): data = data.to(device) optimizer.zero_grad() recon_batch, mu, logvar = model(data) loss = loss_mse(recon_batch, data, mu, logvar) loss.backward() train_loss += loss.item() optimizer.step() # if batch_idx % log_interval == 0: # print(\u0026#39;Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}\u0026#39;.format( # epoch, batch_idx * len(data), len(trainloader.dataset), # 100. * batch_idx / len(trainloader), # loss.item() / len(data))) if epoch % 200 == 0: print(\u0026#39;====\u0026gt; Epoch: {} Average loss: {:.4f}\u0026#39;.format( epoch, train_loss / len(trainloader.dataset))) train_losses.append(train_loss / len(trainloader.dataset)) for epoch in range(1, epochs + 1): train(epoch) 6、训练结果 （1）比较最后一层输出层与输入数据的一致性 1 2 3 4 5 6 7 8 9 10 11 12 model.eval() test_loss = 0 with torch.no_grad(): for i, data in enumerate(trainloader): data = data.to(device) recon_batch, mu, logvar = model(data) recon_batch.shape() # torch.Size([178, 13]) ## 经逆标准化，生成原来的值，从而进行比较 standardizer.inverse_transform(recon_batch[65].cpu().numpy().reshape(1, -1)) #预测 standardizer.inverse_transform(data[65].cpu().numpy()) #实际 （2）查看降维结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 mu_output = [] logvar_output = [] with torch.no_grad(): for i, (data) in enumerate(trainloader): data = data.to(device) optimizer.zero_grad() recon_batch, mu, logvar = model(data) mu_tensor = mu mu_output.append(mu_tensor) mu_result = torch.cat(mu_output, dim=0) logvar_tensor = logvar logvar_output.append(logvar_tensor) logvar_result = torch.cat(logvar_output, dim=0) mu_result.shape # torch.Size([178, 3]) logvar_result.shape # torch.Size([178, 3]) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/704%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--vae%E5%8F%98%E5%88%86%E8%87%AA%E5%8A%A8%E7%BC%96%E7%A0%81%E5%99%A8/","summary":"\u003cblockquote\u003e\n\u003cp\u003e自动编码器（AE, autoencoder）是应用神经网络进行数据降维的有效方，其结构分为编码器（encoder）与解码器（decoder）两部分；基于损失函数优化使模型的编码器输入数据与解码器输出数据尽可能相一致。中间层数据可视为低维结果。\u003c/p\u003e","title":"深度学习--VAE变分自动编码器"},{"content":"1. 数据操作 1.1 入门 张量：具有多个维度（轴）的数组。\n具有一个轴的张量，对应数学上的向量；\n具有两个轴的张量，对应数学上的矩阵。\n创建张量\n1 2 3 4 5 6 7 8 9 import torch x = torch.arange(12) # 长度为12个行向量 torch.zeros((2, 3, 4)) torch.ones((2, 3, 4)) torch.randn(3, 4) torch.tensor([[2,1,4,3],[1,2,3,4],[4,3,2,1]]) 基本信息 1 2 3 4 5 x.shape x.numel #元素个数 X = x.reshape(3, 4) #修改形状 x.reshape(-1, 4) x.reshape(3, -1) 1.2 运算符 任意两个形状相同的张量，执行基本运算符时，均为按元素操作，结果的形状不变。 1 2 3 4 x = torch.tensor([1.0, 2, 3, 4]) y = torch.tensor([2, 2, 2, 2]) x-y, x+y, x*x, x/y, x**y 张量连接操作concatenate 1 2 3 4 5 x = torch.arange(12, dtype = torch.float32).reshape(3, 4) y = torch.tensor([[2,1,4,3],[1,2,3,4],[4,3,2,1]]) torch.cat((x, y), dim = 0) #纵向拼接，增加轴0的维度/行 torch.cat((x, y), dim = 1) #横向拼接，增加轴1的维度/列 逻辑运算符构建逻辑张量 1 x == y 1.3 广播机制 形状不同的两个张量执行基本运算时，会适当复制元素扩展数组，使二者具有相同形状，再按元素计算 1 2 3 4 5 6 x = torch.arange(6) x + torch.tensor(1) a = torch.arange(3).reshape(3, 1) b = torch.arange(2).reshape(1, 2) a + b 1.4 索引切片 类似Python数组操作 1 2 3 4 X = torch.arange(12).reshape(3, 4) X[-1] #最后一行 X[1:3] #第二、三行 X[:, 1:3] #第二、三列 1.5 节省内存 变量名赋值新的计算结果时，会重新分配内存 1 2 3 4 5 6 a = torch.tensor(0) before = id(a) #内存地址 a = a + torch.tensor(1) # 重新分配内存 id(a) == before # False 原地更新、覆盖先前的计算结果 1 2 3 4 5 a = torch.tensor(0) before = id(a) #内存地址 a[:] = a + torch.tensor(1) id(a) == before 1.6 转为其它Python对象 转为Numpy数组 1 2 3 A = X.numpy() # tensor→numpy torch.tensor(A) # numpy→tensor 大小为1的张量转为Python标量 1 2 3 4 5 a = torch.tensor(3.0) a.item() float(a) int(a) 2. 数据预处理 2.1 读取数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import os import pandas as pd os.makedirs(os.path.join(\u0026#39;..\u0026#39;,\u0026#39;data\u0026#39;), exist_ok=True) #上一级目录创建data文件夹 data_file = os.path.join(\u0026#39;..\u0026#39;, \u0026#39;data\u0026#39;, \u0026#39;house_tiny.csv\u0026#39;) with open(data_file, \u0026#39;w\u0026#39;) as f: f.write(\u0026#39;NumRooms,Alley,Price\\n\u0026#39;) #列名 f.write(\u0026#39;NA,Pave,127500\\n\u0026#39;) #每行一个样本 f.write(\u0026#39;2,NA,106000\\n\u0026#39;) f.write(\u0026#39;4,NA,178100\\n\u0026#39;) f.write(\u0026#39;NA,NA,140000\\n\u0026#39;) data = pd.read_csv(data_file) data 2.2 处理缺失值 1 2 3 4 5 6 7 8 9 inputs, outputs = data.iloc[:, 0:2], data.iloc[:, 2] #按列拆分为两个表 # 数值缺失值填充 inputs = inputs.fillna(inputs.mean(numeric_only=True)) inputs # 类别缺失值填充 inputs = pd.get_dummies(inputs, dummy_na=True, dtype = float) inputs 2.3 转换为张量 1 2 3 4 import torch X, y = torch.tensor(inputs.values), torch.tensor(outputs.values) X, y # 深度学习通常用float32 3. 线性代数 3.1 标量 只有一个元素的张量 普通、小写的字母表示 1 2 3 4 5 6 import torch x = torch.tensor(3.0) y = torch.tensor(4.0) x + y, x - y, x / y, x ** y 3.2 向量 具有一个轴的张量 粗体、小写的字母表示 1 2 3 x = torch.arange(4) x x.shape 向量/轴的维度表示向量或轴的长度；\n张量的维度表示张量具有的轴数。\n3.3 矩阵 具有两个轴的张量 粗体、大写的字母表示 1 2 3 4 5 6 7 A = torch.arange(20).reshape(5, 4) A.shape B = A.T #转置矩阵 ## 对称矩阵，转置后等于转置前 A == A.T 3.4 张量 具有任意数量轴的n维数组 1 2 X = torch.arange(24).reshape(2, 3, 4) X.shape 3.5 张量算法的基本性质 张量与一个标量的基本运算不会改变张量的形状； 相同形状的两个张量运算（按元素）结果仍是相同形状的张量 1 2 3 4 5 6 7 8 a = 2 X = torch.arange(24).reshape(2, 3, 4) X + a A = torch.arange(20, dtype = float32).reshape(5, 4) B = A.clone() #分配新内存，隔离 A, A + B A * B #哈达玛积 3.6 降维 默认调用求和函数会计算张量所有元素的和，返回一个标量 1 2 x = torch.arange(4, dtype = float32) x.sum() 指定轴进行求和，会消除该轴，得到降维结果 1 2 3 A = torch.arange(20, dtype = float32).reshape(5, 4) A.sum(axis = 0) A.sum(axis = 1) .mean()求平均值，操作与上述类似。\n非降维求和，方便应用广播机制（前提是张量的轴数相同） 1 A.sum(axis = 0, keepdims = True) 3.7 点积 两个向量按相同位置乘积的和 1 2 3 4 5 x = torch.arange(4, dtype = float32) y = torch.ones(4, dtype = float32) torch.dot(x, y) # 等价于 torch.sum(x * y) 3.8 矩阵—向量积 矩阵的列数（轴0的维度）等于向量的长度； 矩阵的每一行与向量的点积； 最大的用途：将向量的维度改变 1 2 3 4 A = torch.arange(20, dtype = float32).reshape(5, 4) x = torch.arange(4, dtype = float32) torch.mv(A, x) # length 5 3.9 矩阵乘法 左边矩阵的列数等于右边矩阵的行数 可以理解为右边矩阵的每一行与左边矩阵的计算结果，再拼接为矩阵 1 2 3 4 A = torch.arange(20, dtype = float32).reshape(5, 4) B = torch.ones(4, 3) torch.mm(A, B) #(5, 3) 3.10 范数 范数可以理解为距离大小的度量 向量的L2范数：向量元素平方和的平方根 1 2 u = torch.tensor([3.0, 4.0]) torch.nom(u) 向量的L1范数：向量元素的绝对值之和 1 torch.abs(u).sum() 矩阵的F范数：矩阵元素平方和的平方根 1 torch.norm(torch.ones(4, 9)) 4. 微积分 4.1 导数和微分 微分是一种表达方式，表示当自变量有一个微小变化时，因变量的近似变化。 导数是一个数值，其计算为：对于包含模型参数的损失函数，如果将参数增加或减少一个无穷小的量，损失会以多快的速度增加或减少 导数的几何理解：曲线在特点处的切线的斜率 4.2 偏导数 上述导数计算的(损失)函数中，只有一个自变量（参数）； 当函数有多个变量时，分别对每一个自变量（参数）的导数，称为偏导数； 4.3 梯度 标量y对于向量x（多个自变量）的求导结果是向量； 梯度向量表示一个多元函数对于其每个变量的偏导数，综合指向梯度下降最快的方向。 4.4 链式法则 上述的方法方便理解，但难以计算梯度； 对于复合函数，可应用链式法则求微分； 例如两层MLP神经网络。第一层有n个神经元（x1，x2\u0026hellip;）；第二层有m个神经元（u1，u2，\u0026hellip;），输出层为y。而y对于第一层中任意一个偏导数可以表示为： 5. 自动微分 5.1 简单例子 深度学习会根据模型框架，构建一个计算图，跟踪哪些数据通过那些操作组合起来产生输出； 然后从输出项开始，通过反向传播梯度，计算关于每个参数的偏导数； 1 2 3 4 5 6 7 8 9 10 11 12 import torch x = torch.arange(4.0) # 声明需要储存梯度 x.requires_grad_(True) # 查看梯度，默认值为None x.grad #给定一个函数 y = 2 * torch.dot(x, x) # y = 2[(x1)2 + (x2)2 + (x3)2 + (x4)2] y.backward #反向传播每个参数的偏导数 x.grad #梯度计算结果 计算另一个函数的梯度时，需要清楚之前的值 1 2 3 4 x.grad.zero_() y = x.sum() # y = x1 + x2 + x3 + x4 y.backward() x.grad 5.2 非标量的反向传播 标量y对于向量x的导数是一个向量 向量y对于向量x的导数是一个矩阵 在深度学习应用场景中，多见于小批量样本训练。实现形式并非计算微分矩阵，而是单独计算批量中每个样本的偏导数之和。 1 2 3 4 x.grad.zero_() y = x * x # 向量 y.sum().backward() x.grad 5.3 分离计算 y = f(x)\nz = f(y, x)\n计算z关于x的梯度。但由于某种原因，希望将y视为一个常数，只考虑x在y被计算后的作用。\n1 2 3 4 5 6 7 x.grad.zero_() y = x * x u = y.detach() #视为常数 z = u * x #x的导数为1 z.sum().backward() x.grad() == u 6. 概率 6.1 联合概率 P(A, B)：表示事件A，B同时发生的概率 P(A, B) ≤ P(A)：事件A，B同时发生的概率小于等于事件A或B单独发生的概率 6.2 条件概率 P(B|A)：表示在事件A发生前提下，B发生的概率 P(B|A) = P(A, B) / P(A) 6.3 贝叶斯定理 由条件概率可得：P(A, B) = P(B|A)*P(A) 根据对称性可得：P(A, B) = P(A|B)*P(B) 所以可推导： P(A|B) = P(B|A)*P(A) / P(B) P(A) 称为先验概率 P(A|B)称为后验概率 P(B|A)称为似然 P(B)称为全概率 6.4 边际化 事件B的概率相当于计算A的所有可能选择，并将所有选择的联合概率聚合在一起。 6.5 独立性 若事件A与B是独立的，意味着A的发生与B的发生无关 P(B|A) = P(A, B) / P(A) = P(B) 进一步可得 P(A, B) = P(A) * P(B) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/705d2l-%E7%AC%AC%E4%BA%8C%E7%AB%A0%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86/","summary":"\u003ch1 id=\"1-数据操作\"\u003e1. 数据操作\u003c/h1\u003e\n\u003ch2 id=\"11-入门\"\u003e1.1 入门\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e张量\u003c/strong\u003e：具有多个维度（轴）的数组。\u003c/p\u003e\n\u003cp\u003e具有一个轴的张量，对应数学上的\u003cstrong\u003e向量\u003c/strong\u003e；\u003c/p\u003e\n\u003cp\u003e具有两个轴的张量，对应数学上的\u003cstrong\u003e矩阵\u003c/strong\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e创建张量\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e# 长度为12个行向量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.zeros((\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.ones((\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.randn(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.tensor([[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e],[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e],[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]])\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e基本信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex.numel \u003cspan style=\"color:#007f7f\"\u003e#元素个数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX = x.reshape(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#修改形状\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex.reshape(-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex.reshape(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"12-运算符\"\u003e1.2 运算符\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e任意两个形状相同的张量，执行基本运算符时，均为\u003cstrong\u003e按元素\u003c/strong\u003e操作，结果的形状不变。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = torch.tensor([\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1.0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey = torch.tensor([\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex-y, x+y, x*x, x/y, x**y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e张量连接操作concatenate\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e, dtype = torch.float32).reshape(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey = torch.tensor([[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e],[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e],[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e,\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.cat((x, y), dim = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#纵向拼接，增加轴0的维度/行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.cat((x, y), dim = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#横向拼接，增加轴1的维度/列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e逻辑运算符构建逻辑张量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex == y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"13-广播机制\"\u003e1.3 广播机制\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e形状不同的两个张量执行基本运算时，会适当复制元素扩展数组，使二者具有相同形状，再\u003cstrong\u003e按元素\u003c/strong\u003e计算\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-R\" data-lang=\"R\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e6\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex + torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e).reshape(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e).reshape(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea + b\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"14-索引切片\"\u003e1.4 索引切片\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e类似Python数组操作\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e12\u003c/span\u003e).reshape(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX[-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]  \u003cspan style=\"color:#007f7f\"\u003e#最后一行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] \u003cspan style=\"color:#007f7f\"\u003e#第二、三行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX[:, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e] \u003cspan style=\"color:#007f7f\"\u003e#第二、三列\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"15-节省内存\"\u003e1.5 节省内存\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e变量名赋值新的计算结果时，会重新分配内存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebefore = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eid\u003c/span\u003e(a) \u003cspan style=\"color:#007f7f\"\u003e#内存地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = a + torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e# 重新分配内存\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eid\u003c/span\u003e(a) == before\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# False\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e原地更新、覆盖先前的计算结果\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebefore = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eid\u003c/span\u003e(a) \u003cspan style=\"color:#007f7f\"\u003e#内存地址\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea[:] = a + torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eid\u003c/span\u003e(a) == before\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"16-转为其它python对象\"\u003e1.6 转为其它Python对象\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e转为Numpy数组\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eA = X.numpy() \u003cspan style=\"color:#007f7f\"\u003e# tensor→numpy\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.tensor(A) \u003cspan style=\"color:#007f7f\"\u003e# numpy→tensor\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e大小为1的张量转为Python标量\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea = torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3.0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea.item()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efloat\u003c/span\u003e(a)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eint\u003c/span\u003e(a)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2-数据预处理\"\u003e2. 数据预处理\u003c/h1\u003e\n\u003ch2 id=\"21-读取数据集\"\u003e2.1 读取数据集\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e os\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e pandas \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e pd\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eos.makedirs(os.path.join(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;..\u0026#39;\u003c/span\u003e,\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;data\u0026#39;\u003c/span\u003e), exist_ok=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#上一级目录创建data文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata_file = os.path.join(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;..\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;data\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;house_tiny.csv\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003ewith\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eopen\u003c/span\u003e(data_file, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;w\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e f:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    f.write(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;NumRooms,Alley,Price\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#列名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    f.write(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;NA,Pave,127500\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#每行一个样本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    f.write(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;2,NA,106000\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    f.write(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;4,NA,178100\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    f.write(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;NA,NA,140000\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\\n\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u003c/span\u003e)    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata = pd.read_csv(data_file)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"22-处理缺失值\"\u003e2.2 处理缺失值\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e9\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einputs, outputs = data.iloc[:, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e], data.iloc[:, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e] \u003cspan style=\"color:#007f7f\"\u003e#按列拆分为两个表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 数值缺失值填充\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einputs = inputs.fillna(inputs.mean(numeric_only=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einputs\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 类别缺失值填充\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einputs = pd.get_dummies(inputs, dummy_na=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e, dtype = \u003cspan style=\"color:#fff;font-weight:bold\"\u003efloat\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einputs\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"23-转换为张量\"\u003e2.3 转换为张量\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX, y = torch.tensor(inputs.values), torch.tensor(outputs.values)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eX, y\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 深度学习通常用float32\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3-线性代数\"\u003e3. 线性代数\u003c/h1\u003e\n\u003ch2 id=\"31-标量\"\u003e3.1 标量\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e只有一个元素的张量\u003c/li\u003e\n\u003cli\u003e普通、小写的字母表示\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3.0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ey = torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4.0\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex + y, x - y, x / y, x ** y\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"32-向量\"\u003e3.2 向量\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e具有一个轴的张量\u003c/li\u003e\n\u003cli\u003e粗体、小写的字母表示\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex = torch.arange(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ex.shape\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003e向量/轴的维度表示向量或轴的长度；\u003c/p\u003e","title":"D2L--第二章预备知识"},{"content":"1. 线性回归 1.1 线性回归的基本元素 线性模型：目标(y)可以表示为输入特征的加权和，参数包括权重向量w和偏置b 损失函数：表示目标的实际值与预测值之间的差距；一般数值越小，损失越小。回归问题常用平方误差函数，如下公式。 解析解：可以直接计算梯度为0时的参数值。仅对于线性回归类简单问题存在，大部分深度学习问题不存在。\n随机梯度下降：不断在损失函数递减的方向上更新参数来降低误差。\n在实际应用中，常采用小批量随机梯度下降。\n即随机抽取少量样本(B)，计算该批量的损失均值关于模型参数的导数； 然后，将梯度乘以一个预先确定的正数(η，学习率)，并从当前参数的值中减去（梯度负方向上更新参数）。 这里的B，η为超参数，需要人为指定，不会在训练中更新。模型调参即选择超参数的过程。\n用模型预测：基于训练的模型，预测新的样本的结果。\n1.2 向量化加速 向量化运算可以显著提高运算时间 1 2 3 4 5 6 7 8 9 10 11 n = 10000 a = torch.ones(n) b = torch.ones(n) #一般操作 c = torch.zeros(n) for i in range(n): c[i] = a[i] + b[i] #向量化操作 d = a + b 1.3 正态分布与平方损失 假设线性回归（的噪声）遵循正态分布，我们可以计算通过给定的x样本观测到特定y标签的似然； 根据极大似然估计法，参数w与b的最优值是使得整个数据集的似然最大的值； 由于损失问题通常是最小化计算，因此需要对计算公式取-log转换； 最后可证明在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。 1.4 从线性回归到深度网络 线性回归可以理解为一个单层神经网络；其中每个输入都与每个输出（线性回归只有一个输出）连接。这种变换又称为全连接层，或者稠密层。 线性回归其实早于神经科学。 2. 线性回归从零实现 2.1 生成数据集 生成一个模拟数据集，两个输入特征，一个输出：y = 2x - 3.4z 1 2 3 4 5 6 7 8 9 10 11 def synthetic_data(w, b, num_examples): #@save \u0026#34;\u0026#34;\u0026#34;生成y=Xw+b+噪声\u0026#34;\u0026#34;\u0026#34; X = torch.normal(0, 1, (num_examples, len(w))) # (样本数，特征数)矩阵 y = torch.matmul(X, w) + b\t#广播机制 y += torch.normal(0, 0.01, y.shape) #随机噪声 return X, y.reshape((-1, 1)) #y转置为具有1列的矩阵 true_w = torch.tensor([2, -3.4]) true_b = 4.2 features, labels = synthetic_data(true_w, true_b, 1000) features, labels 2.2 小批量读取数据集 小批量数据迭代生成 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def data_iter(batch_size, features, labels): num_examples = len(features) #总样本数 indices = list(range(num_examples)) # 这些样本是随机读取的，没有特定的顺序 random.shuffle(indices) for i in range(0, num_examples, batch_size): #间隔值 batch_indices = torch.tensor( indices[i: min(i + batch_size, num_examples)]) #min操作主要用于最后一个样本（乱序后） yield features[batch_indices], labels[batch_indices] #yield专门用于生成样本迭代 batch_size = 10 for X, y in data_iter(batch_size, features, labels): print(X, \u0026#39;\\n\u0026#39;, y) break 2.3 初始化参数 随机初始化模型的参数 1 2 w = torch.normal(0, 0.01, size=(2,1), requires_grad=True) b = torch.zeros(1, requires_grad=True) 2.4 定义模型 y = Xw + b 1 2 3 def linreg(X, w, b): #@save \u0026#34;\u0026#34;\u0026#34;线性回归模型\u0026#34;\u0026#34;\u0026#34; return torch.matmul(X, w) + b 2.5 定义损失函数 对于回归问题，常采用平方误差损失函数； 1 2 3 def squared_loss(y_hat, y): #@save \u0026#34;\u0026#34;\u0026#34;均方损失\u0026#34;\u0026#34;\u0026#34; return (y_hat - y.reshape(y_hat.shape)) ** 2 / 2 #确保y的形状与y_hat一致 2.6 定义优化算法 将模型参数按照梯度的反方向更新；更新大小由学习率η决定。 由于是小批量样本的梯度，需要取均值；使其更新步长不受批量的影响 1 2 3 4 5 6 def sgd(params, lr, batch_size): #@save \u0026#34;\u0026#34;\u0026#34;小批量随机梯度下降\u0026#34;\u0026#34;\u0026#34; with torch.no_grad(): #不计算梯度，而是使用梯度结果 for param in params: param -= lr * param.grad / batch_size param.grad.zero_() 2.7 训练 每个epoch扫一次全部的样本，涉及多个小批量（取决于Batch大小）； （1）计算小批量的损失 （2）计算参数的梯度 （3）更新参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 lr = 0.03 num_epochs = 3 net = linreg loss = squared_loss for epoch in range(num_epochs): for X, y in data_iter(batch_size, features, labels): l = loss(net(X, w, b), y) # X和y的小批量损失【列向量】 # 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起， # 并以此计算关于[w,b]的梯度 l.sum().backward() sgd([w, b], lr, batch_size) # 使用参数的梯度更新参数 with torch.no_grad(): #每个epoch结束后，返回当前模型的损失 train_l = loss(net(features, w, b), labels) print(f\u0026#39;epoch {epoch + 1}, loss {float(train_l.mean()):f}\u0026#39;) 3. 线性回归的简洁实现 在Pytorch中，对于数据迭代器、损失函数、优化器和神经网络都有简单、高效的实现方式\n3.1 生成数据集 操作步骤同前 1 2 3 4 5 6 7 8 import numpy as np import torch from torch.utils import data from d2l import torch as d2l true_w = torch.tensor([2, -3.4]) true_b = 4.2 features, labels = d2l.synthetic_data(true_w, true_b, 1000) 3.2 读取数据集 调用Pytorch的数据迭代器 1 2 3 4 5 6 7 8 9 def load_array(data_arrays, batch_size, is_train=True): #@save \u0026#34;\u0026#34;\u0026#34;构造一个PyTorch数据迭代器\u0026#34;\u0026#34;\u0026#34; dataset = data.TensorDataset(*data_arrays) return data.DataLoader(dataset, batch_size, shuffle=is_train) batch_size = 10 data_iter = load_array((features, labels), batch_size) next(iter(data_iter)) #获取、打印一个小批量数据 3.3 定义模型 Sequential类可以将多个神经网络层串联在一起； Linear类用于定义全连接层，其中第一个参数指定输入特征形状；第二个参数指定输出特征形状。 1 2 3 4 5 # nn是神经网络的缩写 from torch import nn net = nn.Sequential(nn.Linear(2, 1)) net 3.4 初始化模型参数 1 2 3 4 5 6 net[0] #第一层 net[0].weight.data.normal_(0, 0.01) net[0].bias.data.fill_(0) net[0].weight.data net[0].bias.data 3.5 定义损失函数 1 loss = nn.MSELoss() 3.6 定义优化算法 SGD小批量随机梯度下降算法，交代模型参数以及学习率 1 trainer = torch.optim.SGD(net.parameters(), lr=0.03) 3.7 训练 逻辑与2.7类似 迭代小批量样本 计算损失 计算梯度 参数更新 1 2 3 4 5 6 7 8 9 num_epochs = 3 for epoch in range(num_epochs): for X, y in data_iter: l = loss(net(X) ,y) #计算损失 trainer.zero_grad()\tl.backward() #计算梯度 trainer.step() #更新参数 l = loss(net(features), labels) print(f\u0026#39;epoch {epoch + 1}, loss {l:f}\u0026#39;) 4. softmax回归 4.1 分类问题 独热编码用于表示分类数据； 其本质为一个向量，元素分量与类别数一样多； 对于某个具体样本，真实类别对应的分量为1，其它分量为0。 4.2 网络架构 具有多个输出的单层神经网络模型，以分别估计每个类别的概率； 基于全连接层的特性，所有输入特征都与每个输出建立关系； 4.3 全连接层的参数开销 若具有d个（特征）输入，q的输出（类别）的全连接层，则参数开销为O(dq) 4.4 softmax运算 将模型输出结果视为概率的前提是（1）非负，（2）和为1； Softmax操作可以将输出进行转换，满足上述条件。（1）首先将输出结果求幂（2）每个求幂的结果除以结果的总和； 虽然softmax是一个非线性函数，但softmax回归的输出还是由输出特征的全连接层得到的，因此softmax回归是线性模型\n4.5 小批量样本的向量化 对于具有n个样本，特征维度为d，类别数为q的小批量数据：\n特征矩阵X： n × d 权重W：d × q 偏置b：1 × q 输出结果O：n × q 4.6 损失函数 多分类问题常使用交叉熵作为损失函数，其只关心（最大化）对于正确类别预测的预测概率； 此外，也可从信息论的角度理解交叉熵损失，详见教材3.4.7小结\n5 图像分类数据集 Fashion-MNIST数据集：10个类别图像组成；6000个训练样本，1000个测试样本 1 2 3 4 5 6 7 8 %matplotlib inline import torch import torchvision from torch.utils import data from torchvision import transforms from d2l import torch as d2l d2l.use_svg_display() 5.1 读取数据集 下载到本地上一级的data目录下 1 2 3 4 5 6 7 8 9 10 11 12 # 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式， # 并除以255使得所有像素的数值均在0～1之间 trans = transforms.ToTensor() mnist_train = torchvision.datasets.FashionMNIST( root=\u0026#34;../data\u0026#34;, train=True, transform=trans, download=True) mnist_test = torchvision.datasets.FashionMNIST( root=\u0026#34;../data\u0026#34;, train=False, transform=trans, download=True) len(mnist_train) #6000 len(mnist_train[0]) #2,长度为2的tuple mnist_train[0][0].shape #特征形状 [1, 28, 28] mnist_train[0][1] #样本类别 5.2 读取小批量 参考3.2，使用Pytorch的Dataloader类 1 2 3 4 5 6 7 8 9 10 batch_size = 256 def get_dataloader_workers(): #@save \u0026#34;\u0026#34;\u0026#34;使用4个进程来读取数据\u0026#34;\u0026#34;\u0026#34; return 4 train_iter = data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers()) next(iter(train_iter)) 5.3 整合所有组件 合并上述操作于一个函数 resize参数表示调整，修改图片的形状 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def load_data_fashion_mnist(batch_size, resize=None): #@save \u0026#34;\u0026#34;\u0026#34;下载Fashion-MNIST数据集，然后将其加载到内存中\u0026#34;\u0026#34;\u0026#34; trans = [transforms.ToTensor()] if resize: trans.insert(0, transforms.Resize(resize)) trans = transforms.Compose(trans) mnist_train = torchvision.datasets.FashionMNIST( root=\u0026#34;../data\u0026#34;, train=True, transform=trans, download=True) mnist_test = torchvision.datasets.FashionMNIST( root=\u0026#34;../data\u0026#34;, train=False, transform=trans, download=True) return (data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers()), data.DataLoader(mnist_test, batch_size, shuffle=False, num_workers=get_dataloader_workers())) train_iter, test_iter = load_data_fashion_mnist(32, resize=64) for X, y in train_iter: print(X.shape, X.dtype, y.shape, y.dtype) break 6 softmax回归的从零开始实现 设置数据迭代器的批量大小为256 1 2 3 4 5 6 import torch from IPython import display from d2l import torch as d2l batch_size = 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) 6.1 初始化模型参数 这里将每个样本视为长度为784的向量 1 2 3 4 5 num_inputs = 784 # 1 * 28 * 28 num_outputs = 10 W = torch.normal(0, 0.01, size=(num_inputs, num_outputs), requires_grad=True) b = torch.zeros(num_outputs, requires_grad=True) 6.2 定义Softmax操作 （1）非负；（2）和为1 1 2 3 4 5 6 7 8 def softmax(X): X_exp = torch.exp(X) # 求幂 partition = X_exp.sum(1, keepdim=True) #得到了列向量，表示每一行的和 return X_exp / partition # 这里应用了广播机制 X = torch.normal(0, 1, (2, 5)) X_prob = softmax(X) X_prob, X_prob.sum(1) 6.3 定义模型 先计算原始计算结果；在进行softmax转换 1 2 3 4 X.reshape((-1, W.shape[0])).shape # [256, 784] def net(X): return softmax(torch.matmul(X.reshape((-1, W.shape[0])), W) + b) 6.4 定义损失函数 参考4.6步骤，交叉熵损失函数主要计算模型对于真实标签类别的负对数似然 1 2 3 4 5 6 7 8 # 表示真实类别的预测概率 y = torch.tensor([0, 2]) y_hat = torch.tensor([[0.1, 0.3, 0.6], [0.3, 0.2, 0.5]]) y_hat[[0, 1], y] def cross_entropy(y_hat, y): return - torch.log(y_hat[range(len(y_hat)), y]) cross_entropy(y_hat, y) 6.5 分类精度 通常取预测概率最高的类别作为预测结果； 分类精度是正确预测数与预测总数之比。 1 2 3 4 5 6 7 8 def accuracy(y_hat, y): #@save \u0026#34;\u0026#34;\u0026#34;计算预测正确的数量\u0026#34;\u0026#34;\u0026#34; if len(y_hat.shape) \u0026gt; 1 and y_hat.shape[1] \u0026gt; 1: y_hat = y_hat.argmax(axis=1) #沿轴1，最大值元素所对应的位置 cmp = y_hat.type(y.dtype) == y #逻辑值 return float(cmp.type(y.dtype).sum()) #求和 accuracy(y_hat, y) / len(y) 对于数据迭代器，评估其在全部数据集的精度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def evaluate_accuracy(net, data_iter): #@save \u0026#34;\u0026#34;\u0026#34;计算在指定数据集上模型的精度\u0026#34;\u0026#34;\u0026#34; if isinstance(net, torch.nn.Module): net.eval() # 将模型设置为评估模式 metric = Accumulator(2) # 正确预测数、预测总数 with torch.no_grad(): for X, y in data_iter: #每次迭代一次小批量，分别累加正确预测数、预测总数 metric.add(accuracy(net(X), y), y.numel()) return metric[0] / metric[1] class Accumulator: #@save \u0026#34;\u0026#34;\u0026#34;在n个变量上累加\u0026#34;\u0026#34;\u0026#34; def __init__(self, n): self.data = [0.0] * n def add(self, *args): self.data = [a + float(b) for a, b in zip(self.data, args)] def reset(self): self.data = [0.0] * len(self.data) def __getitem__(self, idx): return self.data[idx] 6.6 训练 定义一个函数训练一轮 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def train_epoch_ch3(net, train_iter, loss, updater): #@save \u0026#34;\u0026#34;\u0026#34;训练模型一个迭代周期（定义见第3章）\u0026#34;\u0026#34;\u0026#34; # 将模型设置为训练模式 if isinstance(net, torch.nn.Module): net.train() # 训练损失总和、训练准确度总和、样本数 metric = Accumulator(3) for X, y in train_iter: # 计算梯度并更新参数 y_hat = net(X) l = loss(y_hat, y) if isinstance(updater, torch.optim.Optimizer): # 使用PyTorch内置的优化器和损失函数 updater.zero_grad() l.mean().backward() updater.step() else: # 使用定制的优化器和损失函数 l.sum().backward() updater(X.shape[0]) metric.add(float(l.sum()), accuracy(y_hat, y), y.numel()) # 返回训练损失和训练精度 return metric[0] / metric[2], metric[1] / metric[2] 定义一个训练函数，会运行多个epoch。每个epoch训练完，会评估在test测试数据的效果 1 2 3 4 5 6 7 8 9 10 11 12 def train_ch3(net, train_iter, test_iter, loss, num_epochs, updater): #@save \u0026#34;\u0026#34;\u0026#34;训练模型（定义见第3章）\u0026#34;\u0026#34;\u0026#34; animator = Animator(xlabel=\u0026#39;epoch\u0026#39;, xlim=[1, num_epochs], ylim=[0.3, 0.9], legend=[\u0026#39;train loss\u0026#39;, \u0026#39;train acc\u0026#39;, \u0026#39;test acc\u0026#39;]) for epoch in range(num_epochs): train_metrics = train_epoch_ch3(net, train_iter, loss, updater) test_acc = evaluate_accuracy(net, test_iter) animator.add(epoch + 1, train_metrics + (test_acc,)) train_loss, train_acc = train_metrics assert train_loss \u0026lt; 0.5, train_loss assert train_acc \u0026lt;= 1 and train_acc \u0026gt; 0.7, train_acc assert test_acc \u0026lt;= 1 and test_acc \u0026gt; 0.7, test_acc 优化函数 1 2 3 4 lr = 0.1 def updater(batch_size): return d2l.sgd([W, b], lr, batch_size) 开始训练 1 2 num_epochs = 10 train_ch3(net, train_iter, test_iter, cross_entropy, num_epochs, updater) 7. softmax回归的简洁实现 设置数据迭代器的批量大小为256 1 2 3 4 5 6 import torch from IPython import display from d2l import torch as d2l batch_size = 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) 7.1 初始化模型参数 1 2 3 4 5 6 7 8 9 # PyTorch不会隐式地调整输入的形状。因此， # 我们在线性层前定义了展平层（flatten），来调整网络输入的形状 net = nn.Sequential(nn.Flatten(), nn.Linear(784, 10)) def init_weights(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, std=0.01) net.apply(init_weights); 7.2 损失函数 1 loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) 7.3 优化算法 1 trainer = torch.optim.SGD(net.parameters(), lr=0.1) 7.4 训练 1 2 num_epochs = 10 d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/706d2l-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","summary":"\u003ch1 id=\"1-线性回归\"\u003e1. 线性回归\u003c/h1\u003e\n\u003ch2 id=\"11-线性回归的基本元素\"\u003e1.1 线性回归的基本元素\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e线性模型：目标(y)可以表示为输入特征的加权和，参数包括权重向量\u003cstrong\u003ew\u003c/strong\u003e和偏置b\u003c/li\u003e\n\u003cli\u003e损失函数：表示目标的实际值与预测值之间的差距；一般数值越小，损失越小。回归问题常用平方误差函数，如下公式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240720171253170.png\" alt=\"image-20240720171253170\"  /\u003e\r\n\u003c/p\u003e","title":"D2L--第三章线性神经网络"},{"content":"1. 多层感知机 1.1 隐藏层 之前所学的线性模型意味着单调假设，并不适用于更复杂的建模问题，例如体温与疾病；图片某个像素点的强度与猫或狗的关系等； 多层感知机（MLP）：在输入层与输出层之间加入一个或多个隐藏层，以学习更加复杂的模型情况； 只有隐藏层与输出层涉及到神经元计算与参数更新，因此如下示例MLP的层数是2； 对于其中的隐藏层需要应用非线性的激活函数（σ），以突破对仍为线性本质的限制。 对于n个样本，d个特征的输入X (n×d)。中间隐藏层的神经元个数为h，权重参数为W1(d×h)，偏置参数为b1(1×h)。输出层神经元个数为q，权重参数为W2(h×q)，偏置参数为b2(1×q)。 1.2 激活函数 1 2 3 %matplotlib inline import torch from d2l import torch as d2l （1）ReLu函数\n变换方式：隐藏层输出的结果若为负数，变为0；正数保持不变； 实现简单，表现良好。 1 2 3 4 5 6 7 8 9 x = torch.arange(-8.0, 8.0, 0.1, requires_grad=True) y = torch.relu(x) # 绘制激活前（x）与后（y） d2l.plot(x.detach(), y.detach(), \u0026#39;x\u0026#39;, \u0026#39;relu(x)\u0026#39;, figsize=(5, 2.5)) # 计算激活函数的导数 y.backward(torch.ones_like(x), retain_graph=True) d2l.plot(x.detach(), x.grad, \u0026#39;x\u0026#39;, \u0026#39;grad of relu\u0026#39;, figsize=(5, 2.5)) 不要太纠结x=0的情况—“如果微妙的边界条件很重要，我们很可能是在研究数学而非工程”\n（2）sigmoid函数\n变换方式：隐藏层输出的结果变换到0与1之间； 如今在隐藏层中已经不常用，多用于二分类问题中输出层的激活函数 1 2 3 4 5 6 7 8 # 绘制激活前（x）与后（y） y = torch.sigmoid(x) d2l.plot(x.detach(), y.detach(), \u0026#39;x\u0026#39;, \u0026#39;sigmoid(x)\u0026#39;, figsize=(5, 2.5)) # 计算激活函数的导数 x.grad.data.zero_() y.backward(torch.ones_like(x),retain_graph=True) d2l.plot(x.detach(), x.grad, \u0026#39;x\u0026#39;, \u0026#39;grad of sigmoid\u0026#39;, figsize=(5, 2.5)) （3）tanh函数（双曲正切）\n变换方式：隐藏层输出的结果变换到-1与1之间； 1 2 3 4 5 6 7 8 # 绘制激活前（x）与后（y） y = torch.tanh(x) d2l.plot(x.detach(), y.detach(), \u0026#39;x\u0026#39;, \u0026#39;tanh(x)\u0026#39;, figsize=(5, 2.5)) # 计算激活函数的导数 x.grad.data.zero_() y.backward(torch.ones_like(x),retain_graph=True) d2l.plot(x.detach(), x.grad, \u0026#39;x\u0026#39;, \u0026#39;grad of tanh\u0026#39;, figsize=(5, 2.5)) 2. 多层感知机的从零实现 1 2 3 4 5 6 import torch from torch import nn from d2l import torch as d2l batch_size = 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) 2.1 初始化模型参数 1 2 3 4 5 6 7 8 9 10 11 num_inputs, num_outputs, num_hiddens = 784, 10, 256 # 隐藏层 W1 = nn.Parameter(torch.randn( num_inputs, num_hiddens, requires_grad=True) * 0.01) b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True)) # 输出层 W2 = nn.Parameter(torch.randn( num_hiddens, num_outputs, requires_grad=True) * 0.01) b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True)) params = [W1, b1, W2, b2] 2.2 激活函数 自定义ReLu函数 1 2 3 def relu(X): a = torch.zeros_like(X) return torch.max(X, a) 2.3 模型 2层MLP结构 1 2 3 4 def net(X): X = X.reshape((-1, num_inputs)) H = relu(X@W1 + b1) # 这里“@”代表矩阵乘法 return (H@W2 + b2) 2.4 损失函数 交叉熵损失函数 1 loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) 2.5 训练 调用第三章的训练函数 1 2 3 num_epochs, lr = 10, 0.1 updater = torch.optim.SGD(params, lr=lr) d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, updater) 3. 多层感知机的简洁实现 1 2 3 import torch from torch import nn from d2l import torch as d2l 1 2 3 4 5 6 7 8 9 10 11 12 # 模型结构 net = nn.Sequential(nn.Flatten(), nn.Linear(784, 256), nn.ReLU(), #激活函数 nn.Linear(256, 10)) # 参数初始化 def init_weights(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, std=0.01) net.apply(init_weights); 1 2 3 4 5 6 7 8 batch_size, lr, num_epochs = 256, 0.1, 10 loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) trainer = torch.optim.SGD(net.parameters(), lr=lr) train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer) 4. 模型欠拟合和过拟合 4.1 训练误差和泛化误差 训练误差：模型在训练数据集上计算得到的误差； 泛化误差：模型应用在同样从原始样本的分布中抽取的无限多数据样本时，模型误差的期望（理论）； 过拟合：模型在训练数据上拟合的比在潜在分布中更接近的现象。 影响模型泛化的因素： （1）参数数量：可调整参数的数量越多，越容易过拟合； （2）参数取值：参数的取值范围越大，越容易过拟合； （3）训练样本的数量：原则上，训练样本越少，越容易过拟合。【DL至少要上千样本】 4.2 模型选择 比较不同超参数设置下的同一类模型，会涉及到数据集的多种划分方式。 方式1：将数据分为3份 训练数据集用于训练模型 验证数据集用于比较、选择模型 测试数据集用于最终的泛化评估（联想高考） 在代码实现部分，教材所写的测试集其实还是验证集。\n方式2：K折交叉验证（样本量不多时） 将数据分为K个子集 每次选取K-1个子集训练，在剩余的一个自己验证； 取K次实验的均值。 在DL中，由于训练成本较高，不会太常用；在ML中常用。\n4.3 欠拟合还是过拟合 欠拟合 训练误差与验证误差都很大，差距较小； 模型可能过于简单，有理由相信可训练更复杂的模型减小训练误差 过拟合 训练误差明显小于验证误差； 值得注意，过拟合并不总是坏事。最终还是更关心验证误差。 4.4 多项式回归 教材中举了一个例子直观的解释了模型复杂度（参数数量）对于模型拟合的影响。 首先生成了200个样本的20个特征数据；特征分别来自于0~19次幂的结果，而真实的标签y仅来自如下图所示的前四个多项式。 第一次训练：取前4列特征，拟合正常； 第二次训练：取前2列特征，欠拟合（参数过少）； 第三次训练：取全部20列数据，过拟合（参数过多）。 详见教材代码：https://zh-v2.d2l.ai/chapter_multilayer-perceptrons/underfit-overfit.html 5. 权重衰减 5.1 范数与权重衰减 模型复杂度的影响因素之一是参数的大小取值范围，可通过L2范数衡量； 可将参数的范数作为惩罚项，和预测损失共同作为最小化的训练目标； 如下公式，具体可通过正则化常数λ控制惩罚项的影响程度。 较小的λ值对w约束较小； 较大的λ值对w约束较大； 通常，网络输出层的偏置项不会被正则化。\n5.2 高维线性回归 模拟数据，在5.3演示权重衰减的作用 1 2 3 4 5 6 7 8 9 # 训练样本数(20)较少，输入特征较多(200)，容易过拟合 n_train, n_test, num_inputs, batch_size = 20, 100, 200, 5 true_w, true_b = torch.ones((num_inputs, 1)) * 0.01, 0.05 train_data = d2l.synthetic_data(true_w, true_b, n_train) train_iter = d2l.load_array(train_data, batch_size) test_data = d2l.synthetic_data(true_w, true_b, n_test) test_iter = d2l.load_array(test_data, batch_size, is_train=False) 5.3 从零开始实现 初始化模型参数 1 2 3 4 def init_params(): w = torch.normal(0, 1, size=(num_inputs, 1), requires_grad=True) b = torch.zeros(1, requires_grad=True) return [w, b] 定义L2范数 1 2 3 4 5 6 def l2_penalty(w): return torch.sum(w.pow(2)) / 2 ## L1范数 # def l1_penalty(w): # return torch.sum(torch.abs(w)) 定义训练代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def train(lambd): w, b = init_params() net, loss = lambda X: d2l.linreg(X, w, b), d2l.squared_loss #模型输出，损失函数 num_epochs, lr = 100, 0.003 animator = d2l.Animator(xlabel=\u0026#39;epochs\u0026#39;, ylabel=\u0026#39;loss\u0026#39;, yscale=\u0026#39;log\u0026#39;, xlim=[5, num_epochs], legend=[\u0026#39;train\u0026#39;, \u0026#39;test\u0026#39;]) for epoch in range(num_epochs): for X, y in train_iter: # 增加了L2范数惩罚项， # 广播机制使l2_penalty(w)成为一个长度为batch_size的向量 l = loss(net(X), y) + lambd * l2_penalty(w) l.sum().backward() d2l.sgd([w, b], lr, batch_size) if (epoch + 1) % 5 == 0: animator.add(epoch + 1, (d2l.evaluate_loss(net, train_iter, loss), d2l.evaluate_loss(net, test_iter, loss))) print(\u0026#39;w的L2范数是：\u0026#39;, torch.norm(w).item()) 训练 1 2 3 4 5 6 7 ## (1) 忽略正则化直接训练：左图 train(lambd=0) # w的L2范数是： 12.963241577148438 ## (2) 使用权重衰减：右图 train(lambd=3) # w的L2范数是： 0.04280993342399597 5.4 简洁实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def train_concise(wd): net = nn.Sequential(nn.Linear(num_inputs, 1)) for param in net.parameters(): param.data.normal_() loss = nn.MSELoss(reduction=\u0026#39;none\u0026#39;) num_epochs, lr = 100, 0.003 # 偏置参数没有衰减 trainer = torch.optim.SGD([ {\u0026#34;params\u0026#34;:net[0].weight,\u0026#39;weight_decay\u0026#39;: wd}, {\u0026#34;params\u0026#34;:net[0].bias}], lr=lr) animator = d2l.Animator(xlabel=\u0026#39;epochs\u0026#39;, ylabel=\u0026#39;loss\u0026#39;, yscale=\u0026#39;log\u0026#39;, xlim=[5, num_epochs], legend=[\u0026#39;train\u0026#39;, \u0026#39;test\u0026#39;]) for epoch in range(num_epochs): for X, y in train_iter: trainer.zero_grad() l = loss(net(X), y) l.mean().backward() trainer.step() if (epoch + 1) % 5 == 0: animator.add(epoch + 1, (d2l.evaluate_loss(net, train_iter, loss), d2l.evaluate_loss(net, test_iter, loss))) print(\u0026#39;w的L2范数：\u0026#39;, net[0].weight.norm().item()) 1 2 3 train_concise(0) train_concise(3) 沐神推荐，一般可设置weight_decay为0.01, 0.001, 0.0001\n6. 暂退法 6.1 扰动的稳健性 防止模型过拟合的另一个角度是增加平滑性，不会对输入的微小变化敏感； 暂退法是在前向传播过程中，计算每一内部层的同时引入噪声，表现为随机丢弃(drop out)一些神经元; 在标准暂退法正则化中，每个中间隐藏层的激活值h以暂退概率p被随机变量*h\u0026rsquo;*替换。 上述公式表示按一种无偏向的方式引入噪声，每层的期望值等于没有噪音的值。\n6.2 实践中的暂退法 暂退法仅用于隐藏层的(激活后)输出结果中，使得不过度依赖隐藏层中的任意一个元素； 仅在训练过程中使用Dropout，在预测过程中不需要使用； Dropout多应用于MLP神经网络，而较少应用于CNN等 6.3 从零开始实现 自定义dropout函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import torch from torch import nn from d2l import torch as d2l def dropout_layer(X, dropout): assert 0 \u0026lt;= dropout \u0026lt;= 1 # 在本情况中，所有元素都被丢弃 if dropout == 1: return torch.zeros_like(X) # 在本情况中，所有元素都被保留 if dropout == 0: return X # torch.rand生成随机数 mask = (torch.rand(X.shape) \u0026gt; dropout).float() #逻辑值 return mask * X / (1.0 - dropout) #丢弃逻辑值为FALSE的结果 # 演示 X= torch.arange(16, dtype = torch.float32).reshape((2, 8)) print(X) print(dropout_layer(X, 0.)) print(dropout_layer(X, 0.5)) print(dropout_layer(X, 1.)) 定义模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 参数：输入输出层，两层隐藏层 num_inputs, num_outputs, num_hiddens1, num_hiddens2 = 784, 10, 256, 256 # Dropout dropout1, dropout2 = 0.3, 0.5 # 定义了一个神经网络类 Net，该类继承自 PyTorch 的 nn.Module class Net(nn.Module): def __init__(self, num_inputs, num_outputs, num_hiddens1, num_hiddens2, is_training = True): super(Net, self).__init__() #调用父类 nn.Module 的构造函数来初始化当前类 Net 的实例 self.num_inputs = num_inputs self.training = is_training self.lin1 = nn.Linear(num_inputs, num_hiddens1) self.lin2 = nn.Linear(num_hiddens1, num_hiddens2) self.lin3 = nn.Linear(num_hiddens2, num_outputs) self.relu = nn.ReLU() def forward(self, X): H1 = self.relu(self.lin1(X.reshape((-1, self.num_inputs)))) # 只有在训练模型时才使用dropout if self.training == True: # 在第一个全连接层之后添加一个dropout层 H1 = dropout_layer(H1, dropout1) H2 = self.relu(self.lin2(H1)) if self.training == True: # 在第二个全连接层之后添加一个dropout层 H2 = dropout_layer(H2, dropout2) out = self.lin3(H2) return out net = Net(num_inputs, num_outputs, num_hiddens1, num_hiddens2) 训练测试 1 2 3 4 5 6 num_epochs, lr, batch_size = 10, 0.5, 256 loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) trainer = torch.optim.SGD(net.parameters(), lr=lr) d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer) #左图 右图：Dropout均设为0的训练结果。\n6.4 简洁实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 net = nn.Sequential(nn.Flatten(), nn.Linear(784, 256), nn.ReLU(), # 在第一个全连接层/激活函数之后添加一个dropout层 nn.Dropout(dropout1), nn.Linear(256, 256), nn.ReLU(), # 在第二个全连接层/激活函数之后添加一个dropout层 nn.Dropout(dropout2), nn.Linear(256, 10)) def init_weights(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, std=0.01) net.apply(init_weights); trainer = torch.optim.SGD(net.parameters(), lr=lr) d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer) 7. 前向传播、后向传播和计算图 7.1 前向传播 前向传播：按顺序（从输入到输出）计算和存储神经网络中每层的结果； 如下图举例（简单起见，隐藏层不包括偏置项b） 输入层：x 隐藏层：参数W(1)，输出结果z；激活函数(Φ)输出结果h 输出层：参数W(2)，输出结果o 预测损失：L = l(o, y) 惩罚项：s ~ W(1), W(2) 目标函数（正则化损失）：J = L + s 7.2 反向传播 反向传播：从输出层到输入层计算和存储神经网络的参数梯度； 如上示例 首先计算J分别关于L与s的梯度； 然后可计算J关于o的梯度，s关于W(1)、W(2)的梯度； 再依次计算J关于W(2)的梯度，J关于h的梯度，J关于z的梯度，J关于W(1)的梯度 7.3 训练神经网络 前向传播与反向传播相互依赖； 例如 前向传播计算的正则化项s取决于模型w1与w2的当前值，由优化算法根据最近迭代的反向传播给出的； 反向传播参数的梯度计算，取决于由前向传播给出的隐藏变量h的当前值。 反向传播需要重复利用前向传播中储存的中间值，副作用是需要暂用较多的内存。 8. 数值稳定性和模型初始化 8.1 梯度消失与梯度爆炸 向量对于向量的梯度为矩阵。当计算目标函数对于特定隐藏层参数的导数可能涉及多个矩阵的乘积。 梯度消失：参数更新过小，在每次更新时几乎不会移动，导致模型无法学习 一个常见的例子是Sigmoid函数，参考上述2.2部分介绍 当Sigmoid函数的输入与输出很大或很小时，梯度近乎消失。 梯度爆炸：参数更新过大，破坏了模型的稳定收敛 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import torch M = torch.normal(0, 1, size=(4,4)) print(\u0026#39;一个矩阵 \\n\u0026#39;,M) for i in range(100): M = torch.mm(M,torch.normal(0, 1, size=(4, 4))) print(\u0026#39;乘以100个矩阵后\\n\u0026#39;, M) #一个矩阵 # tensor([[-0.7872, 2.7090, 0.5996, -1.3191], # [-1.8260, -0.7130, -0.5521, 0.1051], # [ 1.1213, 1.0472, -0.3991, -0.3802], # [ 0.5552, 0.4517, -0.3218, 0.5214]]) #乘以100个矩阵后 # tensor([[-2.1897e+26, 8.8308e+26, 1.9813e+26, 1.7019e+26], # [ 1.3110e+26, -5.2870e+26, -1.1862e+26, -1.0189e+26], # [-1.6008e+26, 6.4559e+26, 1.4485e+26, 1.2442e+26], # [ 3.0943e+25, -1.2479e+26, -2.7998e+25, -2.4050e+25]]) 8.2 参数初始化 Xavier初始化：对全连接层权重的初始化取决于输入与输出层的神经元数量 （1）若是正态分布，则从均值为0，方差如下的高斯分布中抽样权重；\n（2）也可以改为从下述范围的均匀分布中抽样权重\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/707d2l-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/","summary":"\u003ch1 id=\"1-多层感知机\"\u003e1. 多层感知机\u003c/h1\u003e\n\u003ch2 id=\"11-隐藏层\"\u003e1.1 隐藏层\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e之前所学的线性模型意味着单调假设，并不适用于更复杂的建模问题，例如体温与疾病；图片某个像素点的强度与猫或狗的关系等；\u003c/li\u003e\n\u003cli\u003e多层感知机（MLP）：在输入层与输出层之间加入一个或多个隐藏层，以学习更加复杂的模型情况；\n\u003cul\u003e\n\u003cli\u003e只有隐藏层与输出层涉及到神经元计算与参数更新，因此如下示例MLP的层数是2；\u003c/li\u003e\n\u003cli\u003e对于其中的隐藏层需要应用非线性的激活函数（σ），以突破对仍为线性本质的限制。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240723082016977.png\" alt=\"image-20240723082016977\"  /\u003e\r\n\u003c/p\u003e","title":"D2L--第四章多层感知机"},{"content":"1. 层和块 1.1 自定义块 块/模块（block）可以描述单个层、由多个层（lay）组成的组件或整个神经网络模型本身。\n复杂的模块也可以由简单的模块组成 从编程的角度，块由类表示，一般继承自torch的nn.Module\n定义__init__构造函数，声明组成块所需要的层； 定义forward前向传播函数，表明模型如何将输入转换为输出； 由于torch自动微分的性质，将自动实现反向传播函数，以更新模型参数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import torch from torch import nn from torch.nn import functional as F class MLP(nn.Module): # 用模型参数声明层。这里，我们声明两个全连接的层 def __init__(self): # 调用MLP的父类Module的构造函数来执行必要的初始化。 # 这样，在类实例化时也可以指定其他函数参数，例如模型参数params（稍后将介绍） super().__init__() self.hidden = nn.Linear(20, 256) # 隐藏层 self.out = nn.Linear(256, 10) # 输出层 # 定义模型的前向传播，即如何根据输入X返回所需的模型输出 def forward(self, X): # 注意，这里我们使用ReLU的函数版本，其在nn.functional模块中定义。 return self.out(F.relu(self.hidden(X))) # 实例化一个神经网络 net = MLP() # 模拟输入 X = torch.rand(2, 20) # 计算输出 net(X) torch.nn.functional 模块包含了大量用于构建神经网络的常用函数，可以被用来定义损失函数、激活函数、池化操作等。\n1.2 顺序块 1 2 3 net = nn.Sequential(nn.Linear(20, 256), nn.ReLU(), nn.Linear(256, 10)) X = torch.rand(2, 20) net(X) 自定义一个Sequential类，定义两个关键函数 将块逐个添加到列表中的构造函数 按照组成的块顺序，计算输出的前向传播函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MySequential(nn.Module): # args参数表示想要叠加的块 def __init__(self, *args): super().__init__() for idx, module in enumerate(args): # 这里，module是Module子类的一个实例。我们把它保存在\u0026#39;Module\u0026#39;类的成员 # 变量_modules中。_module的类型是OrderedDict self._modules[str(idx)] = module def forward(self, X): # OrderedDict保证了按照成员添加的顺序遍历它们 for block in self._modules.values(): X = block(X) return X net = MySequential(nn.Linear(20, 256), nn.ReLU(), nn.Linear(256, 10)) net(X) 1.3 在前向传播函数中执行代码 灵活的模块定义\n在前向传播中，可以执行Python的控制流；并且可以不依赖预定的层，而执行任意的数学运算； 在构造函数中，也可以定义一些常数参数（constant parameter），不依赖于上一层的结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class FixedHiddenMLP(nn.Module): def __init__(self): super().__init__() # 不计算梯度的随机权重参数。因此其在训练期间保持不变 self.rand_weight = torch.rand((20, 20), requires_grad=False) self.linear = nn.Linear(20, 20) def forward(self, X): X = self.linear(X) # 使用创建的常量参数以及relu和mm函数 X = F.relu(torch.mm(X, self.rand_weight) + 1) # 复用全连接层。这相当于两个全连接层共享参数 X = self.linear(X) # 控制流while循环: 若L1范数大于1，则输出向量除以2 while X.abs().sum() \u0026gt; 1: X /= 2 return X.sum() net = FixedHiddenMLP() net(X) 灵活的模块组合\n1 2 3 4 5 6 7 8 9 10 11 12 class NestMLP(nn.Module): def __init__(self): super().__init__() self.net = nn.Sequential(nn.Linear(20, 64), nn.ReLU(), nn.Linear(64, 32), nn.ReLU()) self.linear = nn.Linear(32, 16) def forward(self, X): return self.linear(self.net(X)) chimera = nn.Sequential(NestMLP(), nn.Linear(16, 20), FixedHiddenMLP()) chimera(X) 2. 参数管理 模型的训练目标是找到损失函数最小化的模型参数值； 基于最优模型，提出其参数保存下来后以便在其他环境中复用 1 2 3 4 5 6 import torch from torch import nn net = nn.Sequential(nn.Linear(4, 8), nn.ReLU(), nn.Linear(8, 1)) X = torch.rand(size=(2, 4)) net(X) 2.1 参数访问 基于Sequential类定义的模型，可通过索引来访问模型的任意层 如下检查第二个全连接层的参数，包括权重与偏置 1 2 print(net[2].state_dict()) # OrderedDict([(\u0026#39;weight\u0026#39;, tensor([[-0.3138, -0.0693, -0.0505, 0.0699, 0.2249, -0.1000, -0.0449, -0.0910]])), (\u0026#39;bias\u0026#39;, tensor([0.1179]))]) 目标参数\n1 2 3 4 5 6 7 8 9 10 print(type(net[2].bias)) # \u0026lt;class \u0026#39;torch.nn.parameter.Parameter\u0026#39;\u0026gt; print(net[2].bias) # Parameter containing: # tensor([0.1179], requires_grad=True) print(net[2].bias.data) # tensor([0.1179]) net[2].weight.grad==None # True 一次性访问所有参数\n1 2 3 4 5 6 7 8 ## 访问第一个全连接层的参数 print(*[(name, param.shape) for name, param in net[0].named_parameters()]) # (\u0026#39;weight\u0026#39;, torch.Size([8, 4])) (\u0026#39;bias\u0026#39;, torch.Size([8])) ## 访问所有层 print(*[(name, param.shape) for name, param in net.named_parameters()]) # (\u0026#39;0.weight\u0026#39;, torch.Size([8, 4])) (\u0026#39;0.bias\u0026#39;, torch.Size([8])) # (\u0026#39;2.weight\u0026#39;, torch.Size([1, 8])) (\u0026#39;2.bias\u0026#39;, torch.Size([1])) 从嵌套块收集参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def block1(): return nn.Sequential(nn.Linear(4, 8), nn.ReLU(), nn.Linear(8, 4), nn.ReLU()) def block2(): net = nn.Sequential() for i in range(4): # 在这里嵌套 net.add_module(f\u0026#39;block {i}\u0026#39;, block1()) return net rgnet = nn.Sequential(block2(), nn.Linear(4, 1)) X = torch.rand(size=(2, 4)) rgnet(X) # 访问第一个主要的块中，第二个子块的第一层的偏置项 rgnet[0][1][0].bias.data 2.2 参数初始化 默认情况下，PyTorch会根据一个范围均匀地初始化权重和偏置矩阵， 这个范围是根据输入和输出维度计算出的。 此外，PyTorch的nn.init模块提供了多种预置初始化方法。 内置初始化\nnn.init.normal_将参数初始化为正态分布 nn.init.zeros_将参数初始化为0 1 2 3 4 5 def init_normal(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, mean=0, std=0.01) nn.init.zeros_(m.bias) net.apply(init_normal) nn.init.constant_()可以将参数初始化为给定的常数 nn.init.xavier_uniform_()使用Xavier初始化方法初始化 1 2 3 4 5 6 7 8 9 10 11 def init_xavier(m): if type(m) == nn.Linear: nn.init.xavier_uniform_(m.weight) def init_42(m): if type(m) == nn.Linear: nn.init.constant_(m.weight, 42) net[0].apply(init_xavier) net[2].apply(init_42) print(net[0].weight.data[0]) print(net[2].weight.data) 自定义初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def my_init(m): if type(m) == nn.Linear: print(\u0026#34;Init\u0026#34;, *[(name, param.shape) for name, param in m.named_parameters()][0]) nn.init.uniform_(m.weight, -10, 10) m.weight.data *= m.weight.data.abs() \u0026gt;= 5 net.apply(my_init) net[0].weight[:2] # 直接修改 net[0].weight.data[:] += 1 net[0].weight.data[0, 0] = 42 net[0].weight.data[0] 2.3 参数绑定 定义一个公共层/块，在多个地方使用，共享参数 1 2 3 4 5 6 7 8 9 10 11 12 # 我们需要给共享层一个名称，以便可以引用它的参数 shared = nn.Linear(8, 8) net = nn.Sequential(nn.Linear(4, 8), nn.ReLU(), shared, nn.ReLU(), shared, nn.ReLU(), nn.Linear(8, 1)) net(X) # 检查参数是否相同 print(net[2].weight.data[0] == net[4].weight.data[0]) net[2].weight.data[0, 0] = 100 # 确保它们实际上是同一个对象，而不只是有相同的值 print(net[2].weight.data[0] == net[4].weight.data[0]) 3. 自定义层 同样继承自nn.Module，灵活地适用于各种任务的架构 3.1 不带参数的层 如下定义一个层，从输入中减去均值 1 2 3 4 5 6 7 8 9 10 11 12 13 import torch import torch.nn.functional as F from torch import nn class CenteredLayer(nn.Module): def __init__(self): super().__init__() def forward(self, X): return X - X.mean() layer = CenteredLayer() layer(torch.FloatTensor([1, 2, 3, 4, 5])) 将该层作为组间，合并到更复杂的模型/模块中 1 2 3 net = nn.Sequential(nn.Linear(8, 128), CenteredLayer()) Y = net(torch.rand(4, 8)) Y.mean() 3.2 带参数的层 使用nn.Parameter创建参数 如下自定义一个全连接层：in_units参数设置输入神经元的维度，units设置输出神经元的维度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyLinear(nn.Module): def __init__(self, in_units, units): super().__init__() self.weight = nn.Parameter(torch.randn(in_units, units)) self.bias = nn.Parameter(torch.randn(units,)) def forward(self, X): linear = torch.matmul(X, self.weight.data) + self.bias.data return F.relu(linear) linear = MyLinear(5, 3) linear.weight # 计算输出 linear(torch.rand(2, 5)) # 组成复杂模型 net = nn.Sequential(MyLinear(64, 8), MyLinear(8, 1)) net(torch.rand(2, 64)) 5. 读写文件 1 2 3 import torch from torch import nn from torch.nn import functional as F 5.1 加载和保存张量 张量 1 2 3 4 5 6 # save x = torch.arange(4) torch.save(x, \u0026#39;x-file\u0026#39;) # load x2 = torch.load(\u0026#39;x-file\u0026#39;) x2 张量列表 1 2 3 4 y = torch.zeros(4) torch.save([x, y],\u0026#39;x-files\u0026#39;) x2, y2 = torch.load(\u0026#39;x-files\u0026#39;) (x2, y2) 字典 1 2 3 4 mydict = {\u0026#39;x\u0026#39;: x, \u0026#39;y\u0026#39;: y} torch.save(mydict, \u0026#39;mydict\u0026#39;) mydict2 = torch.load(\u0026#39;mydict\u0026#39;) mydict2 5.2 加载和保存模型参数 相较于保存模型本身，torch支持保存模型所有的参数； 在新的环境使用时，需要先单独指定模型架构，然后套用之前训练的参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class MLP(nn.Module): def __init__(self): super().__init__() self.hidden = nn.Linear(20, 256) self.output = nn.Linear(256, 10) def forward(self, x): return self.output(F.relu(self.hidden(x))) net = MLP() X = torch.randn(size=(2, 20)) Y = net(X) #保存模型参数 torch.save(net.state_dict(), \u0026#39;mlp.params\u0026#39;) 1 2 3 4 5 6 7 # 新建模型，套用保存的参数 clone = MLP() clone.load_state_dict(torch.load(\u0026#39;mlp.params\u0026#39;)) clone Y_clone = clone(X) Y_clone == Y 6. GPU 默认情况下，所有变量和相关的计算部分都分配给CPU； 当在带有GPU的服务器上训练神经网络时， 希望模型的参数在GPU上； 1 2 # !表示在ipython环境中使用linux命令 !nvidia-smi 6.1 计算设备 默认情况下，张量是在内存中创建的，然后使用CPU计算它\n可通过torch.device()指定计算的设备\ntorch.device('cpu')指代所有物理CPU和内存 torch.device('cuda')默认指代0号GPU，等价于torch.device('cuda:0') 1 2 3 4 5 6 7 import torch from torch import nn torch.device(\u0026#39;cpu\u0026#39;), torch.device(\u0026#39;cuda\u0026#39;), torch.device(\u0026#39;cuda:1\u0026#39;) # 查询可用GPU数量 torch.cuda.device_count() 定义两个方便的函数调用GPU 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def try_gpu(i=0): #@save \u0026#34;\u0026#34;\u0026#34;如果存在，则返回gpu(i)，否则返回cpu()\u0026#34;\u0026#34;\u0026#34; if torch.cuda.device_count() \u0026gt;= i + 1: return torch.device(f\u0026#39;cuda:{i}\u0026#39;) return torch.device(\u0026#39;cpu\u0026#39;) # 返回所有的GPU def try_all_gpus(): #@save \u0026#34;\u0026#34;\u0026#34;返回所有可用的GPU，如果没有GPU，则返回[cpu(),]\u0026#34;\u0026#34;\u0026#34; devices = [torch.device(f\u0026#39;cuda:{i}\u0026#39;) for i in range(torch.cuda.device_count())] return devices if devices else [torch.device(\u0026#39;cpu\u0026#39;)] try_gpu(), try_gpu(10), try_all_gpus() 6.2 张量与GPU 查询张量所在的设备 1 2 x = torch.tensor([1, 2, 3]) x.device 存储在GPU上\n在创建时，指定GPU 1 2 3 4 5 X = torch.ones(2, 3, device=try_gpu()) X Y = torch.rand(2, 3, device=try_gpu(1)) Y 复制\n将数据复制到另一个设备 1 2 3 4 5 Z = X.cuda(1) print(X) print(Z) Y + Z 6.3 神经网络与GPU 将模型参数放在GPU上 1 2 3 4 5 6 7 net = nn.Sequential(nn.Linear(3, 1)) net = net.to(device=try_gpu()) net(X) # 确认模型参数存储在同一个GPU上 net[0].weight.data.device ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/708d2l-%E7%AC%AC%E4%BA%94%E7%AB%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97/","summary":"\u003ch1 id=\"1-层和块\"\u003e1. 层和块\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240727223031831.png\" alt=\"image-20240727223031831\"  /\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"11-自定义块\"\u003e1.1 自定义块\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e块/模块（block）可以描述单个层、由多个层（lay）组成的组件或整个神经网络模型本身。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e复杂的模块也可以由简单的模块组成\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从编程的角度，块由类表示，一般继承自torch的\u003ccode\u003enn.Module\u003c/code\u003e\u003c/p\u003e","title":"D2L--第五章深度学习计算"},{"content":"1. 从全连接层到卷积 1.1 不变性 假设一个场景：需要制作一个检测器，在一张图片中检测一种特定物体。需要满足两个性质：\n平移不变性：无论该物品在图片的哪个位置，都可以检测到； 局部性：检测器只需要关注图像中的局部区域，不过度关注其它无关区域。 1.2 多层感知机的限制 对于图片（例如12M）像素的一维展开，包含36M的元素。若使用包含100个神经元的单隐藏层，模型就要3.6B元素，训练难度过大。 卷积(convolution)计算：输入X为二维矩阵，输出的隐藏表示H仍为矩阵。参数包括权重矩阵V与偏置U。H中的每一个元素都由权重矩阵V与输入X中相应区域元素的\u0026rsquo;点积\u0026rsquo;，再加上偏置所得到。（下图演示忽略了偏置计算） 平移不变性：权重矩阵（又称为卷积核/滤波器）在每次计算中保持不变，以提取相同的模式。 局部性：卷积核(kernel)的形状通常较小(|a|\u0026gt;△;|b|\u0026gt;△)，即针对输入的局部区域进行特征提取。 如上计算中，模型参数的数量比全连接层参数少很多，降低了训练难度。 2. 图像卷积 2.1 互相关运算 CNN中的卷积与数学中的卷积概念不完全相同，本质上为互相关运算(cross-correlation) 如下图，输入是3×3的二维张量；卷积核的高和宽都是2： 卷积窗口从输入的左上角开始，从左到右，从上到下滑动； 每次按对应位置的元素相乘，再求和得到单个标量结果； 按上述规则滑动的计算结果，输出形状将小于输入形状。 输出结果有时被称为特征映射。对于输出结果中的任一元素，其感受野指上一层中所有参与计算的输入元素。\n手动代码实现互相关运算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import torch from torch import nn from d2l import torch as d2l def corr2d(X, K): #@save \u0026#34;\u0026#34;\u0026#34;计算二维互相关运算\u0026#34;\u0026#34;\u0026#34; h, w = K.shape #定义输出的形状 Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1)) #遍历每次滑动 for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i, j] = (X[i:i + h, j:j + w] * K).sum() return Y # 输入 X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]]) # 卷积核 K = torch.tensor([[0.0, 1.0], [2.0, 3.0]]) corr2d(X, K) 2.2 卷积层 如前所述，卷积层中的两个被训练的参数是卷积核权重和标量偏置，在训练时，会被随机初始化； 基于上述互相关运算函数，手动定义一个二维卷积层 1 2 3 4 5 6 7 8 class Conv2D(nn.Module): def __init__(self, kernel_size): super().__init__() self.weight = nn.Parameter(torch.rand(kernel_size)) self.bias = nn.Parameter(torch.zeros(1)) def forward(self, x): return corr2d(x, self.weight) + self.bias 2.3 图像中目标的边缘检测 卷积层的简单应用：根据像素变化的位置，检测图像中不同颜色的边缘。 1 2 3 4 5 6 7 8 9 # 输入数据：下图左 X = torch.ones((6, 8)) X[:, 2:6] = 0 # 卷积核 K = torch.tensor([[1.0, -1.0]]) # 卷积计算：下图右 Y = corr2d(X, K) 2.4 学习卷积核 可通过torch的nn.Conv2d类快速定义一个卷积层 该类的前两个参数分别用于设置输入与输出通道数； kernel_size参数用于指定卷积核的高和宽。 如下代码，将根据上述的输入X与输出Y，学习卷积核 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 构造一个二维卷积层，它具有1个输出通道和形状为（1，2）的卷积核 conv2d = nn.Conv2d(1,1, kernel_size=(1, 2), bias=False) # 这个二维卷积层使用四维输入和输出格式（批量大小、通道、高度、宽度）， # 其中批量大小和通道数都为1 X = X.reshape((1, 1, 6, 8)) #示例输入 Y = Y.reshape((1, 1, 6, 7)) #示例输出 lr = 3e-2 # 学习率 for i in range(10): Y_hat = conv2d(X) l = (Y_hat - Y) ** 2 #预测的平方损失 conv2d.zero_grad() l.sum().backward() # 迭代卷积核 conv2d.weight.data[:] -= lr * conv2d.weight.grad if (i + 1) % 2 == 0: print(f\u0026#39;epoch {i+1}, loss {l.sum():.3f}\u0026#39;) conv2d.weight.data.reshape((1, 2)) # tensor([[ 0.9938, -0.9841]]) 3. 填充和步幅 3.1 填充 可在输入图像的边界填充元素（通常为0），使得经卷积计算后的输出形状变大； 当卷积核的高宽为奇数（推荐）时，若填充的行数（一半在顶，一半在底）与列数（一半在左，一半在右）与卷积核的高宽少1，则输入与输出的形状相同。 可通过nn.Conv2d类的padding参数设置填充。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import torch from torch import nn # 为了方便起见，我们定义了一个计算卷积层的函数。 # 此函数初始化卷积层权重，并对输入和输出提高和缩减相应的维数 def comp_conv2d(conv2d, X): # 这里的（1，1）表示批量大小和通道数都是1 X = X.reshape((1, 1) + X.shape) #(1, 1) + X.shape 长度为4的tuple Y = conv2d(X) # 省略前两个维度：批量大小和通道 return Y.reshape(Y.shape[2:]) # 请注意，这里每边都填充了1行或1列，因此总共添加了2行或2列 conv2d = nn.Conv2d(1, 1, kernel_size=3, padding=1) X = torch.rand(size=(8, 8)) comp_conv2d(conv2d, X).shape # torch.Size([8, 8]) 3.2 步幅 在上述示例中，卷积窗口滑动的长度（步幅）为1； 为了高效计算或是缩减采样次数，可增大滑动的幅度； 当卷积核高宽为奇数，且填充比卷积核形状少1时，则输出的形状大小为输入形状除以步幅； 可通过nn.Conv2d类的stride参数设置 1 2 3 conv2d = nn.Conv2d(1, 1, kernel_size=3, padding=1, stride=2) comp_conv2d(conv2d, X).shape # torch.Size([4, 4]) 4. 多输入多输出通道 4.1 多输入通道 图片通常包含三个通道（红绿蓝三原色），即输入数据有三个维度。其中，前两个轴与像素的空间位置有关，而第三个轴可以看作每个像素的多维表示。 此时，每个通道都有一个卷积核，最后的输出是所有通道卷积结果的和。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import torch from d2l import torch as d2l # X表示多通道输入 # K表示多通道卷积核 def corr2d_multi_in(X, K): # 先遍历“X”和“K”的第0个维度（通道维度），再把它们加在一起 return sum(d2l.corr2d(x, k) for x, k in zip(X, K)) X = torch.tensor([[[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]], [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]]) K = torch.tensor([[[0.0, 1.0], [2.0, 3.0]], [[1.0, 2.0], [3.0, 4.0]]]) corr2d_multi_in(X, K) 4.2 多输出通道 在上述的多通道输入中，每个通道只有一个卷积核，最后得到一个通道的输出； 可以在每个通道中建立多个(o)卷积核。此时，对于i个输入通道，就共有o × i个卷积核； 然后按照4.1计算方法，可以得到o个输出通道的结果； 如下，i=1，o=4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # X表示多通道输入 # K表示多通道卷积核【4个维度】 def corr2d_multi_in_out(X, K): # 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。 # 最后将所有结果都叠加在一起(沿新的第一维度（dim=0）堆叠起来) return torch.stack([corr2d_multi_in(X, k) for k in K], 0) #k三个维度，参考4.1 # 之前的K是三维的多个(等于对应通道数)卷积核 K = torch.stack((K, K + 1, K + 2), 0) K.shape # torch.Size([3, 2, 2, 2]) # i=2; o=3 corr2d_multi_in_out(X, K).shape # torch.Size([3, 2, 2]) 可以将每个输出通道认为是提取的一种特征模式，供下一神经网络层组合学习。(https://poloclub.github.io/cnn-explainer/)\n4.3 1×1卷积层 卷积的本质是有效提取相邻像素间的相关特征，而1×1卷积显然没有此作用； 1×1卷积受欢迎的原因是作为融合通道使用，直观上是改变了输入通道的数量。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #从全连接层的角度，实现1×1卷积 def corr2d_multi_in_out_1x1(X, K): c_i, h, w = X.shape c_o = K.shape[0] X = X.reshape((c_i, h * w)) #每个通道拉平为一个向量，此时X为一个矩阵 K = K.reshape((c_o, c_i)) # 全连接层中的矩阵乘法 Y = torch.matmul(K, X) #(c_o, h * w) return Y.reshape((c_o, h, w)) X = torch.normal(0, 1, (3, 3, 3)) #3个输入通道 K = torch.normal(0, 1, (2, 3, 1, 1)) #2×3个卷积核 Y1 = corr2d_multi_in_out_1x1(X, K) #按常规卷积层角度的实现 Y2 = corr2d_multi_in_out(X, K) assert float(torch.abs(Y1 - Y2).sum()) \u0026lt; 1e-6 5. 汇聚层 5.1 最大汇聚层和平均汇聚层 汇聚层(pooling)又称池化层，降低卷积层对位置的敏感性。 它与卷积操作类似，由一个固定窗口组成，在输入数据中滑动，并计算得到输出。 不同之处在于，汇聚层没有学习参数，为确定性计算；主要分为如下两种 最大汇聚层：汇聚窗口覆盖区域内的最大值； 平均汇聚层：汇聚窗口覆盖区域内的平均值； 手动代码实现（类似上述的2.1处） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import torch from torch import nn from d2l import torch as d2l def pool2d(X, pool_size, mode=\u0026#39;max\u0026#39;): p_h, p_w = pool_size Y = torch.zeros((X.shape[0] - p_h + 1, X.shape[1] - p_w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): if mode == \u0026#39;max\u0026#39;: Y[i, j] = X[i: i + p_h, j: j + p_w].max() elif mode == \u0026#39;avg\u0026#39;: Y[i, j] = X[i: i + p_h, j: j + p_w].mean() return Y X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]]) pool2d(X, (2, 2)) pool2d(X, (2, 2), \u0026#39;avg\u0026#39;) 5.2 填充和步幅 默认情况下，深度学习框架中的步幅与汇聚窗口的大小相同（即每次滑动区域没有重叠）； 可设置nn.MaxPool2d/nn.AvgPool2d类的参数： 第一个参数为窗口的大小 padding与stride参数分别制定填充与步幅 默认stride与窗口的大小相同 1 2 3 4 5 6 7 8 9 10 11 12 X = torch.arange(16, dtype=torch.float32).reshape((1, 1, 4, 4)) #转换为4维的输入 X pool2d = nn.MaxPool2d(3) pool2d(X) #只返回一个值 # 其它灵活设置 pool2d = nn.MaxPool2d(3, padding=1, stride=2) pool2d(X) pool2d = nn.MaxPool2d((2, 3), stride=(2, 3), padding=(0, 1)) pool2d(X) 5.3 多个通道 对于多个通道，汇聚层将在每个通道单独运算，分别作为输出；即输出通道与输入通道数相同。 1 2 3 4 5 6 # 将原有X的第二个维度上，增加一组数据；即两个输入通道 X = torch.cat((X, X + 1), 1) X pool2d = nn.MaxPool2d(3, padding=1, stride=2) pool2d(X) #汇聚后输出通道的数量仍然是2。 6 卷积神经网络(LeNet) 6.1 LeNet LeNet是最早发布的卷积神经网络之一，用于是被图像的手写数字，由AT\u0026amp;T贝尔实验室的研究员Yann LeCun在1989年提出； 主要分为卷积编码器（两个卷积层）与全连接层密集块（三个全连接层）两部分； 1 2 3 4 5 6 7 8 9 10 11 12 13 import torch from torch import nn from d2l import torch as d2l net = nn.Sequential( nn.Conv2d(1, 6, kernel_size=5, padding=2), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Conv2d(6, 16, kernel_size=5), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.Linear(16 * 5 * 5, 120), nn.Sigmoid(), nn.Linear(120, 84), nn.Sigmoid(), nn.Linear(84, 10)) 模型组成特点： 每个卷积层与全连接层（输出层除外）后均连接一个激活函数； 第一个卷积层有6个输出通道，第二个卷积层有16个输出通道； 第一个卷积层通过填充使得输出形状不变，第二个卷积层未使用； 汇聚层的步幅设置使得输出的高宽形状减半； 在接入全连接层之前需要将图像输出展开为一维的形式。 为了构造高性能的卷积神经网络，通常对卷积层进行排列，逐渐降低其表示的空间分辨率，同时增加通道数。\n1 2 3 4 X = torch.rand(size=(1, 1, 28, 28), dtype=torch.float32) for layer in net: X = layer(X) print(layer.__class__.__name__,\u0026#39;output shape: \\t\u0026#39;,X.shape) 6.2 模型训练 数据迭代器 1 2 batch_size = 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size=batch_size) 定义GPU版本的准确率评价指标 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def evaluate_accuracy_gpu(net, data_iter, device=None): #@save \u0026#34;\u0026#34;\u0026#34;使用GPU计算模型在数据集上的精度\u0026#34;\u0026#34;\u0026#34; if isinstance(net, nn.Module): net.eval() # 设置为评估模式 if not device: device = next(iter(net.parameters())).device #与模型的device保持一致 # 正确预测的数量，总预测的数量 metric = d2l.Accumulator(2) with torch.no_grad(): for X, y in data_iter: if isinstance(X, list): #判断是否为list # BERT微调所需的（之后将介绍） X = [x.to(device) for x in X] else: X = X.to(device) y = y.to(device) metric.add(d2l.accuracy(net(X), y), y.numel()) return metric[0] / metric[1] 定义GPU版本的训练函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #@save def train_ch6(net, train_iter, test_iter, num_epochs, lr, device): \u0026#34;\u0026#34;\u0026#34;用GPU训练模型(在第六章定义)\u0026#34;\u0026#34;\u0026#34; def init_weights(m): #模型参数初始化 if type(m) == nn.Linear or type(m) == nn.Conv2d: nn.init.xavier_uniform_(m.weight) net.apply(init_weights) print(\u0026#39;training on\u0026#39;, device) net.to(device) optimizer = torch.optim.SGD(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss() animator = d2l.Animator(xlabel=\u0026#39;epoch\u0026#39;, xlim=[1, num_epochs], legend=[\u0026#39;train loss\u0026#39;, \u0026#39;train acc\u0026#39;, \u0026#39;test acc\u0026#39;]) timer, num_batches = d2l.Timer(), len(train_iter) for epoch in range(num_epochs): # 训练损失之和，训练准确率之和，样本数 metric = d2l.Accumulator(3) # 训练模型 net.train() for i, (X, y) in enumerate(train_iter): timer.start() optimizer.zero_grad() X, y = X.to(device), y.to(device) y_hat = net(X) l = loss(y_hat, y) l.backward() optimizer.step() with torch.no_grad(): metric.add(l * X.shape[0], d2l.accuracy(y_hat, y), X.shape[0]) # 下述代码用于可视化 timer.stop() train_l = metric[0] / metric[2] train_acc = metric[1] / metric[2] if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (train_l, train_acc, None)) #每次epoch后的测试集评价 test_acc = evaluate_accuracy_gpu(net, test_iter) animator.add(epoch + 1, (None, None, test_acc)) print(f\u0026#39;loss {train_l:.3f}, train acc {train_acc:.3f}, \u0026#39; f\u0026#39;test acc {test_acc:.3f}\u0026#39;) print(f\u0026#39;{metric[2] * num_epochs / timer.sum():.1f} examples/sec \u0026#39; f\u0026#39;on {str(device)}\u0026#39;) 开始训练 1 2 lr, num_epochs = 0.9, 10 train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/709d2l-%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","summary":"\u003ch1 id=\"1-从全连接层到卷积\"\u003e1. 从全连接层到卷积\u003c/h1\u003e\n\u003ch2 id=\"11-不变性\"\u003e1.1 不变性\u003c/h2\u003e\n\u003cp\u003e假设一个场景：需要制作一个检测器，在一张图片中检测一种特定物体。需要满足两个性质：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e平移不变性：无论该物品在图片的哪个位置，都可以检测到；\u003c/li\u003e\n\u003cli\u003e局部性：检测器只需要关注图像中的局部区域，不过度关注其它无关区域。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"12-多层感知机的限制\"\u003e1.2 多层感知机的限制\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e对于图片（例如12M）像素的\u003cstrong\u003e一维展开\u003c/strong\u003e，包含36M的元素。若使用包含100个神经元的单隐藏层，模型就要3.6B元素，训练难度过大。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e卷积\u003c/strong\u003e(convolution)计算：输入\u003cstrong\u003eX\u003c/strong\u003e为二维矩阵，输出的隐藏表示\u003cstrong\u003eH\u003c/strong\u003e仍为矩阵。参数包括权重矩阵\u003cstrong\u003eV\u003c/strong\u003e与偏置\u003cstrong\u003eU\u003c/strong\u003e。\u003cstrong\u003eH\u003c/strong\u003e中的每一个元素都由权重矩阵\u003cstrong\u003eV\u003c/strong\u003e与输入\u003cstrong\u003eX\u003c/strong\u003e中相应区域元素的\u0026rsquo;点积\u0026rsquo;，再加上偏置所得到。（下图演示忽略了偏置计算）\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e平移不变性\u003c/strong\u003e：权重矩阵（又称为卷积核/滤波器）在每次计算中保持不变，以提取相同的模式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e局部性\u003c/strong\u003e：卷积核(kernel)的形状通常较小(|a|\u0026gt;△;|b|\u0026gt;△)，即针对输入的局部区域进行特征提取。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"C:%5cUsers%5cxiaoxin%5cAppData%5cRoaming%5cTypora%5ctypora-user-images%5cimage-20240731113235058.png\" alt=\"image-20240731113235058\"  /\u003e\r\n\u003c/p\u003e","title":"D2L--第六章卷积神经网络"},{"content":"1. 深度卷积神经网络(AlexNet) 1.1 学习表征 LeNet提出后，卷积神经网络并未占据主流，而是往往由其它机器学习方法所超越，如SVM。一个主要的原因是输入数据的特征处理上。\nCNN模型是基于端到端的预测，由模型本身来学习、提取特征。例如直接从图片像素到分类结果的预测； SVM等经典机器学习模型则依赖于精细的特征工程，即使用经过人的手工精心设计的特征来建模。 在2012年，AlexNet模型取得了当年ImageNet挑战赛的冠军，标志着深层神经网络相关研究的起点。\n在CNN的底层（例如第一层、第二层等）中的每一个通道可以\u0026rsquo;理解\u0026rsquo;为对某种模式特征的提取表示，用于更高层的综合学习。\n此外，限制神经网络取得良好性能的因素还包括数据与硬件两方面——\n数据：深度模型需要大量的有标签数据才能显著优于基于凸优化的传统方法（如线性方法和核方法） 2009年，由斯坦福教授李飞飞小组发布了ImageNet数据集，并发起ImageNet挑战赛：要求研究人员从100万个样本中训练模型，以区分1000个不同类别的对象。 硬件：深度学习模型对计算资源要求很高，需要数百次迭代训练；每次迭代有需要许多线性代数层传递数据。 相比于CPU，GPU用于大量的计算核心，方便并行运算；此外也提供更高的浮点运算性能（FLOPS），并配备有高带宽的显存（VRAM）等优势。 1.2 AlexNet 本书在这里提供的是一个稍微精简版本的AlexNet\nAlexNet与LeNet架构非常相似，在以下方面进行了提升：\n模型设计：由8层组成，包括5个卷积层、3个全连接层 考虑ImageNet图像宽高显著多于MNIST，第1个卷积层的卷积核窗口为11×11，第二个为5×5，往后都是3×3； 卷积输出通道数也是LeNet的10倍以上； 在第1、第2、第5层卷积层后加入最大汇聚层； 两个全连接隐藏层有4096个输出，用于接近1GB的模型参数； 激活函数：使用ReLU激活函数相比于Sigmoid计算更加简单，且更适应多种参数初始化方法。 容量控制：使用Dropout暂退法控制了全连接层的模型复杂度。 如下的模型架构是为Fashion-MNIST数据集修改后的设计，主要体现在第一层卷积层的输入通道数为1。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import torch from torch import nn from d2l import torch as d2l net = nn.Sequential( # 这里使用一个11*11的更大窗口来捕捉对象。 # 同时，步幅为4，以减少输出的高度和宽度。 # 另外，输出通道的数目远大于LeNet nn.Conv2d(1, 96, kernel_size=11, stride=4, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), # 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数 nn.Conv2d(96, 256, kernel_size=5, padding=2), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), # 使用三个连续的卷积层和较小的卷积窗口。 # 除了最后的卷积层，输出通道的数量进一步增加。 nn.Conv2d(256, 384, kernel_size=3, padding=1), nn.ReLU(), nn.Conv2d(384, 384, kernel_size=3, padding=1), nn.ReLU(), nn.Conv2d(384, 256, kernel_size=3, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), nn.Flatten(), # 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合 nn.Linear(6400, 4096), nn.ReLU(), nn.Dropout(p=0.5), nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(p=0.5), # 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000 nn.Linear(4096, 10)) 以一个高度和宽度都为224的单通道输入数据为例 1 2 3 4 X = torch.randn(1, 1, 224, 224) for layer in net: X=layer(X) print(layer.__class__.__name__,\u0026#39;output shape:\\t\u0026#39;,X.shape) 1.3 读取数据集 为了将Fashion-MNIST数据用于AlexNet模型框架，需要将像素分辨率重新设置为224×224 1 2 batch_size = 128 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224) 1.4 训练AlexNet 1 2 3 4 lr, num_epochs = 0.01, 10 d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.333, train acc 0.879, test acc 0.849 # 5523.8 examples/sec on cuda:0 2 使用块的网络(VGG) AlexNet虽然证明深层网络有效，但未能提供通用的模板指导后续的设计； VGG由牛津大学的视觉几何组于2013年提出，可以简洁地实现更深更窄的网络，在2014年ImageNet中取得优异的表现。 2.1 VGG块 VGG块提出了一种经典的卷积神经网络的组成架构，包括如下：\n多个连续的卷积层 较小的3×3卷积核； 带填充以保持输出分辨率不变； 自定义输出通道。 ReLU激活函数； 步幅为2的2×2最大汇聚层，使得输出高宽减半 代码实现如下，可调整参数包括：\nnum_convs 块包含多少个卷积层； in_channels 输入通道数 out_channels 输出通道数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import torch from torch import nn from d2l import torch as d2l def vgg_block(num_convs, in_channels, out_channels): layers = [] for _ in range(num_convs): layers.append(nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)) layers.append(nn.ReLU()) in_channels = out_channels layers.append(nn.MaxPool2d(kernel_size=2,stride=2)) return nn.Sequential(*layers) 2.2 VGG网络 参考AlexNet，VGG同样可以分为两部分：\n第一部分由多个VGG块组成的卷积层部分； 第二部分由3个的全连接层组成。 原始VGG网络包含如下5个VGG块，共有5个卷积层；结合三个全连接层，因此又称为VGG-11。\n第一个块：1个卷积层，64个输出通道； 第二个块：1个卷积层，128个输出通道； 第三个块：2个卷积层，256个输出通道； 第四个块：2个卷积层，512个输出通道； 第五个块：2个卷积层，512个输出通道； 1 conv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512)) 由于每个块的最后一层都是最大汇聚层，使得输出减半；同时增加输出通道数。这是经典的CNN设计思路。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def vgg(conv_arch): conv_blks = [] in_channels = 1 #Fashion-MNIST通道数为1 # 卷积层部分 for (num_convs, out_channels) in conv_arch: conv_blks.append(vgg_block(num_convs, in_channels, out_channels)) in_channels = out_channels #前者的输出通道数等于后者的输入通道数 return nn.Sequential( *conv_blks, nn.Flatten(), # 全连接层部分 # 224/2/2/2/2/2 = 7 nn.Linear(out_channels * 7 * 7, 4096), nn.ReLU(), nn.Dropout(0.5), nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(0.5), nn.Linear(4096, 10)) net = vgg(conv_arch) X = torch.randn(size=(1, 1, 224, 224)) for blk in net: X = blk(X) print(blk.__class__.__name__,\u0026#39;output shape:\\t\u0026#39;,X.shape) 2.3 训练模型 由于VGG-11比AlexNet计算量更大，因此这里构建了一个通道数较少的网络 1 2 3 4 5 6 7 8 9 ratio = 4 small_conv_arch = [(pair[0], pair[1] // ratio) for pair in conv_arch] net = vgg(small_conv_arch) lr, num_epochs, batch_size = 0.05, 10, 128 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224) d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.174, train acc 0.936, test acc 0.908 # 3872.4 examples/sec on cuda:0 3. 网络中的网络(NiN) 在前述介绍的网络组成中，在最后通常会加入全连接层，会导致引入大量的模型参数； 1×1卷积核可以起到混合通道的作用，有点类似MLP的全连接层； NiN网络在AlexNet的基础之上，使用了1×1卷积核，取代了上述全连接层部分的作用。 3.1 NiN块 NiN块提出了一种特殊的组成架构，包括如下：\n第一层为用户自定义的卷积层，以及ReLU激活函数； 第二、三层为1×1卷积核的卷积层，输出通道数不变，同样分别加入ReLU激活函数； 使用1×1卷积核时，相当于对同一位置，不同通道的元素进行全连接层\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 import torch from torch import nn from d2l import torch as d2l def nin_block(in_channels, out_channels, kernel_size, strides, padding): return nn.Sequential( nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding), nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=1), nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=1), nn.ReLU()) 3.2 NiN模型 由4个NiN块组成，每个NiN块中的卷积核窗口参考AlexNet设置为11×11，5×5，3×3，3×3 前3个NiN块后接一个最大池化层； 最后一个NiN块的输出通道数等于类别数，且后面接一个全局平均池化层，输出为1×1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 net = nn.Sequential( nin_block(1, 96, kernel_size=11, strides=4, padding=0), nn.MaxPool2d(3, stride=2), nin_block(96, 256, kernel_size=5, strides=1, padding=2), nn.MaxPool2d(3, stride=2), nin_block(256, 384, kernel_size=3, strides=1, padding=1), nn.MaxPool2d(3, stride=2), nn.Dropout(0.5), # 标签类别数是10 nin_block(384, 10, kernel_size=3, strides=1, padding=1), nn.AdaptiveAvgPool2d((1, 1)), # 将四维的输出转成二维的输出，其形状为(批量大小,10) nn.Flatten()) X = torch.rand(size=(1, 1, 224, 224)) for layer in net: X = layer(X) print(layer.__class__.__name__,\u0026#39;output shape:\\t\u0026#39;, X.shape) 3.3 训练模型 1 2 3 4 5 6 lr, num_epochs, batch_size = 0.1, 10, 128 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224) d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.341, train acc 0.873, test acc 0.875 # 4756.1 examples/sec on cuda:0 4. 含并行连接的网络(GoogLeNet) 基于NiN中串联网络的思想，GoogLeNet在2014年ImageNet图像识别挑战赛的取得佳绩； 4.1 Inception块 如下图，Inception块由4条并行的路径组成，每个路径仅改变通道数，不改变高宽。\n第一条：1×1卷积 第二条：1×1卷积，加上3×3卷积(填充1) 第三条：1×1卷积，加上5×5卷积(填充2) 第四条：3×3最大汇聚(填充1)，加上1×1卷积 如下是定义Inception块的代码，其中可调参数均是输入以及每条路径中的通道数。\nin_channels 输入通道数; c1 第一条路径的输出通道数; c2 第二条路径每个卷积层的输出通道数; c3 第三条路径每个卷积层的输出通道数; c4 第四条路径每个卷积层的输出通道数; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l class Inception(nn.Module): # c1--c4是每条路径的输出通道数 def __init__(self, in_channels, c1, c2, c3, c4, **kwargs): super(Inception, self).__init__(**kwargs) # 线路1，单1x1卷积层 self.p1_1 = nn.Conv2d(in_channels, c1, kernel_size=1) # 线路2，1x1卷积层后接3x3卷积层 self.p2_1 = nn.Conv2d(in_channels, c2[0], kernel_size=1) self.p2_2 = nn.Conv2d(c2[0], c2[1], kernel_size=3, padding=1) # 线路3，1x1卷积层后接5x5卷积层 self.p3_1 = nn.Conv2d(in_channels, c3[0], kernel_size=1) self.p3_2 = nn.Conv2d(c3[0], c3[1], kernel_size=5, padding=2) # 线路4，3x3最大汇聚层后接1x1卷积层 self.p4_1 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1) self.p4_2 = nn.Conv2d(in_channels, c4, kernel_size=1) def forward(self, x): p1 = F.relu(self.p1_1(x)) p2 = F.relu(self.p2_2(F.relu(self.p2_1(x)))) p3 = F.relu(self.p3_2(F.relu(self.p3_1(x)))) p4 = F.relu(self.p4_2(self.p4_1(x))) # 在通道维度上连结输出 return torch.cat((p1, p2, p3, p4), dim=1) 4.2 GoogLeNet模型 如下示意图，GoogLeNet模型共有5个部分组成(从下到上)：\n第一部分：类似于AlexNet，一个卷积层加上一个最大汇聚层； 1 2 3 b1 = nn.Sequential(nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)) 第二部分：两个卷积层加上一个最大汇聚层 1 2 3 4 5 b2 = nn.Sequential(nn.Conv2d(64, 64, kernel_size=1), nn.ReLU(), nn.Conv2d(64, 192, kernel_size=3, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)) 第三部分：2个Inception块，加上最大汇聚层 e.g. 第一个卷积层：输入通道=192，输出通道=64+128+32+32=256 1 2 3 b3 = nn.Sequential(Inception(192, 64, (96, 128), (16, 32), 32), Inception(256, 128, (128, 192), (32, 96), 64), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)) 第四部分：5个Inception块，加上最大汇聚层 e.g. 第一个卷积层：输入通道=480，输出通道=192+208+48+64=512 1 2 3 4 5 6 b4 = nn.Sequential(Inception(480, 192, (96, 208), (16, 48), 64), Inception(512, 160, (112, 224), (24, 64), 64), Inception(512, 128, (128, 256), (24, 64), 64), Inception(512, 112, (144, 288), (32, 64), 64), Inception(528, 256, (160, 320), (32, 128), 128), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)) 第五部分：2个Inception块，加上全局平均汇聚层以及全连接层 e.g. 最后一层卷积层：输入通道=832，输出通道=384+384+128+128=1024 全局平均汇聚层以及Flatten将输出变为1024的特征向量，后面再根据类别数接一个全连接层 1 2 3 4 5 6 b5 = nn.Sequential(Inception(832, 256, (160, 320), (32, 128), 128), Inception(832, 384, (192, 384), (48, 128), 128), nn.AdaptiveAvgPool2d((1,1)), nn.Flatten()) net = nn.Sequential(b1, b2, b3, b4, b5, nn.Linear(1024, 10)) 查看模型架构（仍是高宽变小，通道数变多的思想） 1 2 3 4 X = torch.rand(size=(1, 1, 96, 96)) for layer in net: X = layer(X) print(layer.__class__.__name__,\u0026#39;output shape:\\t\u0026#39;, X.shape) 4.3 训练模型 1 2 3 4 5 6 lr, num_epochs, batch_size = 0.1, 10, 128 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96) d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.249, train acc 0.905, test acc 0.827 # 3811.4 examples/sec on cuda:0 5. 批量规范化 加速深层神经网络的收敛 5.1 训练深层网络 批量规范化(Batch Normalization, BN)用于对特定神经网络层中，每次训练迭代的小批量输入数据进行\u0026rsquo;归一化\u0026rsquo;处理。\n这使得不同层之间的参数量级得到统一，防止模型参数的更新是为了补偿不同层之间的数据差异，从而针对性的对预测问题本身进行学习，加速模型收敛。\n具体实现其实也并不复杂：\n（1）首先对一个小批量B，计算其（feature）均值与方差\n（2）然后，进行均值为0，方差为1的归一化处理后，进一步进行拉伸与偏移。γ可以变换方差，β可以变换均值，均属于可学习的参数，从而拟合最适合的规范化分布。\n一种角度的解释是BN操作中会引入一定的噪声，控制了模型复杂度。因为随机抽样的小批量分布不能代表总体情况。\n5.2 批量规范化层 对于全连接层： BN操作位于全连接层与激活函数之间； 对于[小批量数，特征数]的输入数据，会对每一列特征进行BN操作。即每个特征学习的γ与β都是不同的； 对于卷积层 BN操作位于卷积层与激活函数之间； 对于多通道输出，会将每个通道作为一个特征，即计算小批量样本对于特定通道的，所有元素的均值与方差。 此外，BN操作在预测过程是估算特征在整个训练数据集的均值与方差，再进行规范化。 5.3 从零实现 首先定义一个函数，进行BN操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import torch from torch import nn from d2l import torch as d2l def batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum): # 通过is_grad_enabled来判断当前模式是训练模式还是预测模式 if not torch.is_grad_enabled(): # 如果是在预测模式下，直接使用传入的移动平均所得的均值和方差 X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps) else: assert len(X.shape) in (2, 4) if len(X.shape) == 2: # 使用全连接层的情况，计算特征维上的均值和方差 mean = X.mean(dim=0) var = ((X - mean) ** 2).mean(dim=0) else: # 使用二维卷积层的情况，计算通道维上（axis=1）的均值和方差。 # 这里我们需要保持X的形状以便后面可以做广播运算 mean = X.mean(dim=(0, 2, 3), keepdim=True) var = ((X - mean) ** 2).mean(dim=(0, 2, 3), keepdim=True) # 训练模式下，用当前的均值和方差做标准化 X_hat = (X - mean) / torch.sqrt(var + eps) # 更新移动平均的均值和方差 moving_mean = momentum * moving_mean + (1.0 - momentum) * mean moving_var = momentum * moving_var + (1.0 - momentum) * var Y = gamma * X_hat + beta # 缩放和移位 return Y, moving_mean.data, moving_var.data 然后定义一个BatchNorm层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class BatchNorm(nn.Module): # num_features：完全连接层的输出数量或卷积层的输出通道数。 # num_dims：2表示完全连接层，4表示卷积层 def __init__(self, num_features, num_dims): super().__init__() if num_dims == 2: shape = (1, num_features) else: shape = (1, num_features, 1, 1) # 参与求梯度和迭代的拉伸和偏移参数，分别初始化成1和0 self.gamma = nn.Parameter(torch.ones(shape)) self.beta = nn.Parameter(torch.zeros(shape)) # 非模型参数的变量初始化为0和1 self.moving_mean = torch.zeros(shape) self.moving_var = torch.ones(shape) def forward(self, X): # 如果X不在内存上，将moving_mean和moving_var # 复制到X所在显存上 if self.moving_mean.device != X.device: self.moving_mean = self.moving_mean.to(X.device) self.moving_var = self.moving_var.to(X.device) # 保存更新过的moving_mean和moving_var Y, self.moving_mean, self.moving_var = batch_norm( X, self.gamma, self.beta, self.moving_mean, self.moving_var, eps=1e-5, momentum=0.9) return Y 5.4 使用批量规范化层的LeNet 定义模型 1 2 3 4 5 6 7 8 net = nn.Sequential( nn.Conv2d(1, 6, kernel_size=5), BatchNorm(6, num_dims=4), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Conv2d(6, 16, kernel_size=5), BatchNorm(16, num_dims=4), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.Linear(16*4*4, 120), BatchNorm(120, num_dims=2), nn.Sigmoid(), nn.Linear(120, 84), BatchNorm(84, num_dims=2), nn.Sigmoid(), nn.Linear(84, 10)) 训练模型 1 2 3 4 5 6 lr, num_epochs, batch_size = 1.0, 10, 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.272, train acc 0.899, test acc 0.863 # 23764.9 examples/sec on cuda:0 查看模型BN层的γ与β参数 1 2 3 4 5 net[1].gamma.reshape((-1,)), net[1].beta.reshape((-1,)) # (tensor([3.3490, 3.2102, 4.1508, 1.7645, 2.7210, 0.5482], device=\u0026#39;cuda:0\u0026#39;, # grad_fn=\u0026lt;ViewBackward0\u0026gt;), # tensor([ 0.3007, 2.3391, 4.3099, -0.4318, -0.8200, -0.5383], device=\u0026#39;cuda:0\u0026#39;, # grad_fn=\u0026lt;ViewBackward0\u0026gt;)) 6. 残差网络(ResNet) 残差网络主要由何凯明等人提出，在2015年ImageNet挑战赛中取得了冠军。 6.1 函数类 （1）非嵌套函数类\n新模型 = 新添加的层 ← 原模型 在先前学习的深度神经网络中，每个神经网络层/块基本独立非嵌套关系，即前者的输出直接作为后者的输入。对于复杂的模型架构，有时新添加的层并不能使模型接近最优解，甚至可能更糟； （2）嵌套函数类\n新模型 = 新添加的层 + 原模型 如果新添加的层效果不明显，新模型仍然有机会基于原模型更新梯度。即新模型可能得出更优的解来拟合数据集（至少不会变差）。 6.2 残差块 如下左图，为一个正常的神经网络架构，若输出为f(x)。 由输入x，经神经网络层映射，得到输出f(x) 如下右图，为一个残差块架构，若输出为f(x)。 由输入x，经神经网络层与原数据共同组成f(x)。 ResNet网络中残差块共有两种，区别在于原模型数据的输入： 一种是原模型的x直接输入 另一种是原模型的x经1×1卷积层后再输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l # input_channels 输入的通道 # num_channels 输出的通道 # use_1x1conv参数声明是否考虑对x进行1×1卷积 # strides 对于第一层卷积以及1×1卷积进行高宽缩减 class Residual(nn.Module): #@save def __init__(self, input_channels, num_channels, use_1x1conv=False, strides=1): super().__init__() self.conv1 = nn.Conv2d(input_channels, num_channels, kernel_size=3, padding=1, stride=strides) self.conv2 = nn.Conv2d(num_channels, num_channels, kernel_size=3, padding=1) if use_1x1conv: self.conv3 = nn.Conv2d(input_channels, num_channels, kernel_size=1, stride=strides) else: self.conv3 = None self.bn1 = nn.BatchNorm2d(num_channels) self.bn2 = nn.BatchNorm2d(num_channels) def forward(self, X): Y = F.relu(self.bn1(self.conv1(X))) Y = self.bn2(self.conv2(Y)) if self.conv3: X = self.conv3(X) Y += X return F.relu(Y) 查看示例输出 1 2 3 4 5 6 7 8 9 10 11 # 输入通道为3，输出通道为3 blk = Residual(3,3) X = torch.rand(4, 3, 6, 6) # 4个样本 Y = blk(X) Y.shape # torch.Size([4, 3, 6, 6]) # 输入通道为3，输出通道为6，高宽减半（必须调用1×1卷积） blk = Residual(3,6, use_1x1conv=True, strides=2) blk(X).shape # torch.Size([4, 6, 3, 3]) 6.3 ResNet模型 ResNet模型由如下部分组成\n第1部分：卷积层+BN+最大汇聚层，64通道输出，高宽降低四倍 1 2 3 b1 = nn.Sequential(nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3), nn.BatchNorm2d(64), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)) 第2~5部分由4个block组成，每个block包含两个2残差块 除了第1个Block以外的第1个残差块都需要将高宽减半，通道数加倍 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def resnet_block(input_channels, num_channels, num_residuals, first_block=False): blk = [] for i in range(num_residuals): if i == 0 and not first_block: blk.append(Residual(input_channels, num_channels, #输出通道数是输入的2倍 use_1x1conv=True, strides=2)) else: blk.append(Residual(num_channels, num_channels)) #输入输出通道数相同 return blk b2 = nn.Sequential(*resnet_block(64, 64, 2, first_block=True)) b3 = nn.Sequential(*resnet_block(64, 128, 2)) b4 = nn.Sequential(*resnet_block(128, 256, 2)) b5 = nn.Sequential(*resnet_block(256, 512, 2)) 最后的第6部分连接全局平均汇聚层以及全连接输出层 1 2 3 net = nn.Sequential(b1, b2, b3, b4, b5, nn.AdaptiveAvgPool2d((1,1)), nn.Flatten(), nn.Linear(512, 10)) 4个Block包含共包含8个残差块，共16个卷积层，加上第一个卷积层以及最后一个全连接层，共有18层，因此又称为ResNet-18。\n查看示例形状输出 1 2 3 4 X = torch.rand(size=(1, 1, 224, 224)) for layer in net: X = layer(X) print(layer.__class__.__name__,\u0026#39;output shape:\\t\u0026#39;, X.shape) 6.4 训练模型 1 2 3 4 5 6 lr, num_epochs, batch_size = 0.05, 10, 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96) d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.010, train acc 0.998, test acc 0.904 # 10662.5 examples/sec on cuda:0 7. 稠密连接网络(DenseNet) DenseNet相当于是ResNet的逻辑扩展。 7.1 从ResNet到DenseNet ResNet和DenseNet的关键区别在于，DenseNet输出是连接（用图中的[,]表示）而不是如ResNet的简单相加。 稠密网络主要由2部分构成：稠密块（dense block）和过渡层（transition layer）。 前者定义如何连接输入和输出，而后者则控制通道数量，使其不会太复杂。 7.2 稠密块 基本的“批量规范化、激活和卷积”架构 1 2 3 4 5 6 7 8 import torch from torch import nn from d2l import torch as d2l def conv_block(input_channels, num_channels): return nn.Sequential( nn.BatchNorm2d(input_channels), nn.ReLU(), nn.Conv2d(input_channels, num_channels, kernel_size=3, padding=1)) #高宽不变 一个稠密块由多个卷积块组成，每个卷积块使用相同数量的输出通道； 在前向传播中，我们将每个卷积块的输入和输出在通道维上连结。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # num_convs 卷积层数, # input_channels 输入通道数, # num_channels 输出通道数 class DenseBlock(nn.Module): def __init__(self, num_convs, input_channels, num_channels): super(DenseBlock, self).__init__() layer = [] for i in range(num_convs): # 每多一个卷积层，其输入通道数不断增加 layer.append(conv_block( num_channels * i + input_channels, num_channels)) self.net = nn.Sequential(*layer) def forward(self, X): for blk in self.net: Y = blk(X) # 连接通道维度上每个块的输入和输出，即通道数增加 X = torch.cat((X, Y), dim=1) return X 示例展示：第一层输入通道数为3，第二层输入通道数是10+3，第二次输出通道数是10 + 10 + 3 1 2 3 4 5 blk = DenseBlock(2, 3, 10) X = torch.randn(4, 3, 8, 8) Y = blk(X) Y.shape # torch.Size([4, 23, 8, 8]) 7.3 过渡层 上述稠密层会导致通道数的不断累加、增多 过渡层用来控制模型复杂度，通过1×1卷积层来减小通道数，并使用步幅为2的平均汇聚层减半高和宽。 1 2 3 4 5 6 7 8 9 def transition_block(input_channels, num_channels): return nn.Sequential( nn.BatchNorm2d(input_channels), nn.ReLU(), nn.Conv2d(input_channels, num_channels, kernel_size=1), nn.AvgPool2d(kernel_size=2, stride=2)) blk = transition_block(23, 10) blk(Y).shape # torch.Size([4, 10, 4, 4]) 7.4 DenseNet模型 架构基本类似ResNet。\n第一部分由单卷积层和最大汇聚层组成 1 2 3 4 b1 = nn.Sequential( nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3), nn.BatchNorm2d(64), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1)) 后面再接4个稠密快，每个块由4个卷积层组成 1 2 3 4 5 6 7 8 9 10 11 12 # num_channels为当前的通道数 num_channels, growth_rate = 64, 32 num_convs_in_dense_blocks = [4, 4, 4, 4] blks = [] for i, num_convs in enumerate(num_convs_in_dense_blocks): blks.append(DenseBlock(num_convs, num_channels, growth_rate)) # 上一个稠密块的输出通道数 num_channels += num_convs * growth_rate # 在稠密块之间添加一个转换层，使通道数量减半 if i != len(num_convs_in_dense_blocks) - 1: blks.append(transition_block(num_channels, num_channels // 2)) num_channels = num_channels // 2 最后接上全局汇聚层和全连接层来输出结果。 1 2 3 4 5 6 net = nn.Sequential( b1, *blks, nn.BatchNorm2d(num_channels), nn.ReLU(), nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(), nn.Linear(num_channels, 10)) 7.5 训练模型 1 2 3 4 5 6 lr, num_epochs, batch_size = 0.1, 10, 256 train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96) d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) # loss 0.140, train acc 0.949, test acc 0.887 # 8501.4 examples/sec on cuda:0 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/710d2l-%E7%AC%AC%E4%B8%83%E7%AB%A0%E7%8E%B0%E4%BB%A3%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","summary":"\u003ch1 id=\"1-深度卷积神经网络alexnet\"\u003e1. 深度卷积神经网络(AlexNet)\u003c/h1\u003e\n\u003ch2 id=\"11-学习表征\"\u003e1.1 学习表征\u003c/h2\u003e\n\u003cp\u003eLeNet提出后，卷积神经网络并未占据主流，而是往往由其它机器学习方法所超越，如SVM。一个主要的原因是输入数据的特征处理上。\u003c/p\u003e","title":"D2L--第七章现代卷积神经网络"},{"content":"1. 序列模型 1.1 自回归模型 （1）自回归模型：对于一个包含T个\u0026rsquo;时间\u0026rsquo;节点的输入序列，若预测其中的第t个数据，则依赖于该节点前面的观察数据\n基于此，对于整个序列的估计值，可以表示为： 然而这对于长序列则计算量过大。我们可以使用该节点前面的τ个样本建模，控制模型参数的数量。 如果序列可以按这种方式计算，则认为其满足马尔科夫条件。 当τ=1（根据前一个节点推测后一个节点）时，序列估计可以写成如下形式。 Tips：称为自回归的原因是输入与输出预测同一类型的数据。\n（2）隐变量自回归模型 通过一个隐藏(latent):的变量推测Xt的值。而该隐藏变量来自于上一状态的隐变量以及当前Xt-1节点的值。（RNN, Recurrent Neural Network)的思想）\n1.2 训练 如下将演示如何根据正弦函数的样本点，建立τ=4的自回归模型\n第一步：模拟正弦函数的数据，x轴从0到1000 1 2 3 4 5 6 7 8 9 %matplotlib inline import torch from torch import nn from d2l import torch as d2l T = 1000 # 总共产生1000个点 time = torch.arange(1, T + 1, dtype=torch.float32) x = torch.sin(0.01 * time) + torch.normal(0, 0.2, (T,)) #添加一点噪音 d2l.plot(time, [x], \u0026#39;time\u0026#39;, \u0026#39;x\u0026#39;, xlim=[1, 1000], figsize=(6, 3)) 第二步：生成特征与标签数据（前4个样本作为输入，第5个样本作为预测） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 tau = 4 features = torch.zeros((T - tau, tau)) #tau列 for i in range(tau): #逐列填充，每次错开一个元素 features[:, i] = x[i: T - tau + i] labels = x[tau:].reshape((-1, 1)) features[:4,:], labels[:4] # (tensor([[-0.1026, -0.2982, 0.1424, 0.0798], # [-0.2982, 0.1424, 0.0798, 0.1033], # [ 0.1424, 0.0798, 0.1033, 0.0814], # [ 0.0798, 0.1033, 0.0814, -0.3063]]), # tensor([[ 0.1033], # [ 0.0814], # [-0.3063], # [ 0.1354]])) batch_size, n_train = 16, 600 # 只有前n_train个样本用于训练 # 批量数据迭代 train_iter = d2l.load_array((features[:n_train], labels[:n_train]), batch_size, is_train=True) 第三步：建立模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 初始化网络权重的函数 def init_weights(m): if type(m) == nn.Linear: nn.init.xavier_uniform_(m.weight) # 一个简单的多层感知机 def get_net(): net = nn.Sequential(nn.Linear(4, 10), nn.ReLU(), nn.Linear(10, 1)) net.apply(init_weights) return net # 平方损失，不做聚合操作 loss = nn.MSELoss(reduction=\u0026#39;none\u0026#39;) 第四步：训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 def train(net, train_iter, loss, epochs, lr): trainer = torch.optim.Adam(net.parameters(), lr) #优化算法 for epoch in range(epochs): for X, y in train_iter: trainer.zero_grad() l = loss(net(X), y) l.sum().backward() trainer.step() print(f\u0026#39;epoch {epoch + 1}, \u0026#39; f\u0026#39;loss: {d2l.evaluate_loss(net, train_iter, loss):f}\u0026#39;) net = get_net() train(net, train_iter, loss, 5, 0.01) 1.3 预测 预测方式1：特征数据全部来自已知数据 1 2 3 4 5 6 onestep_preds = net(features) d2l.plot([time, time[tau:]], [x.detach().numpy(), onestep_preds.detach().numpy()], \u0026#39;time\u0026#39;, \u0026#39;x\u0026#39;, legend=[\u0026#39;data\u0026#39;, \u0026#39;1-step preds\u0026#39;], xlim=[1, 1000], figsize=(6, 3)) # 下图左 预测方式2：前604个样本来训练集的已知数据。再后面预测时，每次将新预测的样本作为输入预测下一个输出。 1 2 3 4 5 6 7 8 9 10 11 12 13 multistep_preds = torch.zeros(T) #初始化全0 multistep_preds[: n_train + tau] = x[: n_train + tau] #前面的训练集数据已知，不做预测 for i in range(n_train + tau, T): # 将新预测的结果加入特征中，作为下一次预测的输入 multistep_preds[i] = net( multistep_preds[i - tau:i].reshape((1, -1))) d2l.plot([time, time[tau:], time[n_train + tau:]], [x.detach().numpy(), onestep_preds.detach().numpy(), multistep_preds[n_train + tau:].detach().numpy()], \u0026#39;time\u0026#39;, \u0026#39;x\u0026#39;, legend=[\u0026#39;data\u0026#39;, \u0026#39;1-step preds\u0026#39;, \u0026#39;multistep preds\u0026#39;], xlim=[1, 1000], figsize=(6, 3)) # 下图右 如上可以看出： 在单步预测（输入均为实际观测数据）时，模型效果不错； 而在预测多步（将最近的预测作为下一步输入）时，即更远的预测时，模型效果不尽如人意。 2 文本预处理 一篇文章可以视为一串单词的序列，需要进行必要的预处理操作步骤：\n（1）将文本作为字符串进行加载；\n（2）将字符串拆分为词元（单词或字符）；\n（3）建立一个词表，将词元映射到数字索引；\n（4）将文本转换为数字索引序列。\n2.1 读取数据集 示例数据：时光机器（The Time Machine）小说 如下操作，按行读取全部小说文本。结果为list，其中每个元素表示一行的文本。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #@save d2l.DATA_HUB[\u0026#39;time_machine\u0026#39;] = (d2l.DATA_URL + \u0026#39;timemachine.txt\u0026#39;, \u0026#39;090b5e7e70c295757f55df93cb0a180b9691891a\u0026#39;) def read_time_machine(): #@save \u0026#34;\u0026#34;\u0026#34;将时间机器数据集加载到文本行的列表中\u0026#34;\u0026#34;\u0026#34; with open(d2l.download(\u0026#39;time_machine\u0026#39;), \u0026#39;r\u0026#39;) as f: lines = f.readlines() return [re.sub(\u0026#39;[^A-Za-z]+\u0026#39;, \u0026#39; \u0026#39;, line).strip().lower() for line in lines] lines = read_time_machine() # list print(f\u0026#39;# 文本总行数: {len(lines)}\u0026#39;) # 文本总行数: 3221 print(lines[0]) # the time machine by h g wells print(lines[10]) # twinkled and his usually pale face was flushed and animated the 2.2 词元化 词元(token)，通常指一个单词或字符 如下操作将每一行以词元为单位，拆分为一个list，结果返回一个list of list 1 2 3 4 5 6 7 8 9 10 11 12 def tokenize(lines, token=\u0026#39;word\u0026#39;): #@save \u0026#34;\u0026#34;\u0026#34;将文本行拆分为单词或字符词元\u0026#34;\u0026#34;\u0026#34; if token == \u0026#39;word\u0026#39;: return [line.split() for line in lines] elif token == \u0026#39;char\u0026#39;: return [list(line) for line in lines] else: print(\u0026#39;错误：未知词元类型：\u0026#39; + token) tokens = tokenize(lines) #list of list, 内部list的元素即为词元 print(tokens[0]) # [\u0026#39;the\u0026#39;, \u0026#39;time\u0026#39;, \u0026#39;machine\u0026#39;, \u0026#39;by\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;wells\u0026#39;] 2.3 词表 词元的类型是字符串，而模型需要的是数字； 词表(Vocabulary)：类似于Python中的字典，将输入的词元转换为数字索引； 语料库(Corpus)：对所有文本中唯一词元的统计结果，按频率降序排。 对于低频率出现的词元，可设置一定标准的阈值过滤； 对于语料库中不存在，或者已过滤的词元，将被映射到未知词元\u0026rsquo;\u0026lt;unk\u0026gt;\u0026rsquo;, 其数字索引记为0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Vocab: #@save \u0026#34;\u0026#34;\u0026#34;文本词表\u0026#34;\u0026#34;\u0026#34; def __init__(self, tokens=None, min_freq=0, reserved_tokens=None): if tokens is None: tokens = [] if reserved_tokens is None: reserved_tokens = [] # 按出现频率排序 counter = count_corpus(tokens) # counter.items() e.g. [(\u0026#39;word1\u0026#39;, 5), (\u0026#39;word2\u0026#39;, 3), (\u0026#39;word3\u0026#39;, 8)] self._token_freqs = sorted(counter.items(), key=lambda x: x[1], reverse=True) # 未知词元的索引为0 self.idx_to_token = [\u0026#39;\u0026lt;unk\u0026gt;\u0026#39;] + reserved_tokens self.token_to_idx = {token: idx for idx, token in enumerate(self.idx_to_token)} for token, freq in self._token_freqs: if freq \u0026lt; min_freq: break if token not in self.token_to_idx: self.idx_to_token.append(token) self.token_to_idx[token] = len(self.idx_to_token) - 1 def __len__(self): return len(self.idx_to_token) # 如果传入单个词元，则返回其索引；如果传入词元列表，则返回对应的索引列表。 def __getitem__(self, tokens): if not isinstance(tokens, (list, tuple)): return self.token_to_idx.get(tokens, self.unk) return [self.__getitem__(token) for token in tokens] # 根据输入的索引或索引列表返回对应的词元。 def to_tokens(self, indices): if not isinstance(indices, (list, tuple)): return self.idx_to_token[indices] return [self.idx_to_token[index] for index in indices] @property def unk(self): # 未知词元的索引为0 return 0 @property def token_freqs(self): return self._token_freqs def count_corpus(tokens): #@save \u0026#34;\u0026#34;\u0026#34;统计词元的频率\u0026#34;\u0026#34;\u0026#34; # 这里的tokens是1D列表或2D列表 if len(tokens) == 0 or isinstance(tokens[0], list): # 将词元list of list列表展平成一个列表 tokens = [token for line in tokens for token in line] return collections.Counter(tokens) vocab = Vocab(tokens) list(vocab.token_to_idx.items())[:5] # [(\u0026#39;\u0026lt;unk\u0026gt;\u0026#39;, 0), (\u0026#39;the\u0026#39;, 1), (\u0026#39;i\u0026#39;, 2), (\u0026#39;and\u0026#39;, 3), (\u0026#39;of\u0026#39;, 4)] vocab.token_freqs[:5] # [(\u0026#39;the\u0026#39;, 2261), (\u0026#39;i\u0026#39;, 1267), (\u0026#39;and\u0026#39;, 1245), (\u0026#39;of\u0026#39;, 1155), (\u0026#39;a\u0026#39;, 816)] 2.4 整合所有功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def load_corpus_time_machine(max_tokens=-1): #@save \u0026#34;\u0026#34;\u0026#34;返回时光机器数据集的词元索引列表和词表\u0026#34;\u0026#34;\u0026#34; lines = read_time_machine() tokens = tokenize(lines, \u0026#39;char\u0026#39;) #词元为字符 vocab = Vocab(tokens) # 因为时光机器数据集中的每个文本行不一定是一个句子或一个段落， # 所以将所有文本行展平到一个列表中 corpus = [vocab[token] for line in tokens for token in line] if max_tokens \u0026gt; 0: corpus = corpus[:max_tokens] return corpus, vocab # corpus 全部文本的词元 corpus, vocab = load_corpus_time_machine() len(corpus), len(vocab) # (170580, 28) corpus[:5] # [3, 9, 2, 1, 3] vocab.token_freqs[:5] # [(\u0026#39; \u0026#39;, 29927), (\u0026#39;e\u0026#39;, 17838), (\u0026#39;t\u0026#39;, 13515), (\u0026#39;a\u0026#39;, 11704), (\u0026#39;i\u0026#39;, 10138)] 3. 语言模型和数据集 3.1 自然语言统计 单个词元统计（一元语法） 1 2 3 4 5 6 7 8 9 10 11 import random import torch from d2l import torch as d2l tokens = d2l.tokenize(d2l.read_time_machine()) # 将list of list转为list corpus = [token for line in tokens for token in line] vocab = d2l.Vocab(corpus) vocab.token_freqs[:10] # [(\u0026#39;the\u0026#39;, 2261), (\u0026#39;i\u0026#39;, 1267), (\u0026#39;and\u0026#39;, 1245)] 两个连续词元统计（二元语法） 1 2 3 4 5 6 bigram_tokens = [pair for pair in zip(corpus[:-1], corpus[1:])] bigram_tokens[:3] # [(\u0026#39;the\u0026#39;, \u0026#39;time\u0026#39;), (\u0026#39;time\u0026#39;, \u0026#39;machine\u0026#39;), (\u0026#39;machine\u0026#39;, \u0026#39;by\u0026#39;)] bigram_vocab = d2l.Vocab(bigram_tokens) bigram_vocab.token_freqs[:3] # [((\u0026#39;of\u0026#39;, \u0026#39;the\u0026#39;), 309), ((\u0026#39;in\u0026#39;, \u0026#39;the\u0026#39;), 169), ((\u0026#39;i\u0026#39;, \u0026#39;had\u0026#39;), 130)] 三个连续词元统计（三元语法） 1 2 3 4 5 6 7 trigram_tokens = [triple for triple in zip( corpus[:-2], corpus[1:-1], corpus[2:])] trigram_vocab = d2l.Vocab(trigram_tokens) trigram_vocab.token_freqs[:3] # [((\u0026#39;the\u0026#39;, \u0026#39;time\u0026#39;, \u0026#39;traveller\u0026#39;), 59), # ((\u0026#39;the\u0026#39;, \u0026#39;time\u0026#39;, \u0026#39;machine\u0026#39;), 30), # ((\u0026#39;the\u0026#39;, \u0026#39;medical\u0026#39;, \u0026#39;man\u0026#39;), 24)] 根据下图的频率分布可视化，可以看出： 三者均不同程度上遵循齐普夫定律，呈现较为显著的衰减 少数高频词占了全部语料库的大多数，大部分可能形式的n元组很少出现 1 2 3 4 5 6 freqs = [freq for token, freq in vocab.token_freqs] bigram_freqs = [freq for token, freq in bigram_vocab.token_freqs] trigram_freqs = [freq for token, freq in trigram_vocab.token_freqs] d2l.plot([freqs, bigram_freqs, trigram_freqs], xlabel=\u0026#39;token: x\u0026#39;, ylabel=\u0026#39;frequency: n(x)\u0026#39;, xscale=\u0026#39;log\u0026#39;, yscale=\u0026#39;log\u0026#39;, legend=[\u0026#39;unigram\u0026#39;, \u0026#39;bigram\u0026#39;, \u0026#39;trigram\u0026#39;]) 3.2 读取长序列数据 如前所述，在处理长序列时，通常仅考虑待预测数据前的若干节点的观测数据。\nbatch_size：每个小批量同时处理的子序列样本数目；\nnum_steps：每个子序列中预定义的时间步数。\n在小批量采样时，由如下两种方式（子序列的时间步数都不重叠）\n随机偏移量：从一个随机起始点开始截取序列，增加每个epoch迭代的随机性\n（1）随机抽样\n每个批量样本之间的起始时间步数无顺序关系 e.g. 第一个小批量的第一个序列与第二个小批量的第一个序列无相邻的顺序关系 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def seq_data_iter_random(corpus, batch_size, num_steps): #@save \u0026#34;\u0026#34;\u0026#34;使用随机抽样生成一个小批量子序列\u0026#34;\u0026#34;\u0026#34; # 从随机偏移量开始对序列进行分区(随机丢弃开头的几个位置数据)，随机范围包括num_steps-1 corpus = corpus[random.randint(0, num_steps - 1):] # 计算可以生成多少个不重叠的子序列(减去1，是因为我们需要考虑标签) num_subseqs = (len(corpus) - 1) // num_steps # 每个子序列的起始索引 initial_indices = list(range(0, num_subseqs * num_steps, num_steps)) # 打乱初始索引 random.shuffle(initial_indices) def data(pos): # 返回从pos位置开始的长度为num_steps的序列 return corpus[pos: pos + num_steps] #根据每个小批量包含的子序列数，计算有多少个批量 num_batches = num_subseqs // batch_size for i in range(0, batch_size * num_batches, batch_size): # 在这里，每个批量内所有子序列的起始索引 initial_indices_per_batch = initial_indices[i: i + batch_size] X = [data(j) for j in initial_indices_per_batch] Y = [data(j + 1) for j in initial_indices_per_batch] yield torch.tensor(X), torch.tensor(Y) 示例 1 2 3 4 5 6 7 8 9 10 11 12 random_iter = seq_data_iter_random(list(range(35)), batch_size=2, num_steps=5) next(iter(random_iter)) # (tensor([[24, 25, 26, 27, 28], # [14, 15, 16, 17, 18]]), # tensor([[25, 26, 27, 28, 29], # [15, 16, 17, 18, 19]])) next(iter(random_iter)) # (tensor([[ 9, 10, 11, 12, 13], # [ 4, 5, 6, 7, 8]]), # tensor([[10, 11, 12, 13, 14], # [ 5, 6, 7, 8, 9]])) （2）顺序分区\n保证两个相邻的小批量中的子序列在原始序列上也是相邻的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def seq_data_iter_sequential(corpus, batch_size, num_steps): #@save \u0026#34;\u0026#34;\u0026#34;使用顺序分区生成一个小批量子序列\u0026#34;\u0026#34;\u0026#34; # 从随机偏移量开始划分序列 offset = random.randint(0, num_steps) # 确保可以被整除的tokens词元数量 num_tokens = ((len(corpus) - offset - 1) // batch_size) * batch_size # 所有作为特征的输入序列 Xs = torch.tensor(corpus[offset: offset + num_tokens]) # 所有的标签值 Ys = torch.tensor(corpus[offset + 1: offset + 1 + num_tokens]) # 行数表示每个批量包含的子序列数 Xs, Ys = Xs.reshape(batch_size, -1), Ys.reshape(batch_size, -1) num_batches = Xs.shape[1] // num_steps for i in range(0, num_steps * num_batches, num_steps): X = Xs[:, i: i + num_steps] Y = Ys[:, i: i + num_steps] yield X, Y 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 iter_seq = seq_data_iter_sequential(list(range(35)), batch_size=2, num_steps=5) next(iter(iter_seq)) # (tensor([[ 2, 3, 4, 5, 6], # [18, 19, 20, 21, 22]]), # tensor([[ 3, 4, 5, 6, 7], # [19, 20, 21, 22, 23]])) next(iter(iter_seq)) # (tensor([[ 7, 8, 9, 10, 11], # [23, 24, 25, 26, 27]]), # tensor([[ 8, 9, 10, 11, 12], # [24, 25, 26, 27, 28]])) Tips：无论上述哪一种方式，生成的序列样本数据都是不重叠的。\n整合上述迭代方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # 定义一个类，生成数据迭代器 class SeqDataLoader: #@save \u0026#34;\u0026#34;\u0026#34;加载序列数据的迭代器\u0026#34;\u0026#34;\u0026#34; def __init__(self, batch_size, num_steps, use_random_iter, max_tokens): if use_random_iter: self.data_iter_fn = d2l.seq_data_iter_random else: self.data_iter_fn = d2l.seq_data_iter_sequential # 返回所有文档的词元索引列表，以及词表vocab self.corpus, self.vocab = d2l.load_corpus_time_machine(max_tokens) self.batch_size, self.num_steps = batch_size, num_steps def __iter__(self): return self.data_iter_fn(self.corpus, self.batch_size, self.num_steps) # 综合词表与数据迭代器 def load_data_time_machine(batch_size, num_steps, #@save use_random_iter=False, max_tokens=10000): \u0026#34;\u0026#34;\u0026#34;返回时光机器数据集的迭代器和词表\u0026#34;\u0026#34;\u0026#34; data_iter = SeqDataLoader( batch_size, num_steps, use_random_iter, max_tokens) return data_iter, data_iter.vocab 4. 循环神经网络 循环神经网络是具有隐状态的神经网络； 隐状态与隐藏层的概念截然不同 隐藏层是指在从输入到输出的路径上，隐藏的层； 隐状态可以理解为RNN中的记忆单元，它保存了序列中先前时间步的信息，并传递给后续的时间步。 4.1 无隐状态的神经网络 以简单的单隐藏层MLP为例：\n输入X，隐藏层输出H，隐藏层权重参数Wxh，偏置参数b 输出层O，权重参数Whq，偏置参数b 4.2 有隐状态的神经网络 对于一个特定时间步长的序列：\nXt步的输出(Ot，表示对于Xt+1的预测)，取决于当前时间序列的隐状态Ht； 而当前的隐状态Ht由当前时间步的输入Xt与前一个时间步的隐状态Ht-1共同计算得出。 对于输入的小批量数据，由n个长度为T的序列样本组成。若样本特征长度为d时，则每次训练输入数据为 Xt：n×d 基于Xt的输入，参与Ht计算的权重参数为Wxh；基于Ht-1隐状态，参与Ht计算的权重参数为Whh，此外还有偏置； 从Ht隐状态，最终计算Ot的权重参数为Whq，以及偏置。 （1）如上可以看出，有隐状态的神经网络从公式上来看，与单隐藏层的神经网络非常类似。只是多了一项Wxh参数的计算过程。\n（2）在同一批量的不同时间节点迭代时，仍然是上述这些模型参数。即模型参数的开销不会随着时间步的增加而增加。\n如下，演示同时对特定一个批量内多个子序列的第i个词元的隐状态计算： 输入的批量包含3条子序列，每条子序列中单个词元的特征长度为1； 隐状态的神经元个数设置为4。 1 2 3 4 5 6 7 import torch from d2l import torch as d2l X, W_xh = torch.normal(0, 1, (3, 1)), torch.normal(0, 1, (1, 4)) H, W_hh = torch.normal(0, 1, (3, 4)), torch.normal(0, 1, (4, 4)) torch.matmul(X, W_xh) + torch.matmul(H, W_hh) 4.3 基于RNN的字符级语言模型 在字符级语言模型中，文本词元为字符而不是单词； 如下可以理解为小批量大小为1，文本序列为\u0026rsquo;machine' 4.4 困惑度 语言模型大部分情况下可以理解为分类问题，可以利用交叉熵计算模型输入与标签之间的差异； 模型性能(损失)可根据一个序列中所有词元(n)的平均交叉熵损失来衡量； 实际建模时，自然语言处理的科学家更喜欢使用困惑度(Perplexity)指标。本质上只是对上述进行exp指数运算。 该指标可以理解为对下一个词元的实际选择数的调和平均数。 困惑度越低，说明模型的预测效果越好。最好的情况为1，即完美地估计了标签词元； 如果困惑度为 kk，那么可以理解为模型预测下一个词时的候选词数量大致为 k。 5. RNN的从零实现 从零开始基于RNN实现字符级语言模型\n读取数据集 batch_size表示每个批量同时读取/处理多少条子序列 num_steps表示每条子序列的长度 1 2 3 4 5 6 7 8 9 %matplotlib inline import math import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l batch_size, num_steps = 32, 35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) 5.1 独热编码 每个词元经转换后表示为一个数字索引，然后经独热编码表示为特征向量； 若词表的唯一词元有N个(len(vocab))，则词元索引范围是 0~N-1，其特征向量长度为N 1 2 F.one_hot(torch.tensor([0, 2]), len(vocab)).shape # torch.Size([2, 28]) 特征编码前，小批量输入形状为二维张量（批量大小，时间步数/序列长度） 编码后则为3维张量，需要再调整下维度的顺序，方便后续操作。（时间步数/序列长度，批量大小，词表大小/特征长度） 1 2 3 4 5 6 # 批量大小为2，序列长度为5 X = torch.arange(10).reshape((2, 5)) #X.T转置操作，将序列长度维数放在前面之后，再进行独热编码 F.one_hot(X.T, 28).shape # torch.Size([5, 2, 28]) 5.2 初始化模型参数 RNN模型参数可参考4.2部分介绍，主要分为隐状态参数与输出层参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_params(vocab_size, num_hiddens, device): # 输入与输出的词元的特征向量长度相同 num_inputs = num_outputs = vocab_size def normal(shape): return torch.randn(size=shape, device=device) * 0.01 # 隐藏层参数 W_xh = normal((num_inputs, num_hiddens)) W_hh = normal((num_hiddens, num_hiddens)) b_h = torch.zeros(num_hiddens, device=device) # 输出层参数，num_outputs等于词元类别数 W_hq = normal((num_hiddens, num_outputs)) b_q = torch.zeros(num_outputs, device=device) # 附加梯度 params = [W_xh, W_hh, b_h, W_hq, b_q] for param in params: param.requires_grad_(True) return params 5.3 RNN模型 初始化隐状态，形状为（批量大小，隐藏单元数） 1 2 3 def init_rnn_state(batch_size, num_hiddens, device): return (torch.zeros((batch_size, num_hiddens), device=device), ) # 这里返回元组，因为后面章节的隐状态会有多个变量（LSTM） 定义前向传播函数，返回一轮batch的预测结果（批量大小×序列长度，词表大小），以及更新的隐状态 输入inputs为上述5.1所介绍的三维张量 1 2 3 4 5 6 7 8 9 10 11 12 13 def rnn(inputs, state, params): # inputs的形状：(时间步数量，批量大小，词表大小) W_xh, W_hh, b_h, W_hq, b_q = params H, = state outputs = [] # 逐时间步迭代：X的形状为(批量大小，词表大小) for X in inputs: H = torch.tanh(torch.mm(X, W_xh) + torch.mm(H, W_hh) + b_h) Y = torch.mm(H, W_hq) + b_q # Y形状：(批量大小，词表大小) outputs.append(Y) return torch.cat(outputs, dim=0), (H,) #纵向叠加，增加行数，列数不变，维度不变 定义模型的类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class RNNModelScratch: #@save \u0026#34;\u0026#34;\u0026#34;从零开始实现的循环神经网络模型\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, num_hiddens, device, get_params, init_state, forward_fn): self.vocab_size, self.num_hiddens = vocab_size, num_hiddens self.params = get_params(vocab_size, num_hiddens, device) self.init_state, self.forward_fn = init_state, forward_fn def __call__(self, X, state): X = F.one_hot(X.T, self.vocab_size).type(torch.float32) return self.forward_fn(X, state, self.params) def begin_state(self, batch_size, device): return self.init_state(batch_size, self.num_hiddens, device) 示例输出 1 2 3 4 5 6 7 8 9 10 11 12 13 num_hiddens = 512 net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params, init_rnn_state, rnn) state = net.begin_state(X.shape[0], d2l.try_gpu()) # 批量包含的序列数为2，序列长度为5 X = torch.arange(10).reshape((2, 5)) Y, new_state = net(X.to(d2l.try_gpu()), state) Y.shape # torch.Size([10, 28]) new_state[0].shape #批量内每个子序列最后一个时间步的隐状态 # torch.Size([2, 512]) 5.4 预测 prefix：包含若干词元的初始文本 num_preds：往后预测多少个词元 在预测过程中，首先逐个遍历给定的初始词元，但不做预测，仅用于更新隐状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def predict_ch8(prefix, num_preds, net, vocab, device): #@save \u0026#34;\u0026#34;\u0026#34;在prefix后面生成新字符\u0026#34;\u0026#34;\u0026#34; # batch_size=1表示单批量逐个预测 state = net.begin_state(batch_size=1, device=device) # 首先将prefix的第一个词元加入到outputs中 outputs = [vocab[prefix[0]]] # 取outputs里最新的一个词元，作为预测下一个词元的输入 get_input = lambda: torch.tensor([outputs[-1]], device=device).reshape((1, 1)) for y in prefix[1:]: # 预热期 _, state = net(get_input(), state) outputs.append(vocab[y]) #传入真实值 for _ in range(num_preds): # 预测num_preds步 y, state = net(get_input(), state) outputs.append(int(y.argmax(dim=1).reshape(1))) #传入预测值 return \u0026#39;\u0026#39;.join([vocab.idx_to_token[i] for i in outputs]) 示例 1 2 predict_ch8(\u0026#39;time traveller \u0026#39;, 10, net, vocab, d2l.try_gpu()) # \u0026#39;time traveller xejnnnnnnn\u0026#39; 5.5 梯度剪裁 对于长度为T的序列，训练时会执行T次矩阵乘法，来进行反向传播、更新梯度。 这对于较长的序列，可能会导致梯度爆炸，模型无法收敛。 此时，可以通过梯度剪裁，将参数的梯度的范数设置一个上限θ（不改变方向）。 1 2 3 4 5 6 7 8 9 10 11 def grad_clipping(net, theta): #@save \u0026#34;\u0026#34;\u0026#34;裁剪梯度\u0026#34;\u0026#34;\u0026#34; if isinstance(net, nn.Module): params = [p for p in net.parameters() if p.requires_grad] else: params = net.params norm = torch.sqrt(sum(torch.sum((p.grad ** 2)) for p in params)) #若范数长度大于θ，就设置其值为θ if norm \u0026gt; theta: for param in params: param.grad[:] *= theta / norm 5.6 训练 在3.2小节中，学习了两种小批量序列样本迭代方法：（1）顺序分区；（2）随机抽样 对于顺序分区，相邻两个batch iteration中，对应的第i个子序列的位序也是相邻的。 隐状态仅需要在刚开始时初始化一次。在后面的多轮小批量训练时，可以继承。 为减少计算量，在处理每个批量数据前，对隐状态参数梯度分离。 对于随机抽样，相邻两个batch iteration的序列样本无确定关系（更常用些） 隐状态在每个batch iteration时，都需要随机初始化（其权重参数是持续更新的）。 如下为训练一个epoch的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #@save def train_epoch_ch8(net, train_iter, loss, updater, device, use_random_iter): \u0026#34;\u0026#34;\u0026#34;训练网络一个迭代周期（定义见第8章）\u0026#34;\u0026#34;\u0026#34; state, timer = None, d2l.Timer() metric = d2l.Accumulator(2) # 训练损失之和,词元数量 for X, Y in train_iter: if state is None or use_random_iter: # 在第一次迭代或使用随机抽样时初始化state state = net.begin_state(batch_size=X.shape[0], device=device) else: if isinstance(net, nn.Module) and not isinstance(state, tuple): # state对于nn.GRU是个张量 state.detach_() else: # state对于nn.LSTM或对于我们从零开始实现的模型是个张量 for s in state: s.detach_() y = Y.T.reshape(-1) X, y = X.to(device), y.to(device) y_hat, state = net(X, state) l = loss(y_hat, y.long()).mean() # y转为长整型(64位整数) if isinstance(updater, torch.optim.Optimizer): updater.zero_grad() l.backward() grad_clipping(net, 1) updater.step() else: l.backward() grad_clipping(net, 1) # 因为已经调用了mean函数 updater(batch_size=1) metric.add(l * y.numel(), y.numel()) return math.exp(metric[0] / metric[1]), metric[1] / timer.stop() 如下为训练的最终形式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #@save def train_ch8(net, train_iter, vocab, lr, num_epochs, device, use_random_iter=False): \u0026#34;\u0026#34;\u0026#34;训练模型（定义见第8章）\u0026#34;\u0026#34;\u0026#34; loss = nn.CrossEntropyLoss() animator = d2l.Animator(xlabel=\u0026#39;epoch\u0026#39;, ylabel=\u0026#39;perplexity\u0026#39;, legend=[\u0026#39;train\u0026#39;], xlim=[10, num_epochs]) # 初始化 if isinstance(net, nn.Module): updater = torch.optim.SGD(net.parameters(), lr) else: updater = lambda batch_size: d2l.sgd(net.params, lr, batch_size) predict = lambda prefix: predict_ch8(prefix, 50, net, vocab, device) # 训练和预测 for epoch in range(num_epochs): ppl, speed = train_epoch_ch8( net, train_iter, loss, updater, device, use_random_iter) if (epoch + 1) % 10 == 0: print(predict(\u0026#39;time traveller\u0026#39;)) animator.add(epoch + 1, [ppl]) print(f\u0026#39;困惑度 {ppl:.1f}, {speed:.1f} 词元/秒 {str(device)}\u0026#39;) print(predict(\u0026#39;time traveller\u0026#39;)) print(predict(\u0026#39;traveller\u0026#39;)) 实际训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## 训练--顺序分区（下图左） num_epochs, lr = 500, 1 train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu()) # 困惑度 1.0, 38769.2 词元/秒 cuda:0 # time travelleryou can show black is white by argument said filby # travelleryou can show black is white by argument said filby ## 训练--随机抽样（下图右） net = RNNModelScratch(len(vocab), num_hiddens, d2l.try_gpu(), get_params, init_rnn_state, rnn) train_ch8(net, train_iter, vocab, lr, num_epochs, d2l.try_gpu(), use_random_iter=True) # 困惑度 1.5, 37930.8 词元/秒 cuda:0 # time travellerit s against reason said filbywas allaing the time # travellerit s against reason said filbywas allaing the time 6. RNN的简洁实现 准备数据 1 2 3 4 5 6 7 import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l batch_size, num_steps = 32, 35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) 6.1 定义模型 基于torch的nn.RNN，定义一个具有256个隐藏单元的单隐藏层，其不涉及输出层的计算 1 2 num_hiddens = 256 rnn_layer = nn.RNN(len(vocab), num_hiddens) 初始化隐状态，形状为（隐藏层数，批量大小，隐藏单元数） 1 2 3 state = torch.zeros((1, batch_size, num_hiddens)) state.shape # torch.Size([1, 32, 256]) 模拟计算，更新隐状态 如下的Y表示，所有批量的子序列的最后一层的隐状态（一般后面需要再接MLP预测Ot输出） state_new表示所有批量的子序列的最后一步的隐状态 1 2 3 4 5 6 7 X = torch.rand(size=(num_steps, batch_size, len(vocab))) Y, state_new = rnn_layer(X, state) Y.shape, state_new.shape # (torch.Size([35, 32, 256]), torch.Size([1, 32, 256])) # 35为序列长度 # 32为批量大小 # 256 隐藏层单元数 定义一个完整的RNNModel类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #@save class RNNModel(nn.Module): \u0026#34;\u0026#34;\u0026#34;循环神经网络模型\u0026#34;\u0026#34;\u0026#34; def __init__(self, rnn_layer, vocab_size, **kwargs): super(RNNModel, self).__init__(**kwargs) self.rnn = rnn_layer self.vocab_size = vocab_size self.num_hiddens = self.rnn.hidden_size # 如果RNN是双向的（之后将介绍），num_directions应该是2，否则应该是1 if not self.rnn.bidirectional: self.num_directions = 1 self.linear = nn.Linear(self.num_hiddens, self.vocab_size) else: self.num_directions = 2 self.linear = nn.Linear(self.num_hiddens * 2, self.vocab_size) def forward(self, inputs, state): X = F.one_hot(inputs.T.long(), self.vocab_size) X = X.to(torch.float32) Y, state = self.rnn(X, state) # 全连接层首先将Y的形状改为(时间步数*批量大小,隐藏单元数) # 它的输出形状是(时间步数*批量大小,词表大小)。 output = self.linear(Y.reshape((-1, Y.shape[-1]))) return output, state def begin_state(self, device, batch_size=1): if not isinstance(self.rnn, nn.LSTM): # nn.GRU以张量作为隐状态 return torch.zeros((self.num_directions * self.rnn.num_layers, batch_size, self.num_hiddens), device=device) else: # nn.LSTM以元组作为隐状态 return (torch.zeros(( self.num_directions * self.rnn.num_layers, batch_size, self.num_hiddens), device=device), torch.zeros(( self.num_directions * self.rnn.num_layers, batch_size, self.num_hiddens), device=device)) 6.2 训练与预测 训练函数仍参考5.6小节 实例化模型 1 2 3 4 5 device = d2l.try_gpu() net = RNNModel(rnn_layer, vocab_size=len(vocab)) net = net.to(device) d2l.predict_ch8(\u0026#39;time traveller\u0026#39;, 10, net, vocab, device) # \u0026#39;time travellerpppwllllll\u0026#39; 训练模型 1 2 3 4 5 num_epochs, lr = 500, 1 d2l.train_ch8(net, train_iter, vocab, lr, num_epochs, device) # perplexity 1.3, 255236.1 tokens/sec on cuda:0 # time traveller but now you be in aly has we mave the gratienttan # travellerit s ala to be accupted is an absolute procimind a ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/711d2l-%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","summary":"\u003ch1 id=\"1-序列模型\"\u003e1. 序列模型\u003c/h1\u003e\n\u003ch2 id=\"11-自回归模型\"\u003e1.1 自回归模型\u003c/h2\u003e\n\u003cp\u003e（1）\u003cstrong\u003e自回归模型\u003c/strong\u003e：对于一个包含T个\u0026rsquo;时间\u0026rsquo;节点的输入序列，若预测其中的第t个数据，则依赖于该节点前面的观察数据\u003c/p\u003e","title":"D2L--第八章循环神经网络"},{"content":"1. 门控循环单元(GRU) 传统的RNN在处理长序列时会遇到梯度消失或梯度爆炸的问题。为了解决这些问题，引入了门控机制的变种，如长短时记忆网络（LSTM, long short-term memory）和门控循环单元（GRU, gated recurrent unit）。GRU是LSTM的一个简化版本，它通过合并某些门并减少参数数量来提高效率。\n1.1 门控隐藏状态 （1）重置门与更新门\n通过支持对隐状态的门控，模型可以学习序列中相对重要的词元，跳过不太相关的词元。GRU包括了两个门控单元：\n重置门：决定上一时刻的隐藏状态(Ht−1)有多少信息需要被“重置”或忽略，计算候选隐状态; 更新门：决定多少旧状态(Ht-1)应该被保留，多少新状态(即上面的候选隐状态，包括新输入的Xt)应该被添加到当前状态中。 计算上述两个门控单元的方式与RNN中Ht的计算公式基本一致，只是激活函数选择不同。这里使用的Sigmoid，使得转换为0~1范围，方便后续的控制操作。 （2）候选隐状态\n可通过重置门，来控制生成候选隐状态。 Rt = 1时，就是基本的RNN层（包含Ht-1与Xt）； Rt = 0时，上一步的隐状态会被重置/忽略，仅考虑Xt输入。 （3）隐状态\n更新门可以控制最终隐状态的输出，用于预测Ot Zt = 0时，会全部使用上述的候选隐状态（包含Xt） Zt = 1时，会丢弃候选隐状态，直接继承前一隐藏状态的Ht-1 若整个子序列的所有时间步的更新门都接近1，则序列起始时间步的隐状态将很容易保留、并传递到序列结束。 综上，\n重置门可以控制多大程度获得上一步骤的隐状态，有助于捕获序列中的短期依赖关系。 更新门可以控制多大程度学习当前步骤(Xt)的观测，有助于捕获序列中的长期依赖关系。 1.2 从零开始实现 加载数据 1 2 3 4 5 6 import torch from torch import nn from d2l import torch as d2l batch_size, num_steps = 32, 35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) （1）初始化模型参数\n与RNN相比，多了更新门与重置门的模型参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def get_params(vocab_size, num_hiddens, device): num_inputs = num_outputs = vocab_size def normal(shape): return torch.randn(size=shape, device=device)*0.01 def three(): return (normal((num_inputs, num_hiddens)), normal((num_hiddens, num_hiddens)), torch.zeros(num_hiddens, device=device)) W_xz, W_hz, b_z = three() # 更新门参数 W_xr, W_hr, b_r = three() # 重置门参数 W_xh, W_hh, b_h = three() # 候选隐状态参数 # 输出层参数 W_hq = normal((num_hiddens, num_outputs)) b_q = torch.zeros(num_outputs, device=device) # 附加梯度 params = [W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q] for param in params: param.requires_grad_(True) return params （2）定义模型\n隐状态初始化函数，与之前RNN一样 1 2 def init_gru_state(batch_size, num_hiddens, device): return (torch.zeros((batch_size, num_hiddens), device=device), ) 定义GRU模型的传播, @表示按元素相乘的矩阵乘法 1 2 3 4 5 6 7 8 9 10 11 12 def gru(inputs, state, params): W_xz, W_hz, b_z, W_xr, W_hr, b_r, W_xh, W_hh, b_h, W_hq, b_q = params H, = state outputs = [] for X in inputs: Z = torch.sigmoid((X @ W_xz) + (H @ W_hz) + b_z) #更新门 R = torch.sigmoid((X @ W_xr) + (H @ W_hr) + b_r) #重置门 H_tilda = torch.tanh((X @ W_xh) + ((R * H) @ W_hh) + b_h) #候选隐状态 H = Z * H + (1 - Z) * H_tilda Y = H @ W_hq + b_q outputs.append(Y) return torch.cat(outputs, dim=0), (H,) 训练预测，与RNN代码基本一致 1 2 3 4 5 6 7 8 9 10 vocab_size, num_hiddens, device = len(vocab), 256, d2l.try_gpu() num_epochs, lr = 500, 1 # 定义模型 model = d2l.RNNModelScratch(len(vocab), num_hiddens, device, get_params, init_gru_state, gru) # 训练 d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device) # perplexity 1.1, 23869.1 tokens/sec on cuda:0 # time traveller for so it will be convenient to speak of himwas e # traveller afweryhin ing sfor the three dimensions of space 1.3 简洁实现 直接通过torch的nn.GRU()定义门控神经单元 1 2 3 4 5 6 7 8 9 10 11 num_inputs = vocab_size gru_layer = nn.GRU(num_inputs, num_hiddens) model = d2l.RNNModel(gru_layer, len(vocab)) model = model.to(device) d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device) # perplexity 1.0, 132652.9 tokens/sec on cuda:0 # time travelleryou can show black is white by argument said filby # travelleryou can show black is white by argument said filby 2. 长短期记忆网络(LSTM) LSTM与GRU较为类似，其被早提出20年，设计更加复杂一点\n2.1 门控记忆元 除了隐状态以外，LSTM又提出了记忆元的概念。它与隐状态的形状相同，设计目的是用于记录更多的信息。 （1）输入门、输出门和输出门\n共有三个门被提出用于控制记忆元： 输出门用来控制从记忆元输出到隐状态； 输入门用来控制如何从上一步的隐状态以及当前的观测中学习记忆元； 遗忘门用来控制多大程度继承上一步的记忆元。 这三个门的计算方式与之前都类似 （2）候选记忆元\n候选记忆元的计算方式与上述也类似，只是激活函数为tanh，因此变换后的范围是(-1, 1) （3）记忆元\n如下图，计算当前时间步的记忆元基于两个门的控制； 输入门It控制多大程度来自于上述计算的候选记忆元； 遗忘门Ft控制多大程度来自于上一时间步的记忆元； （4）隐状态\n基于上述的计算，最终通过输出门Ot决定多大程度将记忆元输出作为隐状态 2.2 从零开始实现 加载数据 1 2 3 4 5 6 import torch from torch import nn from d2l import torch as d2l batch_size, num_steps = 32, 35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) （1）初始化模型参数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def get_lstm_params(vocab_size, num_hiddens, device): num_inputs = num_outputs = vocab_size def normal(shape): return torch.randn(size=shape, device=device)*0.01 def three(): return (normal((num_inputs, num_hiddens)), normal((num_hiddens, num_hiddens)), torch.zeros(num_hiddens, device=device)) #与GRU相比，在数量上多了一组门参数 W_xi, W_hi, b_i = three() # 输入门参数 W_xf, W_hf, b_f = three() # 遗忘门参数 W_xo, W_ho, b_o = three() # 输出门参数 W_xc, W_hc, b_c = three() # 候选记忆元参数 # 输出层参数 W_hq = normal((num_hiddens, num_outputs)) b_q = torch.zeros(num_outputs, device=device) # 附加梯度 params = [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c, W_hq, b_q] for param in params: param.requires_grad_(True) return params （2）定义模型\n初始化隐状态以及记忆元，二者的形状相同 1 2 3 def init_lstm_state(batch_size, num_hiddens, device): return (torch.zeros((batch_size, num_hiddens), device=device), torch.zeros((batch_size, num_hiddens), device=device)) 参照上述思路，定义LSTM的前向传播方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def lstm(inputs, state, params): [W_xi, W_hi, b_i, W_xf, W_hf, b_f, W_xo, W_ho, b_o, W_xc, W_hc, b_c, W_hq, b_q] = params (H, C) = state #隐状态+记忆元 outputs = [] for X in inputs: I = torch.sigmoid((X @ W_xi) + (H @ W_hi) + b_i) F = torch.sigmoid((X @ W_xf) + (H @ W_hf) + b_f) O = torch.sigmoid((X @ W_xo) + (H @ W_ho) + b_o) C_tilda = torch.tanh((X @ W_xc) + (H @ W_hc) + b_c) #候选记忆元 C = F * C + I * C_tilda #记忆元 H = O * torch.tanh(C) #隐状态 Y = (H @ W_hq) + b_q #预测输出 outputs.append(Y) return torch.cat(outputs, dim=0), (H, C) （3）训练和预测\n1 2 3 4 5 6 7 8 9 10 vocab_size, num_hiddens, device = len(vocab), 256, d2l.try_gpu() num_epochs, lr = 500, 1 model = d2l.RNNModelScratch(len(vocab), num_hiddens, device, get_lstm_params, init_lstm_state, lstm) d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device) # perplexity 1.1, 20088.5 tokens/sec on cuda:0 # time traveller proceeded anyreal body must have extension in fou # traveller and whyon geantating simong and why can thive yor 2.3 简洁实现 基于torch的nn.LSTM()，快速实现 1 2 3 4 5 6 7 8 9 10 num_inputs = vocab_size lstm_layer = nn.LSTM(num_inputs, num_hiddens) model = d2l.RNNModel(lstm_layer, len(vocab)) model = model.to(device) d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device) # perplexity 1.0, 130362.3 tokens/sec on cuda:0 # time traveller with a slight accession ofcheerfulness really thi # travelleryou can show black is white by argument said filby 3. 深度RNN 对于之前学习的RNN，以及更加复杂的GRU、LSTM，本质上都可以理解为单隐藏层(Ht)的MLP。 可以搭建具有L个隐藏层的深度循环神经网络， 每个隐状态都连续地传递到当前层的下一个时间步和下一层的当前时间步。 3.1 简洁实现 加载数据 1 2 3 4 5 6 import torch from torch import nn from d2l import torch as d2l batch_size, num_steps = 32, 35 train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) 如下以LSTM模型为例，仅需要在nn.LSTM()模型中的第三个参数中设置层数即可 1 2 3 4 5 6 7 8 vocab_size, num_hiddens, num_layers = len(vocab), 256, 2 num_inputs = vocab_size device = d2l.try_gpu() # num_layers设置为两层 lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers) model = d2l.RNNModel(lstm_layer, len(vocab)) model = model.to(device) 3.2 训练与预测 1 2 3 4 5 num_epochs, lr = 500, 2 d2l.train_ch8(model, train_iter, vocab, lr*1.0, num_epochs, device) # perplexity 1.0, 98815.1 tokens/sec on cuda:0 # time travelleryou can show black is white by argument said filby # travelleryou can show black is white by argument said filby 4. 双向RNN 4.1 定义 有时，序列的下文也对当前步的预测有帮助，例如我__, 请给我点吃的。\n双向RNN可以理解为有两个隐藏层的RNN模型，使用序列两端的信息预测输出。\n其中两层遍历序列的方向相反，分别计算前向与反向隐状态 最后将两个隐状态结果合并起来，共同用于计算Ot 双向RNN模型的计算速度较慢，主要原因是网络的前向传播需要在双向层中进行前向和后向递归， 并且网络的反向传播还依赖于前向传播的结果。 因此，梯度求解将有一个非常长的链。 此外，双向RNN模型的应用场景有限，不适合用于下文预测；可以用于填充缺失的单词、词元注释，机器翻译等。 4.2 错误应用 如上，双向RNN在预测时需要用到过去和未来的数据，不适合用于预测未来词元，尽管有时模型训练性能较好。 在torch中实现也很简单，仅需要设置相应的参数即可。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import torch from torch import nn from d2l import torch as d2l # 加载数据 batch_size, num_steps, device = 32, 35, d2l.try_gpu() train_iter, vocab = d2l.load_data_time_machine(batch_size, num_steps) # 通过设置“bidirective=True”来定义双向LSTM模型 vocab_size, num_hiddens, num_layers = len(vocab), 256, 2 num_inputs = vocab_size lstm_layer = nn.LSTM(num_inputs, num_hiddens, num_layers, bidirectional=True) model = d2l.RNNModel(lstm_layer, len(vocab)) model = model.to(device) # 训练模型 num_epochs, lr = 500, 1 d2l.train_ch8(model, train_iter, vocab, lr, num_epochs, device) # perplexity 1.1, 64036.4 tokens/sec on cuda:0 # time travellerererererererererererererererererererererererererer # travellerererererererererererererererererererererererererer 5. 机器翻译与数据集 机器翻译是将一种语言翻译为另一种语言； 可以理解为是将输入序列转换成输出序列的序列转换模型。 接下来的后面几节都将学习如何实现 1 2 3 import os import torch from d2l import torch as d2l 5.1 下载和预处理 示例数据是一个\u0026rsquo;英语—法语\u0026rsquo;文本数据集。 每一行都是由制表符分割的文本序列对。 文本序列可以是单词，句子，段落（包含标点） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #@save d2l.DATA_HUB[\u0026#39;fra-eng\u0026#39;] = (d2l.DATA_URL + \u0026#39;fra-eng.zip\u0026#39;, \u0026#39;94646ad1522d915e7b0f9296181140edcf86a4f5\u0026#39;) #@save def read_data_nmt(): \u0026#34;\u0026#34;\u0026#34;载入“英语－法语”数据集\u0026#34;\u0026#34;\u0026#34; data_dir = d2l.download_extract(\u0026#39;fra-eng\u0026#39;) with open(os.path.join(data_dir, \u0026#39;fra.txt\u0026#39;), \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: return f.read() raw_text = read_data_nmt() print(raw_text[:20]) # Go.\tVa ! # Hi.\tSalut ! 文本预处理操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #@save def preprocess_nmt(text): \u0026#34;\u0026#34;\u0026#34;预处理“英语－法语”数据集\u0026#34;\u0026#34;\u0026#34; # 返回逻辑值：字符是否为标点符号，且该字符前是否没有空格 def no_space(char, prev_char): return char in set(\u0026#39;,.!?\u0026#39;) and prev_char != \u0026#39; \u0026#39; # 使用空格替换不间断空格 # 使用小写字母替换大写字母 text = text.replace(\u0026#39;\\u202f\u0026#39;, \u0026#39; \u0026#39;).replace(\u0026#39;\\xa0\u0026#39;, \u0026#39; \u0026#39;).lower() # 在单词和标点符号之间插入空格 out = [\u0026#39; \u0026#39; + char if i \u0026gt; 0 and no_space(char, text[i - 1]) else char for i, char in enumerate(text)] return \u0026#39;\u0026#39;.join(out) text = preprocess_nmt(raw_text) print(text[:25]) # go .\tva ! # hi .\tsalut ! # ru 5.2 词元化 将单词以及标点符号认为是词元 在每一行中，对制表符前后的文本分别进行词元化，作为source与target 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #@save def tokenize_nmt(text, num_examples=None): \u0026#34;\u0026#34;\u0026#34;词元化“英语－法语”数据数据集\u0026#34;\u0026#34;\u0026#34; source, target = [], [] for i, line in enumerate(text.split(\u0026#39;\\n\u0026#39;)): if num_examples and i \u0026gt; num_examples: break parts = line.split(\u0026#39;\\t\u0026#39;) if len(parts) == 2: source.append(parts[0].split(\u0026#39; \u0026#39;)) target.append(parts[1].split(\u0026#39; \u0026#39;)) return source, target #list of list source, target = tokenize_nmt(text) source[:3], target[:3] # ([[\u0026#39;go\u0026#39;, \u0026#39;.\u0026#39;], [\u0026#39;hi\u0026#39;, \u0026#39;.\u0026#39;], [\u0026#39;run\u0026#39;, \u0026#39;!\u0026#39;]], # [[\u0026#39;va\u0026#39;, \u0026#39;!\u0026#39;], [\u0026#39;salut\u0026#39;, \u0026#39;!\u0026#39;], [\u0026#39;cours\u0026#39;, \u0026#39;!\u0026#39;]]) 5.3 词表 分别为源语言（英语）以及目标（法语）语言构建词表； 将词频低于2的词元设置为\u0026rsquo;\u0026lt;unk\u0026gt;' 此外，额外指定几个特殊词元 \u0026lsquo;\u0026lt;pad\u0026gt;\u0026rsquo; 填充词元 \u0026lsquo;\u0026lt;bos\u0026gt;\u0026rsquo; 开始词元 \u0026lsquo;\u0026lt;eos\u0026gt;\u0026rsquo; 结束词元 1 2 3 4 5 # 如下以源语言为例 src_vocab = d2l.Vocab(source, min_freq=2, reserved_tokens=[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;, \u0026#39;\u0026lt;bos\u0026gt;\u0026#39;, \u0026#39;\u0026lt;eos\u0026gt;\u0026#39;]) len(src_vocab) #词元类别数 # 10012 5.4 加载数据集 为了便于训练，需要将输入序列为设置为固定长度。此时会有如下两种情况 截断：仅取前面预期序列长度的词元，丢弃后面的词元 填充：当不满足预期序列长度时，在后面填充补齐 1 2 3 4 5 6 7 8 9 10 #@save def truncate_pad(line, num_steps, padding_token): \u0026#34;\u0026#34;\u0026#34;截断或填充文本序列\u0026#34;\u0026#34;\u0026#34; if len(line) \u0026gt; num_steps: return line[:num_steps] # 截断 return line + [padding_token] * (num_steps - len(line)) # 填充 # 如下示例，对source的第一个词元序列进行处理，使用填充字符将长度补到10 truncate_pad(src_vocab[source[0]], 10, src_vocab[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;]) # [47, 4, 1, 1, 1, 1, 1, 1, 1, 1] 定义一个函数，对source/target进行上述处理，并在序列结尾加上一个\u0026rsquo;\u0026lt;eos\u0026gt;\u0026lsquo;词元 此外，会统计一下每个序列的有效长度（除去填充词元） 1 2 3 4 5 6 7 8 9 #@save def build_array_nmt(lines, vocab, num_steps): \u0026#34;\u0026#34;\u0026#34;将机器翻译的文本序列转换成小批量\u0026#34;\u0026#34;\u0026#34; lines = [vocab[l] for l in lines] lines = [l + [vocab[\u0026#39;\u0026lt;eos\u0026gt;\u0026#39;]] for l in lines] array = torch.tensor([truncate_pad( l, num_steps, vocab[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;]) for l in lines]) valid_len = (array != vocab[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;]).type(torch.int32).sum(1) return array, valid_len 5.5 最终形式 定义一个综合函数，返回数据迭代器，源语言词表，目标语言词表 数据迭代器每次返回一个批量的输入序列与输出序列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #@save def load_data_nmt(batch_size, num_steps, num_examples=600): \u0026#34;\u0026#34;\u0026#34;返回翻译数据集的迭代器和词表\u0026#34;\u0026#34;\u0026#34; text = preprocess_nmt(read_data_nmt()) source, target = tokenize_nmt(text, num_examples) src_vocab = d2l.Vocab(source, min_freq=2, reserved_tokens=[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;, \u0026#39;\u0026lt;bos\u0026gt;\u0026#39;, \u0026#39;\u0026lt;eos\u0026gt;\u0026#39;]) tgt_vocab = d2l.Vocab(target, min_freq=2, reserved_tokens=[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;, \u0026#39;\u0026lt;bos\u0026gt;\u0026#39;, \u0026#39;\u0026lt;eos\u0026gt;\u0026#39;]) src_array, src_valid_len = build_array_nmt(source, src_vocab, num_steps) tgt_array, tgt_valid_len = build_array_nmt(target, tgt_vocab, num_steps) data_arrays = (src_array, src_valid_len, tgt_array, tgt_valid_len) data_iter = d2l.load_array(data_arrays, batch_size) return data_iter, src_vocab, tgt_vocab 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 train_iter, src_vocab, tgt_vocab = load_data_nmt(batch_size=2, num_steps=8) for X, X_valid_len, Y, Y_valid_len in train_iter: print(\u0026#39;X:\u0026#39;, X.type(torch.int32)) print(\u0026#39;X的有效长度:\u0026#39;, X_valid_len) print(\u0026#39;Y:\u0026#39;, Y.type(torch.int32)) print(\u0026#39;Y的有效长度:\u0026#39;, Y_valid_len) break # X: tensor([[ 58, 47, 4, 3, 1, 1, 1, 1], # [ 7, 102, 5, 3, 1, 1, 1, 1]], dtype=torch.int32) # X的有效长度: tensor([4, 4]) # Y: tensor([[ 18, 14, 34, 4, 3, 1, 1, 1], # [ 6, 7, 161, 5, 3, 1, 1, 1]], dtype=torch.int32) # Y的有效长度: tensor([5, 5]) 6. 编码器与解码器架构 对于之前学习的CNN以及现在学习的RNN，都可以理解为编码器与解码器架构； 编码器：将输入变换为中间表达形式（特征）； 对于RNN，可将长度可变的序列作为输入，转换为具有固定形状的编码状态 解码器：将提取的中间表示编码成输出。 对于RNN，将固定形状的编码状态映射到长度可变的序列 接下来定义一个抽象的编码器-解码器接口，以方便后续的实现\n6.1 编码器 在编码器接口中，指定长度可变的序列作为输入X 1 2 3 4 5 6 7 8 9 10 from torch import nn #@save class Encoder(nn.Module): \u0026#34;\u0026#34;\u0026#34;编码器-解码器架构的基本编码器接口\u0026#34;\u0026#34;\u0026#34; def __init__(self, **kwargs): super(Encoder, self).__init__(**kwargs) def forward(self, X, *args): raise NotImplementedError raise NotImplementedError 是一种编程模式，用于表明某个方法或功能还没有准备好或者需要被子类覆盖以提供实际的行为。\n6.2 解码器 init_state用于初始化解码器的状态。 主要是将编码器的输出转换为编码后的状态 根据RNN思路，解码器在每个时间步都会将输入X （例如：在前一时间步生成的词元）和编码后的状态 映射成当前时间步的输出词元。 1 2 3 4 5 6 7 8 9 10 11 #@save class Decoder(nn.Module): \u0026#34;\u0026#34;\u0026#34;编码器-解码器架构的基本解码器接口\u0026#34;\u0026#34;\u0026#34; def __init__(self, **kwargs): super(Decoder, self).__init__(**kwargs) def init_state(self, enc_outputs, *args): raise NotImplementedError def forward(self, X, state): raise NotImplementedError 6.3 合并编码器与解码器 在前向传播中，\n编码器的输出用于生成编码状态； 这个状态又被解码器作为其输入的一部分。 1 2 3 4 5 6 7 8 9 10 11 12 #@save class EncoderDecoder(nn.Module): \u0026#34;\u0026#34;\u0026#34;编码器-解码器架构的基类\u0026#34;\u0026#34;\u0026#34; def __init__(self, encoder, decoder, **kwargs): super(EncoderDecoder, self).__init__(**kwargs) self.encoder = encoder self.decoder = decoder def forward(self, enc_X, dec_X, *args): enc_outputs = self.encoder(enc_X, *args) dec_state = self.decoder.init_state(enc_outputs, *args) return self.decoder(dec_X, dec_state) 7. 序列到序列学习(seq2seq) 序列到序列学习模型由两个RNN的编码器与解码器组成 编码器RNN：将输入序列的信息编码为固定形状的隐状态。 解码器RNN：基于编码器输入序列的编码信息以及当前时间步的词元，来预测下一个词元。 1 2 3 4 5 import collections import math import torch from torch import nn from d2l import torch as d2l 7.1 编码器 在编码器RNN部分，主要目的是得到输入序列最后一个时间步的隐状态表示（可以有多层）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #@save class Seq2SeqEncoder(d2l.Encoder): \u0026#34;\u0026#34;\u0026#34;用于序列到序列学习的循环神经网络编码器\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout=0, **kwargs): super(Seq2SeqEncoder, self).__init__(**kwargs) # 嵌入层：提取每个词元的特征向量 self.embedding = nn.Embedding(vocab_size, embed_size) # 这里使用多层的GRU循环神经网络 self.rnn = nn.GRU(embed_size, num_hiddens, num_layers, dropout=dropout) def forward(self, X, *args): # 输入\u0026#39;X\u0026#39;的形状：(batch_size,num_steps) # 输出\u0026#39;X\u0026#39;的形状：(batch_size,num_steps,embed_size) X = self.embedding(X) # 在循环神经网络模型中，需要将第一个轴设置为时间步（批量内的子序列） X = X.permute(1, 0, 2) # 如果未提及状态，则默认为0 output, state = self.rnn(X) # output的形状:(num_steps,batch_size,num_hiddens) # state的形状:(num_layers,batch_size,num_hiddens) return output, state output是基于每个时间步最后一层的隐状态（一般情况下后面需要跟全连接层进行预测输出）；\nstate是最后一个时间步的多层的隐状态。\n示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 encoder = Seq2SeqEncoder(vocab_size=10, embed_size=8, num_hiddens=16, num_layers=2) encoder.eval() X = torch.zeros((4, 7), dtype=torch.long) output, state = encoder(X) output.shape # torch.Size([7, 4, 16]) #(时间步数，批量大小，隐藏单元数) state.shape # torch.Size([2, 4, 16]) #(隐藏层的数量，批量大小，隐藏单元的数量) # output 批量内第1个子序列的第7个时间步的前5个值 # state 批量内第1个子序列的最后一个时间步的第2层的前5个值 output[6, 0, :5], state[1, 0, :5] # (tensor([ 0.0533, -0.2092, 0.0406, -0.0956, -0.3704], grad_fn=\u0026lt;SliceBackward0\u0026gt;), # tensor([ 0.0533, -0.2092, 0.0406, -0.0956, -0.3704], grad_fn=\u0026lt;SliceBackward0\u0026gt;)) 7.2 解码器 在解码器RNN中，\n一方面，会继承编码器RNN的最后一个时间步的所有隐状态，作为解码器输入序列的初始化隐状态； 另一方面会将编码器RNN的最后一个时间步的最后一层隐状态，作为解码器输入序列中每个观测词元的一部分特征（参考上图）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Seq2SeqDecoder(d2l.Decoder): \u0026#34;\u0026#34;\u0026#34;用于序列到序列学习的循环神经网络解码器\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout=0, **kwargs): super(Seq2SeqDecoder, self).__init__(**kwargs) self.embedding = nn.Embedding(vocab_size, embed_size) # 观测词元输入=词元本身特征+编码器的信息context self.rnn = nn.GRU(embed_size + num_hiddens, num_hiddens, num_layers, dropout=dropout) self.dense = nn.Linear(num_hiddens, vocab_size) def init_state(self, enc_outputs, *args): return enc_outputs[1] #取state，而非output def forward(self, X, state): # 输出\u0026#39;X\u0026#39;的形状：(batch_size,num_steps,embed_size) X = self.embedding(X).permute(1, 0, 2) # 广播context，使其具有与X相同的num_steps context = state[-1].repeat(X.shape[0], 1, 1) X_and_context = torch.cat((X, context), 2) output, state = self.rnn(X_and_context, state) output = self.dense(output).permute(1, 0, 2) # output的形状:(batch_size,num_steps,vocab_size)，预测结果 # state的形状:(num_layers,batch_size,num_hiddens)，解码器序列最后一个时间步的隐状态 return output, state 7.3 损失函数 对于解码器的预测输出，一般使用平均交叉熵损失(Softmax)评价与标签序列的差异损失； 在计算损失时，应不需要关注对于序列中的填充词元的预测正确与否 换句话说，仅关注序列中有效词元的预测结果 1 2 3 4 5 6 7 8 9 10 11 12 13 #@save def sequence_mask(X, valid_len, value=0): \u0026#34;\u0026#34;\u0026#34;在序列中屏蔽不相关的项\u0026#34;\u0026#34;\u0026#34; maxlen = X.size(1) mask = torch.arange((maxlen), dtype=torch.float32, device=X.device)[None, :] \u0026lt; valid_len[:, None] X[~mask] = value return X X = torch.tensor([[1, 2, 3], [4, 5, 6]]) sequence_mask(X, torch.tensor([1, 2])) # tensor([[1, 0, 0], #第一个词元以外的部分被置换为0 # [4, 5, 0]]) #前两个词元以外的部分被置换为0 据此自定义一个损失函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #@save class MaskedSoftmaxCELoss(nn.CrossEntropyLoss): \u0026#34;\u0026#34;\u0026#34;带遮蔽的softmax交叉熵损失函数\u0026#34;\u0026#34;\u0026#34; # pred的形状：(batch_size,num_steps,vocab_size) # label的形状：(batch_size,num_steps) # valid_len的形状：(batch_size,) def forward(self, pred, label, valid_len): weights = torch.ones_like(label) #无效词元的权重设置为0，即忽略 weights = sequence_mask(weights, valid_len) self.reduction=\u0026#39;none\u0026#39; #不会自动对输出进行平均或求和 unweighted_loss = super(MaskedSoftmaxCELoss, self).forward( pred.permute(0, 2, 1), label) #(batch_size, vocab_size, num_steps) 将类别概率放在第二维 weighted_loss = (unweighted_loss * weights).mean(dim=1) return weighted_loss 7.4 训练 在解码器中，\u0026rsquo;\u0026lt;bos\u0026gt;\u0026lsquo;与原始的输出序列（不包含\u0026rsquo;\u0026lt;eos\u0026gt;\u0026rsquo;）连接在一起共同作为输入。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #@save def train_seq2seq(net, data_iter, lr, num_epochs, tgt_vocab, device): \u0026#34;\u0026#34;\u0026#34;训练序列到序列模型\u0026#34;\u0026#34;\u0026#34; def xavier_init_weights(m): if type(m) == nn.Linear: nn.init.xavier_uniform_(m.weight) if type(m) == nn.GRU: for param in m._flat_weights_names: if \u0026#34;weight\u0026#34; in param: nn.init.xavier_uniform_(m._parameters[param]) net.apply(xavier_init_weights) net.to(device) optimizer = torch.optim.Adam(net.parameters(), lr=lr) loss = MaskedSoftmaxCELoss() net.train() animator = d2l.Animator(xlabel=\u0026#39;epoch\u0026#39;, ylabel=\u0026#39;loss\u0026#39;, xlim=[10, num_epochs]) for epoch in range(num_epochs): timer = d2l.Timer() metric = d2l.Accumulator(2) # 训练损失总和，词元数量 for batch in data_iter: optimizer.zero_grad() X, X_valid_len, Y, Y_valid_len = [x.to(device) for x in batch] #在之前序列预处理里load_data_nmt中，已将每个序列末尾添加了\u0026lt;eos\u0026gt;词元 #对于解码器的输入序列，在开头插入一个bos词元。为保证长度不变，需要截掉序列的最后一个词元(\u0026lt;eos\u0026gt;) bos = torch.tensor([tgt_vocab[\u0026#39;\u0026lt;bos\u0026gt;\u0026#39;]] * Y.shape[0], device=device).reshape(-1, 1) dec_input = torch.cat([bos, Y[:, :-1]], 1) # 强制教学 # X_valid_len本章暂时用不到，Y_valid_len会用到 Y_hat, _ = net(X, dec_input, X_valid_len) l = loss(Y_hat, Y, Y_valid_len) l.sum().backward() # 损失函数的标量进行“反向传播” d2l.grad_clipping(net, 1) num_tokens = Y_valid_len.sum() optimizer.step() with torch.no_grad(): metric.add(l.sum(), num_tokens) if (epoch + 1) % 10 == 0: animator.add(epoch + 1, (metric[0] / metric[1],)) print(f\u0026#39;loss {metric[0] / metric[1]:.3f}, {metric[1] / timer.stop():.1f} \u0026#39; f\u0026#39;tokens/sec on {str(device)}\u0026#39;) 实例化模型，并训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 embed_size, num_hiddens, num_layers, dropout = 32, 32, 2, 0.1 batch_size, num_steps = 64, 10 lr, num_epochs, device = 0.005, 300, d2l.try_gpu() train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps) encoder = Seq2SeqEncoder(len(src_vocab), embed_size, num_hiddens, num_layers, dropout) decoder = Seq2SeqDecoder(len(tgt_vocab), embed_size, num_hiddens, num_layers, dropout) net = d2l.EncoderDecoder(encoder, decoder) train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device) # loss 0.019, 10100.9 tokens/sec on cuda:0 7.5 预测 与训练部分不同之处在于， 每个解码器当前时间步的输入都将来自于前一时间步的预测词元。而在训练时的解码器输入都是来自真实的词元。 src_sentence 表示用户的输入英语句子 src_vocab表示英语的索引词表 tgt_vocab表示法语的索引词表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #@save def predict_seq2seq(net, src_sentence, src_vocab, tgt_vocab, num_steps, device, save_attention_weights=False): \u0026#34;\u0026#34;\u0026#34;序列到序列模型的预测\u0026#34;\u0026#34;\u0026#34; # 在预测时将net设置为评估模式 net.eval() src_tokens = src_vocab[src_sentence.lower().split(\u0026#39; \u0026#39;)] + [ src_vocab[\u0026#39;\u0026lt;eos\u0026gt;\u0026#39;]] enc_valid_len = torch.tensor([len(src_tokens)], device=device) src_tokens = d2l.truncate_pad(src_tokens, num_steps, src_vocab[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;]) #固定长度 # 添加批量轴（作为第一个维度） enc_X = torch.unsqueeze( torch.tensor(src_tokens, dtype=torch.long, device=device), dim=0) enc_outputs = net.encoder(enc_X, enc_valid_len) dec_state = net.decoder.init_state(enc_outputs, enc_valid_len) # 添加批量轴 dec_X = torch.unsqueeze(torch.tensor( [tgt_vocab[\u0026#39;\u0026lt;bos\u0026gt;\u0026#39;]], dtype=torch.long, device=device), dim=0) output_seq, attention_weight_seq = [], [] for _ in range(num_steps): Y, dec_state = net.decoder(dec_X, dec_state) # 我们使用具有预测最高可能性的词元，作为解码器在下一时间步的输入 dec_X = Y.argmax(dim=2) pred = dec_X.squeeze(dim=0).type(torch.int32).item() # 保存注意力权重（稍后讨论） if save_attention_weights: attention_weight_seq.append(net.decoder.attention_weights) # 一旦序列结束词元被预测，输出序列的生成就提前完成了 if pred == tgt_vocab[\u0026#39;\u0026lt;eos\u0026gt;\u0026#39;]: break output_seq.append(pred) return \u0026#39; \u0026#39;.join(tgt_vocab.to_tokens(output_seq)), attention_weight_seq 7.6 预测序列的评估 可使用Bleu值评估预测序列与真实序列的差异；值越大，且接近1表示效果越好 当预测的序列长度小于真实序列长度时，前面的exp系数运算就会小于1，即对Bleu值惩罚； 当n值较大时的n元预测准确率越高时，Pn项就越大。 具体地说，给定标签序列A、B、C、D、E、F 和预测序列A、B、B、C、D， 我们有p1=4/5、p2=3/4、p3=1/3和p4=0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def bleu(pred_seq, label_seq, k): #@save \u0026#34;\u0026#34;\u0026#34;计算BLEU\u0026#34;\u0026#34;\u0026#34; pred_tokens, label_tokens = pred_seq.split(\u0026#39; \u0026#39;), label_seq.split(\u0026#39; \u0026#39;) len_pred, len_label = len(pred_tokens), len(label_tokens) score = math.exp(min(0, 1 - len_label / len_pred)) for n in range(1, k + 1): num_matches, label_subs = 0, collections.defaultdict(int) for i in range(len_label - n + 1): label_subs[\u0026#39; \u0026#39;.join(label_tokens[i: i + n])] += 1 for i in range(len_pred - n + 1): if label_subs[\u0026#39; \u0026#39;.join(pred_tokens[i: i + n])] \u0026gt; 0: num_matches += 1 label_subs[\u0026#39; \u0026#39;.join(pred_tokens[i: i + n])] -= 1 score *= math.pow(num_matches / (len_pred - n + 1), math.pow(0.5, n)) return score 示例 1 2 3 4 5 6 7 8 9 10 engs = [\u0026#39;go .\u0026#39;, \u0026#34;i lost .\u0026#34;, \u0026#39;he\\\u0026#39;s calm .\u0026#39;, \u0026#39;i\\\u0026#39;m home .\u0026#39;] fras = [\u0026#39;va !\u0026#39;, \u0026#39;j\\\u0026#39;ai perdu .\u0026#39;, \u0026#39;il est calme .\u0026#39;, \u0026#39;je suis chez moi .\u0026#39;] for eng, fra in zip(engs, fras): translation, attention_weight_seq = predict_seq2seq( net, eng, src_vocab, tgt_vocab, num_steps, device) print(f\u0026#39;{eng} =\u0026gt; {translation}, bleu {bleu(translation, fra, k=2):.3f}\u0026#39;) # go . =\u0026gt; va \u0026lt;unk\u0026gt; \u0026lt;unk\u0026gt; ., bleu 0.000 # i lost . =\u0026gt; j\u0026#39;ai perdu ., bleu 1.000 # he\u0026#39;s calm . =\u0026gt; il est bon de de essaye ., bleu 0.418 # i\u0026#39;m home . =\u0026gt; je suis chez de moi \u0026lt;unk\u0026gt; emporté ., bleu 0.578 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/712d2l-%E7%AC%AC%E4%B9%9D%E7%AB%A0%E7%8E%B0%E4%BB%A3%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/","summary":"\u003ch1 id=\"1-门控循环单元gru\"\u003e1. 门控循环单元(GRU)\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e传统的RNN在处理长序列时会遇到梯度消失或梯度爆炸的问题。为了解决这些问题，引入了门控机制的变种，如长短时记忆网络（LSTM, long short-term memory）和门控循环单元（GRU, gated recurrent unit）。GRU是LSTM的一个简化版本，它通过合并某些门并减少参数数量来提高效率。\u003c/p\u003e","title":"D2L--第九章现代循环神经网络"},{"content":"1. 注意力提示 1.1 生物学的注意力提示 如下的观察实验：\n受试者的注意力往往首先被颜色鲜艳的红色咖啡杯吸引（非自主性）； 客观存在的，对于观察者的吸引特征。 喝完咖啡，处于兴奋状态的大脑经思考后，相比看报等，可能更想要读一本书（自主性权重更高）； 在受试者的主观意愿推动下所做的决定。 1.2 查询、键和值 上述的非自主性提示，可以类比之前的全连接层、卷积层等。 红色的咖啡杯可以理解为高权重值的神经元，对输出有较大的影响。 而注意力(Attention)机制可通过注意力汇聚，将查询(Query)与所有的键值(Key-Value)对进行关联，得到输出。 查询：分别与所有键Key计算\u0026rsquo;相似度\u0026rsquo;，表示权重值，得到注意力的抽象表示； 键-值对：基于上述权重，对值value进行加权平均求和，得到输出。(二者可以是同一数据) 一个Query得到一个输出 1.3 注意力的可视化 对注意力的权重进行热图可视化 每行表示一次Query与所有的Key计算的权重结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import torch from d2l import torch as d2l #@save def show_heatmaps(matrices, xlabel, ylabel, titles=None, figsize=(2.5, 2.5), cmap=\u0026#39;Reds\u0026#39;): \u0026#34;\u0026#34;\u0026#34;显示矩阵热图\u0026#34;\u0026#34;\u0026#34; d2l.use_svg_display() num_rows, num_cols = matrices.shape[0], matrices.shape[1] fig, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize, sharex=True, sharey=True, squeeze=False) for i, (row_axes, row_matrices) in enumerate(zip(axes, matrices)): for j, (ax, matrix) in enumerate(zip(row_axes, row_matrices)): pcm = ax.imshow(matrix.detach().numpy(), cmap=cmap) if i == num_rows - 1: ax.set_xlabel(xlabel) if j == 0: ax.set_ylabel(ylabel) if titles: ax.set_title(titles[j]) fig.colorbar(pcm, ax=axes, shrink=0.6); #四维矩阵的输入，前两个维度表示子图的行数与列数 attention_weights = torch.eye(10).reshape((1, 1, 10, 10)) show_heatmaps(attention_weights, xlabel=\u0026#39;Keys\u0026#39;, ylabel=\u0026#39;Queries\u0026#39;) 2. 注意力汇聚 1964年提出的Nadaraya-Watson核回归，本质上可以理解为带有加权平均的注意力机制 2.1 生成数据集 x_train ：键Key y_train：值Value x_test：查询Query 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 n_train = 50 # 训练样本数 x_train, _ = torch.sort(torch.rand(n_train) * 5) # 排序后的训练样本(0~5分布范围) def f(x): return 2 * torch.sin(x) + x**0.8 y_train = f(x_train) + torch.normal(0.0, 0.5, (n_train,)) # 训练样本的输出 x_test = torch.arange(0, 5, 0.1) # 测试样本 y_truth = f(x_test) # 测试样本的真实输出 n_test = len(x_test) # 测试样本数 n_test # 50 #定义一个绘图函数 def plot_kernel_reg(y_hat): d2l.plot(x_test, [y_truth, y_hat], \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, legend=[\u0026#39;Truth\u0026#39;, \u0026#39;Pred\u0026#39;], xlim=[0, 5], ylim=[-1, 5]) d2l.plt.plot(x_train, y_train, \u0026#39;o\u0026#39;, alpha=0.5); 2.2 平均汇聚 最简单的做法是对于任意Query（x），都直接计算所有训练样本输出值(yi)的均值 1 2 3 4 5 y_hat = torch.repeat_interleave(y_train.mean(), n_test) #两个参数，值以及重复的次数 y_hat.shape, y_hat[:5] # (torch.Size([50]), tensor([2.4023, 2.4023, 2.4023, 2.4023, 2.4023])) plot_kernel_reg(y_hat) 2.3 非参数注意力汇聚 根据query(x)与key(xi)的关系度量α，计算当key为xi时，值yi的权重。 一种关系度量方式是将x与xi间的距离进行高斯核函数转换。距离越近，则值越大。 最后的Softmax操作将权重和变为1，得到最终的加权平均方式。 下述的计算为非参数的注意力汇聚，即没有可学习的模型参数。 1 2 3 4 5 6 7 8 9 # X_repeat的形状:(n_test,n_train), # 每一行都包含着相同的测试输入（例如：同样的查询）,以分别计算与所有key的距离（每行） X_repeat = x_test.repeat_interleave(n_train).reshape((-1, n_train)) # attention_weights的形状同样是：(n_test,n_train) # 每一行表示每个查询与所有键key之间的注意力权重 attention_weights = nn.functional.softmax(-(X_repeat - x_train)**2 / 2, dim=1) # 计算最终值value的加权平均值 y_hat = torch.matmul(attention_weights, y_train) plot_kernel_reg(y_hat) #下图左 1 2 3 4 5 6 # 可视化注意力权重 attention_weights.shape # torch.Size([50, 50]) d2l.show_heatmaps(attention_weights.unsqueeze(0).unsqueeze(0), xlabel=\u0026#39;Sorted training inputs\u0026#39;, ylabel=\u0026#39;Sorted testing inputs\u0026#39;) # 上图右 2.4 带参数注意力汇聚 如下，是带可学习参数的Nadaraya-Watson核回归实现 w参数用于控制高斯核的宽度，可以理解为方差。 方差越大，表示越关注少数几个与query高度接近的xi，赋予较高的权重。 （1）批量矩阵乘法\nnn.bmm: 第一个小批量的第i个矩阵与第二个小批量的第i个矩阵相乘。 1 2 3 4 X = torch.ones((2, 1, 4)) Y = torch.ones((2, 4, 6)) torch.bmm(X, Y).shape # torch.Size([2, 1, 6]) 据此，可在注意力机制背景下，计算小批量数据的加权平均值 1 2 3 4 5 6 7 8 9 10 weights = torch.ones((2, 10)) * 0.1 values = torch.arange(20.0).reshape((2, 10)) weights.unsqueeze(1).shape #一次query，10个键值对 # torch.Size([2, 1, 10]) values.unsqueeze(-1).shape # 10个键值对 # torch.Size([2, 10, 1]) torch.bmm(weights.unsqueeze(1), values.unsqueeze(-1)) # tensor([[[ 4.5000]], # [[14.5000]]]) （2）定义模型\nw可学习参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class NWKernelRegression(nn.Module): def __init__(self, **kwargs): super().__init__(**kwargs) self.w = nn.Parameter(torch.rand((1,), requires_grad=True)) def forward(self, queries, keys, values): # queries和attention_weights的形状为(查询个数，“键－值”对个数) # 每个query重复keys的数量次 queries = queries.repeat_interleave(keys.shape[1]).reshape((-1, keys.shape[1])) self.attention_weights = nn.functional.softmax( -((queries - keys) * self.w)**2 / 2, dim=1) #按行做softmax，计算权重 # values的形状为(查询个数，“键－值”对个数) return torch.bmm(self.attention_weights.unsqueeze(1), values.unsqueeze(-1)).reshape(-1) （3）训练\n计算keys与values 因为要使用x_train作为query，所以在keys与values中的每一行中，去除自己本身的观测键值对 1 2 3 4 5 6 7 8 # X_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输入 X_tile = x_train.repeat((n_train, 1)) # Y_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输出 Y_tile = y_train.repeat((n_train, 1)) # keys的形状:(\u0026#39;n_train\u0026#39;，\u0026#39;n_train\u0026#39;-1) keys = X_tile[(1 - torch.eye(n_train)).type(torch.bool)].reshape((n_train, -1)) # values的形状:(\u0026#39;n_train\u0026#39;，\u0026#39;n_train\u0026#39;-1) values = Y_tile[(1 - torch.eye(n_train)).type(torch.bool)].reshape((n_train, -1)) 训练 训练模型使用x_train作为query，而不是x_test； x_train中的第i个query与keys中的第i行进行α计算； 得到对应的权重结果后，再对values的第i行进行加权平均、 1 2 3 4 5 6 7 8 9 10 11 12 net = NWKernelRegression() loss = nn.MSELoss(reduction=\u0026#39;none\u0026#39;) trainer = torch.optim.SGD(net.parameters(), lr=0.5) animator = d2l.Animator(xlabel=\u0026#39;epoch\u0026#39;, ylabel=\u0026#39;loss\u0026#39;, xlim=[1, 5]) for epoch in range(5): trainer.zero_grad() l = loss(net(x_train, keys, values), y_train) l.sum().backward() trainer.step() print(f\u0026#39;epoch {epoch + 1}, loss {float(l.sum()):.6f}\u0026#39;) animator.add(epoch + 1, float(l.sum())) 预测 1 2 3 4 5 6 7 8 9 # keys的形状:(n_test，n_train)，每一行包含着相同的训练输入（例如，相同的键） keys = x_train.repeat((n_test, 1)) # value的形状:(n_test，n_train) values = y_train.repeat((n_test, 1)) y_hat = net(x_test, keys, values).unsqueeze(1).detach() y_hat.shape # torch.Size([50, 1]) plot_kernel_reg(y_hat) #下图左 1 2 3 4 5 6 # 权重可视化 net.attention_weights.shape # torch.Size([50, 50]) d2l.show_heatmaps(net.attention_weights.unsqueeze(0).unsqueeze(0), xlabel=\u0026#39;Sorted training inputs\u0026#39;, ylabel=\u0026#39;Sorted testing inputs\u0026#39;) 如上右图，可以看到w参数将注意力机制更关注少数与query权重更高的key\n3. 注意力评分函数 上面的α(高斯运算)可以视为注意力评分函数，计算query与每个key的\u0026rsquo;关系\u0026rsquo;。然后再经softmax操作，映射为注意力权重。 引申来看，如下公式中： q表示查询query，可以是一个向量； (k, v)表示键值对(key-value)，二者可以是长度不同的向量，也可以是同一数据； 评分函数 α(q, ki)将query与每个key映射成标量，再进行softmax计算。 1 2 3 4 import math import torch from torch import nn from d2l import torch as d2l 3.1 掩蔽softmax操作 在上一章的seq2seq学习中，为了保证子序列长度相同，对于原来较短的序列进行了填充。 同样，这里需要将这些填充词元的注意分数设置为很小的值，从而在softmax操作时计算得到权重值为0。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #@save def masked_softmax(X, valid_lens): \u0026#34;\u0026#34;\u0026#34;通过在最后一个轴上掩蔽元素来执行softmax操作\u0026#34;\u0026#34;\u0026#34; # X:3D张量，valid_lens:1D或2D张量 if valid_lens is None: return nn.functional.softmax(X, dim=-1) else: shape = X.shape if valid_lens.dim() == 1: valid_lens = torch.repeat_interleave(valid_lens, shape[1]) else: valid_lens = valid_lens.reshape(-1) # 最后一轴上被掩蔽的元素使用一个非常大的负值替换，从而其softmax输出为0 X = d2l.sequence_mask(X.reshape(-1, shape[-1]), valid_lens, value=-1e6) return nn.functional.softmax(X.reshape(shape), dim=-1) 示例操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # valid_lens.dim() == 1 masked_softmax(torch.rand(2, 2, 4), torch.tensor([2, 3])) # tensor([[[0.5599, 0.4401, 0.0000, 0.0000], # [0.4361, 0.5639, 0.0000, 0.0000]], # [[0.2928, 0.4262, 0.2810, 0.0000], # [0.3205, 0.3216, 0.3579, 0.0000]]]) # valid_lens.dim() == 2 masked_softmax(torch.rand(2, 2, 4), torch.tensor([[1, 3], [2, 4]])) # tensor([[[1.0000, 0.0000, 0.0000, 0.0000], # [0.3533, 0.3007, 0.3460, 0.0000]], # [[0.5339, 0.4661, 0.0000, 0.0000], # [0.2291, 0.1934, 0.3177, 0.2598]]]) 3.2 加性注意力 Activation attention：将查询向量与键的向量相加后，输入到一个多层感知机中 单隐藏层，tanh激活函数，禁用偏置项，输出层的神经元个数为1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #@save class AdditiveAttention(nn.Module): \u0026#34;\u0026#34;\u0026#34;加性注意力\u0026#34;\u0026#34;\u0026#34; def __init__(self, key_size, query_size, num_hiddens, dropout, **kwargs): super(AdditiveAttention, self).__init__(**kwargs) self.W_k = nn.Linear(key_size, num_hiddens, bias=False) self.W_q = nn.Linear(query_size, num_hiddens, bias=False) self.w_v = nn.Linear(num_hiddens, 1, bias=False) self.dropout = nn.Dropout(dropout) def forward(self, queries, keys, values, valid_lens): queries, keys = self.W_q(queries), self.W_k(keys) # 在维度扩展后， # queries的形状：(batch_size，查询的个数，1，num_hidden) # key的形状：(batch_size，1，“键－值”对的个数，num_hiddens) # 使用广播方式进行求和:对于 queries 的每一个查询（query），将其与所有键（key）相加。 features = queries.unsqueeze(2) + keys.unsqueeze(1) # (batch_size, num_queries, num_keys, num_hiddens) features = torch.tanh(features) # self.w_v仅有一个输出，因此从形状中移除最后那个维度。 scores = self.w_v(features).squeeze(-1) # scores的形状：(batch_size, num_queries, num_keys) self.attention_weights = masked_softmax(scores, valid_lens) # values的形状：(batch_size，“键－值”对的个数，值的维度) # 最后返回结果：(batch_size，num_queries，值的维度) return torch.bmm(self.dropout(self.attention_weights), values) 示例操作：批量大小为2，每个批量 1个query，其向量长度为20 10对key-value，key向量长度为2，value向量长度为4 1 2 3 4 5 queries, keys = torch.normal(0, 1, (2, 1, 20)), torch.ones((2, 10, 2)) # values的小批量，两个值矩阵是相同的 values = torch.arange(40, dtype=torch.float32).reshape(1, 10, 4).repeat( 2, 1, 1) valid_lens = torch.tensor([2, 6]) 注意力汇聚输出的形状为(批量大小，查询数，值value的维度) 1 2 3 4 5 6 7 8 9 # 实例化一个attention attention = AdditiveAttention(key_size=2, query_size=20, num_hiddens=8, dropout=0.1) attention.eval() attention(queries, keys, values, valid_lens) # tensor([[[ 2.0000, 3.0000, 4.0000, 5.0000]], # [[10.0000, 11.0000, 12.0000, 13.0000]]], grad_fn=\u0026lt;BmmBackward0\u0026gt;) attention(queries, keys, values, valid_lens).shape # torch.Size([2, 1, 4]) 每个query对于所有key的注意力权重可视化 1 2 d2l.show_heatmaps(attention.attention_weights.reshape((1, 1, 2, 10)), xlabel=\u0026#39;Keys\u0026#39;, ylabel=\u0026#39;Queries\u0026#39;) 3.3 缩放点积注意力 Scaled dot-product attention：当query向量与key向量长度一致时，可进行点积操作；再根据向量长度进行缩放，作为注意力分数。 相比于加性注意力，模型参数较少（只有dropout） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #@save class DotProductAttention(nn.Module): \u0026#34;\u0026#34;\u0026#34;缩放点积注意力\u0026#34;\u0026#34;\u0026#34; def __init__(self, dropout, **kwargs): super(DotProductAttention, self).__init__(**kwargs) self.dropout = nn.Dropout(dropout) def forward(self, queries, keys, values, valid_lens=None): d = queries.shape[-1] # 交换keys的最后两个维度 # queries的形状：(batch_size，查询的个数，d) # keys的形状：(batch_size，“键－值”对的个数，d) scores = torch.bmm(queries, keys.transpose(1,2)) / math.sqrt(d) self.attention_weights = masked_softmax(scores, valid_lens) # values的形状：(batch_size，“键－值”对的个数，值的维度) return torch.bmm(self.dropout(self.attention_weights), values) 示例操作 1 2 3 4 5 6 queries = torch.normal(0, 1, (2, 1, 2)) attention = DotProductAttention(dropout=0.5) attention.eval() attention(queries, keys, values, valid_lens) # tensor([[[ 2.0000, 3.0000, 4.0000, 5.0000]], # [[10.0000, 11.0000, 12.0000, 13.0000]]]) 4. Bahdanau注意力 在上一章学习seq2seq时，将编码器RNN中最后一个时间步的隐状态作为上下文变量传递给了解码器。 此时，假设该隐状态能够学习到编码器序列的全部信息，但对于较长的序列，实际情况可能并非如此。 对此，Bahdanau等提出了注意力机制的seq2seq模型，具体实现方式如下： 4.1 模型 特定解码器词元的context上下文变量来自于编码器序列所有词元隐状态的加权平均 Query：编码器RNN序列中，前一个时间步的最后一层隐状态输出 Key/Value：解码器RNN序列中，每个时间步的最后一层隐状态输出（既作为Key，也作为Value）。 其它操作与之前学习基本一致。 1 2 3 import torch from torch import nn from d2l import torch as d2l 4.2 定义注意力解码器 编码器不用重新定义，直接使用之前的就行\n首先定义一个基本接口 1 2 3 4 5 6 7 8 9 #@save class AttentionDecoder(d2l.Decoder): \u0026#34;\u0026#34;\u0026#34;带有注意力机制解码器的基本接口\u0026#34;\u0026#34;\u0026#34; def __init__(self, **kwargs): super(AttentionDecoder, self).__init__(**kwargs) @property def attention_weights(self): raise NotImplementedError 然后是具体的代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Seq2SeqAttentionDecoder(AttentionDecoder): def __init__(self, vocab_size, embed_size, num_hiddens, num_layers, dropout=0, **kwargs): super(Seq2SeqAttentionDecoder, self).__init__(**kwargs) self.attention = d2l.AdditiveAttention( num_hiddens, num_hiddens, num_hiddens, dropout) # 编码器与解码器的隐状态的神经元个数一致 self.embedding = nn.Embedding(vocab_size, embed_size) self.rnn = nn.GRU( embed_size + num_hiddens, num_hiddens, num_layers, dropout=dropout) self.dense = nn.Linear(num_hiddens, vocab_size) def init_state(self, enc_outputs, enc_valid_lens, *args): # outputs的形状为(batch_size，num_steps，num_hiddens). # hidden_state的形状为(num_layers，batch_size，num_hiddens) outputs, hidden_state = enc_outputs return (outputs.permute(1, 0, 2), hidden_state, enc_valid_lens) def forward(self, X, state): # enc_outputs的形状为(batch_size,num_steps,num_hiddens). # hidden_state的形状为(num_layers,batch_size, num_hiddens) # 解码器序列的第一个Query隐状态来自于编码器最后一个时间步 enc_outputs, hidden_state, enc_valid_lens = state # 输出X的形状为(num_steps,batch_size,embed_size) X = self.embedding(X).permute(1, 0, 2) outputs, self._attention_weights = [], [] for x in X: # query的形状为(batch_size,1,num_hiddens) query = torch.unsqueeze(hidden_state[-1], dim=1) # 注意力机制的context的形状为(batch_size,1,num_hiddens) context = self.attention(query, enc_outputs, enc_outputs, enc_valid_lens) # 在特征维度上连结 x = torch.cat((context, torch.unsqueeze(x, dim=1)), dim=-1) # 将x变形为(1,batch_size,embed_size+num_hiddens) # 更新Query隐状态 out, hidden_state = self.rnn(x.permute(1, 0, 2), hidden_state) outputs.append(out) self._attention_weights.append(self.attention.attention_weights) outputs = self.dense(torch.cat(outputs, dim=0)) # 全连接层变换后，outputs的形状为(num_steps,batch_size,vocab_size) return outputs.permute(1, 0, 2), [enc_outputs, hidden_state, enc_valid_lens] @property def attention_weights(self): return self._attention_weights 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 encoder = d2l.Seq2SeqEncoder(vocab_size=10, embed_size=8, num_hiddens=16, num_layers=2) encoder.eval() decoder = Seq2SeqAttentionDecoder(vocab_size=10, embed_size=8, num_hiddens=16, num_layers=2) decoder.eval() X = torch.zeros((4, 7), dtype=torch.long) # (batch_size,num_steps) state = decoder.init_state(encoder(X), None) output, state = decoder(X, state) output.shape # (batch_size,num_steps, vocab_size) # torch.Size([4, 7, 10]) len(state) # 3, 分别是[enc_outputs, hidden_state, enc_valid_lens] state[0].shape #编码器所有时间步的最终层隐状态 # torch.Size([4, 7, 16]) state[1].shape #解码器最后一个时间步的所有层隐状态 # torch.Size([2, 4, 16]) 4.3 训练 带有注意力机制的解码器会增加训练的时间 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 embed_size, num_hiddens, num_layers, dropout = 32, 32, 2, 0.1 batch_size, num_steps = 64, 10 lr, num_epochs, device = 0.005, 250, d2l.try_gpu() train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps) encoder = d2l.Seq2SeqEncoder( len(src_vocab), embed_size, num_hiddens, num_layers, dropout) decoder = Seq2SeqAttentionDecoder( len(tgt_vocab), embed_size, num_hiddens, num_layers, dropout) net = d2l.EncoderDecoder(encoder, decoder) d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device) # loss 0.021, 4352.7 tokens/sec on cuda:0 预测 predict_seq2seq函数返回翻译后的outputs，以及相应的注意力权重结果 1 2 3 4 5 6 7 8 9 10 11 engs = [\u0026#39;go .\u0026#39;, \u0026#34;i lost .\u0026#34;, \u0026#39;he\\\u0026#39;s calm .\u0026#39;, \u0026#39;i\\\u0026#39;m home .\u0026#39;] fras = [\u0026#39;va !\u0026#39;, \u0026#39;j\\\u0026#39;ai perdu .\u0026#39;, \u0026#39;il est calme .\u0026#39;, \u0026#39;je suis chez moi .\u0026#39;] for eng, fra in zip(engs, fras): translation, dec_attention_weight_seq = d2l.predict_seq2seq( net, eng, src_vocab, tgt_vocab, num_steps, device, True) print(f\u0026#39;{eng} =\u0026gt; {translation}, \u0026#39;, f\u0026#39;bleu {d2l.bleu(translation, fra, k=2):.3f}\u0026#39;) # go . =\u0026gt; va !, bleu 1.000 # i lost . =\u0026gt; j\u0026#39;ai perdu ., bleu 1.000 # he\u0026#39;s calm . =\u0026gt; il est paresseux ., bleu 0.658 # i\u0026#39;m home . =\u0026gt; je suis chez moi ., bleu 1.000 查看注意力权重 1 2 3 4 5 6 7 8 9 attention_weights = torch.cat([step[0][0][0] for step in dec_attention_weight_seq], 0).reshape(( 1, 1, -1, num_steps)) attention_weights.shape # torch.Size([1, 1, 6, 10]) # 加上一个包含序列结束词元 d2l.show_heatmaps( attention_weights[:, :, :, :len(engs[-1].split()) + 1].cpu(), xlabel=\u0026#39;Key positions\u0026#39;, ylabel=\u0026#39;Query positions\u0026#39;) 5. 多头注意力 5.1 模型 类似于CNN的多输出通道，多头注意力旨在通过多个独立的注意力汇聚学习到不同角度的信息 如下图所示： 首先将query，key，value向量进行线性投影（全连接层转换）； 然后并行地分送到多个不同的注意力汇聚中； 最后将多头注意力输出结果拼接在一起，再经最后一个线性投影转换。 5.2 实现 通常选择缩放点积注意力作为每个注意力头； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #@save class MultiHeadAttention(nn.Module): \u0026#34;\u0026#34;\u0026#34;多头注意力\u0026#34;\u0026#34;\u0026#34; def __init__(self, key_size, query_size, value_size, num_hiddens, num_heads, dropout, bias=False, **kwargs): super(MultiHeadAttention, self).__init__(**kwargs) self.num_heads = num_heads self.attention = d2l.DotProductAttention(dropout) self.W_q = nn.Linear(query_size, num_hiddens, bias=bias) self.W_k = nn.Linear(key_size, num_hiddens, bias=bias) self.W_v = nn.Linear(value_size, num_hiddens, bias=bias) self.W_o = nn.Linear(num_hiddens, num_hiddens, bias=bias) def forward(self, queries, keys, values, valid_lens): # queries，keys，values的形状: (batch_size，查询或者“键－值”对的个数，num_hiddens) queries = transpose_qkv(self.W_q(queries), self.num_heads) keys = transpose_qkv(self.W_k(keys), self.num_heads) values = transpose_qkv(self.W_v(values), self.num_heads) # 经transpose_qkv变换后，输出的queries，keys，values的形状: # (batch_size*num_heads，查询或者“键－值”对的个数，num_hiddens/num_heads) if valid_lens is not None: # 在轴0，将第一项（标量或者矢量）复制num_heads次， # 然后如此复制第二项，然后诸如此类。 valid_lens = torch.repeat_interleave( valid_lens, repeats=self.num_heads, dim=0) # output的形状:(batch_size*num_heads，查询的个数，num_hiddens/num_heads) 除 output = self.attention(queries, keys, values, valid_lens) # output_concat的形状:(batch_size，查询的个数，num_hiddens) output_concat = transpose_output(output, self.num_heads) return self.W_o(output_concat) 如上操作，虽然是多头计算，但可以通过数据处理技巧节省运算。 简单来说，在计算式，通过合并num_head维度到batch_size维度，一次性计算多头的注意力结果。 最后再将结果在num_hiddens维度cat拼接到一起。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #@save def transpose_qkv(X, num_heads): \u0026#34;\u0026#34;\u0026#34;为了多注意力头的并行计算而变换形状\u0026#34;\u0026#34;\u0026#34; # 输入X的形状:(batch_size，查询或者“键－值”对的个数，num_hiddens) X = X.reshape(X.shape[0], X.shape[1], num_heads, -1) # 输出X的形状:(batch_size，查询或者“键－值”对的个数，num_heads，num_hiddens/num_heads) X = X.permute(0, 2, 1, 3) # 输出X的形状:(batch_size，num_heads，查询或者“键－值”对的个数, num_hiddens/num_heads) # 最终输出的形状:(batch_size*num_heads,查询或者“键－值”对的个数,num_hiddens/num_heads) return X.reshape(-1, X.shape[2], X.shape[3]) #@save def transpose_output(X, num_heads): \u0026#34;\u0026#34;\u0026#34;逆转transpose_qkv函数的操作\u0026#34;\u0026#34;\u0026#34; # 三维变四维 X = X.reshape(-1, num_heads, X.shape[1], X.shape[2]) X = X.permute(0, 2, 1, 3) # 四维再变三维：(batch_size，查询的个数，num_hiddens) return X.reshape(X.shape[0], X.shape[1], -1) 示例演示 5个注意力头 qkv隐藏层神经元长度都设置为一样，为100 批量大小为2，每个批量4次query，6个键值对 1 2 3 4 5 6 7 8 9 10 11 12 13 14 num_hiddens, num_heads = 100, 5 attention = MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens, num_hiddens, num_heads, 0.5) attention.eval() batch_size, num_queries = 2, 4 num_kvpairs, valid_lens = 6, torch.tensor([3, 2]) X = torch.ones((batch_size, num_queries, num_hiddens)) #Query Y = torch.ones((batch_size, num_kvpairs, num_hiddens)) #Key/Value是相同的 X.shape, Y.shape # (torch.Size([2, 4, 100]), torch.Size([2, 6, 100])) attention(X, Y, Y, valid_lens).shape # torch.Size([2, 4, 100]) 6. 自注意力和位置编码 6.1 自注意力 可采用自注意力机制对序列词元进行编码。此时Query，以及Key-Value都来自同一组输入 即每个词元查询都会关注所有的键-值对，并生成一个注意力输出 1 2 3 4 5 6 7 8 9 10 11 12 13 num_hiddens, num_heads = 100, 5 attention = d2l.MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens, num_hiddens, num_heads, 0.5) attention.eval() batch_size, num_queries, valid_lens = 2, 4, torch.tensor([3, 2]) # (批量大小，词元序列长度，d) X = torch.ones((batch_size, num_queries, num_hiddens)) # 如下X分别充当queries, keys, values attention(X, X, X, valid_lens).shape # torch.Size([2, 4, 100]) # 输入与输出的形状相同 6.2 比较CNN, RNN, Self-attention 卷积神经网路、循环神经网络，以及自注意力架构都可以将n个词元组成的序列映射到另一个长度相同的序列表示。\nCNN (假设卷积核大小为k，输入与输出通道为d)\n计算复杂度：O(knd*d) 顺序操作：O(1) 最大路径长度：O(n/k) RNN(d×d权重矩阵，d维隐状态)\n计算复杂度：O(d*d)\n顺序操作：O(n)\n最大路径长度：O(n)\nSelf-attention\n计算复杂度：O(n*nd)\n顺序操作：O(1)\n最大路径长度：O(1)\n综上：卷积神经网络和自注意力都拥有并行计算的优势。而自注意力的最大路径长度最短，其计算复杂度在很长的序列中计算会比较慢。\nTIPS: 顺序操作会妨碍并行计算。而任意的序列位置组合之间的路径越短，则能更轻松地学习序列中的远距离依赖关系。\n6.3 位置编码 在6.1的计算过程中，忽略了序列所包含的位置信息。 对于n×d的序列词元输入信息，可进行位置编码生成相同形状的表示，再进行矩阵加法，共同作为输入。 n表示序列中词元的个数，d表示features数 如下公式，一种常见方式是基于正弦函数和余弦函数的固定位置编码。 序列中第i个词元(行)的第偶数个维数(列)使用sin函数 序列中第i个词元(行)的第奇数个维数(列)使用cos函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #@save class PositionalEncoding(nn.Module): \u0026#34;\u0026#34;\u0026#34;位置编码\u0026#34;\u0026#34;\u0026#34; def __init__(self, num_hiddens, dropout, max_len=1000): super(PositionalEncoding, self).__init__() self.dropout = nn.Dropout(dropout) # 创建一个足够长的P self.P = torch.zeros((1, max_len, num_hiddens)) X = torch.arange(max_len, dtype=torch.float32).reshape( -1, 1) / torch.pow(10000, torch.arange( 0, num_hiddens, 2, dtype=torch.float32) / num_hiddens) self.P[:, :, 0::2] = torch.sin(X) self.P[:, :, 1::2] = torch.cos(X) def forward(self, X): X = X + self.P[:, :X.shape[1], :].to(X.device) return self.dropout(X) 如下可视化，可以看出 第2j列与第2j+1列的周期/频率是一样的 j越大，sin/cos函数周期越大，或者说频率越低 1 2 3 4 5 6 7 8 9 encoding_dim, num_steps = 32, 60 pos_encoding = PositionalEncoding(encoding_dim, 0) pos_encoding.eval() X = pos_encoding(torch.zeros((1, num_steps, encoding_dim))) # X+P P = pos_encoding.P[:, :X.shape[1], :] # P d2l.plot(torch.arange(num_steps), P[0, :, 6:10].T, xlabel=\u0026#39;Row (position)\u0026#39;, figsize=(6, 2.5), legend=[\u0026#34;Col %d\u0026#34; % d for d in torch.arange(6, 10)]) 7. Transformer Transformer模型完全基于注意力机制，没有任何卷积层或循环神经网络层 (Attention is all you need)； 它最初是应用于在文本数据上的序列到序列学习，但现在已经推广到各种现代的深度学习中，例如语言、视觉、语音和强化学习领域。 7.1 模型 Transformer是一个经典的编码器与解码器架构。 架构角度\n编码器：n个编码层组成，每个层由2个子层串联组成。每个子层后面都采用了残差连接，再应用层规范化(layer normalization) 第一个子层：多头自注意力汇聚； 第二个子层：基于位置的前馈网络； 解码器：n个解码层组成，每个层由3个子层串联组成。每个子层后面同样都采用了残差连接，再应用层规范化(layer normalization) 第一个子层：带掩码的多头自注意力汇聚； 第二个子层：编码器-解码器注意力层； 第三个子层：基于位置的前馈网络 数据角度\n编码器 输入词元序列的embedding加上位置编码，输入到第一个编码层的第一个子层； 经过n层编码层学习后，输出的形状一般不变（batch_size, num_steps, num_hiddens） 解码器 标签词元序列的embedding，加上位置编码，输入到第一个解码层的第一个子层(掩码自注意力)； 在第二个子层中，将第一个子层的输出作为Query，将编码器的输出作为Key和Value，进行解码，输出到前馈网络； 经过如上n个解码层学习，最后输出到一个全连接层中。 1 2 3 4 5 import math import pandas as pd import torch from torch import nn from d2l import torch as d2l 7.2 基于位置的前馈神经网络 Positionwise feed-forward network, FFN 对序列中的每个位置词元特征，都进行相同的映射变换 本质上就是两层的MLP 输入形状：（批量大小，序列长度，特征维度） 输出形状：（批量大小，序列长度，特征维度2） FFN类的参数 输入：特征维度 中间：隐藏层神经元 输出：特征维度2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #@save class PositionWiseFFN(nn.Module): \u0026#34;\u0026#34;\u0026#34;基于位置的前馈网络\u0026#34;\u0026#34;\u0026#34; def __init__(self, ffn_num_input, ffn_num_hiddens, ffn_num_outputs, **kwargs): super(PositionWiseFFN, self).__init__(**kwargs) self.dense1 = nn.Linear(ffn_num_input, ffn_num_hiddens) self.relu = nn.ReLU() self.dense2 = nn.Linear(ffn_num_hiddens, ffn_num_outputs) def forward(self, X): return self.dense2(self.relu(self.dense1(X))) inputs = torch.ones((2, 3, 4)) ffn = PositionWiseFFN(4, 4, 8) outputs = ffn(inputs) outputs.shape # torch.Size([2, 3, 8]) 7.3 残差连接和层规范化 层规范化，Layer Normalization 对每个序列中所有词元的特征数据进行规范化 e.g. 对于每个序列的二维矩阵(序列长度，特征数)的整体求均值与方差 TIPS: 之前学习的BatchNorm是对一个特征在所有批量样本的规范化。\n1 2 3 4 5 6 7 8 9 ln = nn.LayerNorm(normalized_shape=(5, 10)) #一个序列所有词元的特征 # ln = nn.LayerNorm(normalized_shape=(5, 10)) 单个词元所有特征的规范化 # 输入数据 X = torch.randn(3, 5, 10) # 归一化 output = ln(X) output.shape # torch.Size([3, 5, 10]) 残差连接的定义仍是加上原始输入X，以便计算深层网络 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #@save class AddNorm(nn.Module): \u0026#34;\u0026#34;\u0026#34;残差连接后进行层规范化\u0026#34;\u0026#34;\u0026#34; def __init__(self, normalized_shape, dropout, **kwargs): super(AddNorm, self).__init__(**kwargs) self.dropout = nn.Dropout(dropout) self.ln = nn.LayerNorm(normalized_shape) def forward(self, X, Y): return self.ln(self.dropout(Y) + X) #先计算残差连接，再Norm # 实例化一个类 add_norm = AddNorm([3, 4], 0.5) add_norm.eval() add_norm(torch.ones((2, 3, 4)), torch.ones((2, 3, 4))).shape # torch.Size([2, 3, 4]) 7.4 编码器 首先定义编码层，如上所述包含了两个子层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #@save class EncoderBlock(nn.Module): \u0026#34;\u0026#34;\u0026#34;Transformer编码器块\u0026#34;\u0026#34;\u0026#34; def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias=False, **kwargs): super(EncoderBlock, self).__init__(**kwargs) # 第一个子层 self.attention = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout, use_bias) self.addnorm1 = AddNorm(norm_shape, dropout) # 第二个子层 self.ffn = PositionWiseFFN( ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm2 = AddNorm(norm_shape, dropout) def forward(self, X, valid_lens): Y = self.addnorm1(X, self.attention(X, X, X, valid_lens)) return self.addnorm2(Y, self.ffn(Y)) 示例\n1 2 3 4 5 6 7 8 9 10 11 X = torch.ones((2, 100, 24)) #输入X valid_lens = torch.tensor([3, 2]) # qkv以及hidden均为24 # [100, 24]表示对于后两个维度进行LayerNorm # 24, 48为FNN的输入与隐藏，8个多头注意力 encoder_blk = EncoderBlock(24, 24, 24, 24, [100, 24], 24, 48, 8, 0.5) encoder_blk.eval() encoder_blk(X, valid_lens).shape # torch.Size([2, 100, 24]) 构造编码器类 输入X加上位置编码，输入到n个编码层中得到输出 num_layers设置n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #@save class TransformerEncoder(d2l.Encoder): \u0026#34;\u0026#34;\u0026#34;Transformer编码器\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, use_bias=False, **kwargs): super(TransformerEncoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\u0026#34;block\u0026#34;+str(i), EncoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, use_bias)) def forward(self, X, valid_lens, *args): # 因为位置编码值在-1和1之间，因此嵌入值乘以嵌入维度的平方根进行缩放，然后再与位置编码相加。 X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self.attention_weights = [None] * len(self.blks) for i, blk in enumerate(self.blks): X = blk(X, valid_lens) # 保存注意力权重 self.attention_weights[i] = blk.attention.attention.attention_weights return X 示例\n1 2 3 4 5 6 # n=2 encoder = TransformerEncoder( 200, 24, 24, 24, 24, [100, 24], 24, 48, 8, 2, 0.5) encoder.eval() encoder(torch.ones((2, 100), dtype=torch.long), valid_lens).shape # torch.Size([2, 100, 24]) 7.5 解码器 相对编码器，解码器的构造比较复杂。（1）每个解码层包括3个子层；（2）将编码器的输出结合到解码器中；（3）训练与预测的处理方式有差异\n关于第一个子层，即带掩码的自注意力层：\n在训练时，序列中所有位置的词元理论上都是已知的。\n但是在真实的应用/预测场景中，只有生成的词元才能用于解码器的自注意力计算中。\ndec_valid_lens参数可以使得查询都只会与解码器中所有已经生成词元的位置进行注意力计算。\n关于第二个子层，即编码器-解码器注意力层\n上一的解码层子层的单个词元输出将作为Query 来自编码器的输出将同时作为Key和Value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class DecoderBlock(nn.Module): \u0026#34;\u0026#34;\u0026#34;解码器中第i个块\u0026#34;\u0026#34;\u0026#34; def __init__(self, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i, **kwargs): super(DecoderBlock, self).__init__(**kwargs) # i表示n个解码层中的第i个层 self.i = i # 第一个子层 self.attention1 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm1 = AddNorm(norm_shape, dropout) # 第二个子层 self.attention2 = d2l.MultiHeadAttention( key_size, query_size, value_size, num_hiddens, num_heads, dropout) self.addnorm2 = AddNorm(norm_shape, dropout) # 第三个子层 self.ffn = PositionWiseFFN(ffn_num_input, ffn_num_hiddens, num_hiddens) self.addnorm3 = AddNorm(norm_shape, dropout) def forward(self, X, state): enc_outputs, enc_valid_lens = state[0], state[1] # 训练阶段，输出序列的所有词元都在同一时间处理，因此state[2][self.i]初始化为None。 if state[2][self.i] is None: key_values = X # 预测阶段，输出序列是通过词元一个接着一个解码的，因此state[2][self.i]包含着直到当前时间步第i个块解码的输出表示 else: # (Batch_size, Num_steps + 1, Num_hiddens) 逐步累计每个时间步的解码表示 key_values = torch.cat((state[2][self.i], X), axis=1) state[2][self.i] = key_values if self.training: batch_size, num_steps, _ = X.shape # dec_valid_lens的开头:(batch_size,num_steps), 其中每一行是[1,2,...,num_steps] dec_valid_lens = torch.arange( 1, num_steps + 1, device=X.device).repeat(batch_size, 1) else: dec_valid_lens = None # 第一个子层：自注意力，dec_valid_lens表示掩码 X2 = self.attention1(X, key_values, key_values, dec_valid_lens) Y = self.addnorm1(X, X2) # 第二个子层：编码器－解码器注意力。 # enc_outputs的开头:(batch_size,num_steps,num_hiddens)作为key/value Y2 = self.attention2(Y, enc_outputs, enc_outputs, enc_valid_lens) Z = self.addnorm2(Y, Y2) # 第三个子层，state主要更新了state[2]中的内容 return self.addnorm3(Z, self.ffn(Z)), state 示例\n1 2 3 4 5 6 # 8个head decoder_blk = DecoderBlock(24, 24, 24, 24, [100, 24], 24, 48, 8, 0.5, 0) decoder_blk.eval() X = torch.ones((2, 100, 24)) state = [encoder_blk(X, valid_lens), valid_lens, [None]] decoder_blk(X, state)[0].shape 构造解码器类 最后一个全连接层输出序列中每个词元的vocab_size个可能输出词元的概率 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class TransformerDecoder(d2l.AttentionDecoder): def __init__(self, vocab_size, key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, **kwargs): super(TransformerDecoder, self).__init__(**kwargs) self.num_hiddens = num_hiddens self.num_layers = num_layers # 序列embedding+位置编码 self.embedding = nn.Embedding(vocab_size, num_hiddens) self.pos_encoding = d2l.PositionalEncoding(num_hiddens, dropout) # n个解码层 self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(\u0026#34;block\u0026#34;+str(i), DecoderBlock(key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, i)) #最后一个全连接层 self.dense = nn.Linear(num_hiddens, vocab_size) # 初始化的state值 def init_state(self, enc_outputs, enc_valid_lens, *args): return [enc_outputs, enc_valid_lens, [None] * self.num_layers] def forward(self, X, state): # 序列embedding+位置编码 X = self.pos_encoding(self.embedding(X) * math.sqrt(self.num_hiddens)) self._attention_weights = [[None] * len(self.blks) for _ in range (2)] # n个解码层 for i, blk in enumerate(self.blks): X, state = blk(X, state) # 解码器自注意力权重 self._attention_weights[0][ i] = blk.attention1.attention.attention_weights # “编码器－解码器”自注意力权重 self._attention_weights[1][ i] = blk.attention2.attention.attention_weights #最后一个全连接层 return self.dense(X), state @property def attention_weights(self): return self._attention_weights 7.6 训练 同样以之前的\u0026rsquo;英语-法语\u0026rsquo;的机器翻译任务为例，演示Transformer的训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 num_hiddens, num_layers, dropout, batch_size, num_steps = 32, 2, 0.1, 64, 10 lr, num_epochs, device = 0.005, 200, d2l.try_gpu() ffn_num_input, ffn_num_hiddens, num_heads = 32, 64, 4 key_size, query_size, value_size = 32, 32, 32 norm_shape = [32] # 训练数据 train_iter, src_vocab, tgt_vocab = d2l.load_data_nmt(batch_size, num_steps) # 编码器 encoder = TransformerEncoder( len(src_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) # 解码器 decoder = TransformerDecoder( len(tgt_vocab), key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) # 实例化模型 net = d2l.EncoderDecoder(encoder, decoder) # 训练 d2l.train_seq2seq(net, train_iter, lr, num_epochs, tgt_vocab, device) # loss 0.032, 5852.4 tokens/sec on cuda:0 尽管Transformer架构是为了序列到序列的学习而提出的，但正如本书后面将提及的那样，Transformer编码器或Transformer解码器通常被单独用于不同的深度学习任务中。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/713d2l-%E7%AC%AC%E5%8D%81%E7%AB%A0%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/","summary":"\u003ch1 id=\"1-注意力提示\"\u003e1. 注意力提示\u003c/h1\u003e\n\u003ch2 id=\"11-生物学的注意力提示\"\u003e1.1 生物学的注意力提示\u003c/h2\u003e\n\u003cp\u003e如下的观察实验：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e受试者的注意力往往首先被颜色鲜艳的红色咖啡杯吸引（非自主性）；\n\u003cul\u003e\n\u003cli\u003e客观存在的，对于观察者的吸引特征。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e喝完咖啡，处于兴奋状态的大脑经思考后，相比看报等，可能更想要读一本书（自主性权重更高）；\n\u003cul\u003e\n\u003cli\u003e在受试者的主观意愿推动下所做的决定。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20240812204130442.png\" alt=\"image-20240812204130442\"  /\u003e\r\n\u003c/p\u003e","title":"D2L--第十章注意力机制与Transformer"},{"content":"1. 基础介绍 BERT（来自Transformers的双向编码器表示）基于Transformer编码器进行预训练(Pre-train)，从而对输入词元进行上下文表示。 而在针对具体的自然语言处理任务的训练(Fine-tuning)时，对预训练Transformer编码器的所有参数进行微调，而额外的输出层将从头开始训练。 2. 输入表示 BERT输入序列的Embedding嵌入，表示为词元嵌入、段嵌入和位置嵌入的矩阵加和。\n词元嵌入：词元索引的独热编码的特征表示 片段嵌入：标记来自第一个文本句，还是第二个文本句 每个序列开头加是一个\u0026rsquo;\u0026lt;cls\u0026gt;\u0026lsquo;特殊类别词元。 BERT输入序列可以包括1个或者2个文本句子，每个文本句后加一个\u0026rsquo;\u0026lt;sep\u0026gt;\u0026lsquo;特殊分隔词元 1 2 3 4 5 6 7 8 9 10 11 12 13 #@save def get_tokens_and_segments(tokens_a, tokens_b=None): \u0026#34;\u0026#34;\u0026#34;获取输入序列的词元及其片段索引\u0026#34;\u0026#34;\u0026#34; tokens = [\u0026#39;\u0026lt;cls\u0026gt;\u0026#39;] + tokens_a + [\u0026#39;\u0026lt;sep\u0026gt;\u0026#39;] # 0和1分别标记片段A和B segments = [0] * (len(tokens_a) + 2) if tokens_b is not None: tokens += tokens_b + [\u0026#39;\u0026lt;sep\u0026gt;\u0026#39;] segments += [1] * (len(tokens_b) + 1) return tokens, segments get_tokens_and_segments([\u0026#34;aa\u0026#34;],[\u0026#39;b\u0026#39;]) # ([\u0026#39;\u0026lt;cls\u0026gt;\u0026#39;, \u0026#39;aa\u0026#39;, \u0026#39;\u0026lt;sep\u0026gt;\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;\u0026lt;sep\u0026gt;\u0026#39;], [0, 0, 0, 1, 1]) 位置嵌入：与Transformer不同，BERT使用了可学习的位置编码 获取序列的输入表示后，就可以简单地应用到Transformer的编码器中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #@save class BERTEncoder(nn.Module): \u0026#34;\u0026#34;\u0026#34;BERT编码器\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, max_len=1000, key_size=768, query_size=768, value_size=768, **kwargs): super(BERTEncoder, self).__init__(**kwargs) self.token_embedding = nn.Embedding(vocab_size, num_hiddens) #词元嵌入 self.segment_embedding = nn.Embedding(2, num_hiddens) #段嵌入 # 在BERT中，位置嵌入是可学习的，因此我们创建一个足够长的位置嵌入参数（用多少截多少） self.pos_embedding = nn.Parameter(torch.randn(1, max_len, num_hiddens)) # n个Transformer编码层 self.blks = nn.Sequential() for i in range(num_layers): self.blks.add_module(f\u0026#34;{i}\u0026#34;, d2l.EncoderBlock( key_size, query_size, value_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, dropout, True)) def forward(self, tokens, segments, valid_lens): # 在以下代码段中，X的形状保持不变：（批量大小，最大序列长度，num_hiddens） X = self.token_embedding(tokens) + self.segment_embedding(segments) X = X + self.pos_embedding.data[:, :X.shape[1], :] for blk in self.blks: X = blk(X, valid_lens) return X 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 # 实例化一个encoder vocab_size, num_hiddens, ffn_num_hiddens, num_heads = 10000, 768, 1024, 4 norm_shape, ffn_num_input, num_layers, dropout = [768], 768, 2, 0.2 encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout) # demo输入：批量大小为2，序列长度为8 tokens = torch.randint(0, vocab_size, (2, 8)) # 每个序列的段嵌入 segments = torch.tensor([[0, 0, 0, 0, 1, 1, 1, 1], [0, 0, 0, 1, 1, 1, 1, 1]]) encoded_X = encoder(tokens, segments, None) encoded_X.shape # torch.Size([2, 8, 768]) 3. 预训练任务 上述的encoder前向推断给出了输入文本的每个词元和插入的特殊标记“\u0026lt;cls\u0026gt;”及“\u0026lt;\\seq\u0026gt;”的BERT表示。 基于此，来计算预训练BERT的两个损失函数，从而以自监督(无标签)训练方式，学习词元的embedding 3.1 掩蔽语言模型 Masked language modeling\nBERT随机掩蔽(masked)词元，并使用来自双向上下文的词元预测掩蔽词元。\n这里的双向主要是指在学习特定词元的表示时，可以同时看到该词元前面和后面的序列信息。 这区别于GPT模型从左到右的学习预测方式。 具体来说，在该预训练中，将随机选择15%的词元作为预测的掩蔽/掩码词元。对于每个被选中的词元，会如下处理：\n80%可能变为特殊的“\u0026lt;mask\u0026gt;“词元（例如，“this movie is great”变为“this movie is\u0026lt;\\mask\u0026gt;”； 10%时间为随机词元(噪音)（例如，“this movie is great”变为“this movie is drink”）； 10%时间内为不变的标签词元（例如，“this movie is great”变为“this movie is great”）。 如下定义一个MaskLM类来预测上述的掩蔽标记\n输入：Encoder对词元的编码表示，用于预测的词元位置 输出：这些位置的预测结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #@save class MaskLM(nn.Module): \u0026#34;\u0026#34;\u0026#34;BERT的掩蔽语言模型任务\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, num_hiddens, num_inputs=768, **kwargs): super(MaskLM, self).__init__(**kwargs) # 使用具有单隐藏层的MLP进行预测 self.mlp = nn.Sequential(nn.Linear(num_inputs, num_hiddens), nn.ReLU(), nn.LayerNorm(num_hiddens), nn.Linear(num_hiddens, vocab_size)) def forward(self, X, pred_positions): num_pred_positions = pred_positions.shape[1] #每个序列的masked词元数 pred_positions = pred_positions.reshape(-1) #总共的masked词元数 batch_size = X.shape[0] batch_idx = torch.arange(0, batch_size) # 假设batch_size=2，num_pred_positions=3 # 那么batch_idx是np.array（[0,0,0,1,1,1]） batch_idx = torch.repeat_interleave(batch_idx, num_pred_positions) masked_X = X[batch_idx, pred_positions] masked_X = masked_X.reshape((batch_size, num_pred_positions, -1)) mlm_Y_hat = self.mlp(masked_X) return mlm_Y_hat 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 mlm = MaskLM(vocab_size, num_hiddens) mlm_positions = torch.tensor([[1, 5, 2], [6, 1, 5]]) mlm_Y_hat = mlm(encoded_X, mlm_positions) mlm_Y_hat.shape # torch.Size([2, 3, 10000]) # 10000为词表大小 #计算与真实标签的loss mlm_Y = torch.tensor([[7, 8, 9], [10, 20, 30]]) loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) mlm_l = loss(mlm_Y_hat.reshape((-1, vocab_size)), mlm_Y.reshape(-1)) mlm_l.shape # torch.Size([6]) 3.2 下一步预测 Next sentence prediction\n当BERT的输入序列包含两个句子时，可以预测两个句子是否存在上下文逻辑关系 此时，可以使用序列开头的\u0026lt;cls\u0026gt;词元嵌入表示整个序列，进行建模 1 2 3 4 5 6 7 8 9 10 #@save class NextSentencePred(nn.Module): \u0026#34;\u0026#34;\u0026#34;BERT的下一句预测任务\u0026#34;\u0026#34;\u0026#34; def __init__(self, num_inputs, **kwargs): super(NextSentencePred, self).__init__(**kwargs) self.output = nn.Linear(num_inputs, 2) def forward(self, X): # X的形状：(batchsize,num_hiddens) 每个序列的\u0026lt;cls\u0026gt;词元表示 return self.output(X) 示例 1 2 3 4 5 6 7 8 9 10 11 12 13 encoded_X = torch.flatten(encoded_X, start_dim=1) # torch.Size([2, 6144]) 这里应该只是模拟合适的形状 # NSP的输入形状:(batchsize，num_hiddens) nsp = NextSentencePred(encoded_X.shape[-1]) nsp_Y_hat = nsp(encoded_X) nsp_Y_hat.shape # torch.Size([2, 2]) # 每个样本得到两个概率预测结果 nsp_y = torch.tensor([0, 1]) #真实标签 nsp_l = loss(nsp_Y_hat, nsp_y) nsp_l.shape # encoded_X.shape 3.3 综合代码 基于上述定义的BERTEncoder类，以及两个预训练任务MaskLM和NextSentencePred来定义BERTModel\n输入的是词元相关信息 输出的是编码后BERT表示encoded_X、以及两个任务的预测结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #@save class BERTModel(nn.Module): \u0026#34;\u0026#34;\u0026#34;BERT模型\u0026#34;\u0026#34;\u0026#34; def __init__(self, vocab_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, max_len=1000, key_size=768, query_size=768, value_size=768, hid_in_features=768, mlm_in_features=768, nsp_in_features=768): super(BERTModel, self).__init__() self.encoder = BERTEncoder(vocab_size, num_hiddens, norm_shape, ffn_num_input, ffn_num_hiddens, num_heads, num_layers, dropout, max_len=max_len, key_size=key_size, query_size=query_size, value_size=value_size) self.mlm = MaskLM(vocab_size, num_hiddens, mlm_in_features) self.nsp = NextSentencePred(nsp_in_features) # 为nsp任务添加的一层中间隐藏层, 输入为encoder的cls输出， # 输出是nsp的输入 self.hidden = nn.Sequential(nn.Linear(hid_in_features, num_hiddens), nn.Tanh()) def forward(self, tokens, segments, valid_lens=None, pred_positions=None): encoded_X = self.encoder(tokens, segments, valid_lens) if pred_positions is not None: mlm_Y_hat = self.mlm(encoded_X, pred_positions) else: mlm_Y_hat = None # 用于下一句预测的多层感知机分类器的隐藏层，0是“\u0026lt;cls\u0026gt;”标记的索引 nsp_Y_hat = self.nsp(self.hidden(encoded_X[:, 0, :])) return encoded_X, mlm_Y_hat, nsp_Y_hat 4. 训练数据集 示例数据WikiText-2 教材中提供的下载链接失效了，在讨论区有小伙伴及时保存了，目前已下载上传到Github 将该文件手动上传到../data/目录下，再解压 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import os import random import torch from d2l import torch as d2l #@save d2l.DATA_HUB[\u0026#39;wikitext-2\u0026#39;] = ( \u0026#39;https://s3.amazonaws.com/research.metamind.io/wikitext/\u0026#39; \u0026#39;wikitext-2-v1.zip\u0026#39;, \u0026#39;3c914d17d80b1459be871a5039ac23e752a53cbe\u0026#39;) # 上述链接失效了，收到上传到服务器中 data_dir = \u0026#39;../data/wikitext-2\u0026#39; ls ../data/wikitext-2 # wiki.test.tokens wiki.train.tokens wiki.valid.tokens 预处理 一行代表一个段落 句号为分隔符，将一段拆成多个句子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #@save def _read_wiki(data_dir): file_name = os.path.join(data_dir, \u0026#39;wiki.train.tokens\u0026#39;) with open(file_name, \u0026#39;r\u0026#39;) as f: lines = f.readlines() # 大写字母转换为小写字母 paragraphs = [line.strip().lower().split(\u0026#39; . \u0026#39;) for line in lines if len(line.split(\u0026#39; . \u0026#39;)) \u0026gt;= 2] random.shuffle(paragraphs) return paragraphs # 示例 # 词元化处理 paragraphs = [d2l.tokenize( paragraph, token=\u0026#39;word\u0026#39;) for paragraph in _read_wiki(data_dir)] # 3层嵌套的list # 第一层：段落 # 第二层：句子 # 第三层：词元 paragraphs[0][0][:3] # [\u0026#39;families\u0026#39;, \u0026#39;of\u0026#39;, \u0026#39;45\u0026#39;] # 第一段的第一句的前三个词元 4.1 NSP数据处理 将两句话合并作为一个样本序列 若两句话来自于同一段落的上下文，则为阳性；其余为阴性。 将两种情况序列设置各占50% 如下函数，50%概率返回两个连续的句子（阳性），50%的概率不会 1 2 3 4 5 6 7 8 9 #@save def _get_next_sentence(sentence, next_sentence, paragraphs): if random.random() \u0026lt; 0.5: is_next = True else: # 阴性：随机选择第二个句子 next_sentence = random.choice(random.choice(paragraphs)) is_next = False return sentence, next_sentence, is_next 如下函数，将对每个段落生成具有两个句子的阳性或阴性序列 返回一个list，包含该段落所有的样本序列，片段嵌入，以及是否连续句子的逻辑符 1 2 3 4 5 6 7 8 9 10 11 12 #@save def _get_nsp_data_from_paragraph(paragraph, paragraphs, vocab, max_len): nsp_data_from_paragraph = [] for i in range(len(paragraph) - 1): tokens_a, tokens_b, is_next = _get_next_sentence( paragraph[i], paragraph[i + 1], paragraphs) # 考虑1个\u0026#39;\u0026lt;cls\u0026gt;\u0026#39;词元和2个\u0026#39;\u0026lt;sep\u0026gt;\u0026#39;词元 if len(tokens_a) + len(tokens_b) + 3 \u0026gt; max_len: continue tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b) nsp_data_from_paragraph.append((tokens, segments, is_next)) return nsp_data_from_paragraph 4.2 MLM数据处理 这里所说的序列就是指4.1步骤得到的合并两个句子的词元序列\n为每个输入序列做掩码处理，并记录被替换的位置，以及正确的标签 这里的位置就是每个样本序列的词元的位置（不是索引） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #@save def _replace_mlm_tokens(tokens, candidate_pred_positions, num_mlm_preds, vocab): # 为遮蔽语言模型的输入创建新的词元副本，其中输入可能包含替换的“\u0026lt;mask\u0026gt;”或随机词元 mlm_input_tokens = [token for token in tokens] pred_positions_and_labels = [] # 打乱后用于在遮蔽语言模型任务中获取15%的随机词元进行预测 random.shuffle(candidate_pred_positions) for mlm_pred_position in candidate_pred_positions: if len(pred_positions_and_labels) \u0026gt;= num_mlm_preds: break masked_token = None # 80%的时间：将词替换为“\u0026lt;mask\u0026gt;”词元 if random.random() \u0026lt; 0.8: masked_token = \u0026#39;\u0026lt;mask\u0026gt;\u0026#39; else: # 10%的时间：保持词不变 if random.random() \u0026lt; 0.5: masked_token = tokens[mlm_pred_position] # 10%的时间：用随机词替换该词 else: masked_token = random.choice(vocab.idx_to_token) mlm_input_tokens[mlm_pred_position] = masked_token pred_positions_and_labels.append( (mlm_pred_position, tokens[mlm_pred_position])) return mlm_input_tokens, pred_positions_and_labels 输入：词元序列以及相应的词表 输出：序列索引信息，以及待预测的位置信息以及正确的标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #@save def _get_mlm_data_from_tokens(tokens, vocab): candidate_pred_positions = [] # tokens是一个字符串列表 for i, token in enumerate(tokens): # 在遮蔽语言模型任务中不会预测特殊词元 if token in [\u0026#39;\u0026lt;cls\u0026gt;\u0026#39;, \u0026#39;\u0026lt;sep\u0026gt;\u0026#39;]: continue candidate_pred_positions.append(i) # 遮蔽语言模型任务中预测15%的随机词元 num_mlm_preds = max(1, round(len(tokens) * 0.15)) mlm_input_tokens, pred_positions_and_labels = _replace_mlm_tokens( tokens, candidate_pred_positions, num_mlm_preds, vocab) pred_positions_and_labels = sorted(pred_positions_and_labels, key=lambda x: x[0]) pred_positions = [v[0] for v in pred_positions_and_labels] mlm_pred_labels = [v[1] for v in pred_positions_and_labels] return vocab[mlm_input_tokens], pred_positions, vocab[mlm_pred_labels] 4.3 添加填充词元 为每个序列添加填充词元\u0026rsquo;\u0026lt;pad\u0026gt;\u0026rsquo;，从而保证输入序列的长度固定，并记录有效长度 同时，序列相关的其它标记信息也需要随之补充到固定长度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #@save def _pad_bert_inputs(examples, max_len, vocab): max_num_mlm_preds = round(max_len * 0.15) all_token_ids, all_segments, valid_lens, = [], [], [] all_pred_positions, all_mlm_weights, all_mlm_labels = [], [], [] nsp_labels = [] for (token_ids, pred_positions, mlm_pred_label_ids, segments, is_next) in examples: all_token_ids.append(torch.tensor(token_ids + [vocab[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;]] * ( max_len - len(token_ids)), dtype=torch.long)) all_segments.append(torch.tensor(segments + [0] * ( max_len - len(segments)), dtype=torch.long)) # 片段标记补长 # valid_lens不包括\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;的计数 valid_lens.append(torch.tensor(len(token_ids), dtype=torch.float32)) # 预测词元标记补长: 固定长度的15% - 有效长度的15% all_pred_positions.append(torch.tensor(pred_positions + [0] * ( max_num_mlm_preds - len(pred_positions)), dtype=torch.long)) # 填充词元的预测将通过乘以0权重在损失中过滤掉 all_mlm_weights.append( torch.tensor([1.0] * len(mlm_pred_label_ids) + [0.0] * ( max_num_mlm_preds - len(pred_positions)), dtype=torch.float32)) all_mlm_labels.append(torch.tensor(mlm_pred_label_ids + [0] * ( max_num_mlm_preds - len(mlm_pred_label_ids)), dtype=torch.long)) # 预测词元真实值，也需要补长 nsp_labels.append(torch.tensor(is_next, dtype=torch.long)) return (all_token_ids, all_segments, valid_lens, all_pred_positions, all_mlm_weights, all_mlm_labels, nsp_labels) 4.4 综合处理 all_token_ids: 输入序列的列表 all_segments: 输入序列片段标记的列表 valid_lens: 每个序列有效长度的列表 all_pred_positions, all_mlm_weights, all_mlm_labels: mlm任务中预测词元的信息 nsp_labels: 是否为连续句子对的逻辑符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #@save class _WikiTextDataset(torch.utils.data.Dataset): def __init__(self, paragraphs, max_len): # 输入paragraphs[i]是代表段落的句子字符串列表； # 而输出paragraphs[i]是代表段落的句子列表，其中每个句子都是词元列表 paragraphs = [d2l.tokenize( paragraph, token=\u0026#39;word\u0026#39;) for paragraph in paragraphs] sentences = [sentence for paragraph in paragraphs for sentence in paragraph] self.vocab = d2l.Vocab(sentences, min_freq=5, reserved_tokens=[ \u0026#39;\u0026lt;pad\u0026gt;\u0026#39;, \u0026#39;\u0026lt;mask\u0026gt;\u0026#39;, \u0026#39;\u0026lt;cls\u0026gt;\u0026#39;, \u0026#39;\u0026lt;sep\u0026gt;\u0026#39;]) # 获取下一句子预测任务的数据 examples = [] for paragraph in paragraphs: examples.extend(_get_nsp_data_from_paragraph( paragraph, paragraphs, self.vocab, max_len)) # 获取遮蔽语言模型任务的数据 examples = [(_get_mlm_data_from_tokens(tokens, self.vocab) + (segments, is_next)) for tokens, segments, is_next in examples] # 填充输入 (self.all_token_ids, self.all_segments, self.valid_lens, self.all_pred_positions, self.all_mlm_weights, self.all_mlm_labels, self.nsp_labels) = _pad_bert_inputs( examples, max_len, self.vocab) def __getitem__(self, idx): return (self.all_token_ids[idx], self.all_segments[idx], self.valid_lens[idx], self.all_pred_positions[idx], self.all_mlm_weights[idx], self.all_mlm_labels[idx], self.nsp_labels[idx]) def __len__(self): return len(self.all_token_ids) 制作成数据迭代器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #@save def load_data_wiki(batch_size, max_len): \u0026#34;\u0026#34;\u0026#34;加载WikiText-2数据集\u0026#34;\u0026#34;\u0026#34; num_workers = d2l.get_dataloader_workers() # data_dir = d2l.download_extract(\u0026#39;wikitext-2\u0026#39;, \u0026#39;wikitext-2\u0026#39;) data_dir = \u0026#39;../data/wikitext-2\u0026#39; paragraphs = _read_wiki(data_dir) train_set = _WikiTextDataset(paragraphs, max_len) train_iter = torch.utils.data.DataLoader(train_set, batch_size, shuffle=True, num_workers=num_workers) return train_iter, train_set.vocab # 词元序列最大长度设置为64 batch_size, max_len = 512, 64 train_iter, vocab = load_data_wiki(batch_size, max_len) for (tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) in train_iter: print(tokens_X.shape, segments_X.shape, valid_lens_x.shape, pred_positions_X.shape, mlm_weights_X.shape, mlm_Y.shape, nsp_y.shape) break # torch.Size([512, 64]) torch.Size([512, 64]) torch.Size([512]) torch.Size([512, 10]) # torch.Size([512, 10]) torch.Size([512, 10]) torch.Size([512]) pred_positions_X[0,:] # tensor([ 4, 6, 18, 28, 35, 37, 39, 49, 0, 0]) mlm_Y[0,:] # tensor([3003, 443, 239, 1792, 48, 6, 814, 18, 0, 0]) 5. 预训练BERT 5.1 预训练BERT 1 2 3 import torch from torch import nn from d2l import torch as d2l 实例化模型 1 2 3 4 5 6 7 8 batch_size, max_len = 512, 64 train_iter, vocab = d2l.load_data_wiki(batch_size, max_len) net = d2l.BERTModel(len(vocab), num_hiddens=128, norm_shape=[128], ffn_num_input=128, ffn_num_hiddens=256, num_heads=2, num_layers=2, dropout=0.2, key_size=128, query_size=128, value_size=128, hid_in_features=128, mlm_in_features=128, nsp_in_features=128) 损失函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 loss = nn.CrossEntropyLoss() #@save def _get_batch_loss_bert(net, loss, vocab_size, tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y): # 前向传播 _, mlm_Y_hat, nsp_Y_hat = net(tokens_X, segments_X, valid_lens_x.reshape(-1), pred_positions_X) # 计算遮蔽语言模型损失 mlm_l = loss(mlm_Y_hat.reshape(-1, vocab_size), mlm_Y.reshape(-1)) *\\ mlm_weights_X.reshape(-1, 1) mlm_l = mlm_l.sum() / (mlm_weights_X.sum() + 1e-8) # 计算下一句子预测任务的损失 nsp_l = loss(nsp_Y_hat, nsp_y) l = mlm_l + nsp_l return mlm_l, nsp_l, l GPU训练模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 devices = d2l.try_all_gpus() def train_bert(train_iter, net, loss, vocab_size, devices, num_steps): net = nn.DataParallel(net, device_ids=devices).to(devices[0]) trainer = torch.optim.Adam(net.parameters(), lr=0.01) step, timer = 0, d2l.Timer() animator = d2l.Animator(xlabel=\u0026#39;step\u0026#39;, ylabel=\u0026#39;loss\u0026#39;, xlim=[1, num_steps], legend=[\u0026#39;mlm\u0026#39;, \u0026#39;nsp\u0026#39;]) # 遮蔽语言模型损失的和，下一句预测任务损失的和，句子对的数量，计数 metric = d2l.Accumulator(4) num_steps_reached = False while step \u0026lt; num_steps and not num_steps_reached: for tokens_X, segments_X, valid_lens_x, pred_positions_X,\\ mlm_weights_X, mlm_Y, nsp_y in train_iter: tokens_X = tokens_X.to(devices[0]) segments_X = segments_X.to(devices[0]) valid_lens_x = valid_lens_x.to(devices[0]) pred_positions_X = pred_positions_X.to(devices[0]) mlm_weights_X = mlm_weights_X.to(devices[0]) mlm_Y, nsp_y = mlm_Y.to(devices[0]), nsp_y.to(devices[0]) trainer.zero_grad() timer.start() mlm_l, nsp_l, l = _get_batch_loss_bert( net, loss, vocab_size, tokens_X, segments_X, valid_lens_x, pred_positions_X, mlm_weights_X, mlm_Y, nsp_y) l.backward() trainer.step() metric.add(mlm_l, nsp_l, tokens_X.shape[0], 1) timer.stop() animator.add(step + 1, (metric[0] / metric[3], metric[1] / metric[3])) step += 1 if step == num_steps: num_steps_reached = True break print(f\u0026#39;MLM loss {metric[0] / metric[3]:.3f}, \u0026#39; f\u0026#39;NSP loss {metric[1] / metric[3]:.3f}\u0026#39;) print(f\u0026#39;{metric[2] / timer.sum():.1f} sentence pairs/sec on \u0026#39; f\u0026#39;{str(devices)}\u0026#39;) # 结果 train_bert(train_iter, net, loss, len(vocab), devices, 50) # MLM loss 5.816, NSP loss 0.757 # 6688.3 sentence pairs/sec on [device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] 5.2 用BERT表示文本 给定输入句子，经BERT编码后，返回每个词元的嵌入表示 1 2 3 4 5 6 7 def get_bert_encoding(net, tokens_a, tokens_b=None): tokens, segments = d2l.get_tokens_and_segments(tokens_a, tokens_b) token_ids = torch.tensor(vocab[tokens], device=devices[0]).unsqueeze(0) segments = torch.tensor(segments, device=devices[0]).unsqueeze(0) valid_len = torch.tensor(len(tokens), device=devices[0]).unsqueeze(0) encoded_X, _, _ = net(token_ids, segments, valid_len) return encoded_X 句子1：a crane is flying, 加上头的\u0026lt;cls\u0026gt;以及尾的\u0026lt;sep\u0026gt;，共有6个词元 1 2 3 4 5 6 7 8 9 10 11 12 tokens_a = [\u0026#39;a\u0026#39;, \u0026#39;crane\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;flying\u0026#39;] encoded_text = get_bert_encoding(net, tokens_a) # 词元：\u0026#39;\u0026lt;cls\u0026gt;\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;crane\u0026#39;,\u0026#39;is\u0026#39;,\u0026#39;flying\u0026#39;,\u0026#39;\u0026lt;sep\u0026gt;\u0026#39; encoded_text.shape # torch.Size([1, 6, 128]) encoded_text_cls = encoded_text[:, 0, :] encoded_text_crane = encoded_text[:, 2, :] encoded_text_cls.shape # torch.Size([1, 128]) encoded_text_crane[0][:3] # tensor([-0.3421, -0.6974, -1.9238], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward0\u0026gt;) 句子2: a crane driver came 1 2 3 4 5 tokens_a2 = [\u0026#39;a\u0026#39;, \u0026#39;crane\u0026#39;, \u0026#39;driver\u0026#39;, \u0026#39;came\u0026#39;] encoded_text2 = get_bert_encoding(net, tokens_a2) encoded_text_crane2 = encoded_text2[:, 2, :] encoded_text_crane2[0][:3] # tensor([-0.3659, -0.6927, -1.8660], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward0\u0026gt;) 6. 微调BERT 6.1 SNLI数据集 一对文本序列（前提与假设）通常可认为存在3种逻辑关系： （1）蕴含 entailment：前提可以推出假设 （2）矛盾contradiction：二者逻辑互相矛盾 （3）中性neutral：无法确定 斯坦福自然语言推断(Stanford natural language inferrence, SNLI)数据集包含了50多万个带标签的英语句子组成的集合。 1 2 3 4 5 6 7 8 9 # #@save # d2l.DATA_HUB[\u0026#39;SNLI\u0026#39;] = ( # \u0026#39;https://nlp.stanford.edu/projects/snli/snli_1.0.zip\u0026#39;, # \u0026#39;9fcde07509c7e87ec61c640c1b2753d9041758e4\u0026#39;) # data_dir = d2l.download_extract(\u0026#39;SNLI\u0026#39;) # 下载snli_1.0.zip到 ../data，解压后，重命名为SNLI data_dir = \u0026#39;../data/SNLI\u0026#39; 定义如下代码，读取该数据集 分为训练集与测试集，前者约有55万对；后者约有1万对 每个数据集返回a list of 3 list，每个子list分别包括所有的前提序列，假设序列，以及二者的标签。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #@save def read_snli(data_dir, is_train): \u0026#34;\u0026#34;\u0026#34;将SNLI数据集解析为前提、假设和标签\u0026#34;\u0026#34;\u0026#34; def extract_text(s): # 删除我们不会使用的信息 s = re.sub(\u0026#39;\\\\(\u0026#39;, \u0026#39;\u0026#39;, s) s = re.sub(\u0026#39;\\\\)\u0026#39;, \u0026#39;\u0026#39;, s) # 用一个空格替换两个或多个连续的空格 s = re.sub(\u0026#39;\\\\s{2,}\u0026#39;, \u0026#39; \u0026#39;, s) return s.strip() label_set = {\u0026#39;entailment\u0026#39;: 0, \u0026#39;contradiction\u0026#39;: 1, \u0026#39;neutral\u0026#39;: 2} file_name = os.path.join(data_dir, \u0026#39;snli_1.0_train.txt\u0026#39; if is_train else \u0026#39;snli_1.0_test.txt\u0026#39;) with open(file_name, \u0026#39;r\u0026#39;) as f: rows = [row.split(\u0026#39;\\t\u0026#39;) for row in f.readlines()[1:]] premises = [extract_text(row[1]) for row in rows if row[0] in label_set] hypotheses = [extract_text(row[2]) for row in rows if row[0] \\ in label_set] labels = [label_set[row[0]] for row in rows if row[0] in label_set] return premises, hypotheses, labels train_data = read_snli(data_dir, is_train=True) len(train_data), len(train_data[0]) # (3, 549367) for x0, x1, y in zip(train_data[0][:3], train_data[1][:3], train_data[2][:3]): print(\u0026#39;前提：\u0026#39;, x0) print(\u0026#39;假设：\u0026#39;, x1) print(\u0026#39;标签：\u0026#39;, y) # 前提： A person on a horse jumps over a broken down airplane . # 假设： A person is training his horse for a competition . # 标签： 2 # 前提： A person on a horse jumps over a broken down airplane . # 假设： A person is at a diner , ordering an omelette . # 标签： 1 # 前提： A person on a horse jumps over a broken down airplane . # 假设： A person is outdoors , on a horse . # 标签： 0 6.2 加载预训练模型 1 2 3 4 5 6 import json import multiprocessing import os import torch from torch import nn from d2l import torch as d2l 教材提供了两个预训练好的bert模型，分别是base和small两个版本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # d2l.DATA_HUB[\u0026#39;bert.base\u0026#39;] = (d2l.DATA_URL + \u0026#39;bert.base.torch.zip\u0026#39;, # \u0026#39;225d66f04cae318b841a13d32af3acc165f253ac\u0026#39;) # d2l.DATA_HUB[\u0026#39;bert.small\u0026#39;] = (d2l.DATA_URL + \u0026#39;bert.small.torch.zip\u0026#39;, # \u0026#39;c72329e68a732bef0452e4b96a1c341c8910f81f\u0026#39;) def load_pretrained_model(pretrained_model, num_hiddens, ffn_num_hiddens, num_heads, num_layers, dropout, max_len, devices): # data_dir = d2l.download_extract(pretrained_model) # http://d2l-data.s3-accelerate.amazonaws.com/bert.small.torch.zip data_dir = \u0026#39;../data/bert.small\u0026#39; # 定义空词表以加载预定义词表 vocab = d2l.Vocab() vocab.idx_to_token = json.load(open(os.path.join(data_dir, \u0026#39;vocab.json\u0026#39;))) vocab.token_to_idx = {token: idx for idx, token in enumerate( vocab.idx_to_token)} bert = d2l.BERTModel(len(vocab), num_hiddens, norm_shape=[256], ffn_num_input=256, ffn_num_hiddens=ffn_num_hiddens, num_heads=4, num_layers=2, dropout=0.2, max_len=max_len, key_size=256, query_size=256, value_size=256, hid_in_features=256, mlm_in_features=256, nsp_in_features=256) # 加载预训练BERT参数 bert.load_state_dict(torch.load(os.path.join(data_dir, \u0026#39;pretrained.params\u0026#39;))) return bert, vocab 6.3 数据预处理 根据6.1 ，合并一对文本序列为一个完整的输入序列；以及相应的片段标记，有效长度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class SNLIBERTDataset(torch.utils.data.Dataset): def __init__(self, dataset, max_len, vocab=None): all_premise_hypothesis_tokens = [[ p_tokens, h_tokens] for p_tokens, h_tokens in zip( *[d2l.tokenize([s.lower() for s in sentences]) for sentences in dataset[:2]])] self.labels = torch.tensor(dataset[2]) self.vocab = vocab self.max_len = max_len (self.all_token_ids, self.all_segments, self.valid_lens) = self._preprocess(all_premise_hypothesis_tokens) print(\u0026#39;read \u0026#39; + str(len(self.all_token_ids)) + \u0026#39; examples\u0026#39;) # 定义_mp_worker，多线程预处理， def _preprocess(self, all_premise_hypothesis_tokens): pool = multiprocessing.Pool(4) # 使用4个进程 out = pool.map(self._mp_worker, all_premise_hypothesis_tokens) all_token_ids = [ token_ids for token_ids, segments, valid_len in out] all_segments = [segments for token_ids, segments, valid_len in out] valid_lens = [valid_len for token_ids, segments, valid_len in out] return (torch.tensor(all_token_ids, dtype=torch.long), torch.tensor(all_segments, dtype=torch.long), torch.tensor(valid_lens)) # 每个线程的处理细节 def _mp_worker(self, premise_hypothesis_tokens): p_tokens, h_tokens = premise_hypothesis_tokens self._truncate_pair_of_tokens(p_tokens, h_tokens) tokens, segments = d2l.get_tokens_and_segments(p_tokens, h_tokens) token_ids = self.vocab[tokens] + [self.vocab[\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;]] \\ * (self.max_len - len(tokens)) segments = segments + [0] * (self.max_len - len(segments)) valid_len = len(tokens) return token_ids, segments, valid_len # 保证原始的p_tokens加上h_tokens的词元数小于最大长度 def _truncate_pair_of_tokens(self, p_tokens, h_tokens): # 为BERT输入中的\u0026#39;\u0026lt;CLS\u0026gt;\u0026#39;、\u0026#39;\u0026lt;SEP\u0026gt;\u0026#39;和\u0026#39;\u0026lt;SEP\u0026gt;\u0026#39;词元保留位置 while len(p_tokens) + len(h_tokens) \u0026gt; self.max_len - 3: if len(p_tokens) \u0026gt; len(h_tokens): p_tokens.pop() else: h_tokens.pop() def __getitem__(self, idx): return (self.all_token_ids[idx], self.all_segments[idx], self.valid_lens[idx]), self.labels[idx] def __len__(self): return len(self.all_token_ids) 小批量加载数据 1 2 3 4 5 6 7 8 9 10 11 # 如果出现显存不足错误，请减少“batch_size”。在原始的BERT模型中，max_len=512 batch_size, max_len, num_workers = 512, 128, d2l.get_dataloader_workers() data_dir = d2l.download_extract(\u0026#39;SNLI\u0026#39;) train_set = SNLIBERTDataset(d2l.read_snli(data_dir, True), max_len, vocab) test_set = SNLIBERTDataset(d2l.read_snli(data_dir, False), max_len, vocab) train_iter = torch.utils.data.DataLoader(train_set, batch_size, shuffle=True, num_workers=num_workers) test_iter = torch.utils.data.DataLoader(test_set, batch_size, num_workers=num_workers) # read 549367 examples # read 9824 examples 6.4 微调BERT 在原有的基础上，添加额外的MLP。该MLP由两个全连接层组成（如下的self.hidden与self.output） 基于bert输出中，对于输入序列的\u0026lt;cls\u0026gt;词元的嵌入表示进行微调、预测。 （1）定义前向传播，实例化模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 class BERTClassifier(nn.Module): def __init__(self, bert): super(BERTClassifier, self).__init__() self.encoder = bert.encoder self.hidden = bert.hidden self.output = nn.Linear(256, 3) def forward(self, inputs): tokens_X, segments_X, valid_lens_x = inputs encoded_X = self.encoder(tokens_X, segments_X, valid_lens_x) return self.output(self.hidden(encoded_X[:, 0, :])) net = BERTClassifier(bert) MaskLM类和NextSentencePred类这两个损失函数与微调下游应用无关，因此当BERT微调时，MaskLM和NextSentencePred中采用的多层感知机的参数不会更新（陈旧的，staled）。\n（2）训练微调模型\n1 2 3 4 5 6 lr, num_epochs = 1e-4, 5 trainer = torch.optim.Adam(net.parameters(), lr=lr) loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) d2l.train_ch13(net, train_iter, test_iter, loss, trainer, num_epochs, devices) # loss 0.519, train acc 0.791, test acc 0.783 # 7622.9 examples/sec on [device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/714d2l-%E7%AC%AC%E5%8D%81%E5%9B%9B%E5%8F%8A%E5%8D%81%E4%BA%94%E7%AB%A0bert%E6%A8%A1%E5%9E%8B/","summary":"\u003ch1 id=\"1-基础介绍\"\u003e1. 基础介绍\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eBERT（来自Transformers的双向编码器表示）基于\u003cstrong\u003eTransformer编码器\u003c/strong\u003e进行预训练(Pre-train)，从而对输入词元进行上下文表示。\u003c/li\u003e\n\u003cli\u003e而在针对具体的自然语言处理任务的训练(Fine-tuning)时，对预训练Transformer编码器的所有参数进行微调，而额外的输出层将从头开始训练。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg src=\"https://miro.medium.com/v2/resize:fit:1134/1*FzPes8JAlfFHi-7lR5yWKQ.png\" alt=\"使用Pre-training的方法與時機| by Jia-Yau Shiau | 軟體之心| Medium | AI Blog TW\" style=\"zoom:67%;\" /\u003e\r\n\u003ch1 id=\"2-输入表示\"\u003e2. 输入表示\u003c/h1\u003e\n\u003cp\u003eBERT输入序列的Embedding嵌入，表示为词元嵌入、段嵌入和位置嵌入的矩阵加和。\u003c/p\u003e","title":"D2L--第十四及十五章BERT模型"},{"content":" 在深度学习中，优化算法是训练模型的关键部分，它们用于更新网络的参数以最小化损失函数。 由于优化算法的目标函数通常是基于训练数据集的损失函数，因此优化的目标是减少训练误差。 NOTE: 深度学习的最终目标是减小泛化误差，所以在关注优化算法的同时，也要注意过拟合。\n深度学习问题绝大部分都是非凸函数，使得优化算法可能陷入这些局部最小值而不是找到全局最小值。 不过在实践中，对于很多深度学习任务，即使找到的是局部最小值，模型的表现也可以是非常好的。 本章节将简单学习目前深度学习领域比较常用的几种优化算法 1. 示例任务 NASA开发的测试机翼的数据集不同飞行器产生的噪声 使用前1500样本，并将数据进行归一化处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 %matplotlib inline import numpy as np import torch from torch import nn from d2l import torch as d2l #@save d2l.DATA_HUB[\u0026#39;airfoil\u0026#39;] = (d2l.DATA_URL + \u0026#39;airfoil_self_noise.dat\u0026#39;, \u0026#39;76e5be1548fd8222e5074cf0faae75edff8cf93f\u0026#39;) #@save def get_data_ch11(batch_size=10, n=1500): data = np.genfromtxt(d2l.download(\u0026#39;airfoil\u0026#39;), dtype=np.float32, delimiter=\u0026#39;\\t\u0026#39;) data = torch.from_numpy((data - data.mean(axis=0)) / data.std(axis=0)) data_iter = d2l.load_array((data[:n, :-1], data[:n, -1]), #最后一列作为标签 batch_size, is_train=True) return data_iter, data.shape[1]-1 定义一个通用的训练函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #@save def train_concise_ch11(trainer_fn, hyperparams, data_iter, num_epochs=4): # 初始化模型：只有一个隐藏层的MLP net = nn.Sequential(nn.Linear(5, 1)) def init_weights(m): if type(m) == nn.Linear: torch.nn.init.normal_(m.weight, std=0.01) net.apply(init_weights) #优化器 optimizer = trainer_fn(net.parameters(), **hyperparams) #损失函数 loss = nn.MSELoss(reduction=\u0026#39;none\u0026#39;) animator = d2l.Animator(xlabel=\u0026#39;epoch\u0026#39;, ylabel=\u0026#39;loss\u0026#39;, xlim=[0, num_epochs], ylim=[0.22, 0.35]) n, timer = 0, d2l.Timer() for _ in range(num_epochs): #每个epoch for X, y in data_iter: #每个batch optimizer.zero_grad() out = net(X) y = y.reshape(out.shape) l = loss(out, y) l.mean().backward() optimizer.step() n += X.shape[0] if n % 200 == 0: timer.stop() # MSELoss计算平方误差时不带系数1/2 animator.add(n/X.shape[0]/len(data_iter), (d2l.evaluate_loss(net, data_iter, loss) / 2,)) timer.start() print(f\u0026#39;loss: {animator.Y[0][-1]:.3f}, {timer.avg():.3f} sec/epoch\u0026#39;) 2. SGD 梯度下降(Gradient Descent): 在每次迭代中，批量梯度下降会使用所有训练样本计算损失函数的梯度，然后根据这个梯度更新模型参数。 计算代价高，因为每次迭代都需要遍历整个训练集。 随机梯度下降(Stochastic Gradient Descent, SGD): 在每次迭代中，随机梯度下降只选取一个训练样本（或者随机选择一个样本）来计算损失函数的梯度，然后根据这个梯度更新模型参数。 收敛过程可能会比较震荡，并且无法完全利用CPU/GPU硬件资源。 小批量随机梯度下降(Mini-batch SGD): 在每次迭代中，小批量随机梯度下降从训练集中随机抽取一个小批量（batch）的样本集合来计算损失函数的梯度，然后根据这个梯度更新模型参数。 为上述两种优化方式的折中方案，比批量梯度下降快，比随机梯度下降更稳定。 可通过torch的torch.optim.SGD快速实现 1 2 3 4 5 data_iter, _ = get_data_ch11(10) # 定义优化器 trainer = torch.optim.SGD # 训练 train_concise_ch11(trainer, {\u0026#39;lr\u0026#39;: 0.01}, data_iter) 3. 动量法 如下公式，gt表示在t时刻计算的损失函数梯度；vt则考虑了过去梯度的累加，称为动量(momentum)。 β值越大，则考虑了过去时刻的梯度越多 常见的β取值包括0.5, 0.9, 0.95, 0.99 通常来说，动量法通过在参数更新时引入“动量”，使得梯度下降更稳定和快速。 可以直接在torch.optim.SGD中添加momentum参数，设置动量法 1 2 3 4 5 # 定义优化器 trainer = torch.optim.SGD # 训练 d2l.train_concise_ch11(trainer, {\u0026#39;lr\u0026#39;: 0.005, \u0026#39;momentum\u0026#39;: 0.9}, data_iter) SGD+动量法的优化效果对于某些任务不必Adam差。\n4. 自适应学习率 4.1 AdaGrad 梯度下降方法使用固定的学习率，这意味着所有参数以相同的速度更新。自适应学习率方法为每个参数提供一个动态调整的学习率，这允许算法更加灵活地适应不同的参数需求。\n**AdaGrad (Adaptive Gradient)**使用每个参数的历史梯度平方的累积和来调整学习率。 在梯度较大的参数上采用较小的学习率，而在梯度较小的参数上采用较大的学习率。 缺点在于，学习率随着训练时间的增加会变得非常小，导致训练提前停止。 可通过torch的torch.optim.Adagrad快速实现。 1 2 3 4 5 # 定义优化器 trainer = torch.optim.Adagrad # 训练 d2l.train_concise_ch11(trainer, {\u0026#39;lr\u0026#39;: 0.1}, data_iter) #初始学习率 4.2 RMSprop **RMSprop (Root Mean Square Propagation)**是 AdaGrad 的一个改进版本 它通过使用指数加权平均数来平滑历史梯度的平方，解决了 AdaGrad 中学习率过早衰减的问题。 alpha参数用于设置平滑方式： 当 alpha 接近 1 时，算法更加重视过去的历史梯度信息； 当 alpha 接近 0 时，则更多地依赖于最近的梯度信息。 可通过torch的torch.optim.RMSprop快速实现。 1 2 3 4 5 # 定义优化器 trainer = torch.optim.RMSprop # 训练 d2l.train_concise_ch11(trainer, {\u0026#39;lr\u0026#39;: 0.01, \u0026#39;alpha\u0026#39;: 0.9}, data_iter) 4.3 Adam **Adam (Adaptive Moment Estimation)**是一种结合了动量法和 RMSprop 的优点的自适应学习率优化算法，是目前最常用的优化算法之一。 它同时使用了一阶矩（动量）和二阶矩（梯度平方的指数加权平均）来更新参数。 一阶矩用来平滑梯度（β1,通常取0.9）； 二阶矩（β2）用来平滑梯度的平方（β2,通常取0.999）。 可通过torch的torch.optim.Adam快速实现。 1 2 3 4 5 # 定义优化器 trainer = torch.optim.Adam # 训练 d2l.train_concise_ch11(trainer, {\u0026#39;lr\u0026#39;: 0.01}, data_iter) Yogi 是对 Adam 优化器的一种改进，旨在解决 Adam 可能遇到的一些问题，特别是当 Adam 在某些情况下过度估计梯度平方的均值时可能导致的性能下降。\n5. 多GPU训练 5.1 并行化思路 （1）网络并行：将一个模型拆成多个部分，分别部署到不同的GPU中。 尤其适用于大模型的训练，单个GPU的显存无法存储批量大小为1的全部模型参数； 数据同步与传输有较大难度，不做推荐 （2）按层并行：将每一层的计算分给多个GPU 同样需要大量的同步操作，不推荐 （3）数据并行：模型相同，训练样本不同。 只要GPU的内存足够大，这种并行方式最方便。 对于具有两个GPU的数据并行训练过程为： 在任何一次训练迭代中，给定的随机的小批量样本都将被分成2个部分，并均匀地分配到GPU上； 每个GPU根据分配给它的小批量子集，计算模型参数的损失和梯度； 将2个GPU中的局部梯度聚合，以获得当前全部小批量的梯度； 聚合梯度被重新分发到每个GPU中； 每个GPU使用这个小批量随机梯度，来更新它所维护的完整的模型参数集 TIP：当原本小批量为b的单GPU训练，增加到k个GPU时，此时总的小批量需要扩展到k×b，从而确保每个GPU训练的小批量还是b。\n1 2 3 4 5 %matplotlib inline import torch from torch import nn from torch.nn import functional as F from d2l import torch as d2l 5.2 从零实现 （1）示例模型：简化的LeNet模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 初始化模型参数 scale = 0.01 W1 = torch.randn(size=(20, 1, 3, 3)) * scale b1 = torch.zeros(20) W2 = torch.randn(size=(50, 20, 5, 5)) * scale b2 = torch.zeros(50) W3 = torch.randn(size=(800, 128)) * scale b3 = torch.zeros(128) W4 = torch.randn(size=(128, 10)) * scale b4 = torch.zeros(10) params = [W1, b1, W2, b2, W3, b3, W4, b4] # 定义模型 def lenet(X, params): # 1个输入通道，20个输出通道 h1_conv = F.conv2d(input=X, weight=params[0], bias=params[1]) h1_activation = F.relu(h1_conv) # 激活层 h1 = F.avg_pool2d(input=h1_activation, kernel_size=(2, 2), stride=(2, 2)) # 平均汇聚层 # 20个输入通道，50个输出通道 h2_conv = F.conv2d(input=h1, weight=params[2], bias=params[3]) h2_activation = F.relu(h2_conv) # 激活层 h2 = F.avg_pool2d(input=h2_activation, kernel_size=(2, 2), stride=(2, 2)) # 平均汇聚层 h2 = h2.reshape(h2.shape[0], -1) h3_linear = torch.mm(h2, params[4]) + params[5] #全连接层 h3 = F.relu(h3_linear) y_hat = torch.mm(h3, params[6]) + params[7] return y_hat # 交叉熵损失函数 loss = nn.CrossEntropyLoss(reduction=\u0026#39;none\u0026#39;) （2）定义两个数据同步函数\n函数1：将模型参数复制到指定的GPU中 1 2 3 4 5 6 7 8 9 10 11 12 13 def get_params(params, device): new_params = [p.to(device) for p in params] for p in new_params: p.requires_grad_() return new_params # 示例 new_params = get_params(params, d2l.try_gpu(0)) print(\u0026#39;b1 权重:\u0026#39;, new_params[1]) # b1 权重: tensor([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.], # device=\u0026#39;cuda:0\u0026#39;, requires_grad=True) print(\u0026#39;b1 梯度:\u0026#39;, new_params[1].grad) #初始梯度为None # b1 梯度: None 函数2：将所有GPU计算的梯度结果汇总（cuda:0）后，再返回给每个GPU 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def allreduce(data): for i in range(1, len(data)): data[0][:] += data[i].to(data[0].device) for i in range(1, len(data)): data[i][:] = data[0].to(data[i].device) # 示例 data = [torch.ones((1, 2), device=d2l.try_gpu(i)) * (i + 1) for i in range(2)] print(\u0026#39;allreduce之前：\\n\u0026#39;, data[0], \u0026#39;\\n\u0026#39;, data[1]) # allreduce之前： # tensor([[1., 1.]], device=\u0026#39;cuda:0\u0026#39;) # tensor([[2., 2.]], device=\u0026#39;cuda:1\u0026#39;) allreduce(data) print(\u0026#39;allreduce之后：\\n\u0026#39;, data[0], \u0026#39;\\n\u0026#39;, data[1]) # allreduce之后： # tensor([[3., 3.]], device=\u0026#39;cuda:0\u0026#39;) # tensor([[3., 3.]], device=\u0026#39;cuda:1\u0026#39;) （3）将总的小批量数据分给各个GPU\n这里为了方便，利用了torch提供的nn.parallel.scatter() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 data = torch.arange(12).reshape(4, 3) devices = [torch.device(\u0026#39;cuda:0\u0026#39;), torch.device(\u0026#39;cuda:1\u0026#39;)] print(\u0026#39;input :\u0026#39;, data) # input : tensor([[ 0, 1, 2], # [ 3, 4, 5], # [ 6, 7, 8], # [ 9, 10, 11]]) print(\u0026#39;load into\u0026#39;, devices) # load into [device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] split = nn.parallel.scatter(data, devices) #按行平均分给多个GPU print(\u0026#39;output:\u0026#39;, split) # output: (tensor([[0, 1, 2], # [3, 4, 5]], device=\u0026#39;cuda:0\u0026#39;), # tensor([[ 6, 7, 8], # [ 9, 10, 11]], device=\u0026#39;cuda:1\u0026#39;)) #@save def split_batch(X, y, devices): \u0026#34;\u0026#34;\u0026#34;将X和y拆分到多个设备上\u0026#34;\u0026#34;\u0026#34; assert X.shape[0] == y.shape[0] return (nn.parallel.scatter(X, devices), nn.parallel.scatter(y, devices)) （4）小批量训练函数\n根据如下代码，多个GPU看上去好像是顺序执行的。 其实是因为计算图在小批量内的设备之间没有任何依赖关系，因此它是“自动地”并行执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def train_batch(X, y, device_params, devices, lr): X_shards, y_shards = split_batch(X, y, devices) # 在每个GPU上分别计算损失 ls = [loss(lenet(X_shard, device_W), y_shard).sum() for X_shard, y_shard, device_W in zip( X_shards, y_shards, device_params)] for l in ls: # 反向传播，计算每个GPU的当前梯度 l.backward() # 将每个GPU的所有梯度相加，并将其广播到所有GPU with torch.no_grad(): for i in range(len(device_params[0])): # device_params为list，为每个GPU的模型参数 allreduce( [device_params[c][i].grad for c in range(len(devices))]) # 在每个GPU上分别更新模型参数 for param in device_params: d2l.sgd(param, lr, X.shape[0]) # 在这里，我们使用全尺寸的小批量 （5）定义最终的训练函数\ntest精度计算只根据其中一个GPU的模型（所有GPU的模型参数都是同步的，所以影响不大） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def train(num_gpus, batch_size, lr): train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) devices = [d2l.try_gpu(i) for i in range(num_gpus)] # 将模型参数复制到num_gpus个GPU device_params = [get_params(params, d) for d in devices] num_epochs = 10 animator = d2l.Animator(\u0026#39;epoch\u0026#39;, \u0026#39;test acc\u0026#39;, xlim=[1, num_epochs]) timer = d2l.Timer() for epoch in range(num_epochs): timer.start() for X, y in train_iter: # 为单个小批量执行多GPU训练 train_batch(X, y, device_params, devices, lr) torch.cuda.synchronize() # 确保当前指定GPU已经训练完成 timer.stop() # 在GPU0上评估模型 animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu( lambda x: lenet(x, device_params[0]), test_iter, devices[0]),)) print(f\u0026#39;测试精度：{animator.Y[0][-1]:.2f}，{timer.avg():.1f}秒/轮，\u0026#39; f\u0026#39;在{str(devices)}\u0026#39;) （6）比较\n如下，我们发现使用1个GPU与2个GPU的训练时间并没有差别； 主要原因是由于模型太小了，并且数据集也很小。 1 2 3 4 5 train(num_gpus=1, batch_size=256, lr=0.2) # 测试精度：0.76，4.9秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0)] train(num_gpus=2, batch_size=256, lr=0.2) # 测试精度：0.83，5.0秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] 5.3 简洁实现 （1）示例模型：Resnet18\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #@save def resnet18(num_classes, in_channels=1): \u0026#34;\u0026#34;\u0026#34;稍加修改的ResNet-18模型\u0026#34;\u0026#34;\u0026#34; def resnet_block(in_channels, out_channels, num_residuals, first_block=False): blk = [] for i in range(num_residuals): if i == 0 and not first_block: blk.append(d2l.Residual(in_channels, out_channels, use_1x1conv=True, strides=2)) else: blk.append(d2l.Residual(out_channels, out_channels)) return nn.Sequential(*blk) # 该模型使用了更小的卷积核、步长和填充，而且删除了最大汇聚层 net = nn.Sequential( nn.Conv2d(in_channels, 64, kernel_size=3, stride=1, padding=1), nn.BatchNorm2d(64), nn.ReLU()) net.add_module(\u0026#34;resnet_block1\u0026#34;, resnet_block( 64, 64, 2, first_block=True)) net.add_module(\u0026#34;resnet_block2\u0026#34;, resnet_block(64, 128, 2)) net.add_module(\u0026#34;resnet_block3\u0026#34;, resnet_block(128, 256, 2)) net.add_module(\u0026#34;resnet_block4\u0026#34;, resnet_block(256, 512, 2)) net.add_module(\u0026#34;resnet_block5\u0026#34;, resnet_block(512, 1024, 2)) net.add_module(\u0026#34;resnet_block6\u0026#34;, resnet_block(1024, 1024, 2)) # net.add_module(\u0026#34;resnet_block7\u0026#34;, resnet_block(1024, 1024, 2)) # net.add_module(\u0026#34;resnet_block8\u0026#34;, resnet_block(1024, 1024, 2)) net.add_module(\u0026#34;global_avg_pool\u0026#34;, nn.AdaptiveAvgPool2d((1,1))) net.add_module(\u0026#34;fc\u0026#34;, nn.Sequential(nn.Flatten(), nn.Linear(1024, num_classes))) return net # 实例化模型 net = resnet18(10) # 获取所有的GPU列表 devices = d2l.try_all_gpus() devices # [device(type=\u0026#39;cuda\u0026#39;, index=0), # device(type=\u0026#39;cuda\u0026#39;, index=1), # device(type=\u0026#39;cuda\u0026#39;, index=2)] # 我们将在训练代码实现中初始化网络 （2）定义训练函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def train(net, num_gpus, batch_size, lr): train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) # 定义所使用的多个GPU devices = [d2l.try_gpu(i) for i in range(num_gpus)] def init_weights(m): if type(m) in [nn.Linear, nn.Conv2d]: nn.init.normal_(m.weight, std=0.01) net.apply(init_weights) # 在多个GPU上设置模型 net = nn.DataParallel(net, device_ids=devices) trainer = torch.optim.SGD(net.parameters(), lr) #优化器 loss = nn.CrossEntropyLoss() #损失函数 timer, num_epochs = d2l.Timer(), 10 animator = d2l.Animator(\u0026#39;epoch\u0026#39;, \u0026#39;test acc\u0026#39;, xlim=[1, num_epochs]) for epoch in range(num_epochs): net.train() timer.start() for X, y in train_iter: trainer.zero_grad() X, y = X.to(devices[0]), y.to(devices[0]) # 先把批量样本数据都暂时放到cuda:0中 l = loss(net(X), y) #模型会自动将样本分发给多个GPU l.backward() trainer.step() timer.stop() animator.add(epoch + 1, (d2l.evaluate_accuracy_gpu(net, test_iter),)) print(f\u0026#39;测试精度：{animator.Y[0][-1]:.2f}，{timer.avg():.1f}秒/轮，\u0026#39; f\u0026#39;在{str(devices)}\u0026#39;) （3）比较\n发现在批量数较大时，才能发挥并行计算的优势 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## Batch size = 256 train(net, num_gpus=1,batch_size=256,lr=0.1) # 测试精度：0.90，7.9秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0)] train(net, num_gpus=2,batch_size=512,lr=0.2) # 测试精度：0.75，13.8秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] ## Batch size = 512 train(net, num_gpus=1,batch_size=512,lr=0.1) # 测试精度：0.87，7.6秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0)] train(net, num_gpus=2,batch_size=1024,lr=0.2) # 测试精度：0.90，8.6秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] ## Batch size = 1024 train(net, num_gpus=1,batch_size=1024,lr=0.1) # 测试精度：0.69，7.7秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0)] train(net, num_gpus=2,batch_size=1024*2,lr=0.1*2) # 测试精度：0.79，6.4秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1)] train(net, num_gpus=3,batch_size=1024*3,lr=0.1*3) # 测试精度：0.79，5.4秒/轮，在[device(type=\u0026#39;cuda\u0026#39;, index=0), device(type=\u0026#39;cuda\u0026#39;, index=1), device(type=\u0026#39;cuda\u0026#39;, index=2)] TIP：当训练的批量大小增大时，学习率也要相应的增加。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/715d2l-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%8F%8A%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E5%A4%9Agpu%E5%B9%B6%E8%A1%8C/","summary":"\u003cul\u003e\n\u003cli\u003e在深度学习中，优化算法是训练模型的关键部分，它们用于更新网络的参数以\u003cstrong\u003e最小化损失函数\u003c/strong\u003e。\n\u003cul\u003e\n\u003cli\u003e由于优化算法的目标函数通常是基于训练数据集的损失函数，因此优化的目标是减少\u003cstrong\u003e训练误差\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eNOTE: 深度学习的最终目标是减小泛化误差，所以在关注优化算法的同时，也要注意过拟合。\u003c/p\u003e","title":"D2L--第十一及十二章优化算法\u0026多GPU并行"},{"content":" 2014年论文：https://proceedings.neurips.cc/paper_files/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf Pytorch DCGAN实现：https://pytorch.org/tutorials/beginner/dcgan_faces_tutorial.html Other (e.g. cGAN)：https://github.com/gordicaleksa/pytorch-GANs 1. 简介 GAN (Generative Adversarial Networks, 生成对抗网络) 于2014年由Ian等提出。简单来说，GAN主要包含两个模型：\nGenerator, G：根据来自于随机分布空间的初始变量z，经生成器模型输出，得到目标形式的分布空间（例如图片等） 比喻：罪犯基于一些原材料，设计工艺流程所生成的假币 Discriminator，D：区分来自于真实样本x的分布（标签为1），还是来自生成器输出**G(z)**的模拟分布（标签为0） 比喻：警察根据一些技术手段，辨别是银行的真币，还是罪犯生产的假币。 在每一次(batch)的训练过程中：\n首先，更新Discriminator模型参数，从而区分目前给定的real与fake数据分布 最大化目标函数包括两部分：左侧增大，可以将真实样本预测为1；右侧增大，可以即将模拟样本预测为0 然后，更新Generator，使得模拟的样本分布尽可能被Discriminator误认为是真实的。 最小化目标函数：即让D(G(z))的输出为1 在多轮迭代训练过程中，Discriminator与Generator保持对抗学习，预期目标是Generator的输出足够接近，使得Discriminator对于二者样本类型的预测均为1/2. GAN本质上属于是无监督学习。它不是为学习到与目标图片一模一样的结果，而是学习目标图片的数据分布，从而达到真实的效果。\n2. 代码实现 接下来将基于DCGAN架构，学习GAN的代码实现方式。其主要基于人脸图像数据集，生成虚拟的人脸图像 训练数据集可从google云端硬盘里下载(img_align_celeba.zip)，解压到工作目录的data/celeba路径中（e.g. data/celeba/img_align_celeba/000001.jpg）。 2.1 加载库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #%matplotlib inline import argparse import os import random import torch import torch.nn as nn import torch.nn.parallel import torch.optim as optim import torch.utils.data import torchvision.datasets as dset import torchvision.transforms as transforms import torchvision.utils as vutils import numpy as np import matplotlib.pyplot as plt import matplotlib.animation as animation from IPython.display import HTML # Set random seed for reproducibility manualSeed = 999 #manualSeed = random.randint(1, 10000) # use if you want new results print(\u0026#34;Random Seed: \u0026#34;, manualSeed) random.seed(manualSeed) torch.manual_seed(manualSeed) torch.use_deterministic_algorithms(True) # Needed for reproducible results 2.2 初始参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 # Root directory for dataset dataroot = \u0026#34;data/celeba\u0026#34; # Number of workers for dataloader workers = 2 # Batch size during training batch_size = 128 # Spatial size of training images. All images will be resized to this size using a transformer. # 真实图片的长/宽 image_size = 64 # Number of channels in the training images. For color images this is 3 # 真实图片的通道数 nc = 3 # Size of z latent vector (i.e. size of generator input) # 输入到生成器Generator的数据大小 nz = 100 # Size of feature maps in generator/生成器通道数变化的倍数 ngf = 64 # Size of feature maps in discriminator/辨别器通道数变化的倍数 ndf = 64 # Number of training epochs num_epochs = 5 # Learning rate for optimizers lr = 0.0002 # Beta1 hyperparameter for Adam optimizers beta1 = 0.5 # Number of GPUs available. Use 0 for CPU mode. ngpu = 1 2.3 加载数据集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # We can use an image folder dataset the way we have it setup. # Create the dataset dataset = dset.ImageFolder(root=dataroot, transform=transforms.Compose([ transforms.Resize(image_size), transforms.CenterCrop(image_size), transforms.ToTensor(), transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5)), ])) # Create the dataloader dataloader = torch.utils.data.DataLoader(dataset, batch_size=batch_size, shuffle=True, num_workers=workers) a, _ = next(iter(dataloader)) a.shape # torch.Size([128, 3, 64, 64]) # Decide which device we want to run on device = torch.device(\u0026#34;cuda:0\u0026#34; if (torch.cuda.is_available() and ngpu \u0026gt; 0) else \u0026#34;cpu\u0026#34;) # Plot some training images real_batch = next(iter(dataloader)) plt.figure(figsize=(8,8)) plt.axis(\u0026#34;off\u0026#34;) plt.title(\u0026#34;Training Images\u0026#34;) plt.imshow(np.transpose(vutils.make_grid(real_batch[0].to(device)[:64], padding=2, normalize=True).cpu(),(1,2,0))) plt.show() 2.4 定义生成器 生成器G：主要使用反卷积层，将向量数据映射为图片 参考上述图片，原论文的ngf应该是128。这里的代码设置为了64。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Generator(nn.Module): def __init__(self, ngpu): super(Generator, self).__init__() self.ngpu = ngpu self.main = nn.Sequential( # input is Z, going into a convolution nn.ConvTranspose2d( nz, ngf * 8, 4, 1, 0, bias=False), nn.BatchNorm2d(ngf * 8), nn.ReLU(True), # state size. ``(ngf*8) x 4 x 4`` nn.ConvTranspose2d(ngf * 8, ngf * 4, 4, 2, 1, bias=False), nn.BatchNorm2d(ngf * 4), nn.ReLU(True), # state size. ``(ngf*4) x 8 x 8`` nn.ConvTranspose2d( ngf * 4, ngf * 2, 4, 2, 1, bias=False), nn.BatchNorm2d(ngf * 2), nn.ReLU(True), # state size. ``(ngf*2) x 16 x 16`` nn.ConvTranspose2d( ngf * 2, ngf, 4, 2, 1, bias=False), nn.BatchNorm2d(ngf), nn.ReLU(True), # state size. ``(ngf) x 32 x 32`` nn.ConvTranspose2d( ngf, nc, 4, 2, 1, bias=False), nn.Tanh() # state size. ``(nc) x 64 x 64`` ) def forward(self, input): return self.main(input) 定义网络层参数的初始化方式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # custom weights initialization called on ``netG`` and ``netD`` def weights_init(m): classname = m.__class__.__name__ if classname.find(\u0026#39;Conv\u0026#39;) != -1: nn.init.normal_(m.weight.data, 0.0, 0.02) elif classname.find(\u0026#39;BatchNorm\u0026#39;) != -1: nn.init.normal_(m.weight.data, 1.0, 0.02) nn.init.constant_(m.bias.data, 0) # Create the generator netG = Generator(ngpu).to(device) # Handle multi-GPU if desired if (device.type == \u0026#39;cuda\u0026#39;) and (ngpu \u0026gt; 1): netG = nn.DataParallel(netG, list(range(ngpu))) # Apply the ``weights_init`` function to randomly initialize all weights # to ``mean=0``, ``stdev=0.02``. netG.apply(weights_init) # Print the model print(netG) 2.5 定义辨别器 辨别器D：主要使用卷积层，输出为一个标量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Discriminator(nn.Module): def __init__(self, ngpu): super(Discriminator, self).__init__() self.ngpu = ngpu self.main = nn.Sequential( # input is ``(nc) x 64 x 64`` nn.Conv2d(nc, ndf, 4, 2, 1, bias=False), nn.LeakyReLU(0.2, inplace=True), # state size. ``(ndf) x 32 x 32`` nn.Conv2d(ndf, ndf * 2, 4, 2, 1, bias=False), nn.BatchNorm2d(ndf * 2), nn.LeakyReLU(0.2, inplace=True), # state size. ``(ndf*2) x 16 x 16`` nn.Conv2d(ndf * 2, ndf * 4, 4, 2, 1, bias=False), nn.BatchNorm2d(ndf * 4), nn.LeakyReLU(0.2, inplace=True), # state size. ``(ndf*4) x 8 x 8`` nn.Conv2d(ndf * 4, ndf * 8, 4, 2, 1, bias=False), nn.BatchNorm2d(ndf * 8), nn.LeakyReLU(0.2, inplace=True), # state size. ``(ndf*8) x 4 x 4`` nn.Conv2d(ndf * 8, 1, 4, 1, 0, bias=False), nn.Sigmoid() ) def forward(self, input): return self.main(input) 模型初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 # Create the Discriminator netD = Discriminator(ngpu).to(device) # Handle multi-GPU if desired if (device.type == \u0026#39;cuda\u0026#39;) and (ngpu \u0026gt; 1): netD = nn.DataParallel(netD, list(range(ngpu))) # Apply the ``weights_init`` function to randomly initialize all weights # like this: ``to mean=0, stdev=0.2``. netD.apply(weights_init) # Print the model print(netD) 2.6 训练模型 定义损失函数、优化器等 1 2 3 4 5 6 7 8 9 10 11 12 13 # Initialize the ``BCELoss`` function 二分类交叉熵损失函数 criterion = nn.BCELoss() # Create batch of latent vectors that we will use to visualize the progression of the generator fixed_noise = torch.randn(64, nz, 1, 1, device=device) # Establish convention for real and fake labels during training real_label = 1. fake_label = 0. # Setup Adam optimizers for both G and D 优化算法 optimizerD = optim.Adam(netD.parameters(), lr=lr, betas=(beta1, 0.999)) optimizerG = optim.Adam(netG.parameters(), lr=lr, betas=(beta1, 0.999)) 训练代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 # Lists to keep track of progress img_list = [] G_losses = [] D_losses = [] iters = 0 print(\u0026#34;Starting Training Loop...\u0026#34;) # For each epoch for epoch in range(num_epochs): # For each batch in the dataloader for i, data in enumerate(dataloader, 0): ############################ # (1) Update D network: maximize log(D(x)) + log(1 - D(G(z))) ########################### ## Train with all-real batch，重置模型D的梯度 netD.zero_grad() # Format batch real_cpu = data[0].to(device) b_size = real_cpu.size(0) label = torch.full((b_size,), real_label, dtype=torch.float, device=device) # Forward pass real batch through D, 转为一维向量 output = netD(real_cpu).view(-1) # Calculate loss on all-real batch errD_real = criterion(output, label) # Calculate gradients for D in backward pass，基于真实样本的梯度更新 errD_real.backward() D_x = output.mean().item() ## Train with all-fake batch # Generate batch of latent vectors，基于正态分布，随机初始化输入z noise = torch.randn(b_size, nz, 1, 1, device=device) # Generate fake image batch with G fake = netG(noise) label.fill_(fake_label) # Classify all fake batch with D output = netD(fake.detach()).view(-1) # Calculate D\u0026#39;s loss on the all-fake batch errD_fake = criterion(output, label) # Calculate the gradients for this batch, accumulated (summed) with previous gradients # 再基于模拟样本的梯度更新，两次梯度的结果会累加 errD_fake.backward() D_G_z1 = output.mean().item() # Compute error of D as sum over the fake and the real batches errD = errD_real + errD_fake # Update D，基于上面两轮的梯度，更新模型参数 optimizerD.step() ############################ # (2) Update G network: maximize log(D(G(z))) ########################### netG.zero_grad() #重置模型G的梯度 label.fill_(real_label) # fake labels are real for generator cost # Since we just updated D, perform another forward pass of all-fake batch through D output = netD(fake).view(-1) # Calculate G\u0026#39;s loss based on this output errG = criterion(output, label) # Calculate gradients for G errG.backward() D_G_z2 = output.mean().item() # Update G optimizerG.step() # Output training stats，每50个batch打印一次结果 if i % 50 == 0: print(\u0026#39;[%d/%d][%d/%d]\\tLoss_D: %.4f\\tLoss_G: %.4f\\tD(x): %.4f\\tD(G(z)): %.4f / %.4f\u0026#39; % (epoch, num_epochs, i, len(dataloader), errD.item(), errG.item(), D_x, D_G_z1, D_G_z2)) # Save Losses for plotting later G_losses.append(errG.item()) D_losses.append(errD.item()) # 记录不同训练阶段的训练生成结果 # Check how the generator is doing by saving G\u0026#39;s output on fixed_noise if (iters % 500 == 0) or ((epoch == num_epochs-1) and (i == len(dataloader)-1)): with torch.no_grad(): fake = netG(fixed_noise).detach().cpu() img_list.append(vutils.make_grid(fake, padding=2, normalize=True)) iters += 1 查看训练过程中，模型G与D的损失函数 1 2 3 4 5 6 7 8 plt.figure(figsize=(10,5)) plt.title(\u0026#34;Generator and Discriminator Loss During Training\u0026#34;) plt.plot(G_losses,label=\u0026#34;G\u0026#34;) plt.plot(D_losses,label=\u0026#34;D\u0026#34;) plt.xlabel(\u0026#34;iterations\u0026#34;) plt.ylabel(\u0026#34;Loss\u0026#34;) plt.legend() plt.show() 对比真实与预测图片样本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Grab a batch of real images from the dataloader real_batch = next(iter(dataloader)) # Plot the real images plt.figure(figsize=(15,15)) plt.subplot(1,2,1) plt.axis(\u0026#34;off\u0026#34;) plt.title(\u0026#34;Real Images\u0026#34;) plt.imshow(np.transpose(vutils.make_grid(real_batch[0].to(device)[:64], padding=5, normalize=True).cpu(),(1,2,0))) # Plot the fake images from the last epoch plt.subplot(1,2,2) plt.axis(\u0026#34;off\u0026#34;) plt.title(\u0026#34;Fake Images\u0026#34;) plt.imshow(np.transpose(img_list[-1],(1,2,0))) plt.show() ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/716%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0--gan%E5%9F%BA%E7%A1%80/","summary":"\u003cblockquote\u003e\n\u003cul\u003e\n\u003cli\u003e2014年论文：https://proceedings.neurips.cc/paper_files/paper/2014/file/5ca3e9b122f61f8f06494c97b1afccf3-Paper.pdf\u003c/li\u003e\n\u003cli\u003ePytorch DCGAN实现：https://pytorch.org/tutorials/beginner/dcgan_faces_tutorial.html\u003c/li\u003e\n\u003cli\u003eOther (e.g. cGAN)：https://github.com/gordicaleksa/pytorch-GANs\u003c/li\u003e\n\u003c/ul\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1-简介\"\u003e1. 简介\u003c/h1\u003e\n\u003cp\u003eGAN (Generative Adversarial Networks, 生成对抗网络) 于2014年由Ian等提出。简单来说，GAN主要包含两个模型：\u003c/p\u003e","title":"深度学习--GAN基础"},{"content":"\rHugging Face是一家专注于自然语言处理（NLP）和人工智能（AI）的公司，可以认为是AI领域的Github。(下面简称HF)\n一方面整理、收集了NLP等AI任务常用的数据集，预训练模型； 另一方面提供系列工具库，用以高效地训练AI模型。具体包括如下几个核心库。 Transformers Datasets Tokenizers 1. 获取模型/数据集 HF提供了大量的公开AI数据集以及预训练数据集，同时也提供了下载的方式\n下载数据集 如下，会自动下载https://huggingface.co/datasets/lhoestq/demo1数据集 1 2 from datasets import load_dataset dataset = load_dataset(\u0026#34;lhoestq/demo1\u0026#34;) 加载模型，会有两种使用场景 调用模型的分词器(tokenizer) 调用预训练模型本身(model checkpoint) 1 2 3 4 5 6 7 from transformers import AutoTokenizer from transformers import AutoModelForSequenceClassification checkpoint = \u0026#34;bert-base-uncased\u0026#34; tokenizer = AutoTokenizer.from_pretrained(checkpoint) model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) 如上，至少在国内的下载速度非常慢。可以使用它的镜像源网站，下载数据集/模型到本地。然后在上面的命令中，提供路径参数即可\nhttps://hf-mirror.com/ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 下载命令行工具 pip install -U huggingface_hub # 设置环境变量 export HF_ENDPOINT=https://hf-mirror.com # 下载模型 huggingface-cli download \\ --resume-download bert-base-uncased \\ --local-dir path/to/bert-base-uncased # 下载数据集 huggingface-cli download --repo-type dataset \\ --resume-download \\ lhoestq/demo1 --local-dir path/to/lhoestq_demo1 # Note: 该镜像网站还特别开发了hfd.sh工具，相较上述方式可以更加快速、稳定的下载huggingface数据 1 2 3 dataset = load_dataset(\u0026#34;path/to/lhoestq_demo1\u0026#34;) tokenizer = AutoTokenizer.from_pretrained(\u0026#34;path/to/bert-base-uncased\u0026#34;) ！下面学习相关用法时，均先将数据集/模型下载到datasets文件夹后，再加载。\n2. 加载模型 2.1 完整模型 HF目前有收集了大量不同NLP任务的微调后模型，可根据微调任务进行分类。详见：https://huggingface.co/docs/transformers/v4.45.2/en/main_classes/pipelines#transformers.pipeline\n可以在https://huggingface.co/models?pipeline_tag=token-classification\u0026amp;sort=trending 查看每种task下，可以调用的模型\n主要可通过pipeline函数调用，执行特定场景的推理任务\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from transformers import pipeline #示例1 classifier = pipeline(task=\u0026#34;sentiment-analysis\u0026#34;, model=\u0026#34;./datasets/sentiment-analysis\u0026#34;) classifier( [ \u0026#34;I\u0026#39;ve been waiting for a HuggingFace course my whole life.\u0026#34;, \u0026#34;I hate this so much!\u0026#34;, ] ) # [{\u0026#39;label\u0026#39;: \u0026#39;POSITIVE\u0026#39;, \u0026#39;score\u0026#39;: 0.9598047137260437}, # {\u0026#39;label\u0026#39;: \u0026#39;NEGATIVE\u0026#39;, \u0026#39;score\u0026#39;: 0.9994558691978455}] #示例2 pipe = pipeline(task=\u0026#34;token-classification\u0026#34;, model=\u0026#34;datasets/Medical-NER\u0026#34;) result = pipe(\u0026#39;45 year old woman diagnosed with CAD\u0026#39;) 2.2 预训练模型 首先，预训练模型需要接受原始输入的词元化表示（tokenizer） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from transformers import AutoTokenizer tokenizer = AutoTokenizer.from_pretrained(\u0026#34;./datasets/sentiment-analysis\u0026#34;) raw_inputs = [ \u0026#34;I\u0026#39;ve been waiting for a HuggingFace course my whole life.\u0026#34;, \u0026#34;I hate this so much!\u0026#34; ] inputs = tokenizer(raw_inputs, padding=True, truncation=True, return_tensors=\u0026#34;pt\u0026#34;) print(inputs) # {\u0026#39;input_ids\u0026#39;: tensor([[ 101, 1045, 1005, 2310, 2042, 3403, 2005, 1037, 17662, 12172, # 2607, 2026, 2878, 2166, 1012, 102], # [ 101, 1045, 5223, 2023, 2061, 2172, 999, 102, 0, 0, # 0, 0, 0, 0, 0, 0]]), \u0026#39;attention_mask\u0026#39;: tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], # [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0]])} 在对输入序列进行tokenizer词元化处理时，有两个关键参数：\npadding参数进行短序列进行词元补长，此时attention_mask将对于填充词元注意力设置为0； truncation参数限制最大词元长度，此时需要另外通过max_length设置预期最大长度。 1 2 3 4 5 6 7 8 9 # 展示相关计算细节 sequence = \u0026#34;Using a Transformer network is simple\u0026#34; tokenizer.tokenize(sequence) # [\u0026#39;using\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;transform\u0026#39;, \u0026#39;##er\u0026#39;, \u0026#39;network\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;simple\u0026#39;] tokenizer.encode(sequence) # [101, 2478, 1037, 10938, 2121, 2897, 2003, 3722, 102] tokenizer.decode([101, 2478, 1037, 10938, 2121, 2897, 2003, 3722, 102]) # \u0026#39;[CLS] using a transformer network is simple [SEP]\u0026#39; ！model对于输入词元的要求：(1) tensor，(2) list of list。即上面tokenizer()的结果\n加载模型的预训练部分 1 2 3 4 5 6 7 8 9 from transformers import AutoModel model = AutoModel.from_pretrained(\u0026#34;./datasets/sentiment-analysis\u0026#34;) model # 根据预训练模型，学习每个词元的嵌入表示 outputs = model(**inputs) # 将字典解包为关键字参数，即上面的input_ids, attention_mask print(outputs.last_hidden_state.shape) # torch.Size([2, 16, 768]) 2.3 经典模型 HF的Transformers模块提供了大量经典的AI大模型，涉及test/vision/audio等领域。我们可以很方便的加载其架构，以及预训练参数 例如 Bert：https://huggingface.co/docs/transformers/model_doc/bert （Transformer/API/MODELS/TEXT MODELS/BERT） 1 2 3 4 5 6 7 8 9 from transformers import BertConfig, BertModel config = BertConfig() config model = BertModel(config) #或者 from transformers import BertModel model = BertModel.from_pretrained(\u0026#34;./datasets/bert-base-cased\u0026#34;) 3. 模型微调 如下演示一个基于bert的微调示例\n加载模型框架 1 2 3 4 5 6 7 8 9 10 from datasets import load_dataset from transformers import AutoTokenizer, DataCollatorWithPadding from transformers import AutoModelForSequenceClassification checkpoint = \u0026#34;datasets/bert-base-uncased\u0026#34; model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2) import torch device = torch.device(\u0026#34;cuda\u0026#34;) if torch.cuda.is_available() else torch.device(\u0026#34;cpu\u0026#34;) model.to(device) AutoModelForSequenceClassification 表示基于预训练模型进行序列分类的微调任务的训练API。此外也有适用其它微调任务的API，参考：https://huggingface.co/transformers/v3.0.2/model_doc/auto.html#\n微调数据集 （1）加载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 raw_datasets = load_dataset(\u0026#34;./datasets/glue\u0026#34;, \u0026#34;mrpc\u0026#34;) # DatasetDict({ # train: Dataset({ # features: [\u0026#39;sentence1\u0026#39;, \u0026#39;sentence2\u0026#39;, \u0026#39;label\u0026#39;, \u0026#39;idx\u0026#39;, \u0026#39;input_ids\u0026#39;, \u0026#39;token_type_ids\u0026#39;, \u0026#39;attention_mask\u0026#39;], # num_rows: 3668 # }) # validation: Dataset({ # features: [\u0026#39;sentence1\u0026#39;, \u0026#39;sentence2\u0026#39;, \u0026#39;label\u0026#39;, \u0026#39;idx\u0026#39;, \u0026#39;input_ids\u0026#39;, \u0026#39;token_type_ids\u0026#39;, \u0026#39;attention_mask\u0026#39;], # num_rows: 408 # }) # test: Dataset({ # features: [\u0026#39;sentence1\u0026#39;, \u0026#39;sentence2\u0026#39;, \u0026#39;label\u0026#39;, \u0026#39;idx\u0026#39;, \u0026#39;input_ids\u0026#39;, \u0026#39;token_type_ids\u0026#39;, \u0026#39;attention_mask\u0026#39;], # num_rows: 1725 # }) # }) （2）词元化处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tokenizer = AutoTokenizer.from_pretrained(checkpoint) # 利用Datasets库的Apache Arrow储存，高效访问 def tokenize_function(example): return tokenizer(example[\u0026#34;sentence1\u0026#34;], example[\u0026#34;sentence2\u0026#34;], truncation=True) tokenized_datasets = raw_datasets.map(tokenize_function, batched=True) #暂时先不填充 tokenized_datasets[\u0026#34;train\u0026#34;].column_names # [\u0026#39;sentence1\u0026#39;, # \u0026#39;sentence2\u0026#39;, # \u0026#39;label\u0026#39;, # \u0026#39;idx\u0026#39;, # \u0026#39;input_ids\u0026#39;, # \u0026#39;token_type_ids\u0026#39;, # \u0026#39;attention_mask\u0026#39;] data_collator = DataCollatorWithPadding(tokenizer=tokenizer) #小批量动态填充 （3）数据清洗 1 2 3 4 5 6 7 8 # 移除多余列 tokenized_datasets = tokenized_datasets.remove_columns([\u0026#34;sentence1\u0026#34;, \u0026#34;sentence2\u0026#34;, \u0026#34;idx\u0026#34;]) # 列重命名 tokenized_datasets = tokenized_datasets.rename_column(\u0026#34;label\u0026#34;, \u0026#34;labels\u0026#34;) # 转为tensor tokenized_datasets.set_format(\u0026#34;torch\u0026#34;) tokenized_datasets[\u0026#34;train\u0026#34;].column_names # [\u0026#39;labels\u0026#39;, \u0026#39;input_ids\u0026#39;, \u0026#39;token_type_ids\u0026#39;, \u0026#39;attention_mask\u0026#39;] （4）小批量迭代器：每次迭代一个字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from torch.utils.data import DataLoader train_dataloader = DataLoader( tokenized_datasets[\u0026#34;train\u0026#34;], shuffle=True, batch_size=8, collate_fn=data_collator ) eval_dataloader = DataLoader( tokenized_datasets[\u0026#34;validation\u0026#34;], batch_size=8, collate_fn=data_collator ) for batch in train_dataloader: break {k: v.shape for k, v in batch.items()} # {\u0026#39;labels\u0026#39;: torch.Size([8]), # \u0026#39;input_ids\u0026#39;: torch.Size([8, 81]), # \u0026#39;token_type_ids\u0026#39;: torch.Size([8, 81]), # \u0026#39;attention_mask\u0026#39;: torch.Size([8, 81])} 训练参数 （1）优化器 1 2 3 from transformers import AdamW # an optimizer optimizer = AdamW(model.parameters(), lr=5e-5) （2）学习率调度器 1 2 3 4 5 6 7 8 9 10 11 from transformers import get_scheduler num_epochs = 3 num_training_steps = num_epochs * len(train_dataloader) lr_scheduler = get_scheduler( \u0026#34;linear\u0026#34;, # 线性调度 optimizer=optimizer, num_warmup_steps=0, # 指定预热步数为 0，即不使用学习率预热。 num_training_steps=num_training_steps, ) # 如上表示，学习率从初始值线性下降到 0 开始训练 train step 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from tqdm.auto import tqdm progress_bar = tqdm(range(num_training_steps)) model.train() for epoch in range(num_epochs): for batch in train_dataloader: batch = {k: v.to(device) for k, v in batch.items()} outputs = model(**batch) loss = outputs.loss loss.backward() optimizer.step() lr_scheduler.step() optimizer.zero_grad() progress_bar.update(1) # 1376/1377 [01:12\u0026lt;00:00, 17.79it/s] evaluation step 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import evaluate # https://github.com/huggingface/evaluate/issues/472 metric = evaluate.load(\u0026#34;./evaluate/metrics/glue/glue.py\u0026#34;,\u0026#34;mrpc\u0026#34;) model.eval() for batch in eval_dataloader: batch = {k: v.to(device) for k, v in batch.items()} with torch.no_grad(): outputs = model(**batch) logits = outputs.logits predictions = torch.argmax(logits, dim=-1) metric.add_batch(predictions=predictions, references=batch[\u0026#34;labels\u0026#34;]) metric.compute() # {\u0026#39;accuracy\u0026#39;: 0.8480392156862745, \u0026#39;f1\u0026#39;: 0.8934707903780069} 此外，TF也提供了accelerate库用于方便的执行分布式训练。但在实操过程中，遇到了如下问题 NotImplementedError: Using RTX 4000 series doesn’t support faster communication broadband via P2P or IB. Please set NCCL_P2P_DISABLE=“1” and NCCL_IB_DISABLE=“1” or use accelerate launch which will do this automatically. 可通过如下方式避免报错\n1 2 3 import os os.environ[\u0026#34;NCCL_IB_DISABLE\u0026#34;] = \u0026#34;1\u0026#34; os.environ[\u0026#34;NCCL_P2P_DISABLE\u0026#34;] = \u0026#34;1\u0026#34; https://huggingface.co/learn/nlp-course/chapter3/3?fw=pt\nhttps://huggingface.co/learn/nlp-course/chapter3/4?fw=pt\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/717hugging-face1-nlp-basic/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20241015193100700.png\" alt=\"image-20241015193100700\"  /\u003e\r\n\u003c/p\u003e\n\u003cp\u003eHugging Face是一家专注于自然语言处理（NLP）和人工智能（AI）的公司，可以认为是AI领域的Github。(下面简称HF)\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e一方面整理、收集了NLP等AI任务常用的\u003cstrong\u003e数据集\u003c/strong\u003e，预训练\u003cstrong\u003e模型\u003c/strong\u003e；\u003c/li\u003e\n\u003cli\u003e另一方面提供系列\u003cstrong\u003e工具库\u003c/strong\u003e，用以高效地训练AI模型。具体包括如下几个核心库。\n\u003cul\u003e\n\u003cli\u003eTransformers\u003c/li\u003e\n\u003cli\u003eDatasets\u003c/li\u003e\n\u003cli\u003eTokenizers\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1-获取模型数据集\"\u003e1. 获取模型/数据集\u003c/h1\u003e\n\u003cp\u003eHF提供了大量的公开AI数据集以及预训练数据集，同时也提供了下载的方式\u003c/p\u003e","title":"Hugging Face(1)-NLP basic"},{"content":"https://huggingface.co/docs/tokenizers/quicktour\ntokenizer库的处理流程一般包括如下四步——\nNormalizers: 文本句预处理，使规范化 Pre-tokenizers: 将句子初步拆分为单元词 Model：得到最终的分词token结果，及其对应id编号 Post-Processors: 添加特殊词元标记 1. 训练分词器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 from tokenizers import Tokenizer # (1) 选择一种分词模型，并创建实例 from tokenizers.models import BPE tokenizer = Tokenizer(BPE(unk_token=\u0026#34;[UNK]\u0026#34;)) from tokenizers.trainers import BpeTrainer trainer = BpeTrainer(special_tokens=[\u0026#34;[UNK]\u0026#34;, \u0026#34;[CLS]\u0026#34;, \u0026#34;[SEP]\u0026#34;, \u0026#34;[PAD]\u0026#34;, \u0026#34;[MASK]\u0026#34;]) # (2) 设置预分词器，这里按空白字符分割文本 from tokenizers.pre_tokenizers import Whitespace tokenizer.pre_tokenizer = Whitespace() # (3) 基于语料库，进行分词训练 copus_file = [\u0026#34;datasets/wikitext-103-raw-v1/wiki_train.csv\u0026#34;] tokenizer.train(copus_file, trainer) # (4) 保存并加载 tokenizer.save(\u0026#34;datasets/wikitext-103-raw-v1/tokenizer-wiki.json\u0026#34;) tokenizer = Tokenizer.from_file(\u0026#34;datasets/wikitext-103-raw-v1/tokenizer-wiki.json\u0026#34;) type(tokenizer) # tokenizers.Tokenizer # 与直接从预训练模型中提取的分词器类型不太一样 from transformers import AutoTokenizer tokenizer2 = AutoTokenizer.from_pretrained(\u0026#34;datasets/bert-base-uncased\u0026#34;) type(tokenizer2) # transformers.models.bert.tokenization_bert_fast.BertTokenizerFast tokenizers库提供了4种常见的子词分词方法。BPE通过迭代地合并最频繁的字符或子词对来构建词汇表，常用于GPT 和 RoBERTa 等模型；WordLevel基于完整词的分词方法，使用一个固定的词汇表，未登录词通常被标记为 [UNK]。此外还有Unigram以及WordPiece。\n2. 应用分词器 2.1 单文本句输入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ## 单个词 print(tokenizer.token_to_id(\u0026#34;[SEP]\u0026#34;)) # 2 print(tokenizer.id_to_token(1)) # [CLS] ## 一个文本句输入 output = tokenizer.encode(\u0026#34;Hello, y\u0026#39;all! How are you 😁 ?\u0026#34;) print(output.tokens) print(output.ids) print(output.attention_mask) # [\u0026#39;Hello\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;y\u0026#39;, \u0026#34;\u0026#39;\u0026#34;, \u0026#39;all\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;How\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;you\u0026#39;, \u0026#39;[UNK]\u0026#39;, \u0026#39;?\u0026#39;] # [27195, 16, 93, 11, 5069, 5, 7929, 5084, 6191, 0, 35] # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] ## 一个输入包含两个句子 output = tokenizer.encode(\u0026#34;Hello, y\u0026#39;all!\u0026#34;, \u0026#34;How are you 😁 ?\u0026#34;) print(output.tokens) # [\u0026#39;Hello\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;y\u0026#39;, \u0026#34;\u0026#39;\u0026#34;, \u0026#39;all\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;How\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;you\u0026#39;, \u0026#39;[UNK]\u0026#39;, \u0026#39;?\u0026#39;] 2.2 Post-process 对输出词元进一步处理，主要涉及相关特殊字符。例如在句首添加\u0026lt;cls\u0026gt;， 使用填充字符\u0026lt;pad\u0026gt;补长等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from tokenizers.processors import TemplateProcessing tokenizer.post_processor = TemplateProcessing( # 单文本句处理 single=\u0026#34;[CLS] $A [SEP]\u0026#34;, # 一对文本句的处理 pair=\u0026#34;[CLS] $A [SEP] $B:1 [SEP]:1\u0026#34;, special_tokens=[ (\u0026#34;[CLS]\u0026#34;, tokenizer.token_to_id(\u0026#34;[CLS]\u0026#34;)), (\u0026#34;[SEP]\u0026#34;, tokenizer.token_to_id(\u0026#34;[SEP]\u0026#34;)), ], ) output = tokenizer.encode(\u0026#34;Hello, y\u0026#39;all! How are you 😁 ?\u0026#34;) print(output.tokens) # [\u0026#39;[CLS]\u0026#39;, \u0026#39;Hello\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;y\u0026#39;, \u0026#34;\u0026#39;\u0026#34;, \u0026#39;all\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;How\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;you\u0026#39;, \u0026#39;[UNK]\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;[SEP]\u0026#39;] print(output.type_ids) # [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1] 2.3 批处理 list of sensence为输入 1 2 3 4 5 6 7 ## 批处理 output = tokenizer.encode_batch([\u0026#34;Hello, y\u0026#39;all!\u0026#34;, \u0026#34;How are you 😁 ?\u0026#34;]) # 返回list格式 output[0].tokens # [\u0026#39;[CLS]\u0026#39;, \u0026#39;Hello\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;y\u0026#39;, \u0026#34;\u0026#39;\u0026#34;, \u0026#39;all\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;[SEP]\u0026#39;] output[1].tokens # [\u0026#39;[CLS]\u0026#39;, \u0026#39;How\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;you\u0026#39;, \u0026#39;[UNK]\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;[SEP]\u0026#39;] 对批量中较短的序列进行填充 1 2 3 4 5 6 7 tokenizer.enable_padding(pad_id=3, pad_token=\u0026#34;[PAD]\u0026#34;) output = tokenizer.encode_batch([\u0026#34;Hello, y\u0026#39;all!\u0026#34;, \u0026#34;How are you 😁 ?\u0026#34;]) print(output[1].tokens) # [\u0026#39;[CLS]\u0026#39;, \u0026#39;How\u0026#39;, \u0026#39;are\u0026#39;, \u0026#39;you\u0026#39;, \u0026#39;[UNK]\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;[SEP]\u0026#39;, \u0026#39;[PAD]\u0026#39;] print(output[1].attention_mask) # [1, 1, 1, 1, 1, 1, 1, 0] tokenizer.enable_truncation(max_length = )可以设置允许的最大长度\n2.4 PreTrainedTokenizerFast 更高效的分词批处理方式，返回一个字典格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from transformers import PreTrainedTokenizerFast tokenizer3 = PreTrainedTokenizerFast(tokenizer_file=\u0026#34;datasets/wikitext-103-raw-v1/tokenizer-wiki.json\u0026#34;) type(tokenizer3) # transformers.tokenization_utils_fast.PreTrainedTokenizerFast tokenizer3.convert_ids_to_tokens(3) tokenizer3.cls_token = \u0026#39;[CLS]\u0026#39; tokenizer3.pad_token = \u0026#39;[PAD]\u0026#39; tokenizer3.sep_token = \u0026#39;[SEP]\u0026#39; tokenizer3.sep_token_id tokenizer3( [\u0026#34;Hello, y\u0026#39;all!\u0026#34;, \u0026#34;How are you 😁 ?\u0026#34;], padding=True, truncation=True, max_length=10, return_tensors=\u0026#39;pt\u0026#39; ) # {\u0026#39;input_ids\u0026#39;: tensor([[27195, 16, 93, 11, 5069, 5], # [ 7929, 5084, 6191, 0, 35, 3]]), \u0026#39;token_type_ids\u0026#39;: tensor([[0, 0, 0, 0, 0, 0], # [0, 0, 0, 0, 0, 0]]), \u0026#39;attention_mask\u0026#39;: tensor([[1, 1, 1, 1, 1, 1], # [1, 1, 1, 1, 1, 0]])} 好像没能在句首和句末添加特殊的cls，sep标记。\n3. 基因词元为例 在处理组学数据时，词元通常为基因名。由于不是文本句，可以认为是Pre-tokenized的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 from tokenizers import Tokenizer from tokenizers.models import WordLevel from tokenizers.trainers import WordLevelTrainer from tokenizers.pre_tokenizers import Whitespace # gene list len(gene_names) #60694 gene_names[:5] # [\u0026#39;bP-2171C21.3\u0026#39;, \u0026#39;bP-21264C1.2\u0026#39;, \u0026#39;ZZZ3\u0026#39;, \u0026#39;ZZEF1\u0026#39;, \u0026#39;ZYG11B\u0026#39;] # 初始化 WordLevel Tokenizer tokenizer = Tokenizer(WordLevel()) # 使用空格预分词（其实应该用不到） tokenizer.pre_tokenizer = Whitespace() trainer = WordLevelTrainer(vocab_size=len(gene_names), special_tokens=[\u0026#34;[UNK]\u0026#34;, \u0026#34;[CLS]\u0026#34;, \u0026#34;[SEP]\u0026#34;, \u0026#34;[PAD]\u0026#34;, \u0026#34;[MASK]\u0026#34;]) tokenizer.train_from_iterator(gene_names, trainer=trainer) output = tokenizer.encode(\u0026#34;BRCA1 TP53 EGFR\u0026#34;) print(output.tokens) print(output.ids) # [\u0026#39;BRCA1\u0026#39;, \u0026#39;TP53\u0026#39;, \u0026#39;EGFR\u0026#39;] # [17239, 46049, 5419] output2 = tokenizer.encode([\u0026#39;APOE\u0026#39;,\u0026#34;PTEN\u0026#34;], is_pretokenized=True) print(output2.tokens) print(output2.ids) # [\u0026#39;APOE\u0026#39;, \u0026#39;PTEN\u0026#39;] # [16207, 37733] out = tokenizer.encode_batch([[\u0026#34;BRCA1 TP53 EGFR\u0026#34;],[\u0026#39;APOE\u0026#39;,\u0026#34;PTEN\u0026#34;]], is_pretokenized=True) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/718hugging-face3-tokenizers%E5%BA%93/","summary":"\u003cp\u003e\u003ca href=\"https://huggingface.co/docs/tokenizers/quicktour\"\u003ehttps://huggingface.co/docs/tokenizers/quicktour\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003etokenizer库\u003c/strong\u003e的处理流程一般包括如下四步——\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/docs/tokenizers/components#normalizers\"\u003eNormalizers\u003c/a\u003e: 文本句预处理，使规范化\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/docs/tokenizers/components#pretokenizers\"\u003ePre-tokenizers\u003c/a\u003e: 将句子初步拆分为单元词\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/docs/tokenizers/components#models\"\u003eModel\u003c/a\u003e：得到最终的分词token结果，及其对应id编号\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/docs/tokenizers/components#postprocessors\"\u003ePost-Processors\u003c/a\u003e: 添加特殊词元标记\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1-训练分词器\"\u003e1. 训练分词器\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e tokenizers \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e Tokenizer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) 选择一种分词模型，并创建实例\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e tokenizers.models \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e BPE\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etokenizer = Tokenizer(BPE(unk_token=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;[UNK]\u0026#34;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e tokenizers.trainers \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e BpeTrainer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etrainer = BpeTrainer(special_tokens=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;[UNK]\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;[CLS]\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;[SEP]\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;[PAD]\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;[MASK]\u0026#34;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (2) 设置预分词器，这里按空白字符分割文本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e tokenizers.pre_tokenizers \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e Whitespace\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etokenizer.pre_tokenizer = Whitespace()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (3) 基于语料库，进行分词训练\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecopus_file = [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;datasets/wikitext-103-raw-v1/wiki_train.csv\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etokenizer.train(copus_file, trainer)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (4) 保存并加载\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etokenizer.save(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;datasets/wikitext-103-raw-v1/tokenizer-wiki.json\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etokenizer = Tokenizer.from_file(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;datasets/wikitext-103-raw-v1/tokenizer-wiki.json\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e(tokenizer)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# tokenizers.Tokenizer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 与直接从预训练模型中提取的分词器类型不太一样\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e transformers \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e AutoTokenizer\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etokenizer2 = AutoTokenizer.from_pretrained(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;datasets/bert-base-uncased\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e(tokenizer2)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# transformers.models.bert.tokenization_bert_fast.BertTokenizerFast\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003etokenizers库提供了4种常见的子词分词方法。\u003cstrong\u003eBPE\u003c/strong\u003e通过迭代地合并最频繁的字符或子词对来构建词汇表，常用于GPT 和 RoBERTa 等模型；\u003cstrong\u003eWordLevel\u003c/strong\u003e基于完整词的分词方法，使用一个固定的词汇表，未登录词通常被标记为 \u003ccode\u003e[UNK]\u003c/code\u003e。此外还有Unigram以及WordPiece。\u003c/p\u003e","title":"Hugging Face(3)-Tokenizer库"},{"content":"https://huggingface.co/docs/datasets/index\nA Dataset provides fast random access to the rows, and memory-mapping so that loading even large datasets only uses a relatively small amount of device memory.\nBut for really, really big datasets ( \u0026gt; 100G) that won’t even fit on disk or in memory, an IterableDataset allows you to access and use the dataset without waiting for it to download completely!\nhttps://huggingface.co/learn/nlp-course/chapter5/4?fw=pt#streaming-datasets https://huggingface.co/docs/datasets/about_mapstyle_vs_iterable 1. 读取 1.1 以Json文件读取为例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ## 预先下载解压到本地的datasets文件夹 # wget https://github.com/crux82/squad-it/raw/master/SQuAD_it-train.json.gz # wget https://github.com/crux82/squad-it/raw/master/SQuAD_it-test.json.gz # gzip -dkv SQuAD_it-*.json.gz from datasets import load_dataset squad_it_dataset = load_dataset(\u0026#34;json\u0026#34;, data_files=\u0026#34;./datasets/SQuAD_it-train.json\u0026#34;, field=\u0026#34;data\u0026#34;) # field参数为JSON文件特有，用于指定 JSON 文件中包含实际数据的字段名 squad_it_dataset # 默认读取为train split squad_it_dataset.keys() # dict_keys([\u0026#39;train\u0026#39;]) squad_it_dataset # DatasetDict({ # train: Dataset({ # features: [\u0026#39;title\u0026#39;, \u0026#39;paragraphs\u0026#39;], # num_rows: 442 # }) # }) 1.2 JSON的其它形式读取 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # (1) 同时读取两个split data_files = {\u0026#34;train\u0026#34;: \u0026#34;SQuAD_it-train.json\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;SQuAD_it-test.json\u0026#34;} squad_it_dataset = load_dataset(\u0026#34;json\u0026#34;, data_files=data_files, field=\u0026#34;data\u0026#34;) # (2) 读取gz压缩格式 data_files = {\u0026#34;train\u0026#34;: \u0026#34;SQuAD_it-train.json.gz\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;SQuAD_it-test.json.gz\u0026#34;} squad_it_dataset = load_dataset(\u0026#34;json\u0026#34;, data_files=data_files, field=\u0026#34;data\u0026#34;) # (3) 远程读取 url = \u0026#34;https://github.com/crux82/squad-it/raw/master/\u0026#34; data_files = { \u0026#34;train\u0026#34;: url + \u0026#34;SQuAD_it-train.json.gz\u0026#34;, \u0026#34;test\u0026#34;: url + \u0026#34;SQuAD_it-test.json.gz\u0026#34;, } squad_it_dataset = load_dataset(\u0026#34;json\u0026#34;, data_files=data_files, field=\u0026#34;data\u0026#34;) data_files可以为每个split指定多个文件，https://huggingface.co/docs/datasets/loading\n1.3 表格基本操作 1 2 3 4 5 6 7 8 squad_it_dataset[\u0026#34;train\u0026#34;].column_names #查看列名 squad_it_dataset.features squad_it_dataset[\u0026#34;train\u0026#34;].features #查看每列的详细信息 squad_it_dataset[\u0026#34;train\u0026#34;][0] #第一行 squad_it_dataset[\u0026#34;train\u0026#34;][\u0026#34;title\u0026#34;]\t#title列 此外还支持，CSV/Parquet/Arrow/SQL等文件格式\nCVS泛指表格类文件，可以设置分隔符，例如tsv Parquet: Large datasets may be stored in a Parquet file because it is more efficient and faster at returning your query. Arrow: Datasets库使用的方式 也支持字典Dict，Pandas表格，Generator等\n1 2 3 4 5 6 7 8 9 10 11 12 from datasets import Dataset ## 字典 my_dict = {\u0026#34;a\u0026#34;: [1, 2, 3]} Dataset.from_dict(my_dict) # 等价于 my_list = [{\u0026#34;a\u0026#34;: 1}, {\u0026#34;a\u0026#34;: 2}, {\u0026#34;a\u0026#34;: 3}] dataset = Dataset.from_list(my_list) ## Pandas import pandas as pd df = pd.DataFrame({\u0026#34;a\u0026#34;: [1, 2, 3]}) dataset = Dataset.from_pandas(df) 2. 处理 以一个CSV文件为例\n1 2 3 4 5 6 7 8 ## 预先下载解压到本地的datasets文件夹 # wget \u0026#34;https://archive.ics.uci.edu/ml/machine-learning-databases/00462/drugsCom_raw.zip\u0026#34; # unzip drugsCom_raw.zip from datasets import load_dataset data_files = {\u0026#34;train\u0026#34;: \u0026#34;datasets/drugsComTrain_raw.tsv\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;datasets/drugsComTest_raw.tsv\u0026#34;} drug_dataset = load_dataset(\u0026#34;csv\u0026#34;, data_files=data_files, delimiter=\u0026#34;\\t\u0026#34;) 2.1 行操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ## 基本查看 drug_dataset[\u0026#34;train\u0026#34;][:3] drug_dataset[\u0026#34;train\u0026#34;].select(range(1000)) # by index ## 乱序 drug_dataset[\u0026#34;train\u0026#34;].shuffle(seed=42) ## 过滤行 drug_dataset.filter(lambda x: x[\u0026#34;condition\u0026#34;] is not None) drug_dataset.filter(lambda x: x[\u0026#34;review_length\u0026#34;] \u0026gt; 30) drug_dataset.filter(lambda x: x[\u0026#34;sentence1\u0026#34;].startswith(\u0026#34;Ar\u0026#34;)) dataset.filter(lambda example, idx: idx % 2 == 0, with_indices=True) ## 排序 drug_dataset[\u0026#34;train\u0026#34;].sort(\u0026#34;review_length\u0026#34;)[:3] 2.2 列操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 drug_dataset[\u0026#39;train\u0026#39;] for col1, col2 in zip(drug_dataset[\u0026#39;train\u0026#39;][\u0026#39;drugName\u0026#39;][:5], drug_dataset[\u0026#39;train\u0026#39;][\u0026#39;rating\u0026#39;][:5]): print(f\u0026#34;drugName: {col1}, rating: {col2}\u0026#34;) ## 删除列 drug_dataset.remove_columns([\u0026#34;drugName\u0026#34;, \u0026#34;rating\u0026#34;]) ## 选择列 drug_dataset.select_columns([\u0026#39;sentence1\u0026#39;, \u0026#39;sentence2\u0026#39;, \u0026#39;idx\u0026#39;]) ## 修改列名 drug_dataset.rename_column( original_column_name=\u0026#34;Unnamed: 0\u0026#34;, new_column_name=\u0026#34;patient_id\u0026#34; ) #### add_column方法新增/修改列 data = { \u0026#34;text\u0026#34;: [\u0026#34;Hello world\u0026#34;, \u0026#34;Huggingface is great\u0026#34;, \u0026#34;Datasets are awesome\u0026#34;], \u0026#34;label\u0026#34;: [0, 1, 1] } dataset = Dataset.from_dict(data) ## 新增列 dataset = dataset.add_column(\u0026#34;length\u0026#34;, [len(text) for text in dataset[\u0026#34;text\u0026#34;]]) # or new_column = np.array([5, 3, 7]) dataset = dataset.add_column(\u0026#34;new_column\u0026#34;, new_column) ## 修改列 dataset = dataset.add_column(\u0026#34;label\u0026#34;, [label + 1 for label in dataset[\u0026#34;label\u0026#34;]]) #### map方法新增/修改列 ## 修改列内容(.map) def lowercase_condition(example): return {\u0026#34;condition\u0026#34;: example[\u0026#34;condition\u0026#34;].lower()} drug_dataset.map(lowercase_condition) ## 新增列 def compute_review_length(example): return {\u0026#34;review_length\u0026#34;: len(example[\u0026#34;review\u0026#34;].split())} drug_dataset = drug_dataset.map(compute_review_length) ### 默认情况下，map() 对每个样本单独调用该函数。如果设置 batched=True，则函数会接收一批样本作为输入，这样可以进行批量加速处理。\n1 2 3 4 5 6 7 8 9 from transformers import AutoTokenizer tokenizer = AutoTokenizer.from_pretrained(\u0026#34;./datasets/bert-base-cased\u0026#34;) def tokenize_function(examples): return tokenizer(examples[\u0026#34;review\u0026#34;], truncation=True) tokenized_dataset = drug_dataset.map(tokenize_function, batched=True) # 默认batch_size为1000 2.3 设置输出格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # only changes the *output format* of the dataset drug_dataset.set_format(\u0026#34;pandas\u0026#34;) drug_dataset[\u0026#34;train\u0026#34;][:3] # 此时，可以转换为pandas.DataFrame，执行相关操作 train_df = drug_dataset[\u0026#34;train\u0026#34;][:] frequencies = ( train_df[\u0026#34;condition\u0026#34;] .value_counts() .to_frame() .reset_index() .rename(columns={\u0026#34;index\u0026#34;: \u0026#34;condition\u0026#34;, \u0026#34;condition\u0026#34;: \u0026#34;frequency\u0026#34;}) ) frequencies.head() # from datasets import Dataset # freq_dataset = Dataset.from_pandas(frequencies) # reset from \u0026#39;pandas\u0026#39; to \u0026#39;arrow\u0026#39; drug_dataset.reset_format() # 设置为torch tensor drug_dataset.set_format(\u0026#34;torch\u0026#34;) drug_dataset[\u0026#34;train\u0026#34;][:1] 2.4 Split拆分 1 2 3 4 5 6 7 8 9 10 11 drug_dataset_clean = drug_dataset[\u0026#34;train\u0026#34;].train_test_split(train_size=0.8, seed=42) drug_dataset_clean.keys() # dict_keys([\u0026#39;train\u0026#39;, \u0026#39;test\u0026#39;]) drug_dataset_clean[\u0026#34;validation\u0026#34;] = drug_dataset_clean.pop(\u0026#34;test\u0026#34;) drug_dataset_clean.keys() # dict_keys([\u0026#39;train\u0026#39;, \u0026#39;validation\u0026#39;]) drug_dataset_clean[\u0026#34;test\u0026#34;] = drug_dataset[\u0026#34;test\u0026#34;] drug_dataset_clean.keys() # dict_keys([\u0026#39;train\u0026#39;, \u0026#39;validation\u0026#39;, \u0026#39;test\u0026#39;]) 3. 保存 3.1 保存为arrow格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 drug_dataset_clean.save_to_disk(\u0026#34;datasets/demo-drug-reviews\u0026#34;) # demo-drug-reviews/ # ├── dataset_dict.json # ├── test # │ ├── dataset.arrow # │ ├── dataset_info.json # │ └── state.json # ├── train # │ ├── dataset.arrow # │ ├── dataset_info.json # │ ├── indices.arrow # │ └── state.json # └── validation # ├── dataset.arrow # ├── dataset_info.json # ├── indices.arrow # └── state.json # 加载 from datasets import load_from_disk drug_dataset_reloaded = load_from_disk(\u0026#34;datasets/demo-drug-reviews\u0026#34;) drug_dataset_reloaded 3.2 其它格式 对于json等其它格式(csv, parquet, sql)，需要分别保存每个split 1 2 3 4 5 6 7 8 9 10 11 # 保存 for split, dataset in drug_dataset_clean.items(): dataset.to_json(f\u0026#34;drug-reviews-{split}.jsonl\u0026#34;) # 加载 data_files = { \u0026#34;train\u0026#34;: \u0026#34;drug-reviews-train.jsonl\u0026#34;, \u0026#34;validation\u0026#34;: \u0026#34;drug-reviews-validation.jsonl\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;drug-reviews-test.jsonl\u0026#34;, } drug_dataset_reloaded = load_dataset(\u0026#34;json\u0026#34;, data_files=data_files) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/719hugging-face2-datasets%E5%BA%93/","summary":"\u003cp\u003e\u003ca href=\"https://huggingface.co/docs/datasets/index\"\u003ehttps://huggingface.co/docs/datasets/index\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eA \u003ca href=\"https://huggingface.co/docs/datasets/v3.0.1/en/package_reference/main_classes#datasets.Dataset\"\u003eDataset\u003c/a\u003e provides fast random access to the rows, and memory-mapping so that loading even large datasets only uses a relatively small amount of device memory.\u003c/p\u003e\n\u003cp\u003eBut for really, really big datasets ( \u0026gt; 100G) that won’t even fit on disk or in memory, an \u003ca href=\"https://huggingface.co/docs/datasets/v3.0.1/en/package_reference/main_classes#datasets.IterableDataset\"\u003eIterableDataset\u003c/a\u003e allows you to access and use the dataset without waiting for it to download completely!\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/learn/nlp-course/chapter5/4?fw=pt#streaming-datasets\"\u003ehttps://huggingface.co/learn/nlp-course/chapter5/4?fw=pt#streaming-datasets\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://huggingface.co/docs/datasets/about_mapstyle_vs_iterable\"\u003ehttps://huggingface.co/docs/datasets/about_mapstyle_vs_iterable\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1-读取\"\u003e1. 读取\u003c/h1\u003e\n\u003ch2 id=\"11-以json文件读取为例\"\u003e1.1 以Json文件读取为例\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e## 预先下载解压到本地的datasets文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# wget https://github.com/crux82/squad-it/raw/master/SQuAD_it-train.json.gz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# wget https://github.com/crux82/squad-it/raw/master/SQuAD_it-test.json.gz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# gzip -dkv SQuAD_it-*.json.gz\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e datasets \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e load_dataset\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset = load_dataset(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;json\u0026#34;\u003c/span\u003e, data_files=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;./datasets/SQuAD_it-train.json\u0026#34;\u003c/span\u003e, field=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# field参数为JSON文件特有，用于指定 JSON 文件中包含实际数据的字段名\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset \u003cspan style=\"color:#007f7f\"\u003e# 默认读取为train split\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset.keys()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# dict_keys([\u0026#39;train\u0026#39;])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# DatasetDict({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     train: Dataset({\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         features: [\u0026#39;title\u0026#39;, \u0026#39;paragraphs\u0026#39;],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         num_rows: 442\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#     })\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# })\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"12-json的其它形式读取\"\u003e1.2 JSON的其它形式读取\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (1) 同时读取两个split\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata_files = {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SQuAD_it-train.json\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SQuAD_it-test.json\u0026#34;\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset = load_dataset(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;json\u0026#34;\u003c/span\u003e, data_files=data_files, field=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (2) 读取gz压缩格式\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata_files = {\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SQuAD_it-train.json.gz\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SQuAD_it-test.json.gz\u0026#34;\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset = load_dataset(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;json\u0026#34;\u003c/span\u003e, data_files=data_files, field=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# (3) 远程读取\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eurl = \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;https://github.com/crux82/squad-it/raw/master/\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata_files = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;train\u0026#34;\u003c/span\u003e: url + \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SQuAD_it-train.json.gz\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;test\u0026#34;\u003c/span\u003e: url + \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;SQuAD_it-test.json.gz\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esquad_it_dataset = load_dataset(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;json\u0026#34;\u003c/span\u003e, data_files=data_files, field=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;data\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003edata_files可以为每个split指定多个文件，https://huggingface.co/docs/datasets/loading\u003c/p\u003e","title":"Hugging Face(2)-Datasets库"},{"content":"torchtext.vocab 1 from torchtext.vocab import vocab 1. 定义词汇表 基于词元的频率统计表，OrderedDict 对象 1 2 3 4 vocab(ordered_dict = , #一个 OrderedDict 对象，包含词汇和它们的频率。 min_freq = 1, #指定词汇表中词出现的最小频率。 specials = None, #一个列表，包含特殊标记（如 \u0026lt;unk\u0026gt;, \u0026lt;pad\u0026gt;, \u0026lt;bos\u0026gt;, \u0026lt;eos\u0026gt; 等）。 special_first = True) #一个布尔值，决定特殊标记是否在词汇表的开头。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from collections import Counter, OrderedDict counter = Counter([\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;b\u0026#34;]) counter # Counter({\u0026#39;b\u0026#39;: 3, \u0026#39;a\u0026#39;: 2}) sorted_by_freq_tuples = sorted(counter.items(), key=lambda x: x[1], reverse=True) sorted_by_freq_tuples # [(\u0026#39;b\u0026#39;, 3), (\u0026#39;a\u0026#39;, 2)] ordered_dict = OrderedDict(sorted_by_freq_tuples) # OrderedDict([(\u0026#39;b\u0026#39;, 3), (\u0026#39;a\u0026#39;, 2)]) v1 = vocab(ordered_dict) # Vocab() 直接基于可迭代对象 1 2 3 4 5 6 7 build_vocab_from_iterator( iterator = , # Iterator used to build Vocab. Must yield list or iterator of tokens. min_freq = , specials = , special_first = , max_tokens =None #最多引入多少个词元 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from torchtext.vocab import build_vocab_from_iterator # 定义一个简单的迭代器 # yield关键字，用于定义生成器函数。惰性取值：按需生成值，而不是一次性生成所有值，适合处理大数据集。 def yield_tokens(data_iter): for text in data_iter: yield text.split() # 示例数据 data = [\u0026#34;this is a sentence\u0026#34;, \u0026#34;this is another sentence\u0026#34;] # 构建词汇表 v2 = build_vocab_from_iterator(yield_tokens(data), min_freq=1, specials=[\u0026#39;\u0026lt;unk\u0026gt;\u0026#39;, \u0026#39;\u0026lt;pad\u0026gt;\u0026#39;], special_first=True) ### 直接使用token list作为输入 token_lists = [ [\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;sentence\u0026#34;], [\u0026#34;this\u0026#34;, \u0026#34;is\u0026#34;, \u0026#34;another\u0026#34;, \u0026#34;sentence\u0026#34;] ] # 构建词汇表 v3 = build_vocab_from_iterator(token_lists) 2. 查询词汇表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 1. 查看词元的索引 v1[\u0026#39;a\u0026#39;], v1[\u0026#39;b\u0026#39;] # 2. 设置当查询不在词汇表的新词元时，返回的索引 v2.set_default_index(v2[unk_token]) v2[\u0026#39;sss\u0026#39;] # 3. 查询索引对应的词元 v2.get_itos()[:3] # v2[\u0026#39;out of vocab\u0026#39;] is v2[unk_token] v2.get_stoi() # {\u0026#39;a\u0026#39;: 5, # \u0026#39;this\u0026#39;: 4, # \u0026#39;another\u0026#39;: 6, # \u0026#39;sentence\u0026#39;: 3, # \u0026#39;is\u0026#39;: 2, # \u0026#39;\u0026lt;pad\u0026gt;\u0026#39;: 1, # \u0026#39;\u0026lt;unk\u0026gt;\u0026#39;: 0} ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/720torchtext%E6%9E%84%E5%BB%BAvocab%E8%AF%8D%E8%A1%A8/","summary":"\u003ch2 id=\"torchtextvocab\"\u003etorchtext.vocab\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torchtext.vocab \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e vocab\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"1-定义词汇表\"\u003e1. 定义词汇表\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e基于词元的频率统计表，\u003ccode\u003eOrderedDict\u003c/code\u003e 对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003evocab(ordered_dict = ,       \u003cspan style=\"color:#007f7f\"\u003e#一个 OrderedDict 对象，包含词汇和它们的频率。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      min_freq = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e,          \u003cspan style=\"color:#007f7f\"\u003e#指定词汇表中词出现的最小频率。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      specials = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e,       \u003cspan style=\"color:#007f7f\"\u003e#一个列表，包含特殊标记（如 \u0026lt;unk\u0026gt;, \u0026lt;pad\u0026gt;, \u0026lt;bos\u0026gt;, \u0026lt;eos\u0026gt; 等）。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      special_first = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e#一个布尔值，决定特殊标记是否在词汇表的开头。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e collections \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e Counter, OrderedDict\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecounter = Counter([\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;b\u0026#34;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecounter\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Counter({\u0026#39;b\u0026#39;: 3, \u0026#39;a\u0026#39;: 2})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esorted_by_freq_tuples = \u003cspan style=\"color:#fff;font-weight:bold\"\u003esorted\u003c/span\u003e(counter.items(), key=\u003cspan style=\"color:#fff;font-weight:bold\"\u003elambda\u003c/span\u003e x: x[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e], reverse=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esorted_by_freq_tuples\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# [(\u0026#39;b\u0026#39;, 3), (\u0026#39;a\u0026#39;, 2)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eordered_dict = OrderedDict(sorted_by_freq_tuples)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# OrderedDict([(\u0026#39;b\u0026#39;, 3), (\u0026#39;a\u0026#39;, 2)])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev1 = vocab(ordered_dict)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Vocab()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e直接基于可迭代对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebuild_vocab_from_iterator(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    iterator = , \u003cspan style=\"color:#007f7f\"\u003e# Iterator used to build Vocab. Must yield list or iterator of tokens.\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    min_freq = ,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    specials = ,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    special_first = ,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tmax_tokens =\u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e  \u003cspan style=\"color:#007f7f\"\u003e#最多引入多少个词元\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efrom\u003c/span\u003e torchtext.vocab \u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e build_vocab_from_iterator\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 定义一个简单的迭代器\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# yield关键字，用于定义生成器函数。惰性取值：按需生成值，而不是一次性生成所有值，适合处理大数据集。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e yield_tokens(data_iter):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e text in data_iter:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eyield\u003c/span\u003e text.split()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 示例数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edata = [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;this is a sentence\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;this is another sentence\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 构建词汇表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev2 = build_vocab_from_iterator(yield_tokens(data), min_freq=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, specials=[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u0026lt;unk\u0026gt;\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;\u0026lt;pad\u0026gt;\u0026#39;\u003c/span\u003e], special_first=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e### 直接使用token list作为输入\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etoken_lists = [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;this\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;is\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;a\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;sentence\u0026#34;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;this\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;is\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;another\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;sentence\u0026#34;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 构建词汇表\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev3 = build_vocab_from_iterator(token_lists)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch3 id=\"2-查询词汇表\"\u003e2. 查询词汇表\u003c/h3\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 1. 查看词元的索引\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev1[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;a\u0026#39;\u003c/span\u003e], v1[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;b\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 2. 设置当查询不在词汇表的新词元时，返回的索引\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev2.set_default_index(v2[unk_token])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev2[\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;sss\u0026#39;\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 3. 查询索引对应的词元\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev2.get_itos()[:\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# v2[\u0026#39;out of vocab\u0026#39;] is v2[unk_token]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ev2.get_stoi()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# {\u0026#39;a\u0026#39;: 5,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  \u0026#39;this\u0026#39;: 4,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  \u0026#39;another\u0026#39;: 6,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  \u0026#39;sentence\u0026#39;: 3,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  \u0026#39;is\u0026#39;: 2,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  \u0026#39;\u0026lt;pad\u0026gt;\u0026#39;: 1,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#  \u0026#39;\u0026lt;unk\u0026gt;\u0026#39;: 0}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"Torchtext构建Vocab词表"},{"content":"在 PyTorch 中，Dataset、DataLoader 和 Sampler 是用于数据加载和处理的核心组件。它们相互配合，使得数据的加载和批处理更加高效和灵活。\nDataset 是一个抽象类，用于表示数据集。 DataLoader 是一个迭代器，用于将数据集分成小批量。 Sampler 可以自定义更加复杂的采样策略。 1. Dataset 将训练数据（如特征和标签）封装为一个可迭代的 PyTorch Dataset 类。有如下两种方式。\n1.1 自定义类 继承 Dataset父类，并实现如下两个方法\n__len__: 返回数据集的大小。 __getitem__: 支持索引操作，返回指定位置的数据和标签。这里可以根据数据类型特点，灵活定义。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import torch from torch.utils.data import Dataset data = torch.arange(100).reshape(50, 2) # 50个样本，每个样本有2个特征 labels = torch.randint(0, 2, (50,)) # 50个二分类标签 class MyDataset(Dataset): def __init__(self, data, labels): self.data = data self.labels = labels def __len__(self): return len(self.data) def __getitem__(self, idx): # 返回样本和其对应的标签,可以根据数据特点，灵活定义 return self.data[idx], self.labels[idx] next(iter(dataset)) # (tensor([0, 1]), tensor(0)) 1.2 TensorDataset 对于简单的数组类型数据，可以直接使用TensorDataset(*tensors)\n1 2 3 4 5 from torch.utils.data import TensorDataset dataset_2 = TensorDataset(data, labels) next(iter(dataset_2)) # (tensor([0, 1]), tensor(0)) 2. Dataloader 将数据集拆分为小批量，用于后续的迭代训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from torch.utils.data import DataLoader # dataset: 要加载的数据集，通常是 Dataset 的实例。 # batch_size: 每个批次的数据量。 # shuffle: 是否在每个 epoch 开始时打乱数据。 # num_workers: 使用多少子进程来加载数据，默认仅使用当前进程。 # drop_last: 如果数据集大小不能被批次大小整除，是否丢弃最后一个不完整的批次。默认为False dataloader = DataLoader(dataset, batch_size=4, shuffle=True, num_workers=2) next(iter(dataloader)) # [tensor([[14, 15], # [22, 23], # [70, 71], # [40, 41]]), # tensor([0, 1, 0, 0])] for batch_data, batch_labels in dataloader: # 处理每个批次的数据 pass 2.1 collate_fn 参数 默认情况下，DataLoader 会将多个样本的数据直接拼接成一个批次。 collate_fn 是一个函数参数，用于在批处理时进行数据转换或预处理，以更好地适应训练要求。 1 2 3 4 5 6 7 8 9 10 11 12 def custom_collate_fn(batch): # 假设 batch 是一个列表，包含多个 (features, labels) 元组 features = [item[0] for item in batch] labels = [item[1] for item in batch] # 在这里可以进行序列填充或其他预处理 # 例如，将序列填充到相同长度 padded_features = pad_sequence(features, batch_first=True) return padded_features, torch.tensor(labels) dataloader = DataLoader(dataset, batch_size=4, collate_fn=custom_collate_fn) 2.2 sampler 参数 使用 sampler 参数可以实现复杂的采样逻辑，适用于需要特定采样策略的场景，如不均衡数据处理、分布式训练等。\nSequentialSampler: 顺序采样，按照数据集的顺序返回样本索引。 RandomSampler: 随机采样，打乱数据集顺序返回样本索引。 SubsetRandomSampler: 从数据集的一个子集随机采样。 WeightedRandomSampler: 根据指定的权重随机采样，适用于不平衡数据集。 DistributedSampler，用于在分布式训练中对数据进行采样。 1 2 3 4 5 6 7 8 9 10 11 12 ## 简单示例 # 随机采样 from torch.utils.data import RandomSampler sampler = RandomSampler(dataset) dataloader = DataLoader(dataset, sampler=sampler) # 子集采样 from torch.utils.data import SubsetRandomSampler import numpy as np indices = np.random.permutation(len(dataset))[:subset_size] sampler = SubsetRandomSampler(indices) #参数为子集的index dataloader = DataLoader(dataset, sampler=sampler) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/721pytorch-dataset%E4%B8%8Edataloader%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"\u003cp\u003e在 PyTorch 中，\u003ccode\u003eDataset\u003c/code\u003e、\u003ccode\u003eDataLoader\u003c/code\u003e 和 \u003ccode\u003eSampler\u003c/code\u003e 是用于数据加载和处理的核心组件。它们相互配合，使得数据的加载和批处理更加高效和灵活。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eDataset\u003c/code\u003e 是一个抽象类，用于表示数据集。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDataLoader\u003c/code\u003e 是一个迭代器，用于将数据集分成小批量。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eSampler\u003c/code\u003e 可以自定义更加复杂的采样策略。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"1-dataset\"\u003e1. Dataset\u003c/h1\u003e\n\u003cp\u003e将训练数据（如特征和标签）封装为一个可迭代的 PyTorch \u003ccode\u003eDataset\u003c/code\u003e 类。有如下两种方式。\u003c/p\u003e","title":"Pytorch-Dataset与Dataloader的使用."},{"content":" 1 2 import torch import torch.nn as nn 1. 线性层 1 2 3 4 5 input = torch.randn(3, 4) #3个样本，每个样本4个特征 linear = nn.Linear(in_features=4, out_features=2) linear(input).shape # torch.Size([3, 2]) 2. 正则化层 2.1 dropout 1 2 3 4 5 6 7 dropout = nn.Dropout(p=0.5) input = torch.randn(3, 4) dropout(input) # tensor([[ 0.0000, -0.0000, -0.5670, -0.0000], # [ 4.7224, -4.0010, 0.0000, -0.0000], # [-0.9960, 0.0000, 0.6658, -0.0000]]) 2.2 批归一化 对每个特征（在不同样本的分布）进行归一化 1 2 3 4 5 6 7 batchnorm = nn.BatchNorm1d(num_features=4) batchnorm(input).shape # (batch_size, emb_len) # torch.Size([3, 4]) input2 = torch.randn(2, 4, 3) # (batch_size, emb_len, seq_len) batchnorm(input2).shape # torch.Size([2, 4, 3]) 2.3 层归一化 对每个样本的所有特征分布进行归一化 1 2 3 4 5 6 7 8 layer_norm = nn.LayerNorm(normalized_shape=4) layer_norm(input).shape # torch.Size([3, 4]) input2 = torch.randn(2, 3, 4) # (batch_size, seq_len, emb_len) layer_norm(input2).shape # torch.Size([2, 3, 4]) 3. 激活函数 D2L的简单学习笔记记录了torch部分经典激活函数的计算函数。通常可以直接计算。 1 2 torch.relu(torch.tensor(0.5)) # tensor(0.5000) torch.sigmoid(torch.tensor(0.5)) # tensor(0.6225) 基于torch.nn实现的激活函数多为模块类 1 2 3 4 5 relu = nn.ReLU() relu(torch.tensor(0.5)) sigmoid = nn.Sigmoid() softmax = nn.Softmax(dim=1) #对轴1进行softmax转换，使其和为1 基于Relu的常见变体 1 2 3 4 5 6 7 8 # 负数不置为0，而是乘一个很小的系数 self_activation = nn.LeakyReLU(negative_slope=0.01) # 负数不置为0，而是乘一个可学习的参数 self_activation = nn.PReLU(num_parameters=1) # 整合高斯分布，在神经网络中表现出良好的性能，特别是在Transformer模型中 self_activation = nn.GELU() 4. 嵌入层 为每个离散的整型索引返回一个固定大小的向量，通常用于自然语言处理中的词嵌入。\n1 2 3 4 5 6 7 embedding = nn.Embedding(num_embeddings=1000, embedding_dim=64) # num_embeddings表示词汇表的大小，即共有多少个不同的词元 # embedding_dim表示嵌入向量的长度 input_indices = torch.tensor([1, 2, 3, 4]) embedding(input_indices).shape # torch.Size([4, 64]) 5. Transformer 定义一个Transformer块：包括标准的注意力层以及前馈神经网络层。 在另一篇笔记，有介绍torch实现的注意力层（nn.MultiheadAttention） 值得注意的是，在torch v2版本中默认采用的是flash加速版本的nn.MultiheadAttention。其带来的副作用就是不能输出attn weight信息。https://github.com/pytorch/pytorch/issues/99304 目前想的一个策略是：在预训练的前n-1的epoch中，采用默认的计算方式以加速计算；然后在最后一个epoch中，再采用自定义一个nn.TransformerEncoderLayer子类，用以支持attn weight的输出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 d_model = 512 # 总的输入特征维度 nhead = 8 # 注意力头数 # d_model: 输入和输出的特征维度 # nhead: 注意力头数 # dim_feedforward: FFN的神经元个数（MLP） # dropout: 丢失率，默认0.1 # batch_first: 默认为False，即输入为(seq, batch, feature); 设置为True，则输入为(batch, seq, feature) # norm_first: 默认为False，即在Attention和FFN之前进行norm # activation: 前馈网络中使用的激活函数，默认是 relu，可以选择其他激活函数如 gelu。 # 创建 Transformer 编码器层 encoder_layer = nn.TransformerEncoderLayer(d_model=d_model, nhead=nhead, dim_feedforward=d_model*2, dropout=0.1, batch_first=True) input = torch.randn(2, 10, 512) # (批量大小, 序列长度, 特征维度) encoder_layer(input).shape # torch.Size([2, 10, 512]) 堆叠多个Transformer块，组成编码器 1 2 3 4 num_layers = 12 transformer_encoder = nn.TransformerEncoder(encoder_layer, num_layers=num_layers) transformer_encoder(input).shape # torch.Size([2, 10, 512]) 统计model模型的参数量：\n1 2 num_parameters = sum(p.numel() for p in model.parameters()) print(f\u0026#34;模型参数量: {num_parameters}\u0026#34;) https://blog.csdn.net/weixin_43135178/article/details/140313635 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/722pytorch-%E5%B8%B8%E7%94%A8%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%B1%82/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch.nn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e nn\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1-线性层\"\u003e1. 线性层\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e = torch.randn(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#3个样本，每个样本4个特征\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elinear = nn.Linear(in_features=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, out_features=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elinear(\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e).shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.Size([3, 2])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"2-正则化层\"\u003e2. 正则化层\u003c/h1\u003e\n\u003ch2 id=\"21-dropout\"\u003e2.1 dropout\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edropout = nn.Dropout(p=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e = torch.randn(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003edropout(\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# tensor([[ 0.0000, -0.0000, -0.5670, -0.0000],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         [ 4.7224, -4.0010,  0.0000, -0.0000],\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e#         [-0.9960,  0.0000,  0.6658, -0.0000]])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"22-批归一化\"\u003e2.2 批归一化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e对每个特征（在不同样本的分布）进行归一化\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebatchnorm = nn.BatchNorm1d(num_features=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebatchnorm(\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e).shape       \u003cspan style=\"color:#007f7f\"\u003e# (batch_size, emb_len)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.Size([3, 4])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einput2 = torch.randn(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e# (batch_size, emb_len, seq_len)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ebatchnorm(input2).shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.Size([2, 4, 3])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"23-层归一化\"\u003e2.3 层归一化\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e对每个样本的所有特征分布进行归一化\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elayer_norm = nn.LayerNorm(normalized_shape=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elayer_norm(\u003cspan style=\"color:#fff;font-weight:bold\"\u003einput\u003c/span\u003e).shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.Size([3, 4])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einput2 = torch.randn(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e4\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e# (batch_size, seq_len, emb_len)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elayer_norm(input2).shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.Size([2, 3, 4])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"3-激活函数\"\u003e3. 激活函数\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://lishensuo.github.io/posts/bioinfo/707d2l-%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA/#22-%e6%bf%80%e6%b4%bb%e5%87%bd%e6%95%b0\"\u003eD2L的简单学习笔记\u003c/a\u003e记录了torch部分经典激活函数的计算函数。通常可以直接计算。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.relu(torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e))     \u003cspan style=\"color:#007f7f\"\u003e# tensor(0.5000)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.sigmoid(torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e))  \u003cspan style=\"color:#007f7f\"\u003e# tensor(0.6225)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e基于torch.nn实现的激活函数多为模块类\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erelu = nn.ReLU()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003erelu(torch.tensor(\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.5\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esigmoid = nn.Sigmoid()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esoftmax = nn.Softmax(dim=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e) \u003cspan style=\"color:#007f7f\"\u003e#对轴1进行softmax转换，使其和为1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e基于Relu的常见变体\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 负数不置为0，而是乘一个很小的系数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eself_activation = nn.LeakyReLU(negative_slope=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0.01\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 负数不置为0，而是乘一个可学习的参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eself_activation = nn.PReLU(num_parameters=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 整合高斯分布，在神经网络中表现出良好的性能，特别是在Transformer模型中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eself_activation = nn.GELU()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"4-嵌入层\"\u003e4. 嵌入层\u003c/h1\u003e\n\u003cp\u003e为每个离散的整型索引返回一个固定大小的向量，通常用于自然语言处理中的词嵌入。\u003c/p\u003e","title":"Pytorch-常用神经网络层-torch.nn"},{"content":" https://pytorch.org/get-started/locally/\n1. 概念 GPU（图形处理单元）是执行并行计算的硬件。\n具有不同的型号，例如GeForce RTX 3080、Tesla V100等 https://www.topcpu.net/gpu-r/fp32-float CUDA是NVIDIA 提供的并行计算软件平台，使开发者能够利用 GPU 的强大计算能力\n每个GPU设备都需要安装合适版本的CUDA（通常指CUDA Toolkit） 可通过nvidia-smi命令查找，如下图表示当前GPU驱动支持的最大CUDA版本为12.2（可向下兼容） nvidia-smi shows the highest version of CUDA supported by your driver.\nhttps://stackoverflow.com/questions/53422407/different-cuda-versions-shown-by-nvcc-and-nvidia-smi\n（但后来发现有时安装12.4的cuda也依旧可以进行pytorch运算）\nPyTorch 是一个开源的深度学习框架\nCUDA 是连接 PyTorch 和 GPU 的桥梁。PyTorch 可利用 CUDA 将计算任务放到 GPU，从而加速深度学习模型的训练和推理。 Pytorch的版本与CUDA的版本也要匹配，每个Pytorch版本可以支持多个CUDA版本，具体可查看 https://pytorch.org/get-started/previous-versions/ 2. 最简安装顺序 首先检查当前服务器，有无GPU设备驱动，以及型号数量，支持的CUDA版本等信息, 1 nvidia-smi 再根据上述信息，直接打包安装合适版本的torch+cuda环境，https://pytorch.org/get-started/previous-versions/ 这里选择选择了cuda 11.8, torch 2.3的版本组合 1 2 # 可使用mamba加速 conda install pytorch==2.3.0 torchvision==0.18.0 torchaudio==2.3.0 pytorch-cuda=11.8 -c pytorch -c nvidia 最后，检查上述是否安装成功 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import torch print(\u0026#34;CUDA available:\u0026#34;, torch.cuda.is_available()) # CUDA available: True print(\u0026#34;CUDA version:\u0026#34;, torch.version.cuda) # CUDA version: 11.8 print(\u0026#34;cuDNN version:\u0026#34;, torch.backends.cudnn.version()) # cuDNN version: 8700 # 此时是没有安装cuda开发环境的 nvcc -V # Command \u0026#39;nvcc\u0026#39; not found ls /home01/liss/miniconda3/envs/cuda_env/include | grep \u0026#39;^cuda\u0026#39; # 没有cuda_runtime.h等文件 3. 安装cuda开发环境 有些情况下，我们需要安装cuda的开发编译环境。由于上述安装方式中是在系统安装了cuda驱动软件时，再通过conda将pytorch+cuda打包安装，并非是在linux系统直接安装cuda。 好处是：通过conda环境很方便地设置多个独立、不同cuda版本； 坏处是：对于cuda编译环境需要格外注意，因为一般是假设Linux系统层面安装好了cuda。可能会遇到cuda_runtime.h: No such file or directory，cublas_v2.h: No such file or directory等报错。 主要原因是默认cuda path在根路径的/usr目录下。 下面将演示如何使用conda安装开发环境，并结合一个例子进行演示。 安装方式1: cudatoolkit-dev 不太推荐。因为其最近的一次更新还是一年前，只到了cuda11.7版本\n1 conda install -c conda-forge cudatoolkit-dev # max 11.7 安装方式2: nvidia::cuda 比较推荐，但有一点注意。如果采用默认官方给的指定版本安装命令，发现总是安装最新的cuda版本。 通过搜索他人的记录分享，使用如下方式，可以成功安装指定版本。\n1 conda install nvidia/label/cuda-11.8.0::cuda --channel nvidia/label/cuda-11.8.0 1 2 3 4 5 6 7 8 9 10 11 12 # 安装成功后 nvcc -V # nvcc: NVIDIA (R) Cuda compiler driver # Copyright (c) 2005-2022 NVIDIA Corporation # Built on Wed_Sep_21_10:33:58_PDT_2022 # Cuda compilation tools, release 11.8, V11.8.89 # Build cuda_11.8.r11.8/compiler.31833905_0 ls /home01/liss/miniconda3/envs/cuda_env/include | grep \u0026#39;^cuda\u0026#39; # 有了cuda_runtime.h等文件 cuda_path=/home01/liss/miniconda3/envs/cuda_env 案例 Github上的gpu-burn项目可以用来对GPU进行压力测试。 1 2 3 4 5 6 7 8 9 10 11 12 # (1) 下载并解压缩：https://github.com/wilicc/gpu-burn unzip gpu-burn-master.zip # (2) make编译报错了 cd gpu-burn-master make # g++ -O3 -Wno-unused-result -I/usr/local/cuda/include -std=c++11 -c gpu_burn-drv.cpp # gpu_burn-drv.cpp:62:10: fatal error: cublas_v2.h: No such file or directory # 62 | #include \u0026#34;cublas_v2.h\u0026#34; # | ^~~~~~~~~~~~~ # compilation terminated. # make: *** [Makefile:39: gpu_burn-drv.o] Error 1 在该仓库中，也有类似的issue。解决方式就是采用上述的cuda开发环境安装方式，然后修改Makefile文件。\n1 2 3 4 5 6 # head of original Makefile ifneq (\u0026#34;$(wildcard /usr/bin/nvcc)\u0026#34;, \u0026#34;\u0026#34;) CUDAPATH ?= /usr else ifneq (\u0026#34;$(wildcard /usr/local/cuda/bin/nvcc)\u0026#34;, \u0026#34;\u0026#34;) CUDAPATH ?= /usr/local/cuda endif 将上述设置进行注释后，将cuda路径指定为conda环境\n1 2 # head of modified Makefile CUDAPATH ?= /home01/liss/miniconda3/envs/cuda_env_5 1 2 3 4 5 # (2) 成功编译，产生一个可执行文件 gpu_burn make # (3) 对GPU进行100s的压力测试 ./gpu_burn 100 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/723gpucuda%E4%BB%A5%E5%8F%8Apytorch%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB/","summary":"\u003cblockquote\u003e\n\u003cp\u003e\u003ca href=\"https://pytorch.org/get-started/locally/\"\u003ehttps://pytorch.org/get-started/locally/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20241029090638157.png\" alt=\"image-20241029090638157\"  /\u003e\r\n\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch1 id=\"1-概念\"\u003e1. 概念\u003c/h1\u003e\n\u003cp\u003eGPU（图形处理单元）是执行并行计算的\u003cstrong\u003e硬件\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e具有不同的型号，例如GeForce RTX 3080、Tesla V100等\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.topcpu.net/gpu-r/fp32-float\"\u003ehttps://www.topcpu.net/gpu-r/fp32-float\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eCUDA是NVIDIA 提供的并行计算软件平台，使开发者能够利用 GPU 的强大计算能力\u003c/p\u003e","title":"GPU,CUDA以及Pytorch之间的关系"},{"content":"1. 优化器optimizer Adam：自适应学习率优化器 1 optimizer = torch.optim.Adam(model.parameters(), lr=1e-3) AdamW：Adam 的变体，加入了权重衰减来改善正则化效果，在 Transformer 类模型中表现良好。 1 optimizer = torch.optim.AdamW(model.parameters(), lr=1e-3, weight_decay=1e-2) LAMB 是专为大批量训练设计的优化器，适合大型模型（e.g. BERT）。\n2. 学习率调度器 在深度学习中，学习率调度器 (learning rate scheduler)用于动态调整学习率，以提高模型训练的效率和效果。\n在训练大模型时，lr scheduler的设计一般可遵循如下原则：\nWarmup 阶段 逐步增加学习率: 从一个较小的值线性或非线性地增加到设定的初始学习率。 目的: 稳定训练开始阶段，避免梯度更新过大导致的不稳定。 主训练阶段 保持或缓慢衰减: 在大部分训练过程中保持学习率不变，或者缓慢衰减。 目的: 充分利用初始学习率进行有效的参数更新，快速接近最优解。 衰减阶段 逐步减小学习率: 使用策略如余弦退火、指数衰减或分段衰减等。 目的: 在训练后期细化参数调整，避免振荡，稳定收敛。 下面，主要介绍可以方便实现lr schedule的函数\n2.1 torch库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import torch import matplotlib.pyplot as plt # 一个简单的模型 model = torch.nn.Linear(10, 2) # 使用 SGD 优化器 optimizer = torch.optim.SGD(model.parameters(), lr=0.1) # 支持的Schedule类型 [s for s in dir(torch.optim.lr_scheduler) if s.endswith(\u0026#34;LR\u0026#34;)] # [\u0026#39;ConstantLR\u0026#39;, # \u0026#39;CosineAnnealingLR\u0026#39;, # \u0026#39;CyclicLR\u0026#39;, # \u0026#39;ExponentialLR\u0026#39;, # \u0026#39;LambdaLR\u0026#39;, # \u0026#39;LinearLR\u0026#39;, # \u0026#39;MultiStepLR\u0026#39;, # \u0026#39;MultiplicativeLR\u0026#39;, # \u0026#39;OneCycleLR\u0026#39;, # \u0026#39;PolynomialLR\u0026#39;, # \u0026#39;SequentialLR\u0026#39;, # \u0026#39;StepLR\u0026#39;] (1) StepLR 每隔一定的步数（step_size），将学习率乘以一个给定的因子（gamma）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 创建 StepLR 调度器 scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.1) # 存储学习率的列表 lrs = [] # 模拟训练过程 for epoch in range(30): # 假设训练 30 个 epoch # 在每个 epoch 开始时记录当前学习率 lrs.append(optimizer.param_groups[0][\u0026#39;lr\u0026#39;]) # 模拟一个 epoch 的训练过程 # train(...) # 更新学习率 scheduler.step() # 可视化学习率变化 plt.plot(range(30), lrs) plt.xlabel(\u0026#39;Epoch\u0026#39;) plt.ylabel(\u0026#39;Learning Rate\u0026#39;) plt.title(\u0026#39;StepLR Learning Rate Schedule\u0026#39;) plt.grid(True) plt.show() (2) ExponentialLR 每次更新时，将学习率乘以一个固定的指数因子（gamma）。 1 2 # 创建 ExponentialLR 调度器 scheduler = torch.optim.lr_scheduler.ExponentialLR(optimizer, gamma=0.95) 更多详细示例，见：https://blog.csdn.net/weiman1/article/details/125647517\n2.2 transformers库 transformers为调度器增加了warmup预热阶段，即在训练的初始阶段逐渐增加学习率，而不是直接从设定的初始学习率开始。\n这是因为在训练开始时，模型的权重通常是随机初始化的，直接使用较大的学习率可能导致不稳定的梯度更新\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 import torch import transformers import matplotlib.pyplot as plt # 一个简单的模型 model = torch.nn.Linear(10, 2) # 使用 SGD 优化器 optimizer = torch.optim.SGD(model.parameters(), lr=0.1) [s for s in dir(transformers) if s.startswith(\u0026#34;get_\u0026#34;) \u0026amp; s.endswith(\u0026#34;warmup\u0026#34;)] # [\u0026#39;get_constant_schedule_with_warmup\u0026#39;, # \u0026#39;get_cosine_schedule_with_warmup\u0026#39;, # \u0026#39;get_cosine_with_hard_restarts_schedule_with_warmup\u0026#39;, # \u0026#39;get_linear_schedule_with_warmup\u0026#39;, # \u0026#39;get_polynomial_decay_schedule_with_warmup\u0026#39;] # 创建 get_cosine_schedule_with_warmup 调度器 scheduler = transformers.get_cosine_schedule_with_warmup( optimizer, num_warmup_steps=5, #预热的步数 num_training_steps=30, #总训练步数（num_epoch*num_batch） last_epoch=-1, ) # 绘图代码同上 3. 混合精度训练 混合精度训练是一种在深度学习中使用不同精度（通常是 FP16 和 FP32）进行计算的方法。Flash-attn使用的就是fp16/bp16。\n提高性能：使用 FP16（半精度浮点数）可以加速计算； 降低内存：FP16 占用的内存是 FP32（单精度浮点数）的一半。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import torch import torch.nn as nn import torch.optim as optim from torch.optim.lr_scheduler import StepLR from torch.cuda.amp import autocast, GradScaler from torchvision import datasets, transforms from torch.utils.data import DataLoader # 简单的神经网络模型 class SimpleModel(nn.Module): def __init__(self): super(SimpleModel, self).__init__() self.fc = nn.Linear(28 * 28, 10) def forward(self, x): x = x.view(-1, 28 * 28) return self.fc(x) # 参数设置 batch_size = 64 learning_rate = 0.01 scheduler_interval = 10 scheduler_factor = 0.1 num_epochs = 5 use_fp16 = True # 是否使用混合精度 # 数据加载 transform = transforms.Compose([transforms.ToTensor()]) train_dataset = datasets.MNIST(root=\u0026#39;./data\u0026#39;, train=True, transform=transform, download=True) train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True) # 模型、优化器、调度器、和混合精度缩放器 model = SimpleModel().cuda() optimizer = optim.Adam(model.parameters(), lr=learning_rate) scheduler = StepLR(optimizer, step_size=scheduler_interval, gamma=scheduler_factor) scaler = GradScaler(enabled=use_fp16) # 损失函数 criterion = nn.CrossEntropyLoss() 常规训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for epoch in range(num_epochs): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.cuda(), target.cuda() optimizer.zero_grad() # 前向传播 output = model(data) loss = criterion(output, target) # 反向传播和优化 loss.backward() optimizer.step() # 学习率调度器更新 / batch # scheduler.step() # 学习率调度器更新 / epoch # scheduler.step() 混合精度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 for epoch in range(num_epochs): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.cuda(), target.cuda() optimizer.zero_grad() # 使用 autocast 进行混合精度训练 with autocast(enabled=use_fp16): output = model(data) loss = criterion(output, target) # 使用 GradScaler 进行反向传播 scaler.scale(loss).backward() #损失乘以一个动态缩放因子 scaler.step(optimizer) #更新模型参数 scaler.update()\t#更新缩放因子 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/724%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B8%B8%E8%A7%84config%E8%AE%AD%E7%BB%83%E9%85%8D%E7%BD%AE/","summary":"\u003ch1 id=\"1-优化器optimizer\"\u003e1. 优化器optimizer\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eAdam：自适应学习率优化器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptimizer = torch.optim.Adam(model.parameters(), lr=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e-3\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eAdamW：Adam 的变体，加入了权重衰减来改善正则化效果，在 Transformer 类模型中表现良好。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptimizer = torch.optim.AdamW(model.parameters(), lr=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e-3\u003c/span\u003e, weight_decay=\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1e-2\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cblockquote\u003e\n\u003cp\u003eLAMB 是专为大批量训练设计的优化器，适合大型模型（e.g. BERT）。\u003c/p\u003e","title":"深度学习常规Config训练配置"},{"content":"注意力计算\n注意力计算的三要素分别是：Query， Key，Value。而在自注意力计算中，三者则是等价的。 结合如下图示例：一个序列有2个词元，每个词元有3个特征 ,即输入为(2, 3) 每个Query词元会计算与其它词元Key的“相似度”（包括自己），再经过softmax（每行的和等于1）转换，得到 2 × 2 权重矩阵 然后将其与Value矩阵进行乘法运算(2, 2) × (2, 3)，得到新的(2, 3)输出结果 形象理解：对于词元A的输出特征1，等于输入词元A, B的特征的加权和。 多头注意力：本质上可以理解为将特征维度分成多个部分，每个部分称为一个“头”。每个头独立进行注意力计算，然后将所有头的输出合并在一起；以期学习不同的关系和模式。 注意力计算本身不涉及可学习参数。一般在input前，out后，各设置一层MLP线性变换。 参考：https://blog.csdn.net/God_WeiYang/article/details/131820781\n0. 模拟数据 通常情况下，注意力计算的输入数据拥有四个维度：(batch_size, num_heads, seq_length, head_dim)\nword embed = num_heads × head_dim\n1 2 3 4 5 6 7 8 9 10 11 12 # 注意与上面顺序不太相同 def sample_input(bach_size, seq_length, n_head, n_dim): q = torch.randn((bach_size, seq_length, n_head, n_dim)).to(\u0026#34;cuda:0\u0026#34;, torch.float16) k = torch.rand_like(q) v = torch.rand_like(q) return q, k, v q, k, v = sample_input(32, 100, 8, 64) q.shape, k.shape, v.shape # (torch.Size([32, 100, 8, 64]), # torch.Size([32, 100, 8, 64]), # torch.Size([32, 100, 8, 64])) 最终词元的特征长度为：num_heads × head_dim\n1. 手动Attention计算 causal参数表示注意力掩码操作，常用于GPT生成模型中。表示计算序列中第n个词元时，只关注第1到n-1个（除了本身）； 具体通过torch.finfo(q.dtype).min设置为负无穷，则其softmax转换后的权重值为0。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def custom_attention(q, k, v, causal=False): score = torch.matmul(q, k.transpose(-2, -1)) / math.sqrt(q.size(-1)) if causal: mask = torch.triu(torch.ones(score.shape[-2], score.shape[-1]), diagonal=1) mask = mask.masked_fill(mask==1, torch.finfo(q.dtype).min) mask = mask.to(q.device, q.dtype) score = score + mask attn = F.softmax(score, dim=-1) o = torch.matmul(attn, v) return o q1 = q.transpose(1, 2) # torch.Size([32, 8, 100, 64]) k1 = k.transpose(1, 2) v1 = v.transpose(1, 2) o1 = custom_attention(q1, k1, v1) o1.transpose(2, 3).shape # torch.Size([32, 100, 8, 64]) 2. Flash Attention 1/2 Flash Attention 一种高效的注意力计算方法，旨在优化 Transformer 模型中的注意力机制。它通过减少内存使用和提高计算速度来处理长序列输入。 https://github.com/Dao-AILab/flash-attention 2.1 安装 之前学习的scGPT主要使用了FlashAttention-1，安装方法见之前的整理 1 2 3 4 5 6 7 8 9 10 11 12 13 # scgpt伪代码示例 from flash_attn.flash_attention import FlashAttention # __init__ self.self_attn = FlashAttention(attention_dropout=attention_dropout) # forward pcpt_context, pcpt_attn_weights = self.self_attn( pcpt_qkv, key_padding_mask=pcpt_key_padding_mask, need_weights=need_weights, causal=self.causal, # If true, autoregressive modeling ) 本次主要学习FlashAttention-2版本 （with Better Parallelism and Work Partitioning）。安装过程踩了很多坑，目前找到一种可信的方式。 1 2 3 4 5 6 7 8 9 10 conda create -n flash python=3.10 mamba -y # CUDA 11.8 mamba install cudatoolkit==11.8 -c nvidia # torch 2.3.0 mamba install pytorch==2.3.0 torchvision==0.18.0 torchaudio==2.3.0 pytorch-cuda=11.8 -c pytorch -c nvidia # nvcc conda install nvidia/label/cuda-11.8.0::cuda-nvcc nvcc -V # 下载源文件，本地安装：https://github.com/Dao-AILab/flash-attention/releases pip install \u0026#39;flash_attn-2.6.3+cu118torch2.3cxx11abiFALSE-cp310-cp310-linux_x86_64.whl\u0026#39; 非本地安装方式为：\n1 2 3 4 5 pip install ninja #加速build安装进程，实测发现只对下面的clone安装有作用 pip install flash-attn --no-build-isolation # or clone github repo python setup.py install 由于是在conda环境下安装的cuda，所以在上述过程中会出现类似cuda_runtime_api.h: No such file or directory的报错。查了很多教程，比较靠谱的方法是安装cudatoolkit-dev。这同时带来一个问题，目前其最高版本为11.7，需要安装与之对应的cuda环境，以及torch等\n1 2 3 4 5 mamba install -c conda-forge cudatoolkit-dev mamba install cudatoolkit==11.7 -c nvidia mamba install pytorch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 pytorch-cuda=11.7 -c pytorch -c nvidia python setup.py install 2.2 使用 输入维度要求一般是：(batch_size, seqlen, nheads, headdim) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from flash_attn import flash_attn_func, flash_attn_qkvpacked_func, flash_attn_kvpacked_func # flash_attn_func常规计算 o2 = flash_attn_func(q, k, v) o2.shape # torch.Size([32, 100, 8, 64]) # flash_attn_qkvpacked_func打包计算 qkv_pack = torch.concat([q.unsqueeze(2), k.unsqueeze(2), v.unsqueeze(2)], dim=2) # (batch_size, seqlen, 3, nheads, headdim) qkv_pack.shape # torch.Size([32, 100, 3, 8, 64]) flash_attn_qkvpacked_func(qkv_pack).shape # torch.Size([32, 100, 8, 64]) 3. F.scaled_dot_product_attention torch.nn.functional.scaled_dot_product_attention是torch2.0版本更新后，新增的注意力加速计算方法 https://pytorch.org/docs/stable/generated/torch.nn.functional.scaled_dot_product_attention.html https://pytorch.apachecn.org/2.0/tutorials/intermediate/scaled_dot_product_attention_tutorial/ 其采用了包括Flash-attention2在内的三种加速算法 FlashAttention-2: Faster Attention with Better Parallelism and Work Partitioning Memory-Efficient Attention A PyTorch implementation defined in C++ matching the above formulation All implementations are enabled by default. Scaled dot product attention attempts to automatically select the most optimal implementation based on the inputs 1 2 3 4 5 6 7 8 9 10 import torch.nn.functional as F # 输入要求(batch_size, nheads, seqlen, headdim) q3 = q.transpose(1, 2) # torch.Size([32, 8, 100, 64]) k3 = k.transpose(1, 2) v3 = v.transpose(1, 2) o3 = F.scaled_dot_product_attention(q3, k3, v3) o3.transpose(1, 2).shape # torch.Size([32, 100, 8, 64]) 4. Benchmark 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import math import time from einops import rearrange import torch import torch.nn.functional as F from flash_attn import flash_attn_func def custom_attention(q, k, v, causal=False): score = torch.matmul(q, k.transpose(-2, -1)) / math.sqrt(q.size(-1)) if causal: mask = torch.triu(torch.ones(score.shape[-2], score.shape[-1]), diagonal=1) mask = mask.masked_fill(mask==1, torch.finfo(q.dtype).min) mask = mask.to(q.device, q.dtype) score = score + mask attn = F.softmax(score, dim=-1) o = torch.matmul(attn, v) return o def pytorch_func(q, k, v, causal=False): o = F.scaled_dot_product_attention(q, k, v, is_causal=causal) # o = F.scaled_dot_product_attention(q, k, v, is_causal=causal)[0] return o def flash_attention(q, k, v, causal=False): o = flash_attn_func(q, k, v, causal=causal) return o 定义函数，测试注意力计算的时间以及显存消耗 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def test(func_name, q, k, v, *args, **kwargs): if func_name in [\u0026#34;custom_attention\u0026#34;, \u0026#34;pytorch_func\u0026#34;]: q = rearrange(q, \u0026#34;a b c d -\u0026gt; a c b d\u0026#34;) k = rearrange(k, \u0026#34;a b c d -\u0026gt; a c b d\u0026#34;) v = rearrange(v, \u0026#34;a b c d -\u0026gt; a c b d\u0026#34;) torch.cuda.reset_peak_memory_stats() # 重置 CUDA 内存统计信息 torch.cuda.synchronize() # 确保所有 CUDA 操作完成后再继续 # globals():字典，包含了当前作用域内的所有全局变量和函数 for _ in range(5): o = globals()[func_name](q, k, v, *args, **kwargs) torch.cuda.synchronize() st = time.time() o = globals()[func_name](q, k, v, *args, **kwargs) torch.cuda.synchronize() tt = time.time() - st max_memory = torch.cuda.max_memory_allocated() // 2**20 #单位MB torch.cuda.empty_cache() # 清除未使用的内存（释放那些已被删除但未释放的内存） if func_name in [\u0026#34;custom_attention\u0026#34;, \u0026#34;pytorch_func\u0026#34;]: o = rearrange(o, \u0026#34;a c b d -\u0026gt; a b c d\u0026#34;) return o, tt, max_memory 测试不同序列长度，三种计算时间以及显存消耗情况 （1）序列的长度越长时，pytorch func与flash attention计算优势越明显 （2）pytorch func与flash attention的差距不太明显。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 for seqlen in [256, 512, 1024]: print(f\u0026#34;## Sequence length: {seqlen}\u0026#34;) q, k, v = sample_input(32, seqlen, 8, 64) ## (1) o, t, m = test(\u0026#34;custom_attention\u0026#34;, q, k, v, causal=False) print(f\u0026#34;custom pytorch time: {t:.6f}, peak memory: {m} MB\u0026#34;) ## (2) pf_o, pf_t, pf_m = test(\u0026#34;pytorch_func\u0026#34;, q, k, v, causal=False) print(f\u0026#34;pytorch func time: {pf_t:.6f}, speedup: {t/pf_t:.2f}; peak memory: {pf_m} MB, save: {int((m-pf_m)/m*100)}%\u0026#34;) assert torch.allclose(o, pf_o, rtol=1e-2, atol=1e-2) ## (3) fa_o, fa_t, fa_m = test(\u0026#34;flash_attention\u0026#34;, q, k, v, causal=False) print(f\u0026#34;flash attention time: {fa_t:.6f}, speedup: {t/fa_t:.2f}; peak memory: {fa_m} MB, save: {int((m-fa_m)/m*100)}%\u0026#34;) assert torch.allclose(o, fa_o, rtol=1e-2, atol=1e-2) # ## Sequence length: 256 # custom pytorch time: 0.000259, peak memory: 216 MB # pytorch func time: 0.000058, speedup: 4.44; peak memory: 120 MB, save: 44% # flash attention time: 0.000073, speedup: 3.54; peak memory: 96 MB, save: 55% # ## Sequence length: 512 # custom pytorch time: 0.001135, peak memory: 384 MB # pytorch func time: 0.000142, speedup: 7.98; peak memory: 120 MB, save: 68% # flash attention time: 0.000154, speedup: 7.38; peak memory: 128 MB, save: 66% # ## Sequence length: 1024 # custom pytorch time: 0.004096, peak memory: 1272 MB # pytorch func time: 0.000478, speedup: 8.58; peak memory: 233 MB, save: 81% # flash attention time: 0.000493, speedup: 8.30; peak memory: 249 MB, save: 80% 测试不同特征长度，三种计算时间以及显存消耗情况 词元的特征维度越大时，pytorch func与flash attention计算优势会逐渐下降。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 for seqlen in [256, 512, 1024]: print(f\u0026#34;## Sequence length: {seqlen}\u0026#34;) q, k, v = sample_input(32, seqlen, 8, 64) ## (1) o, t, m = test(\u0026#34;custom_attention\u0026#34;, q, k, v, causal=False) print(f\u0026#34;custom pytorch time: {t:.6f}, peak memory: {m} MB\u0026#34;) ## (2) pf_o, pf_t, pf_m = test(\u0026#34;pytorch_func\u0026#34;, q, k, v, causal=False) print(f\u0026#34;pytorch func time: {pf_t:.6f}, speedup: {t/pf_t:.2f}; peak memory: {pf_m} MB, save: {int((m-pf_m)/m*100)}%\u0026#34;) assert torch.allclose(o, pf_o, rtol=1e-2, atol=1e-2) ## (3) fa_o, fa_t, fa_m = test(\u0026#34;flash_attention\u0026#34;, q, k, v, causal=False) print(f\u0026#34;flash attention time: {fa_t:.6f}, speedup: {t/fa_t:.2f}; peak memory: {fa_m} MB, save: {int((m-fa_m)/m*100)}%\u0026#34;) assert torch.allclose(o, fa_o, rtol=1e-2, atol=1e-2) # ## Sequence length: 32 # custom pytorch time: 0.003847, peak memory: 1128 MB # pytorch func time: 0.000276, speedup: 13.92; peak memory: 105 MB, save: 90% # flash attention time: 0.000286, speedup: 13.45; peak memory: 121 MB, save: 89% # ## Sequence length: 64 # custom pytorch time: 0.004104, peak memory: 1272 MB # pytorch func time: 0.000485, speedup: 8.45; peak memory: 233 MB, save: 81% # flash attention time: 0.000500, speedup: 8.21; peak memory: 249 MB, save: 80% # ## Sequence length: 128 # custom pytorch time: 0.004594, peak memory: 1512 MB # pytorch func time: 0.000952, speedup: 4.82; peak memory: 457 MB, save: 69% # flash attention time: 0.000956, speedup: 4.81; peak memory: 489 MB, save: 67% 5. nn.MultiheadAttention及mask操作 torch.nn.MultiheadAttention\nhttps://pytorch.org/docs/stable/generated/torch.nn.MultiheadAttention.html\ntorch 实现的标准多头注意力层类，包含完整输入与输出的权重参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import torch import torch.nn as nn query = key = value = torch.randn(4, 10, 512) # 实例化 mha = nn.MultiheadAttention(embed_dim=512, num_heads=8, batch_first=True, dropout=0.0) # forward前向计算 out_put, attn_weight = mha(query, key, value, need_weights = True) out_put.shape # torch.Size([4, 10, 512]) attn_weight.shape # torch.Size([4, 10, 10]) # 查看注意力层参数 for name, param in mha.named_parameters(): print(f\u0026#34;Name: {name}\u0026#34;) print(f\u0026#34;Shape: {param.shape}\\n\u0026#34;) # Name: in_proj_weight # Shape: torch.Size([1536, 512]) # Name: in_proj_bias # Shape: torch.Size([1536]) # Name: out_proj.weight # Shape: torch.Size([512, 512]) # Name: out_proj.bias # Shape: torch.Size([512]) 默认need_weights = True，即返回多头注意力矩阵计算结果。如果设置为False，use the optimized scaled_dot_product_attention and achieve the best performance for MHA.\n前向计算的mask相关参数\nkey_padding_mask：用于标记一个序列中的pad填充字符，使得query不会关注与其的注意力。\n其shape通常是 (Batch_size, Seq_len)。 True表示是pad填充字符 1 2 3 4 5 6 7 8 9 10 key_padding_mask = torch.tensor([[0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1, 1]]).bool() #(4, 10) out_put, _ = mha(query, key, value, need_weights = False, key_padding_mask=key_padding_mask) out_put[0,:3,:3] # tensor([[ 0.3662, -0.3266, -0.2634], # [ 0.0777, -0.1854, -0.0766], # [ 0.2575, -0.0160, -0.1000]], grad_fn=\u0026lt;SliceBackward0\u0026gt;) attn_mask：注意力掩码矩阵，直接对特定的query-key组合进行掩码操作\n其shape通常是(Batch_size*Num_head, Seq_len, Seq_len) True表示特定注意力被掩码 与key_padding_mask最终mask的效果是相同的。如下演示如何将key_padding_mask转换为attn_mask，得到一致的输出结果。 https://stackoverflow.com/questions/62629644/what-the-difference-between-att-mask-and-key-padding-mask-in-multiheadattnetion 1 2 3 4 5 6 7 8 9 10 attn_mask = key_padding_mask.unsqueeze(1).unsqueeze(2) attn_mask = attn_mask.expand(4, 8, 10, 10) attn_mask = attn_mask.reshape(4 * 8, 10, 10) # torch.Size([32, 10, 10]) out_put, _ = mha(query, key, value, need_weights = False, attn_mask=attn_mask) out_put[0,:3,:3] # tensor([[ 0.3662, -0.3266, -0.2634], # [ 0.0777, -0.1854, -0.0766], # [ 0.2575, -0.0160, -0.1000]], grad_fn=\u0026lt;SliceBackward0\u0026gt;) 关于上述key_padding_mask的转换有如下值得注意的细节。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 mask = torch.randn(3, 4) # (Batch_size, Seq_len), num_head = 2 ## 直接repeat不是所期望的结果 mask.unsqueeze(1).repeat(2,1,1) # repeat all batch as whole and cannot match the multi-head # tensor([[[ 0.5375, 1.3711, -0.3028, 1.0184]], # [[-0.1414, 1.3067, -0.0363, 0.8482]], # [[ 0.3573, -0.9005, -0.3998, -0.8608]], # [[ 0.5375, 1.3711, -0.3028, 1.0184]], # [[-0.1414, 1.3067, -0.0363, 0.8482]], # [[ 0.3573, -0.9005, -0.3998, -0.8608]]]) ## 如下两种方式均是符合预期的转换 mask.unsqueeze(1).unsqueeze(2).expand(3, 2, 1, 4).reshape(6, 1, 4) # repeat each seq two multi-head (expected) # tensor([[[ 0.5375, 1.3711, -0.3028, 1.0184]], # [[ 0.5375, 1.3711, -0.3028, 1.0184]], # [[-0.1414, 1.3067, -0.0363, 0.8482]], # [[-0.1414, 1.3067, -0.0363, 0.8482]], # [[ 0.3573, -0.9005, -0.3998, -0.8608]], # [[ 0.3573, -0.9005, -0.3998, -0.8608]]]) mask.unsqueeze(1).repeat_interleave(repeats=2, dim=0) # repeat each seq two multi-head (expected) 6. Flash-Attn V2 mask操作 在 flash_attn v1中的， FlashAttention注意力计算是支持key_padding_mask参数的；同时也提供了封装好的 FlashMHA注意力层（包括权重可学习参数）。 ！False代表填充字符，这与上面的MultiheadAttention相反 在 flash_attn v2中，flash_attn_func本身是仅用于计算注意力过程，没有mask操作。 1 2 3 from flash_attn import flash_attn_func, flash_attn_qkvpacked_func, flash_attn_kvpacked_func help(flash_attn_func) 在torch v2引入的F.scaled_dot_product_attention引入了Flash-Attn v2，具体参看上面第三点的介绍。值得注意是，它是支持attn_mask参数的。 attn_mask (optional Tensor) – Attention mask; shape must be broadcastable to the shape of attention weights, which is (N,\u0026hellip;,L,S)(N,\u0026hellip;,L,S). Two types of masks are supported. A boolean mask where a value of True indicates that the element should take part in attention. A float mask of the same type as query, key, value that is added to the attention score.\n如上参数说明有两个注意点\n（1）关于shape，不强制要求是(Batch_size*Num_head, Seq_len, Seq_len)。broadcastable也可以；\n（2）与Flash-Attn一样，False表示填充/被掩码\n1 2 3 4 5 6 7 8 9 10 # 方式1 attn_mask = key_padding_mask.unsqueeze(1) attn_mask.shape # torch.Size([4, 1, 10]) output = F.scaled_dot_product_attention( query, key, value, attn_mask=attn_mask ) output[0,:3,:3] # tensor([[ 0.7855, -0.2025, -0.5377], # [ 0.1681, -2.8067, 0.0794], # [-0.1817, 0.0185, 0.1878]]) 1 2 3 4 5 6 7 8 9 10 # 方式2 attn_mask = key_padding_mask.unsqueeze(1).repeat(1,10,1) attn_mask.shape # torch.Size([4, 10, 10]) output = F.scaled_dot_product_attention( query, key, value, attn_mask=attn_mask ) output[0,:3,:3] # tensor([[ 0.7855, -0.2025, -0.5377], # [ 0.1681, -2.8067, 0.0794], # [-0.1817, 0.0185, 0.1878]]) 注意点：\n（1）上述仅为单头注意力计算；\n（2）F.scaled_dot_product_attention仅提供注意力计算，不能作为完整的注意力层（缺少权重参数）\n核心：attn_mask与key_padding_mask参数并没有本质的区别。\n补充~\nSP1. Performer https://arxiv.org/pdf/2009.14794v4 2020 Google Research https://github.com/lucidrains/performer-pytorch Pytorch版本实现 Performer注意力：将复杂度降低到线性，使得它在处理长序列时更加高效；并从理论角度证明是可行的。\n对于长度为L的输入序列，嵌入向量长度是d\n计算常规Transfomer自注意力时 (下图左栏)，其复杂度为O(L2) → Quadratic;\n(1) 注意力矩阵：Q * (K)T = (L, d) * (d, L) = (L, L) → O(L2 * d) → O(L2) (2) Softmax计算归一化权重：(L, L) = (L, L) → O(L2) (3) 加权和表示：Q * (K)T * V = (L, L) * (L, d) = (L, d) → O(L2 * d) → O(L2) Performer注意力计算的注意力计算 (下图右栏) 复杂度为O(L) → Linear\n(1) 首先对Q与K进行随机特征映射（Random Feature Mapping） Q：(L, d) → Q\u0026rsquo; (L, r), K：(L, d) → K\u0026rsquo; (L, r) (2) 然后计算 (K\u0026rsquo;)T * V = (r, L) * (L, d) = (r, d) → O(Lrd) → O(L) (3) 最后计算 Q\u0026rsquo; * (K\u0026rsquo;)T * V = (L, r) * (r, d) = (L, d) → O(Lrd) → O(L) 计算复杂度时，可忽略常数项、低阶项，以及系数。\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/725flash-attention%E6%B3%A8%E6%84%8F%E5%8A%9B%E4%BC%98%E5%8C%96/","summary":"\u003cp\u003e\u003cstrong\u003e注意力计算\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e注意力\u003c/strong\u003e计算的三要素分别是：Query， Key，Value。而在\u003cstrong\u003e自注意力\u003c/strong\u003e计算中，三者则是等价的。\u003c/li\u003e\n\u003cli\u003e结合如下图示例：一个序列有2个词元，每个词元有3个特征 ,即输入为(2, 3)\n\u003cul\u003e\n\u003cli\u003e每个Query词元会计算与其它词元Key的“相似度”（包括自己），再经过softmax（每行的和等于1）转换，得到 2 × 2 权重矩阵\u003c/li\u003e\n\u003cli\u003e然后将其与Value矩阵进行乘法运算(2, 2) × (2, 3)，得到新的(2, 3)输出结果\n\u003cul\u003e\n\u003cli\u003e形象理解：对于词元A的输出特征1，等于输入词元A, B的特征的加权和。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多头注意力\u003c/strong\u003e：本质上可以理解为将特征维度分成多个部分，每个部分称为一个“头”。每个头独立进行注意力计算，然后将所有头的输出合并在一起；以期学习不同的关系和模式。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images2/main/img01/image-20241027123614983.png\" alt=\"image-20241027123614983\"  /\u003e\r\n\u003c/p\u003e","title":"Flash Attention注意力优化"},{"content":" 在深度/机器学习模型训练时，有必要展示或者记录每个batch/epoch的各种损失以及精度信息。除了最简单的print方式，目前有多种库提供了高级的API实现方式。下面就scGPT项目的学习过程，整理三种方式。\n1. logging库 logging库时python的内置模块，设计用于打印输出多种用户自定义的日志信息 1 2 3 4 5 6 import sys import logging # 创建一个日志记录器对象，并设置name logger = logging.getLogger(\u0026#34;test_log\u0026#34;) logger.setLevel(logging.INFO) # 设置输出级别为INFO及以上 DEBUG: 详细的信息，通常只在诊断问题时使用。 INFO: 确认一切按预期工作的消息。 WARNING: 表示某些不期望的情况或潜在问题。 ERROR: 更严重的问题，程序未能执行某些功能。 CRITICAL: 严重错误，程序可能无法继续运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 创建控制台处理器 console_handler = logging.StreamHandler() # 默认sys.stderr (sys.stdout备选) # 创建格式器并添加到处理器 formatter = logging.Formatter(\u0026#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s\u0026#39;) console_handler.setFormatter(formatter) # 将处理器添加到 logger logger.addHandler(console_handler) logger.info(\u0026#34;This is one info\u0026#34;) # 2024-10-22 21:05:16,441 - test_log - INFO - This is one info epoch = 0 batch = 1 total_batch = 100 acc = 0.85 logger.info( f\u0026#34;| epoch {epoch:3d} | {batch:3d}/{total_batch:3d} batches | \u0026#34; f\u0026#34;Accuray {acc}\u0026#34; ) # 2024-10-22 21:10:02,747 - test_log - INFO - | epoch 0 | 1/100 batches | Accuray 0.85 设置日志输出到指定文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 额外设置一个handler，将log同时保存到本地日志文件中 logger.handlers # [\u0026lt;StreamHandler stderr (NOTSET)\u0026gt;] file_handler = logging.FileHandler(\u0026#39;test.log\u0026#39;) file_handler.setFormatter(formatter) logger.addHandler(file_handler) logger.handlers # [\u0026lt;StreamHandler stderr (NOTSET)\u0026gt;, # \u0026lt;FileHandler /home00/liss/Study/cellxgene/test.log (NOTSET)\u0026gt;] # 删除刚才新增的handler # logger.removeHandler(logger.handlers[2]) 2. tensorboard库 TensorBoard 是一个用于可视化机器学习实验的工具，可与 PyTorch 等框架结合使用。\n参考： https://pytorch.org/docs/stable/tensorboard.html https://pytorch.org/tutorials/recipes/recipes/tensorboard_with_pytorch.html https://pytorch.org/tutorials/intermediate/tensorboard_profiler_tutorial.html?highlight=tensorboard 介绍了如何使用tensorboard记录GPU相关数据，暂不记录。\n1 2 3 4 5 import numpy as np import torch from torch.utils.data import TensorDataset, DataLoader from torch.utils.tensorboard import SummaryWriter # from tensorboardX import SummaryWriter 创建一个SummaryWriter对象，其中设置log文件的保存路径 一级目录runs: 表示本次模型相关的日志组 二级目录experiment_1: 表示本次训练的日志内容 1 writer = SummaryWriter(log_dir=\u0026#39;runs/experiment_1\u0026#39;) 一级目录（runs）下可以放置多次训练（experiment_2, experiment_3, \u0026hellip;）的日志结果，用于比较分析。\n然后在每次迭代训练过程，使用writer.add_scalar()记录目标的性能指标、训练参数等信息 参数1 tag ：例如Loss/train, 进行命名。若使用/，则会进行分组标注，例如 Loss类、Accuracy类 参数2 scalar_value：记录的标量值 参数3 global_step：当前的step数 当训练完成后，需要显式的关闭tensorboard 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 x = torch.arange(-5, 5, 0.1).view(-1, 1) y = -5 * x + 3 * x * x + 0.1 * torch.randn(x.size()) dataloader = DataLoader(TensorDataset(x, y), batch_size=5, shuffle=True) model = torch.nn.Linear(1, 1) criterion = torch.nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), lr = 0.1) def train_model(iter): for epoch in range(iter): for i, (x_dat, y_dat) in enumerate(dataloader): y_hat = model(x_dat) loss = criterion(y_hat, y_dat) writer.add_scalar(\u0026#34;Loss/train\u0026#34;, loss.item(), epoch*len(dataloader) + i) # random value just for demonstration writer.add_scalar(\u0026#34;Loss/test\u0026#34;, np.random.random(), epoch*len(dataloader) + i) writer.add_scalar(\u0026#34;Accuracy/train\u0026#34;, np.random.random(), epoch*len(dataloader) + i) writer.add_scalar(\u0026#34;Accuracy/test\u0026#34;, np.random.random(), epoch*len(dataloader) + i) optimizer.zero_grad() loss.backward() optimizer.step() train_model(5) writer.flush() # make sure that all pending events have been written to disk. writer.close() # close tensorboard 此外，还有其他记录方式，例如add_histogram等。但觉得还是add_scalar最常用。\n最后在linux终端，通过命令打开网页可视化结果。 1 2 3 # linux命令行运行，指定日志组路径 tensorboard --logdir=runs # http://localhost:6006/ 3. wandb库 Weights \u0026amp; Biases (WandB) 是一个用于机器学习实验管理的工具，提供了一系列功能来帮助开发者跟踪、可视化和分享实验结果。\n参考：\nhttps://wandb.ai/site\nhttps://docs.wandb.ai/tutorials/pytorch/\n初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import wandb import torch import torch.nn as nn import torch.optim as optim from torch.utils.data import DataLoader, TensorDataset # 登陆账户，使用用户的API wandb.login(key=\u0026#34;User settings → API keys\u0026#34;) # 初始化 WandB wandb.init( project=\u0026#34;pytorch-simulated-data\u0026#34;, config={ \u0026#34;epochs\u0026#34;: 5, \u0026#34;batch_size\u0026#34;: 16, \u0026#34;learning_rate\u0026#34;: 0.01 } ) # 获取配置 config = wandb.config 加载数据和模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 模拟数据 X = torch.randn(1000, 20) # 1000个样本，每个样本有20个特征 y = (torch.sum(X, dim=1) \u0026gt; 0).long() # 简单的线性可分任务 # 创建数据集和数据加载器 dataset = TensorDataset(X, y) train_loader = DataLoader(dataset, batch_size=config.batch_size, shuffle=True) # 定义简单的模型 class SimpleNN(nn.Module): def __init__(self): super(SimpleNN, self).__init__() self.fc1 = nn.Linear(20, 64) self.fc2 = nn.Linear(64, 2) def forward(self, x): x = torch.relu(self.fc1(x)) x = self.fc2(x) return x model = SimpleNN() criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=config.learning_rate) 记录训练损失以及其它个性化参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 训练模型 for epoch in range(config.epochs): model.train() total_loss = 0 for batch_idx, (data, target) in enumerate(train_loader): optimizer.zero_grad() output = model(data) loss = criterion(output, target) loss.backward() optimizer.step() total_loss += loss.item() # 记录损失 wandb.log({\u0026#34;epoch\u0026#34;: epoch, \u0026#34;loss\u0026#34;: total_loss / len(train_loader)}) # 结束 WandB 运行 wandb.finish() 上面只记录了最简单的用法，有时间再学习下其它高级功能。\nwandb使用教程（持续更新ing\u0026hellip;）_wandb 官网-CSDN博客\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/726%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97%E6%8C%87%E6%A0%87log%E8%AE%B0%E5%BD%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在深度/机器学习模型训练时，有必要展示或者记录每个batch/epoch的各种损失以及精度信息。除了最简单的print方式，目前有多种库提供了高级的API实现方式。下面就scGPT项目的学习过程，整理三种方式。\u003c/p\u003e","title":"机器学习日志指标log记录"},{"content":" 在深度学习的前向传播中，最重要的是理解每个计算步骤的输入前与输入后的维度形状。与之对应的时需要熟悉一些常见的维度操作方法，根据项目的学习总结记录如下：\n1. torch方法 1 2 3 4 import torch data = torch.randn(32, 100, 8, 128) # c(batch_size, seq_len, head_num, head_embed) data.shape # torch.Size([32, 100, 8, 128]) transpose 交换指定的两个维度 1 2 data.transpose(2, 0).shape # torch.Size([8, 100, 32, 128]) permute 指定所有维度的新顺序。 1 2 data.permute(0, 2, 1, 3).shape # torch.Size([32, 8, 100, 128]) reshape/view 变更张量的维度 1 2 3 4 5 6 data.reshape(32 * 8, 100, 128).shape # torch.Size([256, 100, 128]) # -1表示根据已设置维度，计算该维度的大小 data.reshape(32 * 8, -1).shape # torch.Size([256, 12800]) .view与.reshape操作基本一致，前者要求输入张量是内存连续的。\nsqueeze/unsqueeze 管理大小为1的维度 1 2 3 4 5 x = torch.randn(1, 3, 1, 4) y = x.squeeze() # 移除所有大小为1的维度，结果为 (3, 4) y1 = x.squeeze(0) # 结果为 (3, 1, 4) z = x.unsqueeze(2) # 在第2维添加一个维度，结果为 (1, 3, 1, 1, 4) z1 = x.unsqueeze(-1) # 结果为 (1, 3, 1, 1, 4, 1) repeat : 沿指定维度重复张量 1 2 3 4 x = torch.tensor([[1, 2, 3]]) # (1, 3) y = x.repeat(2, 3) # 结果为 (2, 9) y1 = x.repeat(1, 3) # 结果为 (1, 9) cat/stack: 合并多个张量。cat：沿指定维度连接张量；stack：在新维度上堆叠张量。 1 2 3 4 5 6 a = torch.randn(3, 4) b = torch.randn(3, 4) c = torch.cat((a, b), dim=0) # 结果为 (6, 4) d = torch.stack((a, b), dim=0) # 结果为 (2, 3, 4) d1 = torch.stack((a, b), dim=2) # (3, 4, 2) 2. einops https://github.com/arogozhnikov/einops 1 2 3 4 5 6 import torch from einops import rearrange data = torch.randn(32, 100, 8, 128) # c(batch_size, seq_len, head_num, head_embed) data.shape # torch.Size([32, 100, 8, 128]) 维度顺序调换 1 2 rearrange(data, \u0026#39;b s h d -\u0026gt; b s h d\u0026#39;).shape # torch.Size([32, 100, 8, 128]) 可以使用任何符合表示任何维度，但使用常见符号可以让代码更易于理解。例如在LLM模型中，b表示batch，s表示sequence，h表示head number，d表示head dimension\n1 2 rearrange(data, \u0026#39;b s h d -\u0026gt; b h s d\u0026#39;).shape # torch.Size([32, 8, 100, 128]) 维度合并与拆分 1 2 3 4 5 6 7 8 9 10 11 12 rearrange(data, \u0026#39;b s h d -\u0026gt; (b s) h d\u0026#39;).shape # torch.Size([3200, 8, 128]) # 维度合并的不同顺序会对产生不同的结果（维度拆分同理） rearrange(data, \u0026#39;b s h d -\u0026gt; (s b) h d\u0026#39;).shape rearrange(data, \u0026#39;b s h d -\u0026gt; b (s h d)\u0026#39;).shape # torch.Size([32, 102400]) # 维度拆分 rearrange(data, \u0026#39;b (s s1) h d -\u0026gt; b s s1 h d\u0026#39;, s1=5) # torch.Size([32, 20, 5, 8, 128]) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/727torch%E5%BC%A0%E9%87%8F%E7%9A%84%E7%BB%B4%E5%BA%A6%E6%93%8D%E4%BD%9C/","summary":"\u003cblockquote\u003e\n\u003cp\u003e在深度学习的前向传播中，最重要的是理解每个计算步骤的输入前与输入后的维度形状。与之对应的时需要熟悉一些常见的维度操作方法，根据项目的学习总结记录如下：\u003c/p\u003e","title":"torch张量的维度操作"},{"content":"1. 背景 DDP分布式训练与DP并行训练\n在之前了解多GPU训练时，学习过一种数据并行方式DataParallel (DP)。其核心将模型复制到每个 GPU，然后在每个 GPU 上分配一小部分数据并行执行计算。最后，主 GPU 汇总所有 GPU 的梯度并更新模型参数。实现角度也非常简单，使用nn.DataParallel()即可。\n在实际场景中，另一种数据并行方式DistributedDataParallel (DDP)使用更加广泛。每个 GPU（进程）都有一个模型副本，各个副本只处理数据的一个子集。每个 GPU 都独立地进行前向和反向传播，之后所有 GPU 的梯度会同步，确保更新一致。\n以Pytorch为例，其启用方式有很多种，下面学习基于torchrun的用法。\n参考资料\n网页教程：https://pytorch.org/tutorials/beginner/ddp_series_intro.html 教程视频：https://www.youtube.com/watch?v=-K3bZYHYHEA Github源码：https://github.com/pytorch/examples/tree/main/distributed/ddp-tutorial-series 2. 关键代码 需要以脚本形式运行。在jupyter交互式环境无法使用。\nscript.py 分布式训练相关代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 ## 加载Torch相关模块 import torch import torch.nn.functional as F from torch.utils.data import Dataset, DataLoader # 分布式相关模块 from torch.utils.data.distributed import DistributedSampler from torch.nn.parallel import DistributedDataParallel as DDP from torch.distributed import init_process_group, destroy_process_group import os ## 初始设置 # 单机训练时的GPU id local_rank = int(os.environ[\u0026#34;LOCAL_RANK\u0026#34;]) # 多机训练时的GPU 全局id rank = int(os.environ[\u0026#34;RANK\u0026#34;]) # 全部GPU的数量 world_size = torch.distributed.get_world_size() torch.cuda.set_device(local_rank) init_process_group(backend=\u0026#34;nccl\u0026#34;) ## 数据层面 # 分布式样本抽样（使得每个GPU获取样本没有重复） train_sampler = DistributedSampler(train_dataset) # 样本迭代器（由于train_sampler默认已经shuffle，所有这里不用设置shuffle） train_loader = DataLoader(train_dataset, batch_size=BATCH_SIZE, shuffle = False, sampler=train_sampler) ## 模型层面 model = MyModel() # 如果模型有Batchnorm操作 model = nn.SyncBatchNorm.convert_sync_batchnorm(model) model = model.to(local_rank) model = DDP(model, device_ids=[local_rank]) ## 训练时将小批量数据转移至GPU操作类似 for index, (data, labels) in enumerate(train_loader): data, labels = data.to(local_rank), labels.to(local_rank) print(f\u0026#39;[GPU {local_rank}] Epoch {epoch} | Step {index} is OK ---\u0026#39;) #其它需要转移GPU设置类似 ## 结束DDT分布式训练 destroy_process_group() shell命令 1 2 # 单卡4 GPU训练 torchrun --standalone --nproc_per_node=4 torchrun_multigpu.py 3. 更多用法 （1）如果模型model使用到batchnorm，需要使用同步操作。\n1 2 3 4 model = MyModel() model = nn.SyncBatchNorm.convert_sync_batchnorm(model) model = model.to(local_rank) model = DDP(model, device_ids=[local_rank]) （2）torch.distributed.barrier 确保所有进程在到达某个点时都等待其他进程，从而保证所有进程在继续执行下一步之前已经完成了当前的步骤。\n1 2 3 4 5 6 7 8 # 模拟一些操作 print(f\u0026#34;Rank {rank} is working...\u0026#34;) # 假设这里有一些耗时的操作 # 同步所有进程: 阻塞当前进程，直到所有进程都到达这个调用点。 dist.barrier() # 继续执行后续操作 （3）with model.no_sync() 减少通信开销，降低显存需求\n在 DDP 中，默认情况下，每次前向传递和反向传递后，所有进程会同步梯度 使用 no_sync() 可以暂时禁用这种同步，允许你在多个小批次（micro-batches）中累积梯度，然后再进行一次同步。 假设实际批量大小为 16，且每 4 个批次进行一次梯度同步，等价于每次训练都使用 16 × 4 = 64 的等效批量大小。 1 2 3 4 5 6 7 8 9 10 11 for i, (inputs, labels) in enumerate(dataloader): # 在 no_sync 下计算梯度，不同步 with model.no_sync(): outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() # 仅累积梯度，不进行同步 # 每 4 个批次同步一次 if (i + 1) % 4 == 0: optimizer.step() # 更新权重 optimizer.zero_grad() # 清空梯度 （4）torch.distributed.reduce 模型汇总多个GPU的训练结果\n使用场景：在分布式训练中，需在多 GPU 上计算损失或某种指标的平均值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def get_reduced(tensor, current_device, dest_device, world_size): \u0026#34;\u0026#34;\u0026#34; 将不同GPU上的变量或tensor集中在主GPU上，并得到均值 \u0026#34;\u0026#34;\u0026#34; # 如果输入的是 tensor，则创建一个其拷贝并与计算图断开；否则将其转化为 tensor。 tensor = tensor.clone().detach() if torch.is_tensor(tensor) else torch.tensor(tensor) # 将 tensor 移动到当前设备 tensor = tensor.to(current_device) # 使用 torch.distributed.reduce 将当前设备的 tensor 发送到目标设备（dest_device）上 torch.distributed.reduce(tensor, dst=dest_device) # 在目标设备上将 tensor 值取平均 tensor_mean = tensor.item() / world_size return tensor_mean # 计算每个GPU训练的平均loss epoch_loss = get_reduced(epoch_loss, local_rank, 0, world_size) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/728%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%8D%A1torchrun%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%AD%E7%BB%83/","summary":"\u003ch1 id=\"1-背景\"\u003e1. 背景\u003c/h1\u003e\n\u003cp\u003eDDP分布式训练与DP并行训练\u003c/p\u003e\n\u003cp\u003e在之前了解\u003ca href=\"https://lishensuo.github.io/posts/bioinfo/715d2l-%E7%AC%AC%E5%8D%81%E4%B8%80%E5%8F%8A%E5%8D%81%E4%BA%8C%E7%AB%A0%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E5%A4%9Agpu%E5%B9%B6%E8%A1%8C/#5-%e5%a4%9agpu%e8%ae%ad%e7%bb%83\"\u003e多GPU训练\u003c/a\u003e时，学习过一种数据并行方式DataParallel (\u003cstrong\u003eDP\u003c/strong\u003e)。其核心将模型复制到每个 GPU，然后在每个 GPU 上分配一小部分数据并行执行计算。最后，主 GPU 汇总所有 GPU 的梯度并更新模型参数。实现角度也非常简单，使用\u003ccode\u003enn.DataParallel()\u003c/code\u003e即可。\u003c/p\u003e","title":"单机多卡torchrun分布式训练"},{"content":"1. 示例模型 两层MLP的神经网络 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import torch import torch.nn as nn import torch.nn.functional as F class SimpleMLP(nn.Module): def __init__(self, input_size, hidden_size, output_size): super(SimpleMLP, self).__init__() self.fc1 = nn.Linear(input_size, hidden_size) self.fc2 = nn.Linear(hidden_size, output_size) def forward(self, x): x = F.relu(self.fc1(x)) x = self.fc2(x) return x # Example usage input_size = 256 # Number of input features hidden_size = 128 # Number of neurons in the hidden layer output_size = 2 # Number of output classes model = SimpleMLP(input_size, hidden_size, output_size) 2. 组成模块查询 通过递归的方式遍历模型的所有层，包括嵌套在其他层内的子模块 1 2 3 4 5 6 7 8 9 10 # torch.nn.Module类 model.modules for module in model.modules(): print(f\u0026#34;Module: {module}\u0026#34;) for name, module in model.named_modules(): print(f\u0026#34;{name}: {module}\u0026#34;) # fc1: Linear(in_features=256, out_features=128, bias=True) # fc2: Linear(in_features=128, out_features=2, bias=True) 3. 模型参数查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # torch.nn.Parameter类 for param in model.parameters(): print(f\u0026#34;{param.shape}\u0026#34;) for name, param in model.named_parameters(): print(f\u0026#34;{name}: {param.shape}\u0026#34;) # fc1.weight: torch.Size([128, 256]) # fc1.bias: torch.Size([128]) # fc2.weight: torch.Size([2, 128]) # fc2.bias: torch.Size([2]) for name, param in model.fc1.named_parameters(): print(f\u0026#34;{name}: {param.shape}\u0026#34;) # weight: torch.Size([128, 256]) # bias: torch.Size([128]) # 模型总参数量 total_parameters = sum(p.numel() for p in model.parameters()) # 查看具体某一层的参数 param = next(iter(model.fc1.parameters())) type(param) # torch.nn.parameter.Parameter param.shape # torch.Size([128, 256]) param.numel() # 32768 param.requires_grad # True # 参数冻结，即不更新该module参数 param.requires_grad=False 4. 模型（参数）保存与加载 1 2 3 4 5 6 7 type(model.state_dict()) # save torch.save(model.state_dict(), \u0026#39;model.pth\u0026#39;) # pt后缀也可 # load model.load_state_dict(torch.load(\u0026#39;model.pth\u0026#39;)) pretrained_params = torch.load(model_pt, map_location=\u0026#39;cuda:2\u0026#39;) 一个实际加载的示例函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # def load_pretrained( model: torch.nn.Module, pretrained_params: dict = None, strict: bool = False, prefix: list = None, use_flash_attn = True, verbose: bool = True, ) -\u0026gt; torch.nn.Module: # 修改特定参数的key name if not use_flash_attn: pretrained_params = { k.replace(\u0026#34;Wqkv.\u0026#34;, \u0026#34;in_proj_\u0026#34;): v for k, v in pretrained_params.items() } # 只加载特定keys的参数 if prefix is not None and len(prefix) \u0026gt; 0: if isinstance(prefix, str): prefix = [prefix] pretrained_params = { k: v for k, v in pretrained_params.items() if any(k.startswith(p) for p in prefix) } model_dict = model.state_dict() # 严格加载：全部参数需要匹配 if strict: if verbose: for k, v in pretrained_params.items(): print(f\u0026#34;Loading parameter {k} with shape {v.shape}\u0026#34;) model_dict.update(pretrained_params) model.load_state_dict(model_dict) # 部分加载：只加载部分能够匹配的参数（key name以及 value shape） else: if verbose: for k, v in pretrained_params.items(): if k in model_dict and v.shape == model_dict[k].shape: print(f\u0026#34;Loading parameter {k} with shape {v.shape}\u0026#34;) pretrained_params = { k: v for k, v in pretrained_params.items() if k in model_dict and v.shape == model_dict[k].shape } model_dict.update(pretrained_params) model.load_state_dict(model_dict) return model ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/729torch%E6%A8%A1%E5%9E%8B%E7%BB%84%E6%88%90%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0%E6%9F%A5%E8%AF%A2%E7%AE%A1%E7%90%86%E4%BF%9D%E5%AD%98/","summary":"\u003ch2 id=\"1-示例模型\"\u003e1. 示例模型\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e两层MLP的神经网络\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch.nn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e nn\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch.nn.functional \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e F\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eclass\u003c/span\u003e SimpleMLP(nn.Module):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e __init__(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, input_size, hidden_size, output_size):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003esuper\u003c/span\u003e(SimpleMLP, \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e).__init__()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.fc1 = nn.Linear(input_size, hidden_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.fc2 = nn.Linear(hidden_size, output_size)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e forward(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e, x):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        x = F.relu(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.fc1(x))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        x = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eself\u003c/span\u003e.fc2(x)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e x\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Example usage\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003einput_size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e256\u003c/span\u003e   \u003cspan style=\"color:#007f7f\"\u003e# Number of input features\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ehidden_size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e128\u003c/span\u003e   \u003cspan style=\"color:#007f7f\"\u003e# Number of neurons in the hidden layer\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoutput_size = \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e2\u003c/span\u003e   \u003cspan style=\"color:#007f7f\"\u003e# Number of output classes\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel = SimpleMLP(input_size, hidden_size, output_size)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"2-组成模块查询\"\u003e2. 组成模块查询\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e通过递归的方式遍历模型的所有层，包括嵌套在其他层内的子模块\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.nn.Module类\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.modules\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e module in model.modules():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Module: \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003emodule\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e name, module in model.named_modules():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ename\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e: \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003emodule\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fc1: Linear(in_features=256, out_features=128, bias=True)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fc2: Linear(in_features=128, out_features=2, bias=True)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"3-模型参数查询\"\u003e3. 模型参数查询\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.nn.Parameter类\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e param in model.parameters():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eparam.shape\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e name, param in model.named_parameters():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ename\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e: \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eparam.shape\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fc1.weight: torch.Size([128, 256])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fc1.bias: torch.Size([128])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fc2.weight: torch.Size([2, 128])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# fc2.bias: torch.Size([2])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e name, param in model.fc1.named_parameters():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ename\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e: \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003eparam.shape\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# weight: torch.Size([128, 256])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# bias: torch.Size([128])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 模型总参数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etotal_parameters = \u003cspan style=\"color:#fff;font-weight:bold\"\u003esum\u003c/span\u003e(p.numel() \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e p in model.parameters())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 查看具体某一层的参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam = \u003cspan style=\"color:#fff;font-weight:bold\"\u003enext\u003c/span\u003e(\u003cspan style=\"color:#fff;font-weight:bold\"\u003eiter\u003c/span\u003e(model.fc1.parameters()))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e(param)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.nn.parameter.Parameter\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam.shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# torch.Size([128, 256])\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam.numel()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 32768\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam.requires_grad\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 参数冻结，即不更新该module参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eparam.requires_grad=\u003cspan style=\"color:#fff;font-weight:bold\"\u003eFalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"4-模型参数保存与加载\"\u003e4. 模型（参数）保存与加载\u003c/h2\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003etype\u003c/span\u003e(model.state_dict())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# save\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003etorch.save(model.state_dict(), \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;model.pth\u0026#39;\u003c/span\u003e)  \u003cspan style=\"color:#007f7f\"\u003e# pt后缀也可\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# load\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emodel.load_state_dict(torch.load(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;model.pth\u0026#39;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epretrained_params = torch.load(model_pt, map_location=\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;cuda:2\u0026#39;\u003c/span\u003e) \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e一个实际加载的示例函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e23\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e24\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e25\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e26\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e27\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e28\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e29\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e30\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e31\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e32\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e33\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e34\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e35\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e36\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e37\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e38\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e39\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e40\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e41\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e42\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e43\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e44\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e45\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e46\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e47\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e48\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e49\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# \u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003edef\u003c/span\u003e load_pretrained(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    model: torch.nn.Module,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    pretrained_params: \u003cspan style=\"color:#fff;font-weight:bold\"\u003edict\u003c/span\u003e = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    strict: \u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eFalse\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    prefix: \u003cspan style=\"color:#fff;font-weight:bold\"\u003elist\u003c/span\u003e = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    use_flash_attn = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    verbose: \u003cspan style=\"color:#fff;font-weight:bold\"\u003ebool\u003c/span\u003e = \u003cspan style=\"color:#fff;font-weight:bold\"\u003eTrue\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e) -\u0026gt; torch.nn.Module:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 修改特定参数的key name\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e not use_flash_attn:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pretrained_params = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            k.replace(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Wqkv.\u0026#34;\u003c/span\u003e, \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;in_proj_\u0026#34;\u003c/span\u003e): v \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e k, v in pretrained_params.items()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 只加载特定keys的参数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e prefix is not \u003cspan style=\"color:#fff;font-weight:bold\"\u003eNone\u003c/span\u003e and \u003cspan style=\"color:#fff;font-weight:bold\"\u003elen\u003c/span\u003e(prefix) \u0026gt; \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eisinstance\u003c/span\u003e(prefix, \u003cspan style=\"color:#fff;font-weight:bold\"\u003estr\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            prefix = [prefix]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pretrained_params = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            k: v\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e k, v in pretrained_params.items()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#fff;font-weight:bold\"\u003eany\u003c/span\u003e(k.startswith(p) \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e p in prefix)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    model_dict = model.state_dict()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 严格加载：全部参数需要匹配\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e strict:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e verbose:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e k, v in pretrained_params.items():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Loading parameter \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ek\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e with shape \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ev.shape\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        model_dict.update(pretrained_params)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        model.load_state_dict(model_dict)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#007f7f\"\u003e# 部分加载：只加载部分能够匹配的参数（key name以及 value shape）\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eelse\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e verbose:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e k, v in pretrained_params.items():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e k in model_dict and v.shape == model_dict[k].shape:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#fff;font-weight:bold\"\u003eprint\u003c/span\u003e(\u003cspan style=\"color:#0ff;font-weight:bold\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;Loading parameter \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ek\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e with shape \u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e{\u003c/span\u003ev.shape\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        pretrained_params = {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            k: v\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003efor\u003c/span\u003e k, v in pretrained_params.items()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#fff;font-weight:bold\"\u003eif\u003c/span\u003e k in model_dict and v.shape == model_dict[k].shape\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        model_dict.update(pretrained_params)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        model.load_state_dict(model_dict)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#fff;font-weight:bold\"\u003ereturn\u003c/span\u003e model\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e","title":"torch模型组成模块参数查询、管理、保存"},{"content":"1. Collator数据处理 目的：将dataset的初始数据进行规范化批量处理，用以后续的前向计算 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # Start from dataset (Sequences could have diff lengths) Dataset({ features: [\u0026#39;input_ids\u0026#39;], num_rows: 5 }) # End to encoded batch input (BatchEncoding格式) {\u0026#39;input_ids\u0026#39;: tensor([[350, 241, 345, 705, 695, 1, 427, 645, 99, 943, 0, 0, 0, 0], [196, 464, 546, 626, 413, 1, 973, 98, 824, 1, 410, 0, 0, 0], [475, 665, 1, 164, 306, 788, 53, 562, 232, 216, 252, 990, 0, 0], [ 1, 966, 734, 897, 171, 357, 217, 850, 529, 895, 728, 234, 799, 0], [713, 76, 1, 428, 913, 890, 143, 992, 832, 963, 555, 18, 354, 455]]), \u0026#39;attention_mask\u0026#39;: tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]), \u0026#39;labels\u0026#39;: tensor([[-100, -100, -100, -100, -100, 716, -100, -100, -100, -100, -100, -100, -100, -100], [-100, -100, -100, -100, -100, 665, -100, -100, -100, 686, -100, -100, -100, -100], [-100, -100, 56, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100], [ 619, 966, -100, -100, -100, 357, -100, -100, -100, -100, -100, -100, -100, -100], [-100, -100, 218, -100, -100, -100, -100, -100, -100, 963, -100, -100, -100, -100]])} 常见的关键字段包括：\ninput_ids: 编码后的序列token id attention_mask: 注意力的掩码标注。例如会对pad填充字符，标记为0，表示不参与注意力计算 labels: 监督学习任务的样本标签，-100表示掩码/填充token，在计算损失时予以忽略 token_type_ids: 用于区分句子对 tokenizer 对于一个批量的序列数据，数据预处理的首先最重要的一步是将不同长度的序列，进行填充至相同长度。此外根据需要，也包括trunc截取操作。\n在huggingface的Transformer中提供了标准的API工具。\nhttps://huggingface.co/transformers/v4.6.0/_modules/transformers/tokenization_utils_base.html https://huggingface.co/docs/transformers/pad_truncation 在相关API调用时，常见三个参数 padding, max_length, truncation\npadding参数：\n逻辑值True或者字符串\u0026quot;longest\u0026quot; 表示填充到批量内最长序列的长度（如果是单个序列，则不填充） 字符串\u0026quot;max_length\u0026quot;表示填充到预设的最大长度（此时需要设置max_length参数） 逻辑值False表示不填充 \u0026ldquo;longest\u0026quot;填充策略本质上相当于将max_length参数设置为批量内序列最长序列长度的\u0026quot;max_length\u0026quot;填充策略。\ntruncation参数：\n逻辑值True或者字符串\u0026quot;longest_first\u0026quot; 表示根据预设的最大限制长度（max_length参数）进行截取操作。 逻辑值False或者字符串\u0026quot;do_not_truncate\u0026quot;表示不进行截取 collator collators是最终的接口形式，一般都会将tokenizer作为其参数之一，完成全流程的数据预处理操作。根据不同的任务类型与输入类型，可以对Collator以及tokenizer进行个性化修改。\n虽然huggingface中提供了成熟的tokenizer（e.g. PreTrainedTokenizer），但尝试之后觉得单细胞组学模型处理不太适用，需要个性化修改。先前尝试了自定义的修改，出现各种问题\n这里参考Geneformer的代码。其在第一步已经将单细胞数据，按非零基因表达从高到低排序，并截取排名靠前的基因（e.g. 2048）、将基因名转换为token id，保存为dataset。所以理论上仅需要考虑pad操作（不需要trunc），再结合特定任务进行修改。已将相关代码gene_pad_tokenizer.py整理，上传，方便后续的调用。如下为使用演示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 加载函数，以及示例数据 import torch from datasets import Dataset import geneformer from gene_pad_tokenizer import GeneformerPreCollator as GeneTokenizer # 加载词表（dict） token_dictionary = geneformer.TOKEN_DICTIONARY_FILE import pickle with open(token_dictionary, \u0026#34;rb\u0026#34;) as f: token_dictionary = pickle.load(f) token_dictionary[\u0026#34;\u0026lt;mask\u0026gt;\u0026#34;] # 1 token_dictionary[\u0026#34;\u0026lt;cls\u0026gt;\u0026#34;] # 2 token_dictionary[\u0026#34;\u0026lt;pad\u0026gt;\u0026#34;] # 0 # 示例数据 demo_dat = {\u0026#34;input_ids\u0026#34;:[]} for i in range(10, 15): demo_dat[\u0026#34;input_ids\u0026#34;].append(np.random.permutation(range(4,1000))[:i].tolist()) demo_dataset = Dataset.from_dict(demo_dat) demo_dataset = demo_dataset.with_format(\u0026#34;torch\u0026#34;) # Dataset({ # features: [\u0026#39;input_ids\u0026#39;], # num_rows: 5 # }) 方法1：分步\ntokenzier 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 gene_tokenizer = GeneTokenizer(token_dictionary=token_dictionary, padding_side=\u0026#34;right\u0026#34;, model_input_names=[\u0026#34;input_ids\u0026#34;]) gene_tokenizer.convert_ids_to_tokens(0) # \u0026#39;\u0026lt;pad\u0026gt;\u0026#39; gene_tokenizer.convert_tokens_to_ids(\u0026#34;\u0026lt;cls\u0026gt;\u0026#34;) # 2 # 模拟Dataloader迭代的批量格式 list of dicts(samples), 每个dict代表一个样本 encoded_inputs = [{\u0026#34;input_ids\u0026#34;: v} for v in demo_dataset[\u0026#34;input_ids\u0026#34;]] # [{\u0026#39;input_ids\u0026#39;: tensor([350, 241, 345, 705, 695, 716, 427, 645, 99, 943])}, # {\u0026#39;input_ids\u0026#39;: tensor([196, 464, 546, 626, 413, 665, 973, 98, 824, 686, 410])}, # {\u0026#39;input_ids\u0026#39;: tensor([475, 665, 56, 164, 306, 788, 53, 562, 232, 216, 252, 990])}, # {\u0026#39;input_ids\u0026#39;: tensor([619, 966, 734, 897, 171, 357, 217, 850, 529, 895, 728, 234, 799])}, # {\u0026#39;input_ids\u0026#39;: tensor([713, 76, 218, 428, 913, 890, 143, 992, 832, 963, 555, 18, 354, 455])}] padded_inputs = gene_tokenizer.pad( encoded_inputs, padding=True, max_length=None, return_attention_mask=True, return_tensors=\u0026#34;pt\u0026#34; ) type(padded_inputs) # 输出为BatchEncoding格式 # transformers.tokenization_utils_base.BatchEncoding # {\u0026#39;input_ids\u0026#39;: tensor([[350, 241, 345, 705, 695, 716, 427, 645, 99, 943, 0, 0, 0, 0], # [196, 464, 546, 626, 413, 665, 973, 98, 824, 686, 410, 0, 0, 0], # [475, 665, 56, 164, 306, 788, 53, 562, 232, 216, 252, 990, 0, 0], # [619, 966, 734, 897, 171, 357, 217, 850, 529, 895, 728, 234, 799, 0], # [713, 76, 218, 428, 913, 890, 143, 992, 832, 963, 555, 18, 354, 455]]), # \u0026#39;attention_mask\u0026#39;: tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]])} collator，这里直接使用huggingface提供的用于mlm任务的掩码处理 （也可以自定义，例如Geneformer的collator_for_classification.py） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 from transformers import DataCollatorForLanguageModeling data_collator = DataCollatorForLanguageModeling( tokenizer=gene_tokenizer, mlm=True, mlm_probability=0.15 ) # 首先转换为list of dict padded_inputs_reshape = [{\u0026#34;input_ids\u0026#34;: padded_inputs[\u0026#34;input_ids\u0026#34;][i], \u0026#34;attention_mask\u0026#34;: padded_inputs[\u0026#34;attention_mask\u0026#34;][i]} for i in range(len(padded_inputs[\u0026#34;input_ids\u0026#34;]))] # [{\u0026#39;input_ids\u0026#39;: tensor([350, 241, 345, 705, 695, 716, 427, 645, 99, 943, 0, 0, 0, 0]), # \u0026#39;attention_mask\u0026#39;: tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0])}, # {\u0026#39;input_ids\u0026#39;: tensor([196, 464, 546, 626, 413, 665, 973, 98, 824, 686, 410, 0, 0, 0]), # \u0026#39;attention_mask\u0026#39;: tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0])}, # {\u0026#39;input_ids\u0026#39;: tensor([475, 665, 56, 164, 306, 788, 53, 562, 232, 216, 252, 990, 0, 0]), # \u0026#39;attention_mask\u0026#39;: tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0])}, # {\u0026#39;input_ids\u0026#39;: tensor([619, 966, 734, 897, 171, 357, 217, 850, 529, 895, 728, 234, 799, 0]), # \u0026#39;attention_mask\u0026#39;: tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0])}, # {\u0026#39;input_ids\u0026#39;: tensor([713, 76, 218, 428, 913, 890, 143, 992, 832, 963, 555, 18, 354, 455]), # \u0026#39;attention_mask\u0026#39;: tensor([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])}] # Collator处理 batch_input = data_collator(padded_inputs_reshape) type(batch_input) # transformers.tokenization_utils_base.BatchEncoding # {\u0026#39;input_ids\u0026#39;: tensor([[350, 241, 345, 705, 695, 1, 427, 645, 99, 943, 0, 0, 0, 0], # [196, 464, 546, 626, 413, 1, 973, 98, 824, 1, 410, 0, 0, 0], # [475, 665, 1, 164, 306, 788, 53, 562, 232, 216, 252, 990, 0, 0], # [ 1, 966, 734, 897, 171, 357, 217, 850, 529, 895, 728, 234, 799, 0], # [713, 76, 1, 428, 913, 890, 143, 992, 832, 963, 555, 18, 354, 455]]), # \u0026#39;attention_mask\u0026#39;: tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]), # \u0026#39;labels\u0026#39;: tensor([[-100, -100, -100, -100, -100, 716, -100, -100, -100, -100, -100, -100, -100, -100], # [-100, -100, -100, -100, -100, 665, -100, -100, -100, 686, -100, -100, -100, -100], # [-100, -100, 56, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100], # [ 619, 966, -100, -100, -100, 357, -100, -100, -100, -100, -100, -100, -100, -100], # [-100, -100, 218, -100, -100, -100, -100, -100, -100, 963, -100, -100, -100, -100]])} 方法2：一步到位\n1 batch_input_v2 = data_collator(encoded_inputs) 方法3：DataLoader\n1 2 3 4 5 6 7 8 9 10 11 from torch.utils.data import DataLoader demo_loader = DataLoader(demo_dataset, batch_size=2, collate_fn = data_collator) batch_input_v3 = next(iter(demo_loader)) # {\u0026#39;input_ids\u0026#39;: tensor([[350, 241, 345, 705, 695, 716, 427, 645, 99, 943, 0], # [196, 464, 546, 1, 413, 665, 973, 98, 824, 686, 410]]), # \u0026#39;attention_mask\u0026#39;: tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0], # [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]), # \u0026#39;labels\u0026#39;: tensor([[-100, -100, -100, -100, -100, -100, -100, -100, -100, -100, -100], # [-100, -100, -100, 626, -100, -100, -100, -100, -100, -100, -100]])} 在个性化的下游任务中，可根据需要修改上述Collator与tokenizer。目前的学习经验是，如果是更适合对批量数据整体进行操作，则修改Collator部分即可。如果是需要对每个批量内样本进行修改，则修改tokenizer的pad方法（核心是修改_pad()）\n2. Model 1 # SDPA is used by default for torch\u0026gt;=2.1.when an implementation is available, BertConfig Bert模型配置 - BertConfig [Default] vocab_size: 词汇表大小 [30522]\nhidden_size: 隐藏层/嵌入维度 [768]\nnum_hidden_layers: 注意力层的数量 [12]\nnum_attention_heads: 注意力头的个数 [12]\nintermediate_size: FFN的维度 [3072]\nhidden_act: 激活函数 [\u0026ldquo;gelu\u0026rdquo;]\nhidden_dropout_prob: 隐藏层的Dropout概率 [0.1]\nattention_probs_dropout_prob: 注意力的Dropout概率 [0.1]\nmax_position_embeddings: 最大序列长度 [512]\nnum_labels: 分类任务的类别数 [2]\noutput_hidden_states: 是否输出全部隐藏层状态 [False]\noutput_attentions: 是否输出注意力MAP [False]\n**kwargs: 支持添加、设置自定义的模型配置\nBertModel 基础模型 - BertModel，为bert模型的encoder部分，不包括head任务头 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 BertModel( (embeddings): BertEmbeddings( (word_embeddings): Embedding(30522, 768, padding_idx=0) (position_embeddings): Embedding(512, 768) (token_type_embeddings): Embedding(2, 768) (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True) (dropout): Dropout(p=0.1, inplace=False) ) (encoder): BertEncoder( (layer): ModuleList( (0-11): 12 x BertLayer( (attention): BertAttention( (self): BertSdpaSelfAttention( (query): Linear(in_features=768, out_features=768, bias=True) (key): Linear(in_features=768, out_features=768, bias=True) (value): Linear(in_features=768, out_features=768, bias=True) (dropout): Dropout(p=0.1, inplace=False) ) (output): BertSelfOutput( (dense): Linear(in_features=768, out_features=768, bias=True) (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True) (dropout): Dropout(p=0.1, inplace=False) ) ) (intermediate): BertIntermediate( (dense): Linear(in_features=768, out_features=3072, bias=True) (intermediate_act_fn): GELUActivation() ) (output): BertOutput( (dense): Linear(in_features=3072, out_features=768, bias=True) (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True) (dropout): Dropout(p=0.1, inplace=False) ) ) ) ) (pooler): BertPooler( (dense): Linear(in_features=768, out_features=768, bias=True) (activation): Tanh() ) ) BertForPreTraining 标准预训练模型 - BertForPreTraining 包括MLM与NSP两部分 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 BertForPreTraining( (bert): BertModel( ...... ) (cls): BertPreTrainingHeads( (predictions): BertLMPredictionHead( (transform): BertPredictionHeadTransform( (dense): Linear(in_features=768, out_features=768, bias=True) (transform_act_fn): GELUActivation() (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True) ) (decoder): Linear(in_features=768, out_features=30522, bias=True) ) (seq_relationship): Linear(in_features=768, out_features=2, bias=True) ) ) BertForMaskedLM MLM预训练模型 - BertForMaskedLM 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 BertForMaskedLM( (bert): BertModel( ...... ) (cls): BertOnlyMLMHead( (predictions): BertLMPredictionHead( (transform): BertPredictionHeadTransform( (dense): Linear(in_features=768, out_features=768, bias=True) (transform_act_fn): GELUActivation() (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True) ) (decoder): Linear(in_features=768, out_features=30522, bias=True) ) ) ) BertForNextSentencePrediction NSP预训练模型 - BertForNextSentencePrediction 1 (cls)部分的(predictions)变为(seq_relationship) BertForSequenceClassification 句子分类微调模型 - BertForSequenceClassification 对于cls token的分类器 1 2 3 4 5 6 7 8 BertForSequenceClassification( (bert): BertModel( ...... ) (dropout): Dropout(p=0.1, inplace=False) (classifier): Linear(in_features=768, out_features=2, bias=True) # out_features可通过config的num_labels=3设置 ) BertForTokenClassification token分类微调模型 - BertForTokenClassification 对于所有token的分类器 1 2 3 4 5 6 7 BertForTokenClassification( (bert): BertModel( ...... ) (dropout): Dropout(p=0.1, inplace=False) (classifier): Linear(in_features=768, out_features=10, bias=True) ) 3. Trainer Hugging Face 的 Trainer 类是其 Transformers 库中用于简化模型训练和评估的核心组件之一。\n如下为一个简单示例，相关重要参数包括：\nmodel：训练模型，例如上面学习的模型类\nargs：训练超参数，如学习率、批量大小、epoch 数。【要与上面的模型超参数区别开】\ndata_collator：小批量数据预处理。【填充+任务特定的操作，详见上】\ntrain_dataset：训练数据集，huggingface的datasets格式\neval_dataset：验证数据集\ncompute_metrics：计算除了loss以外的评估指标\n参考 compute_metrics from geneformer/classifier_utils.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from transformers import Trainer, TrainingArguments training_args = { \u0026#34;learning_rate\u0026#34;: max_lr, \u0026#34;do_train\u0026#34;: True } training_args = TrainingArguments(**training_args) trainer = Trainer( model=model, args=training_args, data_collator=data_collator, train_dataset=train_data, eval_dataset=eval_data, compute_metrics=compute_metrics ) # train trainer.train() # evaluate metrics = trainer.evaluate() # predict predictions = trainer.predict(test_dataset) # save model trainer.save_model(model_output_dir) 如果使用想直接使用model预测：\n1 2 3 4 5 6 7 8 9 10 padded_batch.set_format(type=\u0026#34;torch\u0026#34;) input_data_batch = padded_batch[\u0026#34;input_ids\u0026#34;] attn_msk_batch = padded_batch[\u0026#34;attention_mask\u0026#34;] label_batch = padded_batch[label_name] with torch.no_grad(): outputs = model( input_ids=input_data_batch.to(\u0026#34;cuda\u0026#34;), attention_mask=attn_msk_batch.to(\u0026#34;cuda\u0026#34;), labels=label_batch.to(\u0026#34;cuda\u0026#34;), ) TrainingArguments常见超参数选项\noutput_dir=\u0026quot;./result\u0026quot; 模型和检查点文件保存的目录 num_train_epochs = 3 训练轮数，可以小数 per_device_train_batch_size = 8 训练集批量数 per_device_eval_batch_size = 64 验证集批量数 gradient_accumulation_steps = 1 梯度累计步数 learning_rate = 5e-5 （最大）学习率 lr_scheduler_type = \u0026quot;cosine\u0026quot; 学习率规划方式 warmup_steps = 10000 学习率预热步数 weight_decay = 0.01 权重衰减 logging_steps = 500 记录log日志的频数 save_steps = 500 模型检查点的频数 evaluation_strategy = \u0026quot;epoch\u0026quot;/\u0026quot;steps\u0026quot;/no 验证集评估维度 eval_steps = 500 验证集评估步数（if \u0026ldquo;steps\u0026rdquo;） ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/730hugging-face4-bert%E6%A8%A1%E5%9E%8B%E5%8F%8Acollator%E4%B8%8Etrainer/","summary":"\u003ch1 id=\"1-collator数据处理\"\u003e1. Collator数据处理\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e目的\u003c/strong\u003e：将dataset的初始数据进行规范化批量处理，用以后续的前向计算\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 8\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e 9\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e10\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e11\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e12\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e13\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e14\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e15\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e16\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e17\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e18\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e19\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e20\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e21\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e22\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# Start from dataset (Sequences could have diff lengths)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDataset({\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    features: [\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;input_ids\u0026#39;\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    num_rows: \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# End to encoded batch input (BatchEncoding格式)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;input_ids\u0026#39;\u003c/span\u003e: tensor([[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e350\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e241\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e345\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e705\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e695\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e427\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e645\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e99\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e943\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e196\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e464\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e546\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e626\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e413\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e973\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e98\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e824\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e410\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e475\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e665\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e164\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e306\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e788\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e53\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e562\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e232\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e216\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e252\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e990\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e966\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e734\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e897\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e171\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e357\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e217\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e850\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e529\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e895\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e728\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e234\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e799\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e713\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e76\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e428\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e913\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e890\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e143\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e992\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e832\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e963\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e555\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e18\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e354\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e455\u003c/span\u003e]]), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;attention_mask\u0026#39;\u003c/span\u003e: tensor([[\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e0\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e1\u003c/span\u003e]]), \n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e \u003cspan style=\"color:#0ff;font-weight:bold\"\u003e\u0026#39;labels\u0026#39;\u003c/span\u003e: tensor([[-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e716\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e665\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e686\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,   \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e56\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [ \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e619\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e966\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e357\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e],\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        [-\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e218\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e,  \u003cspan style=\"color:#ff0;font-weight:bold\"\u003e963\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e, -\u003cspan style=\"color:#ff0;font-weight:bold\"\u003e100\u003c/span\u003e]])}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003cp\u003e常见的关键字段包括：\u003c/p\u003e","title":"Hugging face(4) Bert模型及Collator与Trainer"},{"content":"Faiss (Facebook AI Similarity Search) 是一个用于高效相似向量搜索的库，特别适合处理大规模向量数据。\n它的核心功能是给定一个向量数据库，为当前的query vector(s) 寻找Top-K个相似向量。 此外也支持KNN聚类，PCA降维，数据量化等模块。 官方文档：https://github.com/facebookresearch/faiss/wiki 1 2 3 4 5 # 安装方式: 一个环境不能同时安装cpu与gpu两个版本 pip install faiss-cpu pip install faiss-gpu # 下面以cpu版本为例 1. 相似Top-K查找 Faiss通过构建一个Index（索引）对象，用于建立可实现快速相似搜索的数据结构。\n常见的索引类型：\nIndexFlatL2: 暴力搜索，精度高，速度慢（L2距离） IndexFlatIP: 暴力搜索，适用于内积（dot product） IndexIVFFlat: IVF (Inverted File Indexing) 可加速搜索 IndexIVFPQ: PQ (Product Quantizer) 可降低缓存需求 IndexHNSWFlat: HNSW (Hierarchical Navigable Small World): fast and accurate Basic indexes 介绍了全部的index类型；\nGuidelines to choose an index 介绍下选择index的参考标准。\n1.1 暴力搜索 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import numpy as np import faiss # (1) 初始化index d = 64 # 需要提前设置向量的维度 index = faiss.IndexFlatL2(d) print(index.is_trained) # True # 对于暴力搜索方式，不需要训练，因此这里为True。但对于其它方式需要手动进行训练 # (2) 添加向量数据库 nb = 100000 xb = np.random.random((nb, d)).astype(\u0026#39;float32\u0026#39;) xb.shape # (100000, 64) index.add(xb) print(index.ntotal) # 100000 # (3) 对query向量查询数据库的Top-K相似向量 k = 3 D, I = index.search(xq, k) I.shape # (10000, 4): Top-K的索引 I[:3] # array([[74531, 40931, 30745, 68436], # [53407, 38558, 47694, 51554], # [82772, 20841, 3102, 25325]]) D.shape # (10000, 4): Top-K的度量值 D[:3] # array([[4.651325 , 5.663311 , 5.687874 , 5.708172 ], # [4.663849 , 5.218609 , 5.2473526, 5.313629 ], # [5.563755 , 5.568184 , 5.588524 , 5.8358154]], dtype=float32) 1.2 IVF方式举例 IVF通过事先将数据库的向量分为若干个类群（Voronoi cells），然后计算query vector与每个类群质心的距离度量，可降低搜索范围，加快速度。其中有两个关键参数\nnlist: 分为多少个类群 nprobe: 最终选取多少Top类群，作为搜索范围 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import numpy as np import faiss # (1) 初始化index nlist = 100 k = 4 quantizer = faiss.IndexFlatL2(d) index = faiss.IndexIVFFlat(quantizer, d, nlist) index.train(xb) #训练 # (2) 添加向量数据库 index.add(xb) print(index.ntotal) # 100000 # (3) 对query向量查询数据库的Top-K相似向量 k = 3 D, I = index.search(xq, k) I[:3] # array([[42962, 51466, 57950], # [51817, 59530, 89886], # [95115, 79896, 39241]]) index.nprobe = 10 # default nprobe is 1, try a few more D, I = index.search(xq, k) I[:3] # array([[40931, 30745, 96040], # [53407, 38558, 47694], # [82772, 25325, 27231]]) 暴力搜索是最精确的方式，其它所有方式都会或多或少损失一定精度，以最求其它方面的提升（速度/显存）。PS：每种方式都有自己的参数。\n1.3 联合datasets使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from datasets import Dataset import pandas as pd import numpy as np ## (1) 示例数据集 texts = [\u0026#34;s1\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;] embeddings = np.random.rand(5, 64).tolist() df = pd.DataFrame({\u0026#34;text\u0026#34;: texts, \u0026#34;embeddings\u0026#34;: embeddings}) dataset = Dataset.from_pandas(df) # Dataset({ # features: [\u0026#39;text\u0026#39;, \u0026#39;embeddings\u0026#39;], # num_rows: 5 # }) ## (2) 创建索引 dataset.add_faiss_index(column=\u0026#34;embeddings\u0026#34;) # 等价于 dataset.add_faiss_index(column=\u0026#34;embeddings\u0026#34;, index_factory=\u0026#34;Flat\u0026#34;) # 可以设置其它值(e.g. \u0026#34;IVF100,PQ64\u0026#34;)，具体可参加文档 ## (3) 对query向量进行查询 query_embedding = np.random.rand(64,) scores, retrieved_examples = dataset.get_nearest_examples( \u0026#34;embeddings\u0026#34;, # embedding 列名 query_embedding, # query embedding k=3 # top k ) retrieved_examples[\u0026#34;text\u0026#34;] # [\u0026#39;s3\u0026#39;, \u0026#39;s5\u0026#39;, \u0026#39;s1\u0026#39;] ## (4) 保存与加载 # 保存 Dataset 和 faiss 索引 dataset.save_faiss_index(\u0026#34;embeddings\u0026#34;, \u0026#34;my_faiss.index\u0026#34;) dataset.drop_index(\u0026#34;embeddings\u0026#34;) dataset.save_to_disk(\u0026#34;my_dataset\u0026#34;) # 加载 Dataset 和索引 from datasets import load_from_disk dataset = load_from_disk(\u0026#34;my_dataset\u0026#34;) dataset.load_faiss_index(\u0026#34;embeddings\u0026#34;, \u0026#34;my_faiss.index\u0026#34;) 2. 聚类降维 2.1 K-means聚类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import faiss import numpy as np x = np.random.rand(1000, 128).astype(\u0026#39;float32\u0026#39;) ncentroids = 16 niter = 20 verbose = True d = x.shape[1] kmeans = faiss.Kmeans(d, ncentroids, niter=niter, verbose=verbose) kmeans.train(x) # Clustering 1000 points in 128D to 16 clusters, redo 1 times, 20 iterations # Preprocessing in 0.00 s # Iteration 19 (0.48 s, search 0.15 s): objective=10058 imbalance=1.136 nsplit=0 # 10057.9833984375 # 所有类群的质心Embedding kmeans.centroids.shape # (16, 128) # 计算每个vector属于哪个类群 D, I = kmeans.index.search(x, 1) I.shape # (1000, 1) I[:4] # array([[ 2], # [11], # [14], # [ 5]]) 2.2 PCA降维 1 2 3 4 5 6 7 8 9 10 11 # random training data mt = np.random.rand(1000, 40).astype(\u0026#39;float32\u0026#39;) mat = faiss.PCAMatrix (40, 10) mat.train(mt) assert mat.is_trained tr = mat.apply(mt) tr.shape # (1000, 10) # print this to show that the magnitude of tr\u0026#39;s columns is decreasing print (tr ** 2).sum(0) # 每列的方差递减 ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/731faiss%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E4%BC%BC%E6%90%9C%E7%B4%A2/","summary":"\u003cp\u003e\u003cstrong\u003eFaiss (Facebook AI Similarity Search)\u003c/strong\u003e 是一个用于高效相似向量搜索的库，特别适合处理大规模向量数据。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e它的核心功能是给定一个向量数据库，为当前的query vector(s) 寻找Top-K个相似向量。\u003c/li\u003e\n\u003cli\u003e此外也支持KNN聚类，PCA降维，数据量化等模块。\u003c/li\u003e\n\u003cli\u003e官方文档：https://github.com/facebookresearch/faiss/wiki\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 安装方式: 一个环境不能同时安装cpu与gpu两个版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epip install faiss-cpu\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003epip install faiss-gpu\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#007f7f\"\u003e# 下面以cpu版本为例\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch1 id=\"1-相似top-k查找\"\u003e1. 相似Top-K查找\u003c/h1\u003e\n\u003cp\u003eFaiss通过构建一个Index（索引）对象，用于建立可实现快速相似搜索的数据结构。\u003c/p\u003e","title":"Faiss向量数据库相似搜索"},{"content":" homogeneous graph ： 一种节点，一种边 heterogeneous graph: 多种节点，多种边 bipartite graph : 两种节点，一种边 1、DGLgraph结构 1.1 同构图 Cora论文关系图\u0026ndash;同构图(homogeneous)\n（1）节点：2708篇论文，节点特征表示每个论文有是否出现1433个关键词中信息；节点标签表示每个论文所述的7个类别之一。\n（2）边：10556个论文引用论文的关系，此外没有边的特征信息\n1 2 3 from dgl.data import CoraGraphDataset dataset = CoraGraphDataset() g = dataset[0] 节点信息 1 2 3 4 5 6 7 8 9 10 # 节点类型 g.ntypes # 节点数 g.number_of_nodes() # 节点的meta信息 g.ndata.keys() # 节点具体一种meta信息(特征)的维度 g.ndata[\u0026#39;feat\u0026#39;].shape # 节点具体一种meta信息(标签)的频数 Counter(g.ndata[\u0026#39;label\u0026#39;].numpy()) 边的信息 1 2 3 4 5 6 7 8 # 边的类型 g.etypes # 边的数目 g.number_of_edges() # 边的两端节点ID：sourece → target，以及边的ID g.edges(form=\u0026#34;all\u0026#34;) # 边的meta信息 g.edata.keys() 从头创建一个同构图 1 2 3 4 5 6 7 g = dgl.graph(([0, 0, 0, 0, 0], [1, 2, 3, 4, 5]), #edge的sourece与target num_nodes=6) #node number # 如不指定节点数，则取决于最大的节点id-1 g.ndata[\u0026#39;x\u0026#39;] = torch.randn(6, 3) g.ndata[\u0026#39;y\u0026#39;] = torch.tensor(np.random.randn(6,5)) g.edata[\u0026#39;w\u0026#39;] = torch.tensor([0.1, 0.6, 0.9, 0.7, 1.0]) 1.2 异构图 假设存在药物，蛋白两种节点的异构图，其中有药物-蛋白、药物-药物、蛋白-蛋白3种边\n1 2 3 4 5 6 7 8 9 10 11 12 import dgl import numpy as np import torch g = dgl.heterograph({ (\u0026#39;drug\u0026#39;, \u0026#39;interacts\u0026#39;, \u0026#39;drug\u0026#39;): (torch.tensor([0, 1]), torch.tensor([1, 2])), (\u0026#39;drug\u0026#39;, \u0026#39;targets\u0026#39;, \u0026#39;gene\u0026#39;): (torch.tensor([0, 1]), torch.tensor([2, 3])), (\u0026#39;gene\u0026#39;, \u0026#39;coexpress\u0026#39;, \u0026#39;gene\u0026#39;): (torch.tensor([1]), torch.tensor([2])) }) g.nodes[\u0026#39;drug\u0026#39;].data[\u0026#39;x\u0026#39;] = torch.ones(3, 1) g.nodes[\u0026#39;gene\u0026#39;].data[\u0026#39;x\u0026#39;] = torch.ones(4, 2) g.edges[\u0026#39;interacts\u0026#39;].data[\u0026#39;w\u0026#39;] = torch.ones(2, 1) 节点信息 1 2 3 4 5 6 # 节点类型 g.ntypes # 具体某一种节点类型的节点数(节点数取决于最大的节点id-1) g.num_nodes(\u0026#39;drug\u0026#39;) # 具体某一种节点类型的meta g.nodes[\u0026#39;drug\u0026#39;].data.keys() 边的类型 1 2 3 4 5 6 7 8 9 # 边的类型 g.etypes g.canonical_etypes # 具体某一种边的数目 g.num_edges(\u0026#34;interacts\u0026#34;) # 具体某一种边的ID信息 g.edges(etype=\u0026#34;interacts\u0026#34;, form=\u0026#39;all\u0026#39;) # 具体某一种边的meta信息 g.edges[\u0026#39;interacts\u0026#39;].data.keys() 1.3 其它操作 单向→双向 1 2 g0 = dgl.add_reverse_edges(g) g0.edges() 自己与自己 1 2 g0 = dgl.add_self_loop(g) g0.edges() 保存与加载图 1 2 dgl.save_graphs(\u0026#39;my.dgl\u0026#39;, g) (g,), _ = dgl.load_graphs(\u0026#39;my.dgl\u0026#39;) 更多 （1）图信息查询 https://docs.dgl.ai/api/python/dgl.DGLGraph.html#apigraph-querying-graph-structure\n（2）图信息修改 https://docs.dgl.ai/api/python/dgl.html#api-subgraph-extraction\n2、从文件读入DGL 1 2 3 import dgl ds = dgl.data.CSVDataset(\u0026#39;/path/to/dataset\u0026#39;) g = ds[0] 根据同构图与异构图，文件夹需要准备不同的文件\n2.1 同构图 需要包含以下3个文件\nmeta.yaml：指定边文件与节点文件 1 2 3 4 5 dataset_name: example_hoto_dataset edge_data: - file_name: edges.csv node_data: - file_name: nodes.csv nodes.csv：节点csv文件 1 2 3 4 node_id,label,train_mask,val_mask,test_mask,feat 0,1,False,True,True,\u0026#34;0.07816474278491703, 0.9137336384979067, 0.4654086994009452\u0026#34; 1,1,True,True,True,\u0026#34;0.05354099924658973, 0.8753101998792645, 0.33929432608774135\u0026#34; 2,1,True,False,True,\u0026#34;0.33234211884156384, 0.9370522452510665, 0.6694943496824788\u0026#34; edges.csv：边csv文件 1 2 3 4 src_id,dst_id,label,train_mask,val_mask,test_mask,feat 4,0,2,False,True,True,\u0026#34;0.5477868606453535, 0.4470617033458436, 0.936706701616337\u0026#34; 4,0,0,False,False,True,\u0026#34;0.9794634290792008, 0.23682038840665198, 0.049629338970987646\u0026#34; 0,3,1,True,True,True,\u0026#34;0.8586722047523594, 0.5746912787380253, 0.6462162561249654\u0026#34; 2.2 异构图 假设2种节点、2种边，需要包含以下2种文件\nmeta.yaml：指定边文件与节点文件 1 2 3 4 5 6 7 8 9 10 11 dataset_name: example_hete_dataset edge_data: - file_name: edges_0.csv etype: [user, follow, user] - file_name: edges_1.csv etype: [user, like, item] node_data: - file_name: nodes_0.csv ntype: user - file_name: nodes_1.csv ntype: item 边csv文件：edges_0.csv or edges_1.csv 1 2 3 4 5 src_id,dst_id,label,feat 4,4,1,\u0026#34;0.736833152378035,0.10522806046048205,0.9418796835016118\u0026#34; 3,4,2,\u0026#34;0.5749339182767451,0.20181320245665535,0.490938012147181\u0026#34; 1,4,2,\u0026#34;0.7697294432580938,0.49397782380750765,0.10864079337442234\u0026#34; 0,4,0,\u0026#34;0.1364240150959487,0.1393107840629273,0.7901988878812207\u0026#34; 节点csv文件：nodes_0.csv or nodes_1.csv 1 2 3 4 node_id,label,feat 0,2,\u0026#34;0.5400687466285844,0.7588441197954202,0.4268254673041745\u0026#34; 1,1,\u0026#34;0.08680051341900807,0.11446843700743892,0.7196969604886617\u0026#34; 2,2,\u0026#34;0.8964389655603473,0.23368113896545695,0.8813472954005022\u0026#34; 3、GNN模型 3.1 GNN层结构 GNN的核心是根据邻居信息更新节点特征，更新算法有GCN、Graphsage、GAT\u0026hellip; 根据预测目的，GNN可分为节点分类、回归，边的分类、回归，边是否存在的预测 关于边相关预测，本质上是使用两端节点信息作为边的特征信息 关于多层GNN的结构，大体如下： 1层的GNN：考虑邻居节点的信息 2层的GNN：考虑邻居以及邻居的邻居信息 3.2 sampler与batch模式 默认情况下，一轮epoch，GNN会考虑所有节点的所有邻居信息。\nsampler模式：在具体的某一层GNN中，只考虑节点的有限个邻居 batch模式：将训练集样本划分为多个小样本集，每个小样本集单独训练。 在设置sampler与batch模式下，每个小样本集的每一层GNN称之为block\n","permalink":"https://lishensuo.github.io/en/posts/bioinfo/801%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cdgl-01dgl%E5%9F%BA%E7%A1%80/","summary":"\u003cul\u003e\n\u003cli\u003ehomogeneous graph ： 一种节点，一种边\u003c/li\u003e\n\u003cli\u003eheterogeneous graph: 多种节点，多种边\u003c/li\u003e\n\u003cli\u003ebipartite graph    : 两种节点，一种边\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"https://raw.githubusercontent.com/lishensuo/images/main/image-20220730204438968.png\" alt=\"image-20220730204438968\"  /\u003e\r\n\u003c/p\u003e\n\u003ch2 id=\"1dglgraph结构\"\u003e1、DGLgraph结构\u003c/h2\u003e\n\u003ch3 id=\"11-同构图\"\u003e1.1 同构图\u003c/h3\u003e\n\u003cp\u003eCora论文关系图\u0026ndash;同构图(homogeneous)\u003c/p\u003e","title":"图神经网络DGL-01-DGL基础"},{"content":" 1 2 3 4 5 6 7 8 import dgl import dgl.nn as dglnn import torch import torch.nn as nn import torch.nn.functional as F import numpy as np 0、预测任务与数据 预测论文属于哪一种类别，即为多分类问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 data = dgl.data.CoraGraphDataset() g = data[0] graph = g # 节点ID node_id = g.nodes() # 节点特征 feature_name = \u0026#34;feat\u0026#34; # 节点标签 label_name = \u0026#34;label\u0026#34; #拆分训练集与测试集 train_mask = torch.ones(len(g.nodes()), dtype=torch.bool) train_mask[np.random.permutation(g.nodes())[:int(len(g.nodes())*0.7)]] = False test_mask = ~ train_mask 1、全局训练模型 所谓全局训练模型，就是最常规的训练方式。\n一轮epoch里，使用训练集优化模型，使用测试集评价模型\n1.1 定义GNN模型框架 示例化模型时需要提供每层的参数结构 模型计算时需要根据前向函数提供输入数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class GNN_model(nn.Module): #定义GNN层以及相关参数 def __init__(self, in_feats, hid_feats, out_feats, dropout): super().__init__() self.SAGE1 = dglnn.SAGEConv(in_feats=in_feats, out_feats=hid_feats, aggregator_type=\u0026#34;mean\u0026#34;) self.SAGE2 = dglnn.SAGEConv(in_feats=hid_feats, out_feats=out_feats, aggregator_type=\u0026#34;mean\u0026#34;) self.dropout = nn.Dropout(dropout) #定义前向传播函数 def forward(self, graph, inputs): h = F.relu(self.SAGE1(graph, inputs)) h = self.dropout(h) h = self.SAGE2(graph, h) return h # model = GNN_model(1433, 128, 7, 0.1) ## 自定义函数计算分类精确度 def evaluate(predict, label): pred_label = predict.argmax(1) correct = torch.sum(pred_label == label) acc = correct.item()*1.0 / len(label) return acc 1.2 定义训练模型流程 主涉及设置优化器，模型性能评，训练早停等\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def train(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=True): optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay) val_loss_best = 100000 trigger_times = -1 node_features = graph.ndata[feature_name] node_labels = graph.ndata[label_name] for epoch in range(num_epochs): model.train() predicts = model(graph, node_features) loss = F.cross_entropy(predicts[train_mask], node_labels[train_mask]) train_acc = evaluate(predicts[train_mask], node_labels[train_mask]) test_acc = evaluate(predicts[test_mask], node_labels[test_mask]) test_loss= F.cross_entropy(predicts[test_mask], node_labels[test_mask]) optimizer.zero_grad() loss.backward() optimizer.step() if verbose : print(\u0026#34;Epoch {:03d} | Loss {:.4f} | Train Acc {:.4f} | Test Loss {:.4f} | Test Acc {:.4f}\u0026#34;.format( epoch, loss.item(),train_acc,test_loss.item(),test_acc)) if test_loss.item() \u0026gt; val_loss_best: trigger_times += 1 if trigger_times \u0026gt;= patience: break else: trigger_times = 0 val_loss_best = test_loss.item() return loss.item(), val_loss_best, train_acc, test_acc #依次返回训练集损失、测试集损失、训练精度、测试精度 1.3 训练一次模型 1 2 3 4 5 6 7 8 9 10 11 12 13 #模型结构参数 in_feats, hid_feats, out_feats, dropout = 1433, 128, 7, 0.1 #模型训练参数 num_epochs, learning_rate, weight_decay, patience = 100, 0.01, 1e-4, 5 #实例化模型 model = GNN_model(in_feats, hid_feats, out_feats, dropout) #优化、训练模型 metrics = train(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=False) metrics # (0.004630064591765404, 0.6909242868423462, 1.0, 0.78) 1.4 K折交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 获得每一折的训练集与验证集掩码 def get_k_fold_data(k, j, node_id, shuffle=True): assert k \u0026gt; 1 fold_size = len(node_id) // k idx = slice(j*fold_size, (j+1)*fold_size) np.random.seed(42) if shuffle : node_id2 = np.random.permutation(node_id) else : node_id2 = node_id train_mask = torch.ones(len(node_id2) , dtype=torch.bool) train_mask[node_id2[idx]] = False test_mask = ~ train_mask return train_mask, test_mask # K折训练pipeline，返回每一折的训练结果 def k_fold(k, in_feats, hid_feats, out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience): k_fold_metrics = [] node_id = graph.nodes() for j in range(k): print(f\u0026#39;Fold-{j+1}\u0026#39;) train_mask, test_mask = get_k_fold_data(k, j, node_id) model = GNN_model(in_feats, hid_feats, out_feats, dropout) metrics = train(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=False) k_fold_metrics.append(metrics) return k_fold_metrics # 实际训练 k = 10 ## 其余参数同上 k_fold_metrics = k_fold(k, in_feats, hid_feats, out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience) np.array(k_fold_metrics).mean(0) 2、小批量训练模型 在mini-batch模式中的一轮epoch，在训练集中平均分为若干个batch，然后依次迭代训练；取最后一个batch的model作为该轮epoch的结果。\n2.1 DGL节点采样函数 MultiLayerFullNeighborSampler 设计采样层数，每个节点采样全部邻居 NeighborSampler 每一层中每个节点采样固定样本数量的邻居 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sampler = dgl.dataloading.MultiLayerFullNeighborSampler(2) dataloader = dgl.dataloading.DataLoader( g, nid, sampler, batch_size=32, shuffle=True) input_nodes, output_nodes, blocks = next(iter(dataloader)) # 小批量的32个节点 output_nodes # 小批量相连两层邻居涉及的所有节点 input_nodes # 聚合层情况，按顺序由外到内 print(blocks) # sampler = dgl.dataloading.NeighborSampler([5, 10]) 2.2 定义GNN模型框架 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class GNN_model_batch(nn.Module): def __init__(self, in_feats, hid_feats, out_feats, dropout): super().__init__() self.SAGE1 = dglnn.SAGEConv(in_feats=in_feats, out_feats=hid_feats, aggregator_type=\u0026#34;mean\u0026#34;) self.SAGE2 = dglnn.SAGEConv(in_feats=hid_feats, out_feats=out_feats, aggregator_type=\u0026#34;mean\u0026#34;) self.dropout = nn.Dropout(dropout) #与之前的区别主要体现在前向计算中，其中graph变成了blocks def forward(self, blocks, inputs): h = F.relu(self.SAGE1(blocks[0], inputs)) h = self.dropout(h) h = self.SAGE2(blocks[1], h) return h 2.3 定义训练模型流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def train_batch(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience,batch_size, verbose=True): #与之前的区别之一是多了一个batch_size参数 optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay) val_loss_best = 100000 trigger_times = -1 node_features = graph.ndata[feature_name] node_labels = graph.ndata[label_name] node_ids = graph.nodes() # 根据后续需要，设置不同的节点采样器 sampler = dgl.dataloading.MultiLayerFullNeighborSampler(2) train_dataloader = dgl.dataloading.DataLoader( graph, node_ids[train_mask], sampler, batch_size=batch_size, shuffle=True) all_train_dataloader = dgl.dataloading.DataLoader( graph, node_ids[train_mask], sampler, batch_size=len(node_ids[train_mask]), shuffle=False) all_test_dataloader = dgl.dataloading.DataLoader( graph, node_ids[test_mask], sampler, batch_size=len(node_ids[test_mask]), shuffle=False) for epoch in range(num_epochs): model.train() for it, (_, _, blocks) in enumerate(train_dataloader): x = blocks[0].srcdata[feature_name] #第一层 y = blocks[-1].dstdata[label_name] #最后一层 y_hat = model(blocks, x) loss = F.cross_entropy(y_hat, y) optimizer.zero_grad() loss.backward() optimizer.step() model.eval() _, _, blocks = next(iter(all_train_dataloader)) x = blocks[0].srcdata[feature_name] #第一层 y = blocks[-1].dstdata[label_name] #最后一层 y_hat = model(blocks, x) epoch_loss = F.cross_entropy(y_hat, y) train_acc = evaluate(y_hat, y) _, _, blocks = next(iter(all_test_dataloader)) x = blocks[0].srcdata[feature_name] #第一层 y = blocks[-1].dstdata[label_name] #最后一层 y_hat = model(blocks, x) test_loss = F.cross_entropy(y_hat, y) test_acc = evaluate(y_hat, y) if verbose: print(\u0026#34;Epoch {:03d} | Loss {:.4f} | Train Acc {:.4f} | Test Loss {:.4f} | Test Acc {:.4f} \u0026#34;.format( epoch, loss.item(),train_acc,test_loss.item(),test_acc)) if test_loss.item() \u0026gt; val_loss_best: trigger_times += 1 if trigger_times \u0026gt;= patience: break else: trigger_times = 0 val_loss_best = test_loss.item() return loss.item(), val_loss_best, train_acc, test_acc 2.4 训练一次模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 graph = g feature_name = \u0026#34;feat\u0026#34; label_name = \u0026#34;label\u0026#34; train_mask = torch.ones(len(g.nodes()), dtype=torch.bool) train_mask[np.random.permutation(g.nodes())[:int(len(g.nodes())*0.7)]] = False test_mask = ~ train_mask in_feats, hid_feats, out_feats, dropout = 1433, 128, 7, 0.1 num_epochs, learning_rate, weight_decay, patience = 100, 0.01, 1e-4, 5 batch_size = 32 model = GNN_model_batch(in_feats, hid_feats, out_feats, dropout) metrics = train_batch(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=False) 2.5 K折交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 生成K折训练集/测试集掩码函数同上 def k_fold(k, in_feats, hid_feats, out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience, batch_size): k_fold_metrics = [] node_id = graph.nodes() for j in range(k): print(f\u0026#39;Fold-{j+1}\u0026#39;) train_mask, test_mask = get_k_fold_data(k, j, node_id) model = GNN_model_batch(in_feats, hid_feats, out_feats, dropout) metrics = train_batch(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=False) k_fold_metrics.append(metrics) return k_fold_metrics k = 10 k_fold_metrics = k_fold(k, in_feats, hid_feats, out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience, batch_size) np.array(k_fold_metrics).mean(0) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/802%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cdgl-02%E5%90%8C%E6%9E%84%E5%9B%BE_%E8%8A%82%E7%82%B9%E5%88%86%E7%B1%BB/","summary":"\u003cdiv class=\"highlight\"\u003e\u003cdiv style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\n\u003ctable style=\"border-spacing:0;padding:0;margin:0;border:0;\"\u003e\u003ctr\u003e\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e1\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e2\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e3\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e4\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e5\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e6\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e7\n\u003c/span\u003e\u003cspan style=\"white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272\"\u003e8\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\n\u003ctd style=\"vertical-align:top;padding:0;margin:0;border:0;;width:100%\"\u003e\n\u003cpre tabindex=\"0\" style=\"color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e dgl\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e dgl.nn  \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e dglnn\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch.nn \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e nn\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e torch.nn.functional \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e F\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#fff;font-weight:bold\"\u003eimport\u003c/span\u003e numpy \u003cspan style=\"color:#fff;font-weight:bold\"\u003eas\u003c/span\u003e np\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/td\u003e\u003c/tr\u003e\u003c/table\u003e\n\u003c/div\u003e\n\u003c/div\u003e\u003ch2 id=\"0预测任务与数据\"\u003e0、预测任务与数据\u003c/h2\u003e\n\u003cp\u003e预测论文属于哪一种类别，即为多分类问题\u003c/p\u003e","title":"图神经网络DGL-02同构图_节点分类"},{"content":"（1）边回归问题，对图中已存在的边的定量(回归)/定性(分类)，结合训练得到的边的embedding做GNN神经网络预测。\n（2）边的embedding通常由两端节点计算而得，常采用点积或者拼接的方式。而节点embedding的更新同前。\n（3）由于节点拼接concat需要考虑先后顺序，所以可能需要考虑无向图(双向图)\n1 2 3 4 5 6 7 8 9 10 import dgl import dgl.nn as dglnn import torch import torch.nn as nn import torch.nn.functional as F import numpy as np import itertools from random import sample 0、预测数据与任务 假设100个药物两两之间已知存在1000个相互作用，边的标签为互作强度，药物节点有50个特征。 目的是预测两药物之间可能存在的相互作用强度是多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 eids_raw = [i for i in itertools.combinations(range(0,100), 2)] eids_sp1k = sample(eids_raw, 1000) src = np.array(eids_sp1k)[:,0] dst = np.array(eids_sp1k)[:,1] g_drug = dgl.graph((src, dst), num_nodes=100) g_drug.ndata[\u0026#39;feature\u0026#39;] = torch.randn(100, 50) # 节点特征 g_drug.edata[\u0026#39;label\u0026#39;] = torch.randn(1000) # 边的label #添加双向边：前1k与后1k一一对应 g_drug_bi = dgl.add_reverse_edges(g_drug) g_drug_bi.edata[\u0026#34;label\u0026#34;] = torch.concat((g_drug.edata[\u0026#34;label\u0026#34;], g_drug.edata[\u0026#34;label\u0026#34;])) print(g_drug_bi.num_nodes()) # 100 print(g_drug_bi.num_edges()) # 2000 1、全局训练模型 1.1 定义GNN模型框架 模型分为两部分：第一部分根据图关系更新节点特征，第二部分根据组成节点计算边的特征\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class GNN_MLP_model(nn.Module): #定义GNN层以及相关参数 def __init__(self, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout): super().__init__() #GNN更新节点特征 self.SAGE1 = dglnn.SAGEConv(in_feats=in_feats, out_feats=hid_feats_1, aggregator_type=\u0026#34;mean\u0026#34;) self.SAGE2 = dglnn.SAGEConv(in_feats=hid_feats_1, out_feats=hid_feats_2, aggregator_type=\u0026#34;mean\u0026#34;) #MLP更新边的特征 self.MLP1 = nn.Linear(hid_feats_2*2, mlp_hid_feats_1) self.MLP2 = nn.Linear(mlp_hid_feats_1, mlp_out_feats) self.dropout = nn.Dropout(dropout) def apply_edges(self, edges): h_u, h_v = edges.src[\u0026#39;h\u0026#39;], edges.dst[\u0026#39;h\u0026#39;] h_concat = torch.cat([h_u, h_v], 1) h2 = F.relu(self.MLP1(h_concat)) h2 = self.dropout(h2) h2 = self.MLP2(h2) return {\u0026#39;score\u0026#39;:h2} #定义前向传播函数:需要输入图结构、节点特征 def forward(self, graph, inputs): # GNN部分 h = F.relu(self.SAGE1(graph, inputs)) h = self.dropout(h) h = F.relu(self.SAGE2(graph, h)) # MLP部分 with graph.local_scope(): graph.ndata[\u0026#39;h\u0026#39;] = h graph.apply_edges(self.apply_edges) return graph.edata[\u0026#39;score\u0026#39;] 1.2 定义训练模型流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def train(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=True): optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay) node_feats = graph.ndata[feature_name] edge_labels = graph.edata[label_name].reshape((-1,1)) val_loss_best = 100000 trigger_times = -1 for epoch in range(num_epochs): model.train() predict_labels = model(graph, node_feats) loss = F.mse_loss(predict_labels[train_mask], edge_labels[train_mask]) model.eval() test_loss = F.mse_loss(predict_labels[test_mask], edge_labels[test_mask]) optimizer.zero_grad() loss.backward() optimizer.step() if verbose : print(\u0026#34;Epoch {:03d} | Loss {:.4f} | Test Loss {:.4f} \u0026#34;.format( epoch, loss.item(), test_loss.item())) if test_loss.item() \u0026gt; val_loss_best: trigger_times += 1 if trigger_times \u0026gt;= patience: break else: trigger_times = 0 val_loss_best = test_loss.item() return loss.item(), test_loss.item() 1.3 训练一次模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graph = g_drug_bi feature_name = \u0026#34;feature\u0026#34; label_name = \u0026#34;label\u0026#34; # 按同一种边划分出训练集与测试集 train_mask = torch.zeros(int(g_drug_bi.num_edges()/2), dtype=torch.bool).bernoulli(0.7).tile((2,)) test_mask = ~ train_mask in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout = 50, 32, 16, 16, 1, 0.1 num_epochs, learning_rate, weight_decay, patience = 100, 0.01, 1e-4, 5 #实例化模型 model = GNN_MLP_model(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) #训练模型 metrics = train(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=True) 1.4 K折交叉验证 定义生存定j/k折的训练集与测试集掩码，其中要确保同一种边(不同方向)位于同一个集合 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def get_k_fold_data(k, j, edge_id, shuffle=True): assert k \u0026gt; 1 train_mask = torch.ones(int(len(edge_id)/2) , dtype=torch.bool) np.random.seed(42) if shuffle: edge_id2 = np.random.permutation(range(len(train_mask))) else : edge_id2 = train_mask fold_size = len(train_mask) // k idx = slice(j*fold_size, (j+1)*fold_size) train_mask[edge_id2[idx]] = False train_mask = train_mask.tile((2,)) test_mask = ~ train_mask return train_mask, test_mask # edge_id = g_drug_bi.edges(form=\u0026#34;all\u0026#34;)[2] # train_mask, test_mask = get_k_fold_data(10, 0, edge_id) K折训练 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def k_fold(k, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience): k_fold_metrics = [] #收集每一折的结果 edge_id = graph.edges(form=\u0026#34;all\u0026#34;)[2] for j in range(k): print(f\u0026#39;Fold-{j+1}\u0026#39;) train_mask, test_mask = get_k_fold_data(k, j, edge_id) model = GNN_MLP_model(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) metrics = train(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=False) k_fold_metrics.append(metrics) return k_fold_metrics k = 10 k_fold_metrics = k_fold(k, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience) np.array(k_fold_metrics).mean(0) 2、小批量训练模型 2.1 DGL边采样器 如上可知需要先更新节点特征、再计算边的特征，所以边采样器同样需要考虑边两端节点的邻居节点。\n如下表示从所有边中，随机抽取10条边的相关信息(两端节点做两层聚合)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 E = int(g_drug_bi.number_of_edges()/2) reverse_eids = torch.cat([torch.arange(E, 2 * E), torch.arange(0, E)]) sampler = dgl.dataloading.MultiLayerFullNeighborSampler(2) sampler = dgl.dataloading.as_edge_prediction_sampler( sampler, exclude=\u0026#39;reverse_id\u0026#39;, reverse_eids=reverse_eids) train_eid = graph.edges(form=\u0026#34;all\u0026#34;)[2] dataloader = dgl.dataloading.DataLoader( g_drug_bi, train_eid, sampler, batch_size=32, shuffle=True) input_nodes, pair_graph, blocks = next(iter(dataloader)) # pair_graph：包含10条边的子图结构 # blocks：上图中涉及结构的两层聚合结构 # input_nodes：blocks第一层所需要的全部节点信息 2.2 定义GNN模型框架 与1.1部分基本类似，只是前向传播的输入数据由全图变成了局部的blocks\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class GNN_MLP_model_batch(nn.Module): #定义GNN层以及相关参数 def __init__(self, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout): super().__init__() self.SAGE1 = dglnn.SAGEConv(in_feats=in_feats, out_feats=hid_feats_1, aggregator_type=\u0026#34;mean\u0026#34;) self.SAGE2 = dglnn.SAGEConv(in_feats=hid_feats_1, out_feats=hid_feats_2, aggregator_type=\u0026#34;mean\u0026#34;) self.MLP1 = nn.Linear(hid_feats_2*2, mlp_hid_feats_1) self.MLP2 = nn.Linear(mlp_hid_feats_1, mlp_out_feats) self.dropout = nn.Dropout(dropout) def apply_edges(self, edges): h_u, h_v = edges.src[\u0026#39;h\u0026#39;], edges.dst[\u0026#39;h\u0026#39;] h_concat = torch.cat([h_u, h_v], 1) h2 = F.relu(self.MLP1(h_concat)) h2 = self.dropout(h2) h2 = h2 = torch.sigmoid(self.MLP2(h2)) return {\u0026#39;score\u0026#39;:h2} #定义前向传播函数 def forward(self, blocks, inputs, edge_subgraph): # GNN部分 h = F.relu(self.SAGE1(blocks[0], inputs)) h = self.dropout(h) h = F.relu(self.SAGE2(blocks[1], h)) # MLP部分 with edge_subgraph.local_scope(): edge_subgraph.ndata[\u0026#39;h\u0026#39;] = h edge_subgraph.apply_edges(self.apply_edges) return edge_subgraph.edata[\u0026#39;score\u0026#39;] 2.3 定义训练模型流程 每一轮中分为若干的mini-batch迭代训练，最后将所有的train/test edge的score作为该轮epoch的训练结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def train_batch(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=True): optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay) node_feats = graph.ndata[feature_name] val_loss_best = 100000 trigger_times = -1 E = int(graph.number_of_edges()/2) reverse_eids = torch.cat([torch.arange(E, 2 * E), torch.arange(0, E)]) sampler = dgl.dataloading.MultiLayerFullNeighborSampler(2) sampler = dgl.dataloading.as_edge_prediction_sampler( sampler, exclude=\u0026#39;reverse_id\u0026#39;, reverse_eids=reverse_eids) train_eid = graph.edges(form=\u0026#34;all\u0026#34;)[2][train_mask] test_eid = graph.edges(form=\u0026#34;all\u0026#34;)[2][test_mask] train_dataloader = dgl.dataloading.DataLoader( graph, train_eid, sampler, batch_size=batch_size, shuffle=True) all_train_dataloader = dgl.dataloading.DataLoader( graph, train_eid, sampler, batch_size=len(train_eid), # 全部训练集作为一个batch，计算每个epoch的train loss shuffle=False) all_test_dataloader = dgl.dataloading.DataLoader( graph, test_eid, sampler, batch_size=len(test_eid), # 全部测试集作为一个batch，计算每个epoch的test loss shuffle=False) for epoch in range(num_epochs): model.train() for it, (input_nodes, pair_graph, blocks) in enumerate(train_dataloader): predict_labels = model(blocks, node_feats[input_nodes], pair_graph) edge_labels = pair_graph.edata[\u0026#34;label\u0026#34;] loss = F.mse_loss(predict_labels, edge_labels.reshape((-1,1))) optimizer.zero_grad() loss.backward() optimizer.step() model.eval() input_nodes, pair_graph, blocks = next(iter(all_train_dataloader)) predict_labels = model(blocks, node_feats[input_nodes], pair_graph) edge_labels = pair_graph.edata[\u0026#34;label\u0026#34;] epoch_loss = F.mse_loss(predict_labels, edge_labels.reshape((-1,1))) model.eval() input_nodes, pair_graph, blocks = next(iter(all_test_dataloader)) predict_labels = model(blocks, node_feats[input_nodes], pair_graph) edge_labels = pair_graph.edata[\u0026#34;label\u0026#34;] test_loss = F.mse_loss(predict_labels, edge_labels.reshape((-1,1))) if verbose : print(\u0026#34;Epoch {:03d} | Loss {:.4f} | Test Loss {:.4f} \u0026#34;.format( epoch, loss.item(), test_loss.item())) if test_loss.item() \u0026gt; val_loss_best: trigger_times += 1 if trigger_times \u0026gt;= patience: break else: trigger_times = 0 val_loss_best = test_loss.item() return epoch_loss.item(), test_loss.item() 2.4 训练一次模型 1 2 3 4 5 6 7 8 #其余参数同前 batch_size = 32 #模型实例化 model = GNN_MLP_model_batch(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) #模型训练 metrics = train_batch(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=True) 2.5 K折交叉验证 生成第i/k折的训练集/测试集掩码的函数同1.4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def k_fold(k, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience, batch_size): k_fold_metrics = [] edge_id = graph.edges(form=\u0026#34;all\u0026#34;)[2] for j in range(k): print(f\u0026#39;Fold-{j+1}\u0026#39;) train_mask, test_mask = get_k_fold_data(k, j, edge_id) model = GNN_MLP_model_batch(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) metrics = train_batch(model, graph, feature_name, label_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=False) k_fold_metrics.append(metrics) return k_fold_metrics k = 10 k_fold_metrics = k_fold(k, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout, graph, feature_name, label_name, num_epochs, learning_rate, weight_decay, patience, batch_size) np.array(k_fold_metrics).mean(0) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/803%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cdgl-03%E5%90%8C%E6%9E%84%E5%9B%BE_%E8%BE%B9%E5%9B%9E%E5%BD%92/","summary":"\u003cp\u003e（1）边回归问题，对图中已存在的边的定量(回归)/定性(分类)，结合训练得到的边的embedding做GNN神经网络预测。\u003c/p\u003e\n\u003cp\u003e（2）边的embedding通常由两端节点计算而得，常采用点积或者拼接的方式。而节点embedding的更新同前。\u003c/p\u003e","title":"图神经网络DGL-03同构图_边回归"},{"content":"边的预测问题即预测两个节点间是否可能存在边，可以视为二分类问题。\n在训练时，首先同样要先更新节点信息，然后计算边的特征\u0026mdash;\n将图中已知存在的边作为阳性边，标签为1 随机抽取图中不存在边的两节点组成的边作为阴性边，标签为0 0、预测数据与任务 假设100个药物两两之间已知存在1000个相互作用，药物节点有50个特征。\n目的是预测两药物之间可能存在相互作用的概率是多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 eids_raw = [i for i in itertools.combinations(range(0,100), 2)] eids_sp1k = sample(eids_raw, 1000) src = np.array(eids_sp1k)[:,0] dst = np.array(eids_sp1k)[:,1] g_drug = dgl.graph((src, dst), num_nodes=100) g_drug.ndata[\u0026#39;feature\u0026#39;] = torch.randn(100, 50) # 节点特征 #添加双向边：前1k与后1k一一对应 g_drug_bi = dgl.add_reverse_edges(g_drug) g_drug_bi.edata[\u0026#34;label\u0026#34;] = torch.concat((g_drug.edata[\u0026#34;label\u0026#34;], g_drug.edata[\u0026#34;label\u0026#34;])) print(g_drug_bi.num_nodes()) # 100 print(g_drug_bi.num_edges()) # 2000 1、全局训练模型 1.1 定义GNN模型框架 基本与边回归相同，模型分为两部分：第一部分根据图关系更新节点特征，第二部分根据组成节点计算边的特征\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class GNN_MLP_model(nn.Module): #定义GNN层以及相关参数 def __init__(self, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout): super().__init__() #GNN更新节点特征 self.SAGE1 = dglnn.SAGEConv(in_feats=in_feats, out_feats=hid_feats_1, aggregator_type=\u0026#34;mean\u0026#34;) self.SAGE2 = dglnn.SAGEConv(in_feats=hid_feats_1, out_feats=hid_feats_2, aggregator_type=\u0026#34;mean\u0026#34;) #MLP更新边的特征 self.MLP1 = nn.Linear(hid_feats_2*2, mlp_hid_feats_1) self.MLP2 = nn.Linear(mlp_hid_feats_1, mlp_out_feats) self.dropout = nn.Dropout(dropout) def apply_edges(self, edges): h_u, h_v = edges.src[\u0026#39;h\u0026#39;], edges.dst[\u0026#39;h\u0026#39;] h_concat = torch.cat([h_u, h_v], 1) h2 = F.relu(self.MLP1(h_concat)) h2 = self.dropout(h2) #与边回归的主要区别之一：本质上是二分类问题 h2 = torch.sigmoid(self.MLP2(h2)) return {\u0026#39;score\u0026#39;:h2} #定义前向传播函数:需要输入图结构、节点特征 def forward(self, graph, inputs, edge_graph): # GNN部分 h = F.relu(self.SAGE1(graph, inputs)) h = self.dropout(h) h = F.relu(self.SAGE2(graph, h)) # MLP部分 with edge_graph.local_scope(): edge_graph.ndata[\u0026#39;h\u0026#39;] = h edge_graph.apply_edges(self.apply_edges) return edge_graph.edata[\u0026#39;score\u0026#39;] 定义拆分训练集与测试集子图的函数 阳性边更新节点训练集 阳性边训练集、阳性边测试集 阴性边训练接、阴性边测试集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import scipy.sparse as sp import numpy as np def produce_5_graph(graph, train_mask, test_mask): u, v = graph.edges() eids = np.arange(graph.number_of_edges()) #用于更新节点的图(排除测试集的边) train_g = dgl.remove_edges(graph, eids[test_mask]) #阳性边的训练集/测试集 train_pos_g = dgl.graph((u[eids[train_mask]], v[eids[train_mask]]), num_nodes=graph.number_of_nodes()) test_pos_g = dgl.graph((u[eids[test_mask]], v[eids[test_mask]]), num_nodes=graph.number_of_nodes()) #阴性边的训练集/测试集 adj = sp.coo_matrix((np.ones(len(u)), (u.numpy(), v.numpy()))) adj_neg = 1 - adj.todense() - np.eye(graph.number_of_nodes()) neg_u, neg_v = np.where(adj_neg != 0) neg_eids = np.random.choice(len(neg_u), graph.number_of_edges(), replace=False) train_neg_g = dgl.graph((neg_u[neg_eids[train_mask]], neg_v[neg_eids[train_mask]]), num_nodes=graph.number_of_nodes()) test_neg_g = dgl.graph((neg_u[neg_eids[test_mask]], neg_v[neg_eids[test_mask]]), num_nodes=graph.number_of_nodes()) return train_g, train_pos_g, test_pos_g, train_neg_g, test_neg_g 1.2 定义训练模型流程 首先定义一个评价模型的函数，返回loss与auc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from sklearn.metrics import roc_auc_score def loss_evaluate(model, train_g, pos_g, neg_g, mode=\u0026#34;train\u0026#34;): if mode==\u0026#34;train\u0026#34;: model.train() else: model.eval() pos_score = model(train_g, train_g.ndata[feature_name], pos_g) neg_score = model(train_g, train_g.ndata[feature_name], neg_g) scores = torch.cat([pos_score, neg_score]).reshape((-1)) labels = torch.cat([torch.ones(pos_score.shape[0]), torch.zeros(neg_score.shape[0])]) loss = F.binary_cross_entropy(scores, labels) auc = roc_auc_score(labels.detach().numpy(), scores.detach().numpy()) return loss, auc 训练模型流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def train(model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=True): train_g, train_pos_g, test_pos_g, train_neg_g, test_neg_g = produce_5_graph(graph, train_mask, test_mask) optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay) val_loss_best = 100000 trigger_times = -1 for epoch in range(num_epochs): loss, auc = loss_evaluate(model, train_g, train_pos_g, train_neg_g) test_loss,test_auc = loss_evaluate(model, train_g, test_pos_g, test_neg_g) optimizer.zero_grad() loss.backward() optimizer.step() if verbose : print(\u0026#34;Epoch {:03d} | Loss {:.4f} | Auc {:.4f} | Test Loss {:.4f} | Test Auc {:.4f} \u0026#34;.format( epoch, loss.item(), auc, test_loss.item(), test_auc)) if test_loss.item() \u0026gt; val_loss_best: trigger_times += 1 if trigger_times \u0026gt;= patience: break else: trigger_times = 0 val_loss_best = test_loss.item() return loss.item(), auc, test_loss.item(), test_auc 1.3 训练一次模型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 graph = g_drug_bi feature_name = \u0026#34;feature\u0026#34; # 按同一种边划分出训练集与测试集 train_mask = torch.zeros(int(g_drug_bi.num_edges()/2), dtype=torch.bool).bernoulli(0.7).tile((2,)) test_mask = ~ train_mask in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout = 50, 32, 16, 16, 1, 0.1 num_epochs, learning_rate, weight_decay, patience = 100, 0.01, 1e-4, 5 #实例化模型 model = GNN_MLP_model(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) #训练模型 metrics = train(model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=True) 1.4 K折交叉验证 生成第i/k折的训练集与测试集掩码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def get_k_fold_data(k, j, edge_id, shuffle=True): assert k \u0026gt; 1 train_mask = torch.ones(int(len(edge_id)/2) , dtype=torch.bool) np.random.seed(42) if shuffle: edge_id2 = np.random.permutation(range(len(train_mask))) else : edge_id2 = train_mask fold_size = len(train_mask) // k idx = slice(j*fold_size, (j+1)*fold_size) train_mask[edge_id2[idx]] = False train_mask = train_mask.tile((2,)) test_mask = ~ train_mask return train_mask, test_mask k折训练流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def k_fold(k, model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience): k_fold_metrics = [] #收集每一折的结果 edge_id = graph.edges(form=\u0026#34;all\u0026#34;)[2] for j in range(k): print(f\u0026#39;Fold-{j+1}\u0026#39;) train_mask, test_mask = get_k_fold_data(k, j, edge_id) model = GNN_MLP_model(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) metrics = train(model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, verbose=False) k_fold_metrics.append(metrics) return k_fold_metrics k = 10 k_fold_metrics = k_fold(k, model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience) np.array(k_fold_metrics).mean(0) 2、小批量训练模型 2.1 DGL阳性/阴性边采样器 与边回归任务的边采样器大致相同，多了一个采集阴性边的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 eids = np.arange(graph.number_of_edges()) train_eid = graph.edges(form=\u0026#34;all\u0026#34;)[2][train_mask] sampler = dgl.dataloading.MultiLayerFullNeighborSampler(2) sampler = dgl.dataloading.as_edge_prediction_sampler( sampler, negative_sampler=dgl.dataloading.negative_sampler.Uniform(1)) dataloader = dgl.dataloading.DataLoader( g, train_eids, sampler, batch_size=16, shuffle=True) input_nodes, positive_graph, negative_graph, blocks = next(iter(dataloader)) positive_graph.num_edges(),negative_graph.num_edges() # (16, 16) 2.2 定义GNN模型框架 在前向传播过程有所区别\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class GNN_MLP_model_batch(nn.Module): #定义GNN层以及相关参数 def __init__(self, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout): super().__init__() self.SAGE1 = dglnn.SAGEConv(in_feats=in_feats, out_feats=hid_feats_1, aggregator_type=\u0026#34;mean\u0026#34;) self.SAGE2 = dglnn.SAGEConv(in_feats=hid_feats_1, out_feats=hid_feats_2, aggregator_type=\u0026#34;mean\u0026#34;) self.MLP1 = nn.Linear(hid_feats_2*2, mlp_hid_feats_1) self.MLP2 = nn.Linear(mlp_hid_feats_1, mlp_out_feats) self.dropout = nn.Dropout(dropout) def apply_edges(self, edges): h_u = edges.src[\u0026#39;h\u0026#39;] h_v = edges.dst[\u0026#39;h\u0026#39;] h_concat = torch.cat([h_u, h_v], 1) h2 = F.relu(self.MLP1(h_concat)) h2 = self.dropout(h2) h2 = torch.sigmoid(self.MLP2(h2)) return {\u0026#39;score\u0026#39;:h2} #定义前向传播函数 ## blocks用于更新节点 ## edge_subgraph用于计算目标边的特征 def forward(self, blocks, inputs, edge_subgraph): # GNN部分 h = F.relu(self.SAGE1(blocks[0], inputs)) h = self.dropout(h) h = F.relu(self.SAGE2(blocks[1], h)) # MLP部分 with edge_subgraph.local_scope(): edge_subgraph.ndata[\u0026#39;h\u0026#39;] = h edge_subgraph.apply_edges(self.apply_edges) return edge_subgraph.edata[\u0026#39;score\u0026#39;] 2.3 定义训练模型流程 计算损失函数与AUC指标 1 2 3 4 5 6 7 8 9 10 11 12 13 def loss_evaluate_batch(model, blocks, pos_g, neg_g, input_nodes, node_feats, mode=\u0026#34;train\u0026#34;): if mode==\u0026#34;train\u0026#34;: model.train() else: model.eval() pos_score = model(blocks, node_feats[input_nodes], pos_g) neg_score = model(blocks, node_feats[input_nodes], neg_g) scores = torch.cat([pos_score, neg_score]).reshape((-1)) labels = torch.cat([torch.ones(pos_score.shape[0]), torch.zeros(neg_score.shape[0])]) loss = F.binary_cross_entropy(scores, labels) auc = roc_auc_score(labels.detach().numpy(), scores.detach().numpy()) return loss, auc 训练流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def train_batch(model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=True): optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay) node_feats = graph.ndata[feature_name] val_loss_best = 100000 trigger_times = -1 train_eids = graph.edges(form=\u0026#34;all\u0026#34;)[2][train_mask] test_eids = graph.edges(form=\u0026#34;all\u0026#34;)[2][test_mask] sampler = dgl.dataloading.MultiLayerFullNeighborSampler(2) sampler = dgl.dataloading.as_edge_prediction_sampler( sampler, negative_sampler=dgl.dataloading.negative_sampler.Uniform(1)) train_dataloader = dgl.dataloading.DataLoader( graph, train_eids, sampler, batch_size=batch_size, shuffle=True) all_train_dataloader = dgl.dataloading.DataLoader( graph, train_eids, sampler, batch_size=len(train_eids), shuffle=False) all_test_dataloader = dgl.dataloading.DataLoader( graph, test_eids, sampler, batch_size=len(test_eids), shuffle=False) for epoch in range(num_epochs): for it, (input_nodes, positive_graph, negative_graph, blocks) in enumerate(train_dataloader): loss, auc = loss_evaluate_batch(model, blocks, positive_graph, negative_graph, input_nodes, node_feats, mode=\u0026#34;train\u0026#34;) optimizer.zero_grad() loss.backward() optimizer.step() # 该epoch的训练集loss与auc input_nodes, positive_graph, negative_graph, blocks = next(iter(all_train_dataloader)) loss, auc = loss_evaluate_batch(model, blocks, positive_graph, negative_graph, input_nodes, node_feats, mode=\u0026#34;eval\u0026#34;) # 该epoch的测试集loss与auc input_nodes, positive_graph, negative_graph, blocks = next(iter(all_test_dataloader)) test_loss, test_auc = loss_evaluate_batch(model, blocks, positive_graph, negative_graph, input_nodes, node_feats, mode=\u0026#34;eval\u0026#34;) if verbose : print(\u0026#34;Epoch {:03d} | Loss {:.4f} | Auc {:.4f} | Test Loss {:.4f} | Test Auc {:.4f} \u0026#34;.format( epoch, loss.item(), auc, test_loss.item(), test_auc)) if test_loss.item() \u0026gt; val_loss_best: trigger_times += 1 if trigger_times \u0026gt;= patience: break else: trigger_times = 0 val_loss_best = test_loss.item() return loss.item(), auc, test_loss.item(), test_auc 2.4 训练一次模型 1 2 3 4 5 6 # 其余参数同1.3 batch_size = 64 model = GNN_MLP_model_batch(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) metrics = train_batch(model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=True) 2.5 K折交叉验证 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 生成第i/k折训练集与测试集掩码的函数同1.4 def k_fold(k, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout, graph, feature_name, num_epochs, learning_rate, weight_decay, patience, batch_size): k_fold_metrics = [] edge_id = graph.edges(form=\u0026#34;all\u0026#34;)[2] for j in range(k): print(f\u0026#39;Fold-{j+1}\u0026#39;) train_mask, test_mask = get_k_fold_data(k, j, edge_id) model = GNN_MLP_model_batch(in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout) metrics = train_batch(model, graph, feature_name, train_mask, test_mask, num_epochs, learning_rate, weight_decay, patience, batch_size, verbose=True) k_fold_metrics.append(metrics) return k_fold_metrics k = 10 batch_size = 64 k_fold_metrics = k_fold(k, in_feats, hid_feats_1, hid_feats_2, mlp_hid_feats_1, mlp_out_feats, dropout, graph, feature_name, num_epochs, learning_rate, weight_decay, patience, batch_size) ","permalink":"https://lishensuo.github.io/en/posts/bioinfo/804%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9Cdgl-04%E5%90%8C%E6%9E%84%E5%9B%BE_%E8%BE%B9%E9%A2%84%E6%B5%8B/","summary":"\u003cp\u003e边的预测问题即预测两个节点间是否可能存在边，可以视为二分类问题。\u003c/p\u003e\n\u003cp\u003e在训练时，首先同样要先更新节点信息，然后计算边的特征\u0026mdash;\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将图中已知存在的边作为阳性边，标签为1\u003c/li\u003e\n\u003cli\u003e随机抽取图中不存在边的两节点组成的边作为阴性边，标签为0\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"0预测数据与任务\"\u003e0、预测数据与任务\u003c/h1\u003e\n\u003cp\u003e假设100个药物两两之间已知存在1000个相互作用，药物节点有50个特征。\u003c/p\u003e","title":"图神经网络DGL-03同构图_边预测"},{"content":" 李申锁，男，在读研究生，学习生信ing\n此前以小贝学生信为昵称在简书平台写一些学习心得。于2022年4月10日创建此博客，记录今后学习生信的过程。\n如你也对博客的内容感兴趣，欢迎邮件交流，一起学习！\nEmail : lishensuo@163.com\nGithub: https://github.com/lishensuo\n简书 ：https://www.jianshu.com/u/423436813cc4\n2022年1月1日 摄于上海天文馆\nAll posts 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 setwd(\u0026#34;C:\\\\Users\\\\xiaoxin\\\\Desktop\\\\Blog\\\\content\\\\posts\u0026#34;) library(tidyverse) dir_bioinfo = list.files(\u0026#34;bioinfo/\u0026#34;)[-1] %\u0026gt;% str_match(pattern = \u0026#39;([0-9]{3})(.*)\u0026#39;) %\u0026gt;% .[,3] %\u0026gt;% paste0(1:length(.), \u0026#34;、\u0026#34;, .) %\u0026gt;% paste0(collapse = \u0026#34;\\n\\n\u0026#34;) %\u0026gt;% paste0(\u0026#34;## Part1: 生信数据分析\\n\u0026#34;, .) dir_program = list.files(\u0026#34;program/\u0026#34;)[-1] %\u0026gt;% str_match(pattern = \u0026#39;([0-9]{3})(.*)\u0026#39;) %\u0026gt;% .[,3] %\u0026gt;% paste0(1:length(.), \u0026#34;、\u0026#34;, .) %\u0026gt;% paste0(collapse = \u0026#34;\\n\\n\u0026#34;) %\u0026gt;% paste0(\u0026#34;\\n\\n## Part2: R\u0026amp;Python\u0026amp;Shell\\n\u0026#34;, .) dir_basic = list.files(\u0026#34;basic/\u0026#34;)[-1] %\u0026gt;% str_match(pattern = \u0026#39;([0-9]{3})(.*)\u0026#39;) %\u0026gt;% .[,3] %\u0026gt;% paste0(1:length(.), \u0026#34;、\u0026#34;, .) %\u0026gt;% paste0(collapse = \u0026#34;\\n\\n\u0026#34;) %\u0026gt;% paste0(\u0026#34;\\n\\n## Part3: 文献与基础\\n\u0026#34;, .) cat(paste0(dir_bioinfo, dir_program, dir_basic)) 1 2 3 4 5 hugo cd public/ git add . git commit -m \u0026#39;add blogs\u0026#39; git push -u origin master Part1: 生信数据分析 1、conda环境下载管理软件、R包.md\n2、服务器外网文件传输\u0026ndash;奶牛快传、阿里云盘.md\n3、单细胞分析工具\u0026ndash;cellranger比对.md\n4、单细胞分析工具\u0026ndash;Seurat4基础流程.md\n5、单细胞分析工具\u0026ndash;monocle轨迹分析.md\n6、单细胞分析工具\u0026ndash;CellChat细胞通讯分析.md\n7、单细胞分析工具\u0026ndash;转录因子pySCENIC.md\n8、单细胞分析工具\u0026ndash;Palantir轨迹分析-.md\n9、单细胞分析工具\u0026ndash;Seurat空间转录组.md\n10、单细胞分析工具\u0026ndash;hdWGCNA共表达网络.md\n11、单细胞分析工具\u0026ndash;ECAUGT提取hECA数据.md\n12、单细胞分析工具\u0026ndash;infercnv拷贝数变异鉴定.md\n13、单细胞分析工具\u0026ndash;SingleR细胞类型注释.md\n14、单细胞分析工具\u0026ndash;细胞周期分析.md\n15、单细胞分析工具\u0026ndash;多样本批次校正.md\n16、单细胞分析工具\u0026ndash;SingleCellExperiment对象格式.md\n17、单细胞分析工具\u0026ndash;scanpy基础用法.md\n18、单细胞分析工具\u0026ndash;RNAvelocity速率分析.md\n19、单细胞分析工具\u0026ndash;CytoTRACE轨迹分析.md\n20、单细胞分析工具\u0026ndash;cellphonedb细胞通讯分析.md\n21、单细胞分析工具\u0026ndash;DoubletFinder识别双细胞.md\n22、单细胞分析工具\u0026ndash;基于文献的细胞类型注释marker.md\n23、单细胞分析工具\u0026ndash;NicheNet细胞通讯分析.md\n24、单细胞分析工具\u0026ndash;MAST差异基因分析.md\n25、单细胞分析工具\u0026ndash;Scissor表型相关亚群鉴定.md\n26、单细胞分析工具\u0026ndash;MARVEL单细胞可变剪切.md\n27、单细胞分析工具\u0026ndash;scCustomize包改进Seurat可视化.md\n28、单细胞分析工具\u0026ndash;Asgard单细胞药物重定向.md\n29、单细胞分析工具\u0026ndash;scSTAR挖掘分组样本细胞亚型.md\n30、单细胞分析工具\u0026ndash;celldancer细胞速率分析.md\n31、单细胞分析工具\u0026ndash;sccode综合差异分析.md\n32、单细胞分析工具\u0026ndash;sccoda细胞组成比较.md\n33、单细胞分析工具\u0026ndash;COSG鉴定marker基因.md\n34、单细胞分析工具\u0026ndash;ShinyCell交互式展示单细胞数据.md\n35、差异分析R包-DESeq2+edgeR+limma.md\n36、TCGAbiolinks包-TCGA数据下载与差异分析.md\n37、表达矩阵TPM,FPKM标准化.md\n38、从GEO下载芯片或RNAseq测序数据.md\n39、下载测序数据SRR与fastq.gz方式.md\n40、Refgenie下载参考基因组.md\n41、STRINGdb包下载蛋白PPI数据.md\n42、使用clusterProfiler下载GO\u0026amp;KEGG通路基因.md\n43、人类基因组基础知识与下载查询.md\n44、基因-蛋白-化合物ID转换.md\n45、GSEA富集分析工具.md\n46、clusterProfiler包富集分析与可视化.md\n47、富集通路可视化方式.md\n48、GSVA包单样本富集分析.md\n49、survival包生存分析及glmnet包lasso回归.md\n50、从RNAseq的fastq.gz提取表达矩阵.md\n51、使用IsoformSwitchAnalyzeR包进行可变剪切分析.md\n52、WGCNA基因加权共表达网络分析.md\n53、xCell与CIBERSORT等免疫浸润分析.md\n54、ClusterGVis包绘制基因表达矩阵热图.md\n55、MuSiC包根据scRNAseq预测Bulk细胞组成.md\n56、生信相关网站数据库集锦.md\n57、TCGA的SNV数据下载与maftools可视化.md\n58、肿瘤亚型分群工具ConsensusClusterPlus.md\n59、诺模图或列线图绘制分析.md\n60、UCSCXenaShiny包肿瘤数据分析可视化.md\n61、EnhancedVolcano包绘制火山图.md\n62、IOBR包肿瘤signature打分与免疫浸润分析.md\n63、BayesPrism包根据scRNAseq预测Bulk细胞组成.md\n64、R包NMF非负矩阵分解.md\n65、机器学习基于R包mlr3(0)\u0026ndash;mlr3基本流程.md\n66、机器学习基于R包mlr3(0)\u0026ndash;mlr3基本流程_v2.md\n67、机器学习基于R包mlr3(1)\u0026ndash;分类\u0026ndash;KNN.md\n68、机器学习基于R包mlr3(2)\u0026ndash;分类\u0026ndash;逻辑回归.md\n69、机器学习基于R包mlr3(3)\u0026ndash;分类\u0026ndash;LDA与QDA.md\n70、机器学习基于R包mlr3(4)\u0026ndash;分类\u0026ndash;朴素贝叶斯.md\n71、机器学习基于R包mlr3(5)\u0026ndash;分类\u0026ndash;SVM.md\n72、机器学习基于R包mlr3(6)\u0026ndash;分类\u0026ndash;决策树与随机森林.md\n73、机器学习基于R包mlr3(7)\u0026ndash;分类\u0026ndash;XGBoost.md\n74、机器学习基于R包mlr3(8)\u0026ndash;回归\u0026ndash;线性回归.md\n75、机器学习基于R包mlr3(9)\u0026ndash;回归\u0026ndash;GAM非线回归.md\n76、机器学习基于R包mlr3(10)\u0026ndash;回归\u0026ndash;岭回归+LASSON回归+弹性网络.md\n77、机器学习基于R包mlr3(11)\u0026ndash;回归\u0026ndash;kNN+随机森林+XGBoost.md\n78、机器学习基于R包mlr3(12)\u0026ndash;降维\u0026ndash;PCA.md\n79、机器学习基于R包mlr3(13)\u0026ndash;降维t-SNE与UMAP.md\n80、机器学习基于R包mlr3(14)\u0026ndash;聚类-k均值.md\n81、机器学习基于R包mlr3(15)\u0026ndash;聚类-层次聚类.md\n82、机器学习基于R包mlr3(16)\u0026ndash;聚类-EM混合分布.md\n83、机器学习基于sklearn(1)\u0026ndash;sklearn基础.md\n84、机器学习基于sklearn(2)\u0026ndash;交叉验证与超参数优化.md\n85、机器学习基于sklearn(3)\u0026ndash;常见分类任务学习器.md\n86、机器学习基于sklearn(4)\u0026ndash;常见回归任务学习器.md\n87、机器学习\u0026ndash;自动机器学习工具autogluon.md\n88、数据库\u0026ndash;药物与药物靶点TTD.md\n89、数据库\u0026ndash;药物干扰转录组CMap.md\n90、数据库\u0026ndash;通路基因集MsigDB.md\n91、使用igraph包进行网络结构分析与可视化.md\n92、重启随机游走算法与RandomWalkRestartMH包.md\n93、obabel化学小分子格式转换.md\n94、化合物指纹与描述符生成系列工具.md\n95、数据库\u0026ndash;化合物敏感度GDSC_CTRL.md\n96、ChemmineR处理化合物信息的基础工具R包.md\n97、深度学习D2L\u0026ndash;01\u0026ndash;线性回归.md\n98、深度学习D2L\u0026ndash;02\u0026ndash;softmax多分类.md\n99、深度学习D2L\u0026ndash;03\u0026ndash;K折交叉验证的torch训练基础流程.md\n100、深度学习\u0026ndash;VAE变分自动编码器.md\n101、D2L-第二章预备知识.md\n102、D2L-第三章线性神经网络.md\n103、D2L-第四章多层感知机.md\n104、D2L-第五章深度学习计算.md\n105、D2L-第六章卷积神经网络.md\n106、D2L-第七章现代卷积神经网络.md\n107、D2L-第八章循环神经网络.md\n108、D2L-第九章现代循环神经网络.md\n109、D2L-第十章注意力机制.md\n110、D2L-第十四及十五章BERT模型.md\n111、D2L-第十一及十二章优化算法\u0026amp;多GPU并行.md\n112、深度学习\u0026ndash;GAN基础.md\n113、图神经网络DGL-01DGL基础.md\n114、图神经网络DGL-02同构图_节点分类.md\n115、图神经网络DGL-03同构图_边回归.md\n116、图神经网络DGL-04同构图_边预测.md\nPart2: R\u0026amp;Python\u0026amp;Shell 1、Python基础-(1)初识.md\n2、Python基础-(2)序列、元组与字符串.md\n3、Python基础-(3)条件与循环语句.md\n4、Python基础-(4)函数.md\n5、Python基础-(5)类与实例.md\n6、Python基础-(6)异常.md\n7、Python基础-(7)模块基础.md\n8、Python基础-(8)常用内置模块.md\n9、Python基础-(9)文本读写与pickle保存.md\n10、Python-lambda函数表达式.md\n11、Python-threading多线程.md\n12、Python数据科学-IPython魔法命令.md\n13、Python数据科学-NumPy数组.md\n14、Python数据科学-Pandas表格.md\n15、Python数据科学-Matplotlib可视化.md\n16、Python-可视化-pandas绘图.md\n17、快捷键系列.md\n18、正则表达式基础.md\n19、hugo+github搭建我的个人博客.md\n20、R基础配置.md\n21、R语言的多线程循环语句.md\n22、R-数据分析-dplyr表格操作.md\n23、R-数据分析-reshape2表格长短转换.md\n24、R-可视化-ggplot2绘图基础.md\n25、R-可视化-ggpubr包快速绘制点图、线图与柱状图.md\n26、R-可视化-拼图patchwork.md\n27、R-可视化-韦恩图venn.md\n28、ggplot+ggpubr绘制箱图boxplot.md\n29、ggplot绘制常规柱状图barplot.md\n30、绘图颜色与画板的选择.md\n31、R-可视化\u0026ndash;热图heatmap.md\n32、R-可视化\u0026ndash;弦图chordDiagram.md\n33、R-可视化\u0026ndash;桑基(sankey)与冲击(alluvial)图ggsankey.md\n34、R-可视化\u0026ndash;饼图与环图.md\n35、R-可视化\u0026ndash;ggplot标注文本标签text\u0026amp;label.md\n36、R-可视化\u0026ndash;corrplot相关性绘图.md\n37、R-可视化\u0026ndash;ggplot添加四周边际图.md\n38、R\u0026ndash;可视化-ggbeeswarm绘制蜂群图.md\n39、R\u0026ndash;可视化-ggsignif注释显著性.md\n40、R\u0026ndash;可视化-funkyheatmap绘制table热图.md\n41、R语言RSelenium爬虫.md\n42、shiny包开发网页APP.md\n43、基于Rstudio创建R包.md\n44、R包purrr的函数编程.md\n45、shiny包开发网页APP进阶.md\n46、Shiny-basic-1-IO.md\n47、Shiny-basic-2-Layout.md\n48、Shiny-basic-3-Reactive.md\n49、Shiny-basic-4-Feedback.md\n50、Shiny-basic-5-Module.md\n51、Shiny-pkg-1-shinyWidgets.md\n52、Shiny-pkg-2-shinyJS.md\n53、Shiny-pkg-3-shinydashboard.md\n54、Shiny-pkg-4-shinydashboardPlus.md\n55、Shiny-pkg-5-bslib.md\n56、Shiny-pkg-6-others.md\n57、renv包环境可重复性.md\n58、rhinoverse系列-rhino包.md\n59、rhinoverse系列-shiny.router包.md\n60、UCSCXenaShiny-dev-tutorials\u0026ndash;231119.md\n61、Shell基础\u0026ndash;变量名字符串操作.md\n62、Shell基础\u0026ndash;find查找文件.md\n63、Sehll基础\u0026ndash;gzip压缩与pigz多线程.md\n64、Shell基础\u0026ndash;grep等文本处理命令.md\n65、linux进程管理与后台运行.md\n66、初识slurm基础操作.md\n67、window系统快速安装ubuntu子系统.md\n68、docker初学.md\n69、在Linux系统里部署Jupyter环境.md\n70、Linux的parallel并行方法.md\n71、Shell_Python_R脚本基础.md\n72、MySQL初学.md\nPart3: 文献与基础 1、统计学基础\u0026ndash;统计描述指标与常见统计分布.md\n2、统计学基础\u0026ndash;以T检验为例学习基于中心极限定理的假设检验.md\n3、统计学基础\u0026ndash;方差分析与卡方检验.md\n4、统计学基础\u0026ndash;相关性与一致性.md\n5、统计学基础\u0026ndash;二分类模型评价指标.md\n6、统计学基础\u0026ndash;重抽样Bootstrap与置换检验permutation test.md\n7、统计学\u0026ndash;生信中常见统计指标.md\n8、文献\u0026ndash;AD星形胶质细胞与小胶质细胞的单细胞数据分析.md\n9、文献\u0026ndash;AD小鼠空间转录组数据分析.md\n10、文献\u0026ndash;挖掘AD单细胞数据分析NK浸润.md\n11、文献\u0026ndash;基于肝细胞癌M2样肿瘤巨噬细胞建立预后模型.md\n12、文献\u0026ndash;椎间盘退行性疾病bulk与scRNA-seq数据挖掘.md\n13、文献\u0026ndash;小鼠缺血性中风单细胞数据分析.md\n14、文献\u0026ndash;WGCNA发现的卵巢癌肿瘤相关成纤维细胞的预后模型.md\n15、文献\u0026ndash;小鼠前列腺癌单细胞数据分析.md\n16、文献\u0026ndash;hECA人类单细胞表达图谱平台.md\n17、文献\u0026ndash;immuCan肿瘤微环境单细胞数据库.md\n18、文献\u0026ndash;克罗恩肠炎疾病的大型单细胞图谱.md\n19、文献-数据挖掘-肾癌与凝血相关基因.md\n20、文献-数据挖掘-肺腺癌相关基因对.md\n21、文献\u0026ndash;综合多种分析建立TNBC预后模型.md\n22、文献\u0026ndash;四逆散与非酒精性脂肪肝网药分析.md\n23、文献\u0026ndash;基于PPI网络的靶点群距离预测药物组合.md\n24、文献\u0026ndash;矩阵相似性计算样本通路一致性.md\n25、文献\u0026ndash;从相关性网络中鉴定节点间的直接调控关系.md\n26、文献\u0026ndash;基于通路富集的药物重定向(以AD药物为例).md\n27、文献\u0026ndash;基于药物干扰转录组建立距离网络用于药物重定向.md\n28、文献\u0026ndash;synergyfinder包计算协同评价指标.md\n29、文献\u0026ndash;32种乳腺癌细胞系单细胞转录组图谱.md\n30、文献\u0026ndash;乳腺癌单细胞与空间转录组图谱.md\n31、文献\u0026ndash;肝癌空间转录组数据分析.md\n32、文献\u0026ndash;生信套路之肿瘤预后.md\n33、文献\u0026ndash;ccRCC单细胞转录组.md\n34、文献\u0026ndash;髓鞘脱失与再生模型小鼠snRNAseq数据分析.md\n35、文献\u0026ndash;基于泛癌scRNAseq的T细胞图谱整合分析.md\n36、文献\u0026ndash;浆细胞(Plasma cells)在膀胱癌(Bladder cancer)中的预后分析.md\n37、文献\u0026ndash;机器学习模型预测药物肾毒性-1.md\n38、文献\u0026ndash;机器学习模型预测药物肾毒性-2.md\n","permalink":"https://lishensuo.github.io/en/about/","summary":"\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e李申锁，男，在读研究生，学习生信ing\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e此前以\u003cu\u003e小贝学生信\u003c/u\u003e为昵称在简书平台写一些学习心得。于2022年4月10日创建此博客，记录今后学习生信的过程。\u003c/p\u003e","title":""},{"content":"","permalink":"https://lishensuo.github.io/en/search.fr/","summary":"","title":""}]